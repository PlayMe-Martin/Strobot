import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import processing.serial.*; 
import java.util.Iterator; 
import java.util.*; 
import java.io.*; 
import java.awt.*; 
import java.awt.image.*; 
import java.net.*; 
import java.io.*; 
import com.google.protobuf.*; 
import java.io.File; 
import javax.xml.parsers.DocumentBuilderFactory; 
import javax.xml.parsers.DocumentBuilder; 
import javax.xml.parsers.ParserConfigurationException; 
import org.w3c.dom.*; 
import java.io.IOException; 
import org.xml.sax.SAXException; 
import java.awt.Frame; 
import java.awt.BorderLayout; 
import java.util.List; 
import controlP5.*; 
import themidibus.*; 
import javax.sound.midi.MidiEvent; 
import javax.sound.midi.MidiMessage; 
import javax.sound.midi.MidiSystem; 
import javax.sound.midi.Sequence; 
import javax.sound.midi.ShortMessage; 
import javax.sound.midi.Track; 
import java.awt.Graphics; 
import java.awt.Graphics2D; 
import java.awt.RenderingHints; 
import java.awt.image.BufferedImage; 
import java.awt.image.DataBufferInt; 
import java.awt.image.WritableRaster; 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import java.util.zip.Adler32; 
import processing.core.PApplet; 
import processing.serial.Serial; 

import com.google.protobuf.*; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class Strobot extends PApplet {


///////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////          Strobot - Processing application part of the Xi live lighting setup        /////////
/////////                                 Martin Di Rollo - 2013                                  /////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////
///////// Main file of the program - contains the initial config, as well as setup and draw loops /////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////



/*
/////////////////////////////////////////////    -  User manual  -    /////////////////////////////////////

This program allows to control a LED matrix, DMX devices and RF-controlled devices synced to MIDI commands.
This program has two modes : automatic and manual. Manual mode allows to create very specific animations,
and leave very little chance in the selection of the different animations.
The easiest way to use this program is manual mode is either :
- within Ableton Live, create a MIDI clip and compose your sequence, in reference to the audio clip you want
- within Maschine, do the same as with Ableton, create a pattern, and link it to a scene
-> Configure the sequencer's MIDI to be output to the IAC virtual MIDI bus (OSX), this will allow this
   program to receive these MIDI commands.
Of course, a similar method can be applied for any other DAW
   
In semi-automatic mode, specific MIDI notes control each animation.
The notes itself can be configured from within the GUI. The default config allows the following actions :
E7  (MIDI 100) : Change both front stroboscopes' speed/intensity (without starting it if it's not active)
F7  (MIDI 101) : Start both front stroboscope
F#7 (MIDI 102) : Stop the front stroboscope
G7  (MIDI 103) : Start the left front stroboscope, stop it upon releasing the note
G#7 (MIDI 104) : Start the left front stroboscope, stop it upon releasing the note
A7  (MIDI 105) : Start the back stroboscope, stop it upon releasing the note
F9  (MIDI 122) : Change LED panel animation - bank 4
D#9 (MIDI 123) : Change LED panel animation - bank 1
E9  (MIDI 124) : Change LED panel animation - bank 2
F9  (MIDI 125) : Change LED panel animation - bank 3
F#9 (MIDI 126) : Display an image on the LED panels
G9  (MIDI 127) : Change output mapping (change which panel each image is sent to)
For the animations and the images, the animation number is specified via the MIDI note's velocity

These additional commands are also available, using MIDI channel 1 (for a keyboard):
C-1 (MIDI 0)   : For the games - Player 1 Left
D-1 (MIDI 2)   : For the games - Player 1 Right
B0  (MIDI 23)  : For the games - Player 2 Left
C1  (MIDI 24)  : For the games - Player 2 Right

In manual mode, the paradigm is similar, except the selection is not made following the input notes' velocity
Using a MPC-like controller, such as Maschine, pads trigger the animations and the DMX equipments
The registered commands in this mode are:
Note On : trigger an animation according to the configuration
Note Off : in case of particular animations, black out (DMX equipments), or go back to the previous persistent animation (strobe)
The configuration allows to create groups of 16 animations which go pretty well together
In manual mode, the additional inputs used in automatic mode also apply

In automatic mode, the program's behaviour is completely different.
Automatic behaviour is set by the audio processed directly from the DAW, using multiple instances
of the Signal Processor VST

In automatic mode, other actions include keyboard and pad input :
For example --- 
  - Pressing the stutter pads will trigger the stroboscope and violent animations
  - Using the low pass filter will kill the LED panels' brightness
  - Using the high pass filter will brighten the LED panels  

///////////////////////////////////////////////////////////////////////////////////////////////////////////
*/


//import processing.video.*;





/////////////////////////////////////////////////////
//-----------Start of user configuration-----------//
/////////////////////////////////////////////////////

//Set to true to create a web page allowing easy management of the registered animations
//This file's primary use is to provide support when creating large MIDI files calling multiple animations
boolean output_PHP = false;

/////////////////////////////////////////////////////
/////////Define the DMX configuration here !/////////
/////////////////////////////////////////////////////

//Set to True to execute the sketch in debug mode, without the Teensy2 connected
boolean debug_without_dmx = false;
boolean debug_without_custom_devices = false;

String DMX_MICROCONTROLLER_NAME = "/dev/tty.usbmodem12341";
String CUSTOMDEVICES_MICROCONTROLLER_NAME = "/dev/tty.usbserial-A961L7NJ";

//////////////////////////////////////////////////////
//Define the initial config of the LED matrix here !//
//////////////////////////////////////////////////////

final static int PANEL_RESOLUTION_X = 8;        //Resolution for each individual panel - width
final static int PANEL_RESOLUTION_Y = 16;       //Resolution for each individual panel - height 
final static String LED_COLOR_FORMAT = "RGB";   //LED color arrangement
int NUMBER_OF_PANELS = 5;                       //Number of panels - TBIL : automatic detection of the number of panels connected, either 3 or 5

//Define the serial ports for the microcontrollers
//String[] TEENSY_SERIAL_PORT_LIST_3 = {"NONSTATIC", "/dev/tty.usbmodem11331", "/dev/tty.usbmodem17031"};
//All the devices in the 3 panel configuration need to be nonstatic : we don't know what panels we will be taking
String[] TEENSY_SERIAL_PORT_LIST_3 = {"NONSTATIC", "NONSTATIC", "NONSTATIC"};
String[] TEENSY_SERIAL_PORT_LIST_5 = {"/dev/tty.usbmodem113361", "/dev/tty.usbmodem479061", "/dev/tty.usbmodem479101", "/dev/tty.usbmodem707701", "/dev/tty.usbmodem814421"}; // 707701 to add
String[] devicesToParse;

//Define the Gamma value to be used for the panels - recommended for WS2801 modules : gamma_25
final String panelGamma = "gamma_25";

//Mapping for an individual LED Panel - if the LEDs are cabled the following way, follow the example to create the mapping
//    8 7 6
//    3 4 5     ->    {6,7,8,3,4,5,0,1,2}
//    2 1 0
final int[] MANUAL_MAPPING = {127, 126, 125, 124, 123, 122, 121, 120,
                              112, 113, 114, 115, 116, 117, 118, 119,
                              111, 110, 109, 108, 107, 106, 105, 104,
                               96,  97,  98,  99, 100, 101, 102, 103,
                               95,  94,  93,  92,  91,  90,  89,  88,
                               80,  81,  82,  83,  84,  85,  86,  87,
                               79,  78,  77,  76,  75,  74,  73,  72,
                               64,  65,  66,  67,  68,  69,  70,  71,
                               63,  62,  61,  60,  59,  58,  57,  56,
                               48,  49,  50,  51,  52,  53,  54,  55,
                               47,  46,  45,  44,  43,  42,  41,  40,
                               32,  33,  34,  35,  36,  37,  38,  39,
                               31,  30,  29,  28,  27,  26,  25,  24,
                               16,  17,  18,  19,  20,  21,  22,  23,
                               15,  14,  13,  12,  11,  10,   9,   8,
                                0,   1,   2,   3,   4,   5,   6,   7};

//Resize option : choose either QUALITY for a slow, but good resize (using mean average), or SPEED, for a faster, but low quality pixel resize
//Possible values : "QUALITY", "SPEED"
final String RESIZE_OPTION = "QUALITY";

//Choose the device from which Processing should receive MIDI commands
//Standard choice : IEC bus to receive internal MIDI messages from the DAW -> "Bus 1"
String MIDI_BUS_MAIN_INPUT       = "Bus 1";
String MIDI_BUS_PIONEER_CONTROLLER_INPUT = "PIONEER RMX-500";
String MIDI_BUS_CONTROLLER_INPUT = "LPD8";
String MIDI_BUS_KEYBOARD_INPUT   = "LPK25";

//Used to changed on the fly the panel order (LED remapping), using MIDI commands
int[] screen_order_configuration = new int [NUMBER_OF_PANELS];

/////////////////////////////////////////////////////
//--Should also be configured :                    //
//--Manual mode pad/animation mapping--            //
// This can be set up in the ManualModeConfig file //
/////////////////////////////////////////////////////

/////////////////////////////////////////////////////
//----------End of main user configuration---------//
/////////////////////////////////////////////////////



/////////////////////////////////////////////////////
// Misc global variables used everywhere in the program 

//Create a log file, where all system output shall be redirected to
static PrintWriter outputLog;

//Internal panel and resolution configuration
final int DISPLAY_SCALING_FACTOR = 4;
int PIXELS_X;                                                   //To be defined once the number of panels is known
int PIXELS_Y;                                                   //16 pixels high -> 64 pixels wide
int COM_BAUD_RATE = 115200;                                     //Serial communication rate between Processing and the LED Panel Teensy microcontrollers
int COM_BAUD_RATE_NANO = 57600;                                 //Serial communication rate between Processing and the Arduino Nano used to dispatch orders to custom devices

//Buffers used to stock the displayed pixels (not yet resized)
int[][] pixelsPanels;

//Buffer which will keep the resized transformed data for all panels (both the output devices and the simulator get their data here)
int[][] transformedBuffersLEDPanels;

//Output objects
Tpm2[] outputDevices;
ArrayList<String> registeredDevices;

//Resize objects : allows buffer resize, slow or fast
QualityResize qualityResize;
PixelResize pixelResize;

//RGB Colorspace : 3 bits per pixel
int BPP = 3;

//Flag to prevent execution of the draw function before custom setup : if a new animation is requested, setupcomplete is set back to false
boolean setupcomplete = false;

//Flag to prevent listening to MIDI events before completing the first INIT routine
boolean initComplete = false;

//the maximal UDP packet size
int MAXIMAL_UDP_PACKET_SIZE = 65507;

//Instanciate MIDI control objects
MidiBus myMainBus;
MidiBus myControllerBus;
MidiBus myPioneerControllerBus;      //Create a specific object for Pioneer RMX-like controllers, which have a special MIDI implementation, and as such specific processing
MidiBus myKeyboardBus;
MidiBus myBackupBus;

//Control the brightness of the LED panels - 1 for full brightness
float brightness = 1;

//Set to True to execute the sketch in debug mode, without the LED panels' Teensy3 connected
//This variable is set to true when trying to change the number of panels from inside the GUI, until the program is reset
boolean debug_without_panels = false;

//If set to true, the devices are set on and off according to the DMX animations.
//Otherwise, the DMX devices are controlled manually using each group's MIDI notes
boolean dmxAutomaticControl        = false;


//Variables used to select between image and animation mode, and which image/animation to draw
int drawImage = 0;
int drawAnimation = 0;
int imagenumber;
int animationnumber;

//Create a AnimatedGifEncoder object to allow for easy export of all the animations 
AnimatedGifEncoder gifRecorder;
boolean keyRegistered       = false;
boolean setGifRecording     = false;
boolean gifRecordingActive  = false;
ArrayList gifRecordingFrameRate;
int gifRecordingFrameNumber = 0;
String ROOTDIR = "";    //Folder where the GIF shall be stored

//Create a Sequencer object, to allow for automatic animation selection
PlayMeSequencer automaticSequencer;

public void setup()
{
  //Create a log file, where all system output shall be redirected to
  try {
    create_logfileHeader();

  }
  catch (Exception e) {
    println("Couldn't create logger file : " + e); 
  }
  
  //Read all the available DMX fixture files
  readFixtureFiles();

  setDefaultScreenOrderConfiguration();
  init_defaultDMXDevices();
  init_defaultCustomDevices();
  
  //Read the configuration file, and initialize the different parameters accordingly, overwrite the default DMX setup
  getInfoFromConfigFile();
  
  //Declare the dimensions of the matrix now that we know how many panels there are
  PIXELS_X = PANEL_RESOLUTION_X * DISPLAY_SCALING_FACTOR * NUMBER_OF_PANELS;    //24 LEDs wide -> 96 pixels wide, or 40 LEDs wide -> 160 pixels wide
  PIXELS_Y = PANEL_RESOLUTION_Y * DISPLAY_SCALING_FACTOR;                       //16 pixels high -> 64 pixels wide
  
  //Register attributes for all loaded animations
  animationAttributes = new ArrayList<Attribute>();
  registeredAttributes = new StringList();
  setAnimationAttributes();
  
  //Do the same for Custom devices actions
  customDevicesAttributes = new ArrayList<Attribute>();
  setCustomDevicesActionsAttributes();
  
  //And do the same for the DMX animations
  DMXStrobeAttributes                    = new ArrayList<Attribute>();
  DMXMovingHead_MovementAttributes       = new ArrayList<Attribute>();
  DMXMovingHead_ColorAttributes          = new ArrayList<Attribute>();
  DMXMovingHead_RhythmAttributes         = new ArrayList<Attribute>();
  DMXMovingHead_LightStyleAttributes     = new ArrayList<Attribute>();
  DMXMovingHead_AnimationAttributes      = new ArrayList<Attribute>();
  DMXOtherFixturesAttributes             = new ArrayList<Attribute>();
  setDMXAnimationsAttributes();

  
  if (output_PHP == true) {
    //Initialize and fill in the PHP file
    create_PHP_output();
  }
  
  //Useful for debug : initialize the sketch with a specific animation
  //Initial release : display 12345 on the panels -> change this to "light up all the panels in white" ("12345" is hardly elegant if a reset needs to be done live)
  //The mapping must be requested explicitely using the dedicated procedure
  animationnumber = 2;
  drawAnimation = 1;
  drawImage = 0;
  imagenumber = 0;
    
  //Initialize the frame buffers
  pixelsPanels = new int[NUMBER_OF_PANELS][PIXELS_X*PIXELS_Y];  
  transformedBuffersLEDPanels = new int[NUMBER_OF_PANELS][PANEL_RESOLUTION_X*PANEL_RESOLUTION_Y];
  outputLog.println("Frame buffers initialized. Size : " + str(PIXELS_X*PIXELS_Y));
  
  devicesToParse = TEENSY_SERIAL_PORT_LIST_3;
  if (NUMBER_OF_PANELS == 3) {
    devicesToParse = TEENSY_SERIAL_PORT_LIST_3;
  }
  else if (NUMBER_OF_PANELS == 5) {
    devicesToParse = TEENSY_SERIAL_PORT_LIST_5;
  }
  IntList nonstaticDeviceArrayNumber = new IntList();  
  ArrayList<String> candidateDevices = new ArrayList<String>();
  registeredDevices = new ArrayList<String>();
  if (DMX_MICROCONTROLLER_NAME.equals("NONSTATIC") == false) {
    registeredDevices.add(DMX_MICROCONTROLLER_NAME);
  }
  for (int i = 0; i < devicesToParse.length; i++) {
    if (devicesToParse[i].equals("NONSTATIC") == false) {
      registeredDevices.add(devicesToParse[i]);
    }
    else {
      nonstaticDeviceArrayNumber.append(i);
    }
  }
  if (nonstaticDeviceArrayNumber.size() == 0) {
    outputLog.println("All USB serial devices are defined statically, no guesswork is needed"); 
  }
  else {
    outputLog.println(nonstaticDeviceArrayNumber.size() + " non static USB serial device configured, trying to guess the mystery Teensy...");
  }
  
  //Find out which microcontrollers of the configuration list are defined as non-static
  for (int i = 0; i < devicesToParse.length; i++) {
    if (devicesToParse[i].equals("NONSTATIC") == true) {
      nonstaticDeviceArrayNumber.append(i);
    }
  }  
  
  boolean nameExceptionFound = false;
  if (nonstaticDeviceArrayNumber.size() >= 1) {
    String rootName = "/dev/tty.usbmodem";
    for (int i =0; i < nonstaticDeviceArrayNumber.size();i++) {
      for (String portName: Serial.list()) {

        if (portName.contains(rootName) == true) {
          for (String registeredDevice: registeredDevices) {

            if (registeredDevice.contains(portName.substring(5, portName.length())) == false || portName.equals("/dev/tty.usbmodem1")) {
              boolean newCandidate = true;
              for (int j = 0; j<candidateDevices.size();j++) {
                for (String registered: registeredDevices) {
                  if (portName.contains(registered) || registered.contains(portName)) {
                    newCandidate = false;
                  }
                  if (portName.equals("/dev/tty.usbmodem1")) {
                    newCandidate = true;
                  }
                }
                if (candidateDevices.get(j).equals(portName)) {
                  newCandidate = false;
                }
              }
              if (newCandidate) {
                if (portName.equals("/dev/tty.usbmodem1")) {
                  if (nameExceptionFound == false) {
                    outputLog.println("--- Found possible candidate for the non static device : " + portName);
                    candidateDevices.add(portName);
                    nameExceptionFound = true;
                  }
                }
                else { 
                  outputLog.println("--- Found possible candidate for the non static device : " + portName);
                  candidateDevices.add(portName);
                }
              }
            }
          }
        }
      }
    }
  }
  for (int i = 0; i<candidateDevices.size();i++) {
    registeredDevices.add(candidateDevices.get(i));
  }
  for (int i = 0; i<candidateDevices.size();i++) {
    devicesToParse[nonstaticDeviceArrayNumber.get(i)] = candidateDevices.get(i);
  }
  

  
  for (int i = 0; i<devicesToParse.length;i++) {
    if (devicesToParse[i].contains("NONSTATIC")) {
        outputLog.println("!!!!! -------------------------------------- !!!!!");
        outputLog.println("!!!!! Error - Among the serial devices registered by the OS, couldn't find a possible candidate for non static device number " + i + ", the corresponding panel will not be initialised");
        outputLog.println("!!!!! For information, the only available serial devices are :");
        for (String portName: Serial.list()) { 
            outputLog.println("!!!!! --- " + portName);
        }
        outputLog.println("!!!!! -------------------------------------- !!!!!");
    }
  }
  
  if (NUMBER_OF_PANELS == 3) {
    TEENSY_SERIAL_PORT_LIST_3 = devicesToParse;
  }
  else if (NUMBER_OF_PANELS == 5) {
    TEENSY_SERIAL_PORT_LIST_5 = devicesToParse;
  }
  
  
  //Initialize the output objects
  outputDevices = new Tpm2[NUMBER_OF_PANELS];
  for (int i=0; i<NUMBER_OF_PANELS; i++) {
    outputDevices[i] = new Tpm2(i);
  }
  
  //Map the output objects to their respective panel
  for (int i=0; i<outputDevices.length; i++) {
    outputDevices[i].panelNumber = screen_order_configuration[i];
    outputLog.println("Microcontroller init - device " + outputDevices[i].serialPort + " is affected to output #" + outputDevices[i].panelNumber);
  }
  
  //Initialize the resize objects
  //--- try out the results with the shitty resize, it might be enough, and the performance could be better
  qualityResize = new QualityResize();
  pixelResize = new PixelResize();
  
  //Define the frameRate - shall be redefined by each individual animation, inside specificActions()
  frameRate(50);
  //Define the size of the display
  size(PIXELS_X, PIXELS_Y);
  //Sanity check regarding the Teensy serial list
  if (NUMBER_OF_PANELS == 3) {
    if (TEENSY_SERIAL_PORT_LIST_3.length < NUMBER_OF_PANELS) {
      outputLog.println("!!! Error on Teensy Serial Port List ! Please fill in a correct serial port, or 'NONSTATIC' for each output !!!");
      println("!!! Error on Teensy Serial Port List ! Please fill in a correct serial port, or 'NONSTATIC' for each output !!!");
      System.exit(1);    //Quit application
    }
  }
  else if (NUMBER_OF_PANELS == 5) {
    if (TEENSY_SERIAL_PORT_LIST_5.length < NUMBER_OF_PANELS) {
      outputLog.println("!!! Error on Teensy Serial Port List ! Please fill in a correct serial port, or 'NONSTATIC' for each output !!!");
      println("!!! Error on Teensy Serial Port List ! Please fill in a correct serial port, or 'NONSTATIC' for each output !!!");
      System.exit(1);    //Quit application
    }
  }  
  
  //Initialize Object for Serial2DMX microcontroller
  myDMX = new DMX(this);
  //Initialize Object for Serial2CustomDevices microcontroller
  myCustomDeviceController = new CustomDeviceController(this);
  
  //Initialize MIDI Control object
  //This allows Processing to be controlled by MIDI messages coming from external equipments or the IEC internal MIDI Bus (ie. messages from Ableton)
  midiInit();
  
  //Parse all available MIDI clips, in order to feed them to the auto sequencer
  parseAllAvailableMidiClips();
  //Create a new PlayMeSequencer object, to allow for automatic animation selection using audio input
  automaticSequencer = new PlayMeSequencer();
  
  //Initialize the ring buffers which will store incoming audio data
  initializeCircularBuffers();
  //Initialize the FFT buffers which will hold the current FFT for every signal
  initializeSignalFFTBuffers();
  
  //Start the thread which will receive any protobuf audio data, coming from the different SignalProcessor plugin instances
  startAudioSignalMonitoringThread();
  
  //Pre-load video animations, there is a slight latency gain by not creating the objects upon reading the video
  //Note that this is not really used anymore, but the function is interesting enough for it not to be removed from the app
  initialize_video_animations();
    
  //Initialize manual mode
  init_ManualMode();
  
  //Execute the init actions for the initial animation
  specificActions();

  //Refresh the outputLog file
  outputLog.flush();
    
  //Initialize GIF Recording object, set the GIF to loop
  gifRecorder = new AnimatedGifEncoder();
  gifRecorder.setRepeat(0);
  
  //Set the window location to be next to the GUI
  setLocation(gui_width, 0);
  
  //Initialize the GUI
  if (DISPLAY_GUI == true) {
     setup_gui();
  }

  //Set all the custom devices to light up
  customDeviceAnimation(4);
  
  //We're finally over !
  initComplete = true;
}

////////////////////////////////////////////////////////////////////////////
//                        Main loop of the program                        //
// The cyclic image generation and LED output buffer updates is done here //
////////////////////////////////////////////////////////////////////////////

public void draw()
{  

  if (setupcomplete == true) 
  {

    // for (Tpm2 outputDevice: outputDevices) {
      // try {
      //   outputDevices[0].readDebugData();
      // }
      // catch (Exception e) {
      //   println("Exception while trying to read - " + e);
      // }
      
    // }

    //Execute the draw function for the animation corresponding to animationnumber
    //The specific setup is executed once, upon reception of an MIDI message changing the animation
    try {
      //retrigger every cycle the possibility to call a user input animation
      userInputAnim_enableDrawForCurrentCycle = true;
      
      //Panel graphic generation
      if (AUTOMATIC_MODE == false) {
        if (authorizeGeneralManualMode == true) {
          if (setShredderManualMode == true) {
             // Some effects, like the shredder, are a bit particular, and require the main animation not to be drawn
             actionControlled_preSpecificDraw();
          }
          else {
            specific_draw();
            draw_effects();
          }
          //Draw the post-treatment effects
          actionControlled_postSpecificDraw();
        }
        //No additional user input is allowed, execute specific draw the regular way
        else {
          specific_draw();
          draw_effects();
        }
      }
      else {
        automaticSequencer.performAutomaticActions();
        draw_effects();
      }
      
      //DMX animations - set to true when receiving the corresponding MIDI message, or when the general AUTOMATIC mode is on
      //Sending an explicit specific DMX group message will set dmxAutomaticControl to false (ex: "front stroboscope on")
      if (dmxAutomaticControl == true || AUTOMATIC_MODE == true) {
        playDMXAnimation();
      }
      
      //Reset the Audio flags if requested by the animation
      if (impulseMessageProcessed) {
        resetImpulseFlags();
        impulseMessageProcessed = false;
      }
    }
    catch(Exception e) {
      outputLog.println("Caught an exception in the draw thread ! " + e); 
    }
  }

  //Update the buffers corresponding to the panels
  update_buffer();

  
  //Fill the data buffers with the resized data of the Processing output window
  getNewTransformedBuffersLEDPanels();
  
  //Send actual data - when changing live the setting regarding the number of panels (using the GUI), this is set to false
  if (debug_without_panels == false) {
    
    //Update each device (only those registered during init though)
    for (int i=0; i<outputDevices.length; i++) { 
      outputDevices[i].update();
    }
    
  }
  
  //Refresh the outputLog file
  outputLog.flush();
  
  if (setGifRecording == true) {
    if (gifRecordingActive == true) {
      saveFrame("tmp/animation" + animationnumber + "-" + formatNumber(gifRecordingFrameNumber) + ".jpeg");
      gifRecordingFrameRate.add(frameRate);
      gifRecordingFrameNumber += 1;
    }      
  }
}

public void create_logfileHeader() {
    outputLog = createWriter("Strobot_logfile.txt");
    
    outputLog.println("///////////////////////////////////////////");
    outputLog.println("//Xi Light Setup - Output logger file//");
    outputLog.println("///////////////////////////////////////////");
    outputLog.println("");
    outputLog.println("");
    outputLog.println("// All information output by the application shall be stored in this log file //");
    outputLog.println("");
    outputLog.flush();
}

//////////////////////////////////////////////////////////////////////////////////////
/////////Contains parameters specific to animations called in the main sketch/////////
//////////////////////////////////////////////////////////////////////////////////////


//Carglass parameters
float carglass_progress = 0;
float carglass_speed = 0.1f;
float carglass_linelength;

//initFlasher (intro) parameters
int initFlasher_progress = 0;
int initFlasher_firstFlashSpeed = 1;
int initFlasher_startNoise = 220;
int initFlasher_startNoise2 = 450;
int initFlasher_startNoise3 = 550;
int initFlasher_startNoise4 = 600;
int initFlasher_startBlackout = 700;
int initFlasher_startWhiteout = 1000;
int initFlasher_startMegawhiteout = 1200;
int initFlasher_startStrobo = 1320;
float initFlasher_noiseBrightness = 0;
int initFlasher_startJitter = 2000;
float initFlasher_noiseSpeed_1 = 0.03f;
float initFlasher_noiseSpeed_2 = 0.06f;
float initFlasher_noiseSpeed_3 = 0.09f;
float initFlasher_blackoutProbability = 0;
float initFlasher_blackoutProbability_max = 0.4f;
float initFlasher_blackoutProbability_speed = 0.001f;
float initFlasher_whiteoutProbability = 0;
float initFlasher_whiteoutProbability_max = 0.7f;
float initFlasher_whiteoutProbability_speed = 0.001f;
float initFlasher_flashProbability = 0;
float initFlasher_flashProbability_max = 0.5f;
float initFlasher_flashProbability_speed = 0.0025f;
int initFlasher_pixelSize = 4;

//Va et vient parameters
float va_et_vient_progress = 0;
float va_et_vient_speed_horizontal = 8;
float va_et_vient_speed_vertical = 4;

//Spiraluality parameters
float spiraluality_i;
int spiraluality_numCircles = 23;
float spiraluality_1stdiameter = 300;
float spiraluality_diameterDiff = 13;
float spiraluality_xArticulation = 13;
float spiraluality_yArticulation;
float spiraluality_speed = 0.002f;

//Shadows parameters
float rand = random(1);

//RedWhiteGlowingBalls parameters
float redGlowingBalls_size = 20;
float redGlowingBalls_noiseSpeed = 0.1f;


//Bouncing Circle parameters
int rad = 10;        // Width of the shape
float xpos, ypos;    // Starting position of shape    
float xspeed = 2.9f;  // Speed of the shape
float yspeed = 2.9f;  // Speed of the shape
int xdirection = 1;  // Left or Right
int ydirection = 1;  // Top to Bottom

//Rotating Circles parameters
int background_color = 255;
int circle_color = 0;
int objNum = 20;
float degrees = 360/5;
float distance = 50;
float angleOffset = 0;
int positionX = NUMBER_OF_PANELS*32/2;
int positionY = 64/2;
int diameter = 30;

//Waveform parameters
float yoff = 0.0f;        // 2nd dimension of perlin noise
float waveform_y_growing = 32.0f;

//Worms parameters
Worm[] worms;
int numWorms = 4*NUMBER_OF_PANELS;
boolean worms_init = false;
PVector pulse;
boolean pulsed;

//Upwards Line parameters
float line_height;

//Wind particles parameters
Particle[] particle ;
int NUMPARTICLES = 15*NUMBER_OF_PANELS ;
Wind wind ;

//PanelFill parameters
ArrayList<PanelFillLineClass> panelFillLinesList;
boolean panelFillLinesListInit = false;
boolean panelfilllines_kill = false;
int panelfilllines_j = 0;
int panelfilllines_maxsize = 4;
int panelfilllines_maxspeed = 3;
int panelfilllines_frequency = 35;
boolean panelfilllines_draw = false;
int panelfilllines_randtype = 0;

//Symmetry parameters
static int SHADES = 255 ;                // - Number of shades of gray that can be displayed
static int CYCLESBEFORECHANGE = 3 ;     // - Number of times the featured pattern is drawn before cycling to the next pattern
 
// The three patterns that can be displayed
static public int CIRCLE_PATTERN = 0;
static public int SPIKE_PATTERN = 1;
static public int FLOWER_PATTERN = 2;
static int NUM_PATTERNS = 3;
static int NUM_MODES = 7;
static int MODES[][] =
  { {6, 3, 10, 20, 30},
    {8, 100, 30, 20, 50}, 
    {3, 3, 20, 20, 60},
    {5, 3, 1, 60, 60},
    {4, 6, 40, 2, 1},
    {7, 250, 20, 8, 10},
    {77, 1, 30, 10, 10 }
  } ;
  
int framesToCycle = 90 ;   // Time to complete half a pattern (180 degrees) - 3 seconds
// Variables that define the 'mode' being displayed
int numSegments;          // number of reflections
public int numRibbons;     // Number of ribbons drawn in each segment
public float redChange, greenChange, blueChange ; // Speed at which each colour is cycled
int redVal, greenVal, blueVal; // Holds the current colour of the line
public Ribbon[] ribbons ; // An array to hold the ribbons
int mode = 0;
public float delta = 0;
int frames = 0;
int fadeFrames = 0;


//Flashleft, center and right parameters
int flash_sustain = 1;
int drawextremeleft    = flash_sustain;
int drawleft           = flash_sustain;
int drawcenter         = flash_sustain;
int drawright          = flash_sustain;
int drawextremeright   = flash_sustain;
int drawwide           = flash_sustain;

//Rhombus parameters
float rhombus_diaX = NUMBER_OF_PANELS*32/2;
float rhombus_diaR = 30;
float rhombus_diaS = 6;

//KaleidoTriangle parameters
float trianglepos;

//Glitch parameters
PImage redImg, greenImg, blueImg;
float sincounter = 0;

//Snow parameters
Floco[] snowMatrix=new Floco[30*NUMBER_OF_PANELS];
int snowflakecounter;
int snowflakeSize=4;
float snowflakemaxValue=0.5f;

//MechanicLines parameters
float mechaniclines_w = 30;
float mechaniclines_h = 20;
float mechaniclines_wspeed = 1;
float mechaniclines_hspeed = 0.5f;

//RedvsBlackvsWhite parameters
ArrayList dots;
float dots_row = 5;
float redvsblackvswhite_incr;
float redvsblackvswhite_start;
float redvsblackvswhite_angle = 0;
int redvsblackvswhite_i=0;
int redvsblackvswhite_frameCount=0;
boolean one_off = false;

//RotatingSquare parameters
float thetaStart;
TriRot [] TriRotElem = new TriRot[1];
boolean rotatingSquare_init = false;
int rotatingSquare_strokeweight = 6;

//MovingSine parameters
int movingsine_howMany = 32*NUMBER_OF_PANELS;
float movingsine_speed;
ExLine [] SineElem = new ExLine[movingsine_howMany];

//Smoke parameters
float smoke_particles_movement = 0;

//Sinefuckedup parameters
int sine_fuckedup_counter = 0;
float v = 0;
float w = 0;

//Manual/AutomaticCircle parameters
ArrayList rings = new ArrayList();
float howManyRings= 10;
float dropcircle_x, dropcircle_y;
float dropcircle_sz = 0;
boolean dropcircle_kill = false;
int dropcircle_j = 0;

//Rain parameters
int howManyRainDrops = 50;
float[] raindrops_x = new float[howManyRainDrops];
float[] raindrops_y = new float[howManyRainDrops];
float[] raindrops_speed = new float[howManyRainDrops];


//PulseStar parameters
float pulsestar_R;
float pulsestar_r;
int pulsestar_N = 9;
float pulsestar_OMEGA = 0.2f;
float pulsestar_t;

//MovingLines parameters
ArrayList<MovingLine> movingLines = new ArrayList<MovingLine>();
boolean movingline_kill = false;
int movingline_j = 0;
int movingline_maxangle = 45;
int movingline_maxspeed = 3;
int movingline_frequency = 67-(NUMBER_OF_PANELS-3)*7;

//MovingSquares parameters
ArrayList<MovingSquare> movingSquares = new ArrayList<MovingSquare>();
int movingsquare_j = 0;
int movingsquare_maxsize = 4;
int movingsquare_maxspeed = 3;
int movingsquare_frequency = 40-4*NUMBER_OF_PANELS;

//UpwardGlitchLines parameters
int upwards_glitchlines_a;
int upwards_glitchlines_b;
int upwards_glitchlines_c;
int upwards_glitchlines_interligne;
int upwards_glitchlines_speed;
int upwards_glitchlines_count;
int upwards_glitchlines_glitch_x;
int upwards_glitchlines_glitch_y;
int upwards_glitchlines_freq;

//DiagonalGlitchLines parameters
int diagonal_glitchlines_a;
int diagonal_glitchlines_b;
int diagonal_glitchlines_c;
int diagonal_glitchlines_strokeWidth;
int diagonal_glitchlines_speed;
int diagonal_glitchlines_count;

//CompressedLines parameters
int compressedlines_ratio;

//PanelFill parameters
ArrayList<PanelFillClass> panelFillList;
boolean panelFillListInit = false;
boolean panelfill_kill = false;
int panelfill_j = 0;
int panelfill_maxsize = 4;
int panelfill_maxspeed = 3;
int panelfill_frequency = 35;
boolean panelfill_draw = false;

//MixedLines parameters
int mixedlines_horizontal1;
int mixedlines_horizontal2;
int mixedlines_horizontal3;
int mixedlines_vertical1;
int mixedlines_vertical2;
int mixedlines_vertical3;
int mixedlines_circlex;
int mixedlines_speed;
int mixedlines_strokeWeight;
int mixedlines_ellipsewidth;

//DoubleGradientTransition parameters
int doublegradient_a = 0;
int doublegradient_b = NUMBER_OF_PANELS*32;
boolean doublegradient_direction = true;

//CarreMarshall parameters
int carreMarshall_a;
int carreMarshall_largeurCarre;
int carreMarshall_interligne;
int carreMarshall_epaisseurLigne;
int carreMarshall_vitesseLigne;
int carreMarshall_compteur;
int carreMarshall_coeffAgrandissement;

//Fusee parameters
int fusee_a;
int fusee_epaisseurLigne;
int fusee_vitesseLigne;
int fusee_compteur;
int[] fusee_tab1;
int[] fusee_tab2;

//Spots parameters
int spots_tailleCone;

//UpwardsGlitchMixedLines parameters
int upwards_glitch_mixedlines_b;
int upwards_glitch_mixedlines_c;
int upwards_glitch_mixedlines_d;
int upwards_glitch_mixedlines_e;
int upwards_glitch_mixedlines_f;
int upwards_glitch_mixedlines_g;
int upwards_glitch_mixedlines_ac;
int upwards_glitch_mixedlines_bc;
int upwards_glitch_mixedlines_cc;
int upwards_glitch_mixedlines_dc;
int upwards_glitch_mixedlines_epaisseurLigne;
int upwards_glitch_mixedlines_interligne;
int upwards_glitch_mixedlines_speed;

//Scope parameters
float scope_arc_b_r = 0;
float scope_arc_s_r = 0;
float scope_ellipsewidth = 24;
 
float scope_rotationcounter = 0;
int scope_freqcounter = 0;
int scope_flg1 = 0;
int scope_flg2 = 0;
int scope_flg3 = 0;
 
int scope_color;
int scope_g = 0;
int scope_b = 0;
boolean scope_decrease = false;


//SquareWaveGenerator parameters
int [] squarewave_button;
int [] squarewave_timer;
int squarewave_step = 0;
int squarewave_tA = 0;
int squarewave_tB = 0;
int squarewave_tC = 0;
boolean squarewave_alreadycalled = false;
boolean squarewave_signalpulse = false; 
int squarewave_signalframecounter = 0;

//Tetris parameters
final int CYAN = color(0,150,255);
final int ORANGE = color(255,165,0);
final int YELLOW = color(255,255,0);
final int PURPLE = color(160,32,240);
final int BLUE = color(0,0,255);
final int RED = color(255,0,0);
final int GREEN = color(0,255,0);
 
Grid board;
Tetromino curr;
Shape next;
Shape[] shapes = new Shape[7];
int timer = 8;
int currTime = 0;
int score = 0;
int lines = 0;
int level = 1;
final int SPEED_DECREASE = 2;
boolean game_over = false;
boolean show_score = false;
boolean init = false;

//PixelLines parameters
IntList pixellines_color1;
IntList pixellines_color2;
int pixellines_strokeWidth = 4;

//Pong parameters
boolean gameover= false, command_p1_right = false, command_p1_left = false, command_p2_right = false, command_p2_left = false;
int topscore = 0;
int topmatchcount = 0;
int bottomscore = 0;
int bottommatchcount = 0;
float changespeed = 0;
int randomarea = 10;
int pong_rectwidth = 5;
int pong_rectheight = 4;
int pong_rectspacing = 8;
Paddle bottom;
Ball pongball;
Paddle top;
PFont font;
boolean gamestart = false;
float pong_sideFactor = 0;

//Rorschach parameters
int nBalls;
int nSteps;
float thresh;
float vMax;
float[][] balls;
 
int numBallShapes = 4;
int movementMode = 3;
boolean invertAlpha;
boolean blackBackground;
int backgroundColor;
int ballColor = color(255,0,0);
boolean randomColor;
PImage ballImage;
int radius;

//Unfolding lines parameters
float supposed_height = 1;

//Superformula parameters
int superformula_num = 60;
int superformula_colorL=255,superformula_k = 0,superformula_j=100,superformula_i=200;
float superformula_x,superformula_y,superformula_z;
float superformula_r,superformula_th=0,superformula_step=.1f,superformula_epi=200;
float superformula_m = 1,superformula_n1=-1,superformula_n2=0,superformula_n3=0;
float superformula_b=1,superformula_a=1;
int superformula_counter1=-2, superformula_counter2=0;

//Growing Triangle parameters
ArrayList trianglelist = new ArrayList();
growingTriangle triangle1;

//Moire parameters
moire moireOne;
moire moireTwo;

//ResponsiveCircles parameters
int responsiveCircles_x;
int responsiveCircles_y;
boolean responsiveCircles_forward = true;
boolean responsiveCircles_alreadycalled = false;
int[] colortheme = {
  0xff00B9EE, 0xff009FE3, 0xff00497F,
  0xff03326C, 0xff83D0F5, 0xff006F9E,
  0xff004899, 0xff052453
};

//ParticlesExplode parameters
ArrayList<ParticleExplode> arr;
int particleColor;
boolean particlesexplode_alreadyinitialised = false;

//Starfield parameters
StarPoint[] starfield_asteroids1 = new StarPoint[4];
StarPoint[] starfield_asteroids2 = new StarPoint[6];
 
StarPoint[] starfield_satellite = new StarPoint[1]; //starfield_satellite
StarPoint[] starfield_planet = new StarPoint[1]; //starfield_planet
//StarPoint[] asteroids3 = new StarPoint[155]; //bg

//ColorVertex parameters
ArrayList colorvertex_pointarray;
int colorvertex_distance =50;

//ParticlesFlow parameters
ImgProc imgProc = new ImgProc();
 
float particlesflow_noiseScale = 0.01f;
float particlesflow_noiseZ = 0;
int particlesflow_particlesDensity = 1;
int particlesflow_particleMargin = 30; 
ParticleFlow[] particlesflow_particles;
int[] particlesflow_currFrame;
int[] particlesflow_prevFrame;
int[] particlesflow_tempFrame;

//BezierFlowers
int bezierflowers_leaf = 1;  //  Number of leaves
int bezierflowers_col = 0;   //  Color
int bezierflowers_deep = 0;  //  Color density
final int bezierflowers_MAX_POINT = 2;   //  Number of control points for the Bezier lines
ControlPoint[] bezierflowers_controlpoints = new ControlPoint[bezierflowers_MAX_POINT];  // Bezier control points
int bezierflowers_timer = 0;  //  Timer

//JointCircles parameters
int jointcircles_time = 0;

//TunnelRed and TunnelWhite parameters
int tunnel_num = 20;
int tunnel_counter = 0;
int tunnel_color_counter;
float[] tunnel_grises = new float[tunnel_num];

//CosmoCurve parameters
float cosmoscurve_r;
float cosmoscurve_a = 50;
float cosmoscurve_n = 0;
float cosmoscurve_d = 2;
  
PVector cosmoscurve_point = new PVector(0,0);;
PVector cosmoscurve_center;

//PerlinColor parameters
float colorperlin_LOOKER_RADIUS = 32.0f;
float colorperlin_numX = 13;
float colorperlin_numY = 13;
float colorperlin_noiseCount = 1;
AngleThing[][] colorperlin_myAngleThing = new AngleThing[(int)colorperlin_numX][(int)colorperlin_numY];

//OppositeLinesNoBackground parameters
float oppositeLinesNoBackground_x = 0;
boolean oppositeLinesNoBackground_rightside = true;
boolean oppositeLinesNoBackground_reinit = true;

//OpeningLines parameters
float openinglines_x = 0;

//SingleSquareSpiral parameters
int singleSquareSpiral_boxSize = 36;
int singleSquareSpiral_windowSize = NUMBER_OF_PANELS*40;
float singleSquareSpiral_tick = 1; 
boolean singleSquareSpiral_altCol = true;
boolean singleSquareSpiral_start = true; 

//DualSquareSpiral parameters
int dualSquareSpiral_boxSize = 40;
int dualSquareSpiral_windowSize = 32*NUMBER_OF_PANELS;
float dualSquareSpiral_tick = 1; 
boolean dualSquareSpiral_altCol = true;
boolean dualSquareSpiral_start = true; 

//ComplexSpiral parameters
int complexspiral_counter = 0;

//BeatCircle parameters
int beatcircle_counter = 0;
float beatcircle_radius = 64;
float beatcircles_linepos = 0;

//Blue and RedDiagonalLines parameters
float blueposx = 0;
float redposx = 0;
float blueposy = 0;
float redposy = 0;

//WhiteNoiseCrescendo parameters
int whitenoisecrescendo_brightness = 20;

//InwardsSpiral parameters
int inwardsspiral_counter = 0;
int inwardsspiral_size = 12;
float inwardsspiral_speed = 0.15f;
float inwardsspiral_ratio = inwardsspiral_speed*8;
float inwardsspiral_radius = 50+(NUMBER_OF_PANELS-3)*15;

//ExplodingCircle parameters
int explodingcircle_counter = 0;
int explodingcircle_speed = 8 + 2*(NUMBER_OF_PANELS-3);

//Rotozoom parameters
int rotozoom_w=256,rotozoom_a,rotozoom_b,rotozoom_c,rotozoom_d;

//NewtonPendulum parameters
WavePendulum newtonpendulum_p;
float newtonpendulum_t = 0.0f;
ArrayList newtonpendulum_pends;
float[] newtonpendulum_lengths = new float[30];
float newtonpendulum_g = 9.8f;

//Pendulum parameters
int pendulum_n = 200;
LargeWheelPendulum wheelpendulum_p;
float wheelpendulum_t = 0.0f;
ArrayList wheelpendulum_pends;
float[] wheelpendulum_lengths = new float[pendulum_n];
float wheelpendulum_g = 9.8f;
HypnoWheelPendulum hypnopendulum_p;
float hypnopendulum_t = 0.0f;
ArrayList hypnopendulum_pends;
float[] hypnopendulum_lengths = new float[pendulum_n];
float hypnopendulum_g = 9.8f;
float hypnopendulum_fadein = 0;
float hypnopendulum_fadeinSpeed = 0.05f;

//Mugen parameters
float mugen_xamp, mugen_yamp, mugen_x, mugen_y, mugen_px, mugen_py;

//ArcWave parameters
ArcWaveClass[] arcwave_arcs;
float arcwave_ray;int arcwave_maxi;

//OutwardSpiral parameters
float outwardspiral_x,outwardspiral_y, outwardspiral_theta, outwardspiral_r, outwardspiral_c;

//Columns parameters
float columns_firsty = PApplet.parseInt(random(0,64));
float columns_secondy = PApplet.parseInt(random(0,64));
float columns_thirdy = PApplet.parseInt(random(0,64));
int columns_firstheight1 = 16;
int columns_secondheight1 = 16;
int columns_thirdheight1 = 16;
int columns_firstheight2, columns_secondheight2, columns_thirdheight2;
int columns_offsetx = 8;
int columns_offsety = 4;
boolean columns_shift = false;

//CircleContour parameters
float circlecontour_amp2 = 24;
float circlecontour_amp = 24;
float circlecontour_phase = 1;
int circlecontour_elements = 5;
float circlecontour_turn = 1.0f;
float circlecontour_lineweight = 0.23f;

//ColorExplode parameters
colorexplode_particle[] colorexplode_Z = new colorexplode_particle[100];
float colorexplode_colour = random(1);
float colorexplode_r;
int colorexplode_intcounter = 0;
boolean colorexplode_init = false;

//ColorRain parameters
boolean colorrain_init = false;
colorrain_CellArray colorrain_cells;

//WarpSpeed parameters
int warpspeed_i,warpspeed_x,warpspeed_y,warpspeed_b;

//BWTriangles parameters
ParticleSystem bwtriangles_particles;
int bwtriangles_nbrParticles = 5 + (NUMBER_OF_PANELS-2);
int bwtriangles_vit = 2;
float bwtriangles_boxDist = 2;

//GlitchDiagonalLines parameters
int glitchdiagonallines_num = 25;
glitchdiagonallines_Particle[] glitchdiagonallines_particleArray = new glitchdiagonallines_Particle[glitchdiagonallines_num];

//FlashingDotsBorder parameters
int flashingdotsborder_num = 6;
int flashingdotsborder_posx = PApplet.parseInt(random(0,24));
int flashingdotsborder_posy = 0;
int[] flashingdotsborder_x = new int[flashingdotsborder_num];
int[] flashingdotsborder_y = new int[flashingdotsborder_num];

//FallingCircles parameters
FallingCircles fallingCircles;
int fallingcircles_fade;
boolean fallingCircles_init = false;

//ExplodingParticles
int nbExplodingParticles=1000;
float explodingparticle_asp=0;
ExplodingParticles[] explodingparticle = new ExplodingParticles[nbExplodingParticles];
boolean ExplodingParticles_explodeflag = true;
boolean explodingparticle_init = false;

//RandomBWFlow
int randomBWFlow_resolutionX = 8*NUMBER_OF_PANELS;
int randomBWFlow_resolutionY = 16;
PVector randomBWFlow_flow[][] = new PVector[randomBWFlow_resolutionX][randomBWFlow_resolutionY];
float randomBWFlow_density[][] = new float[randomBWFlow_resolutionX][randomBWFlow_resolutionY];
float randomBWFlow_wind[] = new float[randomBWFlow_resolutionY]; // horizontal bands
int randomBWFlow_particleCount = randomBWFlow_resolutionX*randomBWFlow_resolutionY*3;
RandomBWFlowParticle bwflowparticle[] = new RandomBWFlowParticle[randomBWFlow_particleCount];
int currentRandomBWFlowParticle;
int randomBWFlow_oldMouseX;
int randomBWFlow_oldMouseY;
int randomBWFlow_alpha = 255;
float randomBWFlow_varSpeed = 0.03f;
boolean randomBWFlow_initComplete = false;

//Tesselate parameters
int tesselate_palette[] = { 0xff3415B0, 0xffFFCF00,
                    0xffFF2100, 0xff0F4DAB,
                    0xffF80012, 0xff1DD300,
                    0xffFFFFFF, 0xff999999};
int tesselate_size_b;
int tesselate_size_a;
int tesselate_size_dir = 1;
int tesselate_size_time_den = 120;
int tesselate_size_c_pal = 1;
int tesselate_size_point_x;
float tesselate_cont = 0;
final int tesselate_BIG   = 0;
final int tesselate_SMALL = 1;
 
//DigitalHexParticles parameters
DigitalHexParticleSystem digitalhexparticleSystem;

 
//RedArcTransition and BlueArcTransition parameters
int redarctransition_topleftx;
int redarctransition_toplefty;
int redarctransition_toprightx;
int redarctransition_toprighty;
int redarctransition_x1;
int redarctransition_y1;
int redarctransition_x2;
int redarctransition_y2;
int redarctransition_x21;
int redarctransition_y21;
int redarctransition_x22;
int redarctransition_y22;
int redarctransition_bottomtopx;
int redarctransition_bottomtopy;
int redarctransition_bottomdownx;
int redarctransition_bottomdowny;
int redarctransition_increment = 4;

//LightBlobs
int lightblobs_numBlobs = 13;
float lightblobs_scale = 1;
lightblobs_Blob lightblobs_b[] = new lightblobs_Blob[lightblobs_numBlobs];
PGraphics lightblobs_pg;
int lightblobs_w,lightblobs_h;

//RandomSmokeParticles
int smokeparticles_count = 200;
float smokeparticles_t = 0, smokeparticles_dt = 0.01f;
float smokeparticles_spinSpeed = 75 * 0.01f/smokeparticles_dt;
int smokeparticles_seed;

//RedMetaBalls
int redmetaballs_numBlobs = 3;
redmetaballs_Blob redmetaballs_b[] = new redmetaballs_Blob[redmetaballs_numBlobs];
PGraphics redmetaballs_pg;
int redmetaballs_w,redmetaballs_h;

//Butterfly
float butterfly_t=0,butterfly_s,butterfly_p,butterfly_k,butterfly_l;
float butterfly_x,butterfly_y,butterfly_x2,butterfly_y2,butterfly_x3,butterfly_y3,butterfly_x4,butterfly_y4;
float butterfly_a1,butterfly_b1,butterfly_a2,butterfly_b2,butterfly_a3,butterfly_b3,butterfly_a4,butterfly_b4;
float butterfly_formFactor = 0.15f;
float butterfly_speedFactor = 0.02f;
float butterfly_scale = 0.3f;

//CirclePusher
PVector[] circlepusher_loc;                      //Circles position
float[] circlepusher_rad;                        //Circles radius
int circlepusher_num = 18 + NUMBER_OF_PANELS*2;  //Number of circles
float circlepusher_rate = 1.05f;                  //Circle radius magnification rate
boolean circlepusher_alreadyGenerated = false;   //Boolean to go through Init routine
boolean circlepusher_setAngleRotate;             //Switch between rotating and straight circles 

//Shutter parameters
int shutter_colorMode = 0;
float shutter_angle = 0;
final float shutter_distanceInit = NUMBER_OF_PANELS*32;
final float shutter_distanceLimit = 0;
final float shutter_speedIncrement = 1;
final float shutter_angleIncrement = 0.01f;
float shutter_distance = shutter_distanceInit;

//OrbitingParticles parameters
OrbitingParticle[] orbitingparticles_particlelist;
int orbitingparticles_number = 20;
float orbitingparticles_dispersion = 4;
float orbitingparticles_speedmin = 0.1f;
float orbitingparticles_speedmax = 0.3f;
float orbitingparticles_globalx;
float orbitingparticles_globaly;
float orbitingparticles_pullback = 1.6f;
boolean orbitingparticles_initialised = false;
int orbitingparticles_state = 0;

//FlowingLines (Vines) parameters
final float flowing_lines_MAX_ANGLE = radians(50);
final int flowing_lines_MARGIN = 12;
final int flowing_lines_DISTANCE = 300;
final int flowing_lines_FRAMES_PER_DISTANCE = 80;
final int flowing_lines_NUM_POINTS = 75;
FlowingLinePath flowing_lines_Path;
FlowingLine flowing_lines_lines[];
int flowing_lines_screen_x, flowing_lines_screen_y;
boolean flowing_lines_init = false;

//ArrowStyle parameters
float arrowstyle_height;
float arrowstyle_pos;
float arrowstyle_increment = 1.5f + (NUMBER_OF_PANELS - 3);

//SingleArrow parameters
int singlearrow_strokeCap = 16;
int singlearrow_maxarrownumber = 50;
ArrayList<SingleArrow> singlearrow_arrowlist;
boolean singlearrow_initialized = false;

//Rotozoom parameters
PImage rotozoom_img;
float rotozoom_angle=0;
float rotozoom_scalee=1;
float rotozoom_dscalee=0.05f;

//MilkTank parameters
final int milktank_numberofparticles = 20;
final int milktank_contractiontime = 25;
int[][] milktank_pixi;
float milktank_f;
int milktank_contraction = 0;
int milktank_w;
int milktank_h;
int milktank_regroupX;
int milktank_regroupY;
boolean milktank_m;
milktank_blob[] milktank_blobs;

//FireNoiseSquares parameters
FireNoiseSquare[] squares;

//Slasher parameters
Slash[] slash;
int slasher_nb = 6;
int[] slasher_colors = {color(120,30,220), color(222, 31, 31), color(222, 184, 31)};
boolean slasher_initialized = false;

//NekoJiru parameters
int nekojiru_eyearcparam1;
int nekojiru_eyearcparam2;
int nekojiru_eyesizeX;
int nekojiru_eyesizeY;
int nekojiru_eyedistance;
int nekojiru_bulgesize;
int nekojiru_bulgedistance;
float nekojiru_posX = 0;
float nekojiru_posY = 0;
float nekojiru_blinky = 0;
float nekojiru_blinkyMax = 0;
float nekojiru_blinkyNasty = 0;
float nekojiru_mx;
float nekojiru_my;
float nekojiru_bulge = 0;
float nekojiru_leftdist;
float nekojiru_rightdist;
float nekojiru_fillr;
float nekojiru_fillg;
float nekojiru_fillb;
boolean nekojiru_blink = false;
boolean nekojiru_blinkNasty = false;
boolean nekojiru_surprise = false;
boolean nekojiru_angry = false;
NekoJiruStateMachine nekojiru_machine;
int nekojiru_currentState = 0;

//LetterExplode parameters
int particleletters_N = 180;
float particleletters_repulsion = 0.05f;       // how much the particles repel each other
float particleletters_contraction = 0.0002f;    // how much they are pulled towards the center
float particleletters_damping = 0.80f;          // how much drag is applied to the particles
float particleletters_drift = 0.25f;            // how strong the random forces are
int particleletters_impulse = 50;              // number of frames until the particles reach the target
int particleletters_activeTime = 20;           // number of frames until they become particleletters_idle again
int particleletters_printTime = 30;           // number of frames between letters
 
boolean particleletters_idle = true;           // particleletters_idle => particles repel and drift around
boolean particleletters_printing = false;
String particleletters_buffer = "";
String particleletters_wordToPrint = "XI";
int particleletters_counter = 0;
PGraphics particleletters_letter;
PFont particleletters_font;
LinkedList<LetterParticle> particleletters_parts = new LinkedList<LetterParticle>();

//Thunderlines parameters
float thunderline_maxperturbation = 0.15f;
float thunderline_maxspeed = 8;
ArrayList<ThunderLine> thunderline_list;
int thunderline_density = 5;
int thunderline_refreshrate = 10;    //0, no refresh, - 255, points disappear immediately
int thunderline_persistance  = 12;
boolean thunderline_init = false;
boolean thunderline_setupcomplete = false;

//Opening Whiteout parameters
float openingWhiteout_cpt = 4;
float openingWhiteout_verticalCpt = 0;
float openingWhiteout_speed = 0.19f;
float openingWhiteout_verticalSpeed = 0.35f;
long openingWhiteout_lastInitTimestamp = System.nanoTime();
final long TEN_SECONDS = 10000000000l;

//DoubleFusee parameters
int doublefusee_a;
int doublefusee_epaisseurLigne;
int doublefusee_vitesseLigne;
int doublefusee_compteur;
int[] doublefusee_tab1;
int[] doublefusee_tab2;
int[] doublefusee_tab3;
int[] doublefusee_tab4;

//DiscoStar parameters
float discostar_colorwheel = 0;
float discostar_colorinc = 0.5f;

//WormHole parameters
float wormhole_x = 0;
float wormhole_y = 0;
float wormhole_a = 0;
float wormhole_b = 0;
float wormhole_c_init = PI/16;
float wormhole_c = wormhole_c_init;

//Atoms parameters
boolean atoms_initialised = false;
ArrayList<Electron> atoms_electronlist;
int atoms_orbitsize = 32;
int atoms_electronsize = 8;
int atoms_electrontail = 30;
int atoms_beatprotomaxsize = 36;
int atoms_beatprotominsize = 8;
int atoms_numberofelectrons;
float atoms_beatprotosize;
boolean atoms_redprotocolor = true;

//PerfectCircle parameters
boolean perfect_circleinitialised = false;
ArrayList<PerfectCircle> perfect_circleperfectcirclelist;
int perfect_circleorbitsize = 32;
int perfect_circleperfectcirclesize = 8;
int perfect_circleperfectcircletail = 30;
int perfect_circlebeatprotomaxsize = 36;
int perfect_circlebeatprotominsize = 8;
float perfect_circlebeatprotosize;
boolean perfect_circleredprotocolor = true;

//HyperSpeed parameters
int hyperspeed_numberofstars = 64 + 15*(NUMBER_OF_PANELS - 3);
int hyperspeed_blur = 25;
int hyperspeed_maxspeed = 6;
ArrayList<NagareBoshi> hyperspeed_nagarelist;
boolean hyperspeed_init = false;

//ColorWave parameters
float waves_t = 0, waves_dt = 0.005f;
float waves_ampsize = 0;
int waves_numberofparticles = 400;
int waves_maxcolorhue = 20;
int waves_mincolorhue = 0;
int waves_attenuation = 50;
boolean waves_ampwait = false;
boolean waves_init = false;
ArrayList<ColorWave> waves_list;

//ContinuousTriangles parameters
float continoustriangles_leftposy = 0;
float continoustriangles_centerposy = 0;
float continoustriangles_rightposy = 0;
float continoustriangles_leftspeed = 1.2f;
float continoustriangles_centerspeed = 1.2f;
float continoustriangles_rightspeed = 1.2f;
int continoustriangles_red = color(255,0,0);
int continoustriangles_white = color(255);
int continoustriangles_black = color(0);
boolean continoustriangles_drift = false;
boolean continoustriangles_resync = true;
boolean continoustriangles_invert = false;

//Mandala parameters
int mandala_numbranches = 3;
int mandala_numstarlayers = 4;
int mandala_numstars = 6;
int mandala_numsquares = 6;
float mandala_figuresize = 34;
float mandala_barsize = 27;
float mandala_angle = 0;
float mandala_angle2 = 0;
int mandala_color;
int mandala_maxballsize = 48;
int mandala_minballsize = 8;
float mandala_ballsize;
boolean mandala_switch;

//Kaleido parameters
int kaleido_rings = 10;
int kaleido_t = 0;
int kaleido_seed = 751;      //floor(random(1000))
int kaleido_posX;

//Flowers parameters
ArrayList flowers_flowers;
int flowers_sequencenumber = 0;

//ElectricSpiral parameters
int electricspiral_nbrPoints = 50;
int electricspiral_cx,electricspiral_cy;
int electricspiral_counter =0 ;
int electricspiral_frameCtr = 0;
int electricspiral_animationspeed = 30;
long electricspiral_framecounter = 0;
float electricspiral_crad;
float electricspiral_cycleLength = 2*PI*electricspiral_nbrPoints;
float electricspiral_speed = 2;
ElectricSpiralDot[] electricspiral_dots = new ElectricSpiralDot[electricspiral_nbrPoints];

//SmallSquares parameters
int smallsquares_offset = 4;

//FastSpiral parameters
float fastspiral_x,fastspiral_y, fastspiral_theta, fastspiral_r, fastspiral_c;
float fastspiral_transparency = 0;
boolean fastspiral_kill = false;

//WeirdSquare parameters
int weirdsquare_step;
float weirdsquare_bezierbase;
int weirdsquare_offset;
float weirdsquare_time = 0;
float hueOffset = 0.90f;
float weirdsquare_redbackground = 0;
float weirdsquare_noiseSpeed = 0.0015f;

//ProgressiveRed parameters
float progressivered_color = 0;

//SpotsMulticolor parameters
int[] spotsmulticolor_colorselection = {color(0, 176, 250),color(89, 180, 116),color(71, 206, 205),color(255, 255, 255),color(38, 30, 157),color(255, 255, 255),color(123, 9, 254),color(63, 144, 86),color(255, 255, 255)};

//Strobolinecolor parameters
int[] strobolinecolor_colorselection;

//DoubleFlowers parameters
ArrayList doubleflower_flowers;
ArrayList doubleflower_zOscillators;

//3DAnimations parameters
ProjectionViewer thirdDimension_viewer3d;
int[] thirdDimension_colorlist3d = new int[2];
int thirdDimension_pyramidfrequency = 35;
int thirdDimension_jerkyEdgeFrequency = 3;
int thirdDimension_counter = 0;
int thirdDimension_nodeSelector = 0;
boolean thirdDimension_noglitchcubeinit = false;
boolean thirdDimension_jerkyinit = false;

//BloodSki parameters
int bloodSki_Co;
int bloodSki_Xc;
int bloodSki_Yc;
int bloodSki_Wc;
int bloodSki_Hc;
int bloodSki_S;
int bloodSki_N;
int bloodSki_minRad;
int bloodSki_maxRad;
BloodSkiParticleManager bloodSki_particleManager;

//Gloubiboulga parameters
int gloubiboulga_thresh=30;
int gloubiboulga_avoid_distance = 2;
float gloubiboulga_avoid_strength = 0.6f;
int gloubiboulga_cohere_distance = 15;
float gloubiboulga_cohere_strength = 0.05f;
int gloubiboulga_align_distance = 10;
float gloubiboulga_align_strength = 0.02f;
float gloubiboulga_maxvel = 1.8f;
ArrayList gloubiboulga_swarm = new ArrayList(); 

//RevolutionLine parameters
RevolutionLine[] revolutionline_lines;

//Rednoise parameters
float rednoise_circlerad = 0;

//TurningSingleLines parameters
float turningsinglelines_init = 0;    //Defined during setup
float turningsinglelines_increment = 10;
float turningsinglelines_angle = 0;
float turningsinglelines_angleincrement = 0.2f;
ArrayList<SingleTurningLine> turningsinglelines_lines;

//RandomAppearingLines parameters
float randomappearinglines_speedx = 0;
float randomappearinglines_speedy = 12;
float randomappearinglines_currentangle = 0;
int randomappearinglines_framechange = 9;
int randomappearinglines_framecount = 0;
int randomappearinglines_initx = 20;
int randomappearinglines_inity = -40;
int randomappearinglines_currentx = randomappearinglines_initx;
int randomappearinglines_currenty = randomappearinglines_inity;
int randomappearinglines_previousx = randomappearinglines_currentx;
int randomappearinglines_previousy = randomappearinglines_currenty;

//ImpulseRectangles parameters
int impulserectangles_posx = 0;
int impulserectangles_posy = 0;
int impulserectangles_incrementx = 15;
int impulserectangles_incrementy = 10;
int impulserectangles_rectanglesize = 32;

//Crescent parameters
float crescent_distext;
float crescent_distint;
int crescent_number = 6;
float crescent_emphasis = 0;
float crescent_speed = 0.1f;
float crescent_minstrokeweight = 4;
float crescent_maxbonussize = 16;
float crescent_fatfactor;
float crescent_colorfactor = 10;

//Clock parameters
float clock_mainangle = 0;
float clock_speed = 0.025f;
int clock_numberofbranches = 4;
boolean clock_rotate;
float clock_subangle = 0;
float clock_subspeed = 0.075f;

//ColorBeat parameters
float colorbeat_maxval;
float colorbeat_value;
float colorbeat_minvalue;
float colorbeat_transitionpos;

//InvertExplode parameters
int invertexplode_numberoflines = 6;
float invertexplode_maxcirclewidth;
float invertexplode_circlewidth;
float invertexplode_circlespeed = 8;
float invertexplode_maxcirclehue = 90;
float invertexplode_circlehue;
float invertexplode_huespeed = 7;
float invertexplode_pos;
float invertexplode_linelength;
float invertexplode_angle = 0;
float invertexplode_anglespeed = 0.5f * (PI/invertexplode_numberoflines);

//DarkSnakes and BrightSnakes parameters
BrightSnake[] brightsnakes_snakes = new BrightSnake[0];
DarkSnake[] darksnakes_snakes = new DarkSnake[0];


//LightPainting parameters
int lightpainting_particleCount = 64;
int lightpainting_emissionPeriod = 2;                                      //The number of events that must occur before a spark is emitted.  Increasing this will improve performance as well as change the aesthetics.
float lightpainting_lowBounce = 0.5f;                                       //The lowest ratio of vertical speed retained after a spark bounces.
float lightpainting_highBounce = 0.8f;                                      //The highest ratio of vertical speed retained after a spark bounces.
float lightpainting_spraySpread = 2.0f;                                     //The variation in velocity of newly-created lightpainting_sparks.
float lightpainting_earthGravity = 1.0f / 16.0f;
float lightpainting_moonGravity = lightpainting_earthGravity / 6.0f;
float lightpainting_jupiterGravity = lightpainting_earthGravity * 2.5f;
float lightpainting_gravity = lightpainting_earthGravity;                  //The amount of acceleration due to gravity.
float lightpainting_tolerance = 0.5f;                                       //The amount of error allowed in model coordinate measurements.  Lowering this will let lightpainting_sparks have tiny bounces longer.
float lightpainting_focalLength = 1000.0f;                                  //The focal length from the viewer to the screen in model coordinates.
float lightpainting_interaction_distance = 4 * lightpainting_focalLength;  //The distance in model coordinates from the viewer to where new lightpainting_sparks are created.  Increasing this number will move the created sparks further away.
LightPaintingCanvas3D lightpainting_canvas;                                //A custom 3D lightpainting_canvas used to draw the world.
LightPaintingParticle lightpainting_sparks[] = new LightPaintingParticle[lightpainting_particleCount];//A collection of Particles that represent the spraying sparks. 
int lightpainting_nextSpark = 0;                                           //The index of the LightPaintingParticle to use for the next spark created.
int lightpainting_skipCount = 0;                                           //The number of drag events that have passed without emitting a spark.
int lightpainting_numberofimpulses = 4;                                    //The number of sparks created by calling the animation
boolean lightpainting_initok = false;                                      //Define if the animation was initialised
long lastFrameDrawn = millis(); 
float averageElapsedMillis = 20.0f;

//ShiftPixels parameters
int shiftpixels_slowspeed = 4;
int shiftpixels_fastspeed = 8;
int shiftpixels_speed = shiftpixels_slowspeed;

//LightFusion parameters
int lightfusion_xmin = -20;
int lightfusion_xmax = 10;
int lightfusion_ymin = -20;
int lightfusion_ymax = 10;
int lightfusion_xspan;
int lightfusion_yspan;
float lightfusion_X;
float lightfusion_Y;
float lightfusion_speedX;
float lightfusion_speedY;
float lightfusion_timeincrement = 0.4f;
float lightfusion_time = 0;
boolean lightfusion_moveUp;
boolean lightfusion_moveRight;
boolean lightfusion_column = true;
boolean lightfusion_mousemoved = false;

//RandomPaint parameters
float randompaint_len = 0.4f;
float randompaint_lastX,randompaint_lastY;
float randompaint_startX;
float randompaint_startY;
int randompaint_t = 0;
float randompaint_ang = random(360);
int randompaint_pixelsize = 4;

//RedWave parameters
float redwave_xmin = 0;
float redwave_xmax = 30;
float redwave_ymin = 0;
float redwave_ymax = 30;
float redwave_timeIncrement = 0.1f;
float redwave_dx, redwave_dy;
float redwave_t = 0;
int redwave_i = 0;
float redwave_xspan;
float redwave_yspan;

//DiagonalColors parameters
boolean diagonalcolor_init = false;
DiagonalColor[] diagonalcolors = new DiagonalColor[90];

//HypnoSpiralRed parameters
float hypnospiralred_X;
float hypnospiralred_Y;
float hypnospiralred_xmin = -1;
float hypnospiralred_xmax = 1;
float hypnospiralred_ymin = -1;
float hypnospiralred_ymax = 1;
float hypnospiralred_timeIncrement = 0.04f;
float hypnospiralred_timeIncrementFactor = 0.001f;
float hypnospiralred_noiseScale = 0.01f;
float hypnospiralred_noiseScale2 = 0.03f;
float hypnospiralred_noiseMove = 2;
float hypnospiralred_t = 0;
float hypnospiralred_xspan;
float hypnospiralred_yspan;


//NightRoad parameters
float nightroad_xmin = -1;
float nightroad_xmax = 1;
float nightroad_ymin = 0.5f;
float nightroad_ymax = 0.04f;
float nightroad_t = 0;
float nightroad_xspan;
float nightroad_yspan;
float nightroad_timeIncrement = 0.2f;
float nightroad_direction;
float nightroad_Y;
float nightroad_beatspeed = 6;
int nightroad_frameCounter = 0;
float nightroad_brightness;

//HypnoFlashTriangle parameters
int hypnotriangle_instancecounter = 0;
boolean hypnotriangle_init = true;
ArrayList<HypnoTriangle> hypnotriangle_list;

//RotatingCut parameters
float rotatingcut_angle = random(0, 2*PI);
float rotatingcut_speed = 0.01f;

//ArcRot parameters
float arcRot_maxiPi = 5 * TWO_PI;
float arcRot_maxPulseSize = 24;
float arcRot_pulseSize = arcRot_maxPulseSize;
float arcRot_pulseSpeed = 2;

//EnergyGrid parameters
int energytriangles_density = 4; 
ArrayList<EnergyTriangle> EnergyTriangles = new ArrayList<EnergyTriangle>();
float energytriangles_energy = 180; 
boolean energytriangles_init = false;

//ReverseTriangles parameters
PGraphics reverseTriangles_red;
PGraphics reverseTriangles_green;
float reverseTriangles_sizeInit = 0.4f;
float reverseTriangles_speed = 1.15f;
float reverseTriangles_size;

//TrigoShapes parameters
int trigoshapes_chosenFunction = 0;
float trigoshapes_particleAngle = 0;
float trigoshapes_particleFormation = 0;
float trigoshapes_radius;
float trigoshapes_smallradius;
TrigoShapeParticle[] trigoshapes_particles;
TrigoShapeParticle[] trigoshapes_particles2;
float trigoshapes_hue = 0;
float trigoshapes_hueIncrement = 2;
PImage trigoshapes_arrowImage;
boolean trigoshapes_initComplete = false;

//nonotak parameters
int nonotak_1_color = 0;
int nonotak_1_x = 0;
int nonotak_2_x = 0;
int nonotak_3_x = 0;
int nonotak_4_y = 0;
int nonotak_5_y = 0;
boolean nonotak_5_up = false;

//NonotakPanelFill parameters
ArrayList<NonotakPanelFill> nonotakPanelFill_list = new ArrayList<NonotakPanelFill>();

//NonotakWoosh parameters
ArrayList<NonotakWoosh> nonotakWoosh_list = new ArrayList<NonotakWoosh>();

//Patatap parameters
boolean patatap_init = false;
ArrayList<PatatapObject> patatapObjectList;
int[] patatap_maxProgressTable = {10, 15, 30, 15, 40, 16, 20, 26, 45, 96/4, 35, 25, 30, 15, 40};
boolean[] patatap_switcher = {false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false};
int patatap_currentColorset = 1;
int[] patatap_colorsetBackground  =   {color(46,167,209),  color(0,0,0)          };
int[] patatap_colorsetFlash       =   {color(255,0,0),     color(255,255,255)    };
int[] patatap_colorsetElement1    =   {color(239,30,54),   color(229,252,194)    };
int[] patatap_colorsetElement2    =   {color(240,139,95),  color(157,224,173)    };
int[] patatap_colorsetElement3    =   {color(241,216,142), color(69,173,168)     };
int[] patatap_colorsetElement4    =   {color(126,210,182), color(84,121,128)     };

//ParallelWorlds parameters
ArrayList<ParallelWorldLine> parallelworlds_list;
float parallelworlds_speed = 3;
float parallelworlds_flashpower = 0;
float parallelworlds_colorDecreaseSpeed = 255/13;
boolean parallelworlds_init = false;
boolean parallelworlds_reverse = false;

//Fireflies parameters
int fireflies_number = 50;
int fireflies_edge;
ArrayList<Firefly> fireflies_list;
boolean fireflies_init = false;

//MultiCrecy parameters
int[] crecy_maxProgressList = {10,10,10,10,10,10,10,10,10,10,
                               20,20,20,20,20,20,20,20,20,20,
                               35,35,35,
                               15,15,15,15,15,15,15,15,15,15,
                               25,25,25,25,25,25,
                               25,25,25,25,25,25};
ArrayList<Crecy> crecy_list;
int crecy_internalCounter = 0;
int crecy_changeRate = 64;
int crecy_red   = 0;
int crecy_green = 255;
int crecy_blue  = 0;
boolean crecy_init = false;
int crecy_colorcounter = 0;
int crecy_previousDouble = 0;

//Snake parameters
ArrayList<SnakeObjective> snake_objectives;
Snake snake_instance1;
Snake snake_instance2;
Snake snake_instance3;
Snake snake_instance4;
Snake snake_instance5;
Snake snake_instance6;
int snake_weight = 8;
boolean snake_init = false;

//SweepingBallsAndArrows parameters
float sweeperBalls_randomAccel = 0.1f;
ArrayList<SweeperBall> sweeperBalls_list;
ArrayList<DoubleArrow> sweeperBalls_listarrow;
int sweeperBalls_maxBallSize = 24;
int sweeperBalls_minBallSize = 4;
float sweeperBalls_initSpeed = 4;
float sweeperBalls_initSpeedVar = 3;
int sweeperBalls_nbOfBalls = 30;
float sweeperBalls_arrowSpeed = 4;
boolean sweeperBalls_arrowcolor = false;
boolean sweeperBalls_init = false;

//RotatingHalfCircle parameters
float rotatingHalfCircle_x;
float rotatingHalfCircle_transparency; 
float rotatingHalfCircle_corner; 
float rotatingHalfCircle_theta;
float rotatingHalfCircle_size;
int rotatingHalfCircle_num = 40;

//PeriodicNoise parameters
float periodicNoise_noiseSpeed = 0.02f;

//Tumbler parameters
float tumbler_r = 0;
float tumbler_theta = 0;

//DynamicAngleLines parameters
float dynamicAngleLines_angle = 0;
float dynamicAngleLines_angleSpeed = 0.02f;
int dynamicAngleLines_maxLineWidth;
int dynamicAngleLines_nbrLines = 15;
boolean dynamicAngleLines_positiveInc = true;

//FauveRandomFlash parameters
int fauveRandomFlash_blueWhite = color(230,230,255);
int fauveRandomFlash_red = color(255,0,0);
int fauveRandomFlash_minEllipseSize = 58;
int fauveRandomFlash_maxEllipseSize = 24;

//BarWaves parameters
int barWaves_colBlue1=0xff0B486B, barWaves_colBlue2=0xffCFF09E;
int barWaves_colBlack=0xff000000, barWaves_colWhite=0xffFFFFFF;
int barWaves_colRed1=0xff220000, barWaves_colRed2=0xffFF0000;
int barWaves_columns;
float barWaves_stepX, barWaves_theta, barWaves_ot, barWaves_fc, barWaves_time, barWaves_scal=1;
float[] barWaves_offSets;
float[] barWaves_offTheta;
float barWaves_speed = 0.1f;
boolean barWaves_init = false;

//RedSun parameters
int redSun_rs = PApplet.parseInt(random(1000));
int redSun_num=50;
float redSun_szS, redSun_szB, redSun_angle, redSun_theta;
int redSun_internalCircleRadius = 0;
int redSun_internalCircleLimitSize = 32;
int redSun_circleSpeed = 4;

//SlicedWave parameters
int slicedWave_slices = 4;
int slicedWave_pieces = 5;
int slicedWave_num=slicedWave_slices*slicedWave_pieces;
float[] slicedWave_r = new float[slicedWave_num];
int slicedWave_c;
float slicedWave_scal, slicedWave_theta, slicedWave_sw;
boolean slicedWave_init = false;
float slicedWave_angle = 0;
float slicedWave_rotSpeed = 0.1f;
int slicedWave_angleStock = 0;
int slicedWave_white = color(255,255,255);
int slicedWave_red = color(255,0,0);

// UglyAudioAnimation parameters
ArrayList<UglyImpulseKick> uglyImpulseKickList;
ArrayList<UglyImpulseSnare> uglyImpulseSnareList;
ArrayList<UglyImpulseCymbal> uglyImpulseCymbalList;
ArrayList<UglyImpulseBass> uglyImpulseBassList;

// HypnoAudio parameters
int hypnoAudio_currentPoint = 0;
float[] hypnoAudio_currentCoordinates = {-0.25f,-0.25f};
float[][] hypnoAudio_coordinates = {{-0.25f,-0.25f}, {0.25f,-0.15f}, {0.25f,0.25f}, {-0.15f,0.25f}}; 
float hypnoAudio_moveSpeed = 0.1f;
int hypnoAudio_redImpact = 0;
int hypnoAudio_colorAttenuation = 5;
boolean hypnoAudio_listenToAudio = true;

// Spider Web
boolean spiderweb_audioReactive = false;
boolean spiderweb_fade          = false;
ArrayList<SpiderWebPoint> spiderWebPoints;
int spiderweb_nbPoints    = 25;
int spiderweb_maxFriends  = 4;    //Allow at most 4 points to be in contact
final int SPIDERWEB_WHITE = 0;
final int SPIDERWEB_RED   = 1;
int spiderweb_color       = SPIDERWEB_WHITE;
int spiderweb_fadecpt     = 0;
int spiderweb_fadespeed   = 8;

// Woublines
ArrayList<WoubLine> woublines_list;
boolean woublines_init  = false;
boolean woublines_audio = false;
float woublines_speed   = 2;

// Signal Waveform
final int signalWaveForm_offsetY = (PANEL_RESOLUTION_Y * DISPLAY_SCALING_FACTOR)/2 - DISPLAY_SCALING_FACTOR/2;

// Simple Spiral
float simplespiral_theta = 0;
int simplespiral_num = 20;

// TV Power off
int tvpoweroff_progress = 0;
int tvpoweroff_speed = 3;

//White Spread
int whitespread_progress = 0;
int whitespread_speed = 4;

//ScannerLine
float scannerLine_progress = 0;
float scannerLine_SlowSpeed = 1;
float scannerLine_FastSpeed = 3;
float scannerLine_SpeedVar = 0.0007f;
///////////////////////////////////////////////////////////////
// AnimatedGifEncoder - Encode a GIF files with still frames //
///////////////////////////////////////////////////////////////

//Use example :
//   AnimatedGifEncoder e = new AnimatedGifEncoder();
//   e.start(outputFileName);
//   e.setDelay(1000);   // 1 frame per sec
//   e.addFrame(image1);
//   e.addFrame(image2);
//   e.finish();







////////////////////////////////////////////
//   Render the animations to gif files   //
//Control the animations with the keyboard//
////////////////////////////////////////////

//Controls :
//BACKSPACE (DEL) : set active the gif recording process - can only be set during the Init
//TAB : set inactive the gif recording process
//RIGHT/LEFT : next/previous animation, start recording
//ENTER : close the gif file for the current animation

//Utility parameter : useful to cycle through the animations using the left and right keys. To be updated each time a new animation is added
final int totalNumberOfAnimations = 385;

public void keyPressed()
{
  
  if (keyCode == TAB) {
//    println("TEST");
//    myMainBus.clearAll();
//    myMainBus.dispose();
//    println("Main Bus closed");
////    myControllerBus.clearAll();
////    println("Controller Bus closed");
////    myKeyboardBus.clearAll();
////    println("Keyboard Bus closed");
//    
//    myMainBus = new MidiBus(this, MIDI_BUS_MAIN_INPUT, MIDI_BUS_MAIN_INPUT, MIDI_BUS_MAIN_INPUT);
//    
//    myMainBus.sendNoteOn(5, 50, 50); 
//    
//    noteOn(CHANNEL_SEMIAUTOMODE, PITCH_LOAD_ANIMATION_BANK1, 5, 10000000L, myMainBus.getBusName());
//    
////    midiInit();
//    println("wouhou");
  }
  
  
  if (keyCode == BACKSPACE) {
    if (drawImage == 1 && imagenumber == 0) {
      outputLog.println("Setting GIF Recording mode to ON");
      selectFolder("Select a folder to save the GIF files:", "folderSelected");
      setGifRecording = true;
    }
  }
  if (keyCode == TAB) {
//    setGifRecording = false;
//    outputLog.println("Setting GIF Recording mode to OFF");
  }
  if (keyCode == ENTER || keyCode == RETURN) {
    if (animationnumber != 0) {
      if (setGifRecording = true && gifRecordingActive == true) {
        gifRecorder.start(ROOTDIR + "/Strobot" + animationnumber + ".gif");
        for (int i=0;i<gifRecordingFrameRate.size();i++) {
          try {
            gifRecorder.setDelay(PApplet.parseInt(1000/frameRate));
            PImage image = loadImage("tmp/animation" + animationnumber + "-" + formatNumber(i) + ".jpeg");
            BufferedImage buffer = (BufferedImage) image.getNative();    //Convert PImage to BufferedImage
            gifRecorder.addFrame(buffer);
          }
          catch (Exception e) {println(e);}      
        }
        gifRecorder.finish();  //Flush all data
        gifRecordingActive = false;
      }
      outputLog.println("Writing GIF file for animation " + animationnumber + "...");
    }
  }
  if (key == CODED) {
    if (keyCode == RIGHT) {
      if (keyRegistered == false) {
        //Reset the flag to prevent any nullpointer exception
        setupcomplete = false;
        
        //Go to the next animation
        drawAnimation = 1;
        drawImage = 0;
        if (animationnumber == 99) {
          animationnumber = 102;
        }
        else {
          if (animationnumber < totalNumberOfAnimations) {
            animationnumber += 1;
          }
          else { 
            animationnumber = 1;
          }
        }
        specificActions();
        
        if (animationnumber != 0) {
          if (setGifRecording = true) {
            gifRecordingActive = true;
            gifRecordingFrameNumber = 0;
            gifRecordingFrameRate = new ArrayList();
          }
        }
      }
    }
    if (keyCode == LEFT) {
      if (keyRegistered == false) {
        //Reset the flag to prevent any nullpointer exception
        setupcomplete = false;
  
        //Go to the previous animation
        drawAnimation = 1;
        drawImage = 0;
        if (animationnumber > 1) {
          animationnumber -= 1;
        }
        else {
          animationnumber = totalNumberOfAnimations;
        }
        specificActions();
        
        if (animationnumber != 0) {
          if (setGifRecording = true) {
            gifRecordingActive = true;
            gifRecordingFrameNumber = 0;
            gifRecordingFrameRate = new ArrayList();
          }
        }
      }
    }
  }
}


public void folderSelected(File selection) {
  if (selection == null) {
    outputLog.println("Gif recording was cancelled");
    setGifRecording = false;
  } else {
    outputLog.println("User selected GIF folder : " + selection.getAbsolutePath());
    ROOTDIR = selection.getAbsolutePath();
  }
}

public String formatNumber(int input) {
  String output = "";
  if (input < 10) {
     output = "00000" + str(input);
  }
  else if (input < 100) {
     output = "0000" + str(input);
  }
  else if (input < 1000) {
     output = "000" + str(input);
  }
  else if (input < 10000) {
     output = "00" + str(input);
  }
  else if (input < 100000) {
     output = "0" + str(input);
  }
  else if (input < 1000000) {
     output = str(input);
  }
  else {
    outputLog.println("Error - input value is too high"); 
  }
  
  return output;
}


public class AnimatedGifEncoder {

  protected int width; // image size
  protected int height;
  protected Color transparent = null; // transparent color if given
  protected int transIndex; // transparent index in color table
  protected int repeat = -1; // no repeat
  protected int delay = 0; // frame delay (hundredths)
  protected boolean started = false; // ready to output frames
  protected OutputStream out;
  protected BufferedImage image; // current frame
  protected byte[] pixels; // BGR byte array from frame
  protected byte[] indexedPixels; // converted frame indexed to palette
  protected int colorDepth; // number of bit planes
  protected byte[] colorTab; // RGB palette
  protected boolean[] usedEntry = new boolean[256]; // active palette entries
  protected int palSize = 7; // color table size (bits-1)
  protected int dispose = -1; // disposal code (-1 = use default)
  protected boolean closeStream = false; // close stream when finished
  protected boolean firstFrame = true;
  protected boolean sizeSet = false; // if false, get size from first frame
  protected int sample = 10; // default sample interval for quantizer
  
  /**
   * Sets the delay time between each frame, or changes it for subsequent frames
   * (applies to last frame added).
   * 
   * @param ms
   *          int delay time in milliseconds
   */
  public void setDelay(int ms) {
    delay = Math.round(ms / 10.0f);
  }

  /**
   * Sets the GIF frame disposal code for the last added frame and any
   * subsequent frames. Default is 0 if no transparent color has been set,
   * otherwise 2.
   * 
   * @param code
   *          int disposal code.
   */
  public void setDispose(int code) {
    if (code >= 0) {
      dispose = code;
    }
  }

  /**
   * Sets the number of times the set of GIF frames should be played. Default is
   * 1; 0 means play indefinitely. Must be invoked before the first image is
   * added.
   * 
   * @param iter
   *          int number of iterations.
   * @return
   */
  public void setRepeat(int iter) {
    if (iter >= 0) {
      repeat = iter;
    }
  }

  /**
   * Sets the transparent color for the last added frame and any subsequent
   * frames. Since all colors are subject to modification in the quantization
   * process, the color in the final palette for each frame closest to the given
   * color becomes the transparent color for that frame. May be set to null to
   * indicate no transparent color.
   * 
   * @param c
   *          Color to be treated as transparent on display.
   */
  public void setTransparent(Color c) {
    transparent = c;
  }

  /**
   * Adds next GIF frame. The frame is not written immediately, but is actually
   * deferred until the next frame is received so that timing data can be
   * inserted. Invoking <code>finish()</code> flushes all frames. If
   * <code>setSize</code> was not invoked, the size of the first image is used
   * for all subsequent frames.
   * 
   * @param im
   *          BufferedImage containing frame to write.
   * @return true if successful.
   */
  public boolean addFrame(BufferedImage im) {
    if ((im == null) || !started) {
      return false;
    }
    boolean ok = true;
    try {
      if (!sizeSet) {
        // use first frame's size
        setSize(im.getWidth(), im.getHeight());
      }
      image = im;
      getImagePixels(); // convert to correct format if necessary
      analyzePixels(); // build color table & map pixels
      if (firstFrame) {
        writeLSD(); // logical screen descriptior
        writePalette(); // global color table
        if (repeat >= 0) {
          // use NS app extension to indicate reps
          writeNetscapeExt();
        }
      }
      writeGraphicCtrlExt(); // write graphic control extension
      writeImageDesc(); // image descriptor
      if (!firstFrame) {
        writePalette(); // local color table
      }
      writePixels(); // encode and write pixel data
      firstFrame = false;
    } catch (IOException e) {
      ok = false;
    }

    return ok;
  }

  /**
   * Flushes any pending data and closes output file. If writing to an
   * OutputStream, the stream is not closed.
   */
  public boolean finish() {
    if (!started)
      return false;
    boolean ok = true;
    started = false;
    try {
      out.write(0x3b); // gif trailer
      out.flush();
      if (closeStream) {
        out.close();
      }
    } catch (IOException e) {
      ok = false;
    }

    // reset for subsequent use
    transIndex = 0;
    out = null;
    image = null;
    pixels = null;
    indexedPixels = null;
    colorTab = null;
    closeStream = false;
    firstFrame = true;

    return ok;
  }

  /**
   * Sets frame rate in frames per second. Equivalent to
   * <code>setDelay(1000/fps)</code>.
   * 
   * @param fps
   *          float frame rate (frames per second)
   */
  public void setFrameRate(float fps) {
    if (fps != 0f) {
      delay = Math.round(100f / fps);
    }
  }

  /**
   * Sets quality of color quantization (conversion of images to the maximum 256
   * colors allowed by the GIF specification). Lower values (minimum = 1)
   * produce better colors, but slow processing significantly. 10 is the
   * default, and produces good color mapping at reasonable speeds. Values
   * greater than 20 do not yield significant improvements in speed.
   * 
   * @param quality
   *          int greater than 0.
   * @return
   */
  public void setQuality(int quality) {
    if (quality < 1)
      quality = 1;
    sample = quality;
  }

  /**
   * Sets the GIF frame size. The default size is the size of the first frame
   * added if this method is not invoked.
   * 
   * @param w
   *          int frame width.
   * @param h
   *          int frame width.
   */
  public void setSize(int w, int h) {
    if (started && !firstFrame)
      return;
    width = w;
    height = h;
    if (width < 1)
      width = 320;
    if (height < 1)
      height = 240;
    sizeSet = true;
  }

  /**
   * Initiates GIF file creation on the given stream. The stream is not closed
   * automatically.
   * 
   * @param os
   *          OutputStream on which GIF images are written.
   * @return false if initial write failed.
   */
  public boolean start(OutputStream os) {
    if (os == null)
      return false;
    boolean ok = true;
    closeStream = false;
    out = os;
    try {
      writeString("GIF89a"); // header
    } catch (IOException e) {
      ok = false;
    }
    return started = ok;
  }

  /**
   * Initiates writing of a GIF file with the specified name.
   * 
   * @param file
   *          String containing output file name.
   * @return false if open or initial write failed.
   */
  public boolean start(String file) {
    boolean ok = true;
    try {
      File myGifFile = new File(file);
      if (myGifFile.exists()) {
        myGifFile.createNewFile(); 
      }
      FileOutputStream outputfile = new FileOutputStream(myGifFile, false);
      out = new BufferedOutputStream(outputfile);
      ok = start(out);
      closeStream = true;
    } catch (IOException e) {
      outputLog.println(e);
      ok = false;
    }
    return started = ok;
  }

  /**
   * Analyzes image colors and creates color map.
   */
  protected void analyzePixels() {
    int len = pixels.length;
    int nPix = len / 3;
    indexedPixels = new byte[nPix];
    NeuQuant nq = new NeuQuant(pixels, len, sample);
    // initialize quantizer
    colorTab = nq.process(); // create reduced palette
    // convert map from BGR to RGB
    for (int i = 0; i < colorTab.length; i += 3) {
      byte temp = colorTab[i];
      colorTab[i] = colorTab[i + 2];
      colorTab[i + 2] = temp;
      usedEntry[i / 3] = false;
    }
    // map image pixels to new palette
    int k = 0;
    for (int i = 0; i < nPix; i++) {
      int index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);
      usedEntry[index] = true;
      indexedPixels[i] = (byte) index;
    }
    pixels = null;
    colorDepth = 8;
    palSize = 7;
    // get closest match to transparent color if specified
    if (transparent != null) {
      transIndex = findClosest(transparent);
    }
  }

  /**
   * Returns index of palette color closest to c
   * 
   */
  protected int findClosest(Color c) {
    if (colorTab == null)
      return -1;
    int r = c.getRed();
    int g = c.getGreen();
    int b = c.getBlue();
    int minpos = 0;
    int dmin = 256 * 256 * 256;
    int len = colorTab.length;
    for (int i = 0; i < len;) {
      int dr = r - (colorTab[i++] & 0xff);
      int dg = g - (colorTab[i++] & 0xff);
      int db = b - (colorTab[i] & 0xff);
      int d = dr * dr + dg * dg + db * db;
      int index = i / 3;
      if (usedEntry[index] && (d < dmin)) {
        dmin = d;
        minpos = index;
      }
      i++;
    }
    return minpos;
  }

  /**
   * Extracts image pixels into byte array "pixels"
   */
  protected void getImagePixels() {
    int w = image.getWidth();
    int h = image.getHeight();
    int type = image.getType();
    if ((w != width) || (h != height) || (type != BufferedImage.TYPE_3BYTE_BGR)) {
      // create new image with right size/format
      BufferedImage temp = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR);
      Graphics2D g = temp.createGraphics();
      g.drawImage(image, 0, 0, null);
      image = temp;
    }
    pixels = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();
  }

  /**
   * Writes Graphic Control Extension
   */
  protected void writeGraphicCtrlExt() throws IOException {
    out.write(0x21); // extension introducer
    out.write(0xf9); // GCE label
    out.write(4); // data block size
    int transp, disp;
    if (transparent == null) {
      transp = 0;
      disp = 0; // dispose = no action
    } else {
      transp = 1;
      disp = 2; // force clear if using transparent color
    }
    if (dispose >= 0) {
      disp = dispose & 7; // user override
    }
    disp <<= 2;

    // packed fields
    out.write(0 | // 1:3 reserved
        disp | // 4:6 disposal
        0 | // 7 user input - 0 = none
        transp); // 8 transparency flag

    writeShort(delay); // delay x 1/100 sec
    out.write(transIndex); // transparent color index
    out.write(0); // block terminator
  }

  /**
   * Writes Image Descriptor
   */
  protected void writeImageDesc() throws IOException {
    out.write(0x2c); // image separator
    writeShort(0); // image position x,y = 0,0
    writeShort(0);
    writeShort(width); // image size
    writeShort(height);
    // packed fields
    if (firstFrame) {
      // no LCT - GCT is used for first (or only) frame
      out.write(0);
    } else {
      // specify normal LCT
      out.write(0x80 | // 1 local color table 1=yes
          0 | // 2 interlace - 0=no
          0 | // 3 sorted - 0=no
          0 | // 4-5 reserved
          palSize); // 6-8 size of color table
    }
  }

  /**
   * Writes Logical Screen Descriptor
   */
  protected void writeLSD() throws IOException {
    // logical screen size
    writeShort(width);
    writeShort(height);
    // packed fields
    out.write((0x80 | // 1 : global color table flag = 1 (gct used)
        0x70 | // 2-4 : color resolution = 7
        0x00 | // 5 : gct sort flag = 0
        palSize)); // 6-8 : gct size

    out.write(0); // background color index
    out.write(0); // pixel aspect ratio - assume 1:1
  }

  /**
   * Writes Netscape application extension to define repeat count.
   */
  protected void writeNetscapeExt() throws IOException {
    out.write(0x21); // extension introducer
    out.write(0xff); // app extension label
    out.write(11); // block size
    writeString("NETSCAPE" + "2.0"); // app id + auth code
    out.write(3); // sub-block size
    out.write(1); // loop sub-block id
    writeShort(repeat); // loop count (extra iterations, 0=repeat forever)
    out.write(0); // block terminator
  }

  /**
   * Writes color table
   */
  protected void writePalette() throws IOException {
    out.write(colorTab, 0, colorTab.length);
    int n = (3 * 256) - colorTab.length;
    for (int i = 0; i < n; i++) {
      out.write(0);
    }
  }

  /**
   * Encodes and writes pixel data
   */
  protected void writePixels() throws IOException {
    LZWEncoder encoder = new LZWEncoder(width, height, indexedPixels, colorDepth);
    encoder.encode(out);
  }

  /**
   * Write 16-bit value to output stream, LSB first
   */
  protected void writeShort(int value) throws IOException {
    out.write(value & 0xff);
    out.write((value >> 8) & 0xff);
  }

  /**
   * Writes string to output stream
   */
  protected void writeString(String s) throws IOException {
    for (int i = 0; i < s.length(); i++) {
      out.write((byte) s.charAt(i));
    }
  }
}

/*
 * NeuQuant Neural-Net Quantization Algorithm
 * ------------------------------------------
 * 
 * Copyright (c) 1994 Anthony Dekker
 * 
 * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See
 * "Kohonen neural networks for optimal colour quantization" in "Network:
 * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of
 * the algorithm.
 * 
 * Any party obtaining a copy of these files from the author, directly or
 * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
 * world-wide, paid up, royalty-free, nonexclusive right and license to deal in
 * this software and documentation files (the "Software"), including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons who
 * receive copies from any such party to do so, with the only requirement being
 * that this copyright notice remain intact.
 */

// Ported to Java 12/00 K Weiner
class NeuQuant {

  protected static final int netsize = 256; /* number of colours used */

  /* four primes near 500 - assume no image has a length so large */
  /* that it is divisible by all four primes */
  protected static final int prime1 = 499;

  protected static final int prime2 = 491;

  protected static final int prime3 = 487;

  protected static final int prime4 = 503;

  protected static final int minpicturebytes = (3 * prime4);

  /* minimum size for input image */

  /*
   * Program Skeleton ---------------- [select samplefac in range 1..30] [read
   * image from input file] pic = (unsigned char*) malloc(3*width*height);
   * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output
   * image header, using writecolourmap(f)] inxbuild(); write output image using
   * inxsearch(b,g,r)
   */

  /*
   * Network Definitions -------------------
   */

  protected static final int maxnetpos = (netsize - 1);

  protected static final int netbiasshift = 4; /* bias for colour values */

  protected static final int ncycles = 100; /* no. of learning cycles */

  /* defs for freq and bias */
  protected static final int intbiasshift = 16; /* bias for fractions */

  protected static final int intbias = (((int) 1) << intbiasshift);

  protected static final int gammashift = 10; /* gamma = 1024 */

  protected static final int gamma = (((int) 1) << gammashift);

  protected static final int betashift = 10;

  protected static final int beta = (intbias >> betashift); /* beta = 1/1024 */

  protected static final int betagamma = (intbias << (gammashift - betashift));

  /* defs for decreasing radius factor */
  protected static final int initrad = (netsize >> 3); /*
                                                         * for 256 cols, radius
                                                         * starts
                                                         */

  protected static final int radiusbiasshift = 6; /* at 32.0 biased by 6 bits */

  protected static final int radiusbias = (((int) 1) << radiusbiasshift);

  protected static final int initradius = (initrad * radiusbias); /*
                                                                   * and
                                                                   * decreases
                                                                   * by a
                                                                   */

  protected static final int radiusdec = 30; /* factor of 1/30 each cycle */

  /* defs for decreasing alpha factor */
  protected static final int alphabiasshift = 10; /* alpha starts at 1.0 */

  protected static final int initalpha = (((int) 1) << alphabiasshift);

  protected int alphadec; /* biased by 10 bits */

  /* radbias and alpharadbias used for radpower calculation */
  protected static final int radbiasshift = 8;

  protected static final int radbias = (((int) 1) << radbiasshift);

  protected static final int alpharadbshift = (alphabiasshift + radbiasshift);

  protected static final int alpharadbias = (((int) 1) << alpharadbshift);

  /*
   * Types and Global Variables --------------------------
   */

  protected byte[] thepicture; /* the input image itself */

  protected int lengthcount; /* lengthcount = H*W*3 */

  protected int samplefac; /* sampling factor 1..30 */

  // typedef int pixel[4]; /* BGRc */
  protected int[][] network; /* the network itself - [netsize][4] */

  protected int[] netindex = new int[256];

  /* for network lookup - really 256 */

  protected int[] bias = new int[netsize];

  /* bias and freq arrays for learning */
  protected int[] freq = new int[netsize];

  protected int[] radpower = new int[initrad];

  /* radpower for precomputation */

  /*
   * Initialise network in range (0,0,0) to (255,255,255) and set parameters
   * -----------------------------------------------------------------------
   */
  public NeuQuant(byte[] thepic, int len, int sample) {

    int i;
    int[] p;

    thepicture = thepic;
    lengthcount = len;
    samplefac = sample;

    network = new int[netsize][];
    for (i = 0; i < netsize; i++) {
      network[i] = new int[4];
      p = network[i];
      p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;
      freq[i] = intbias / netsize; /* 1/netsize */
      bias[i] = 0;
    }
  }

  public byte[] colorMap() {
    byte[] map = new byte[3 * netsize];
    int[] index = new int[netsize];
    for (int i = 0; i < netsize; i++)
      index[network[i][3]] = i;
    int k = 0;
    for (int i = 0; i < netsize; i++) {
      int j = index[i];
      map[k++] = (byte) (network[j][0]);
      map[k++] = (byte) (network[j][1]);
      map[k++] = (byte) (network[j][2]);
    }
    return map;
  }

  /*
   * Insertion sort of network and building of netindex[0..255] (to do after
   * unbias)
   * -------------------------------------------------------------------------------
   */
  public void inxbuild() {

    int i, j, smallpos, smallval;
    int[] p;
    int[] q;
    int previouscol, startpos;

    previouscol = 0;
    startpos = 0;
    for (i = 0; i < netsize; i++) {
      p = network[i];
      smallpos = i;
      smallval = p[1]; /* index on g */
      /* find smallest in i..netsize-1 */
      for (j = i + 1; j < netsize; j++) {
        q = network[j];
        if (q[1] < smallval) { /* index on g */
          smallpos = j;
          smallval = q[1]; /* index on g */
        }
      }
      q = network[smallpos];
      /* swap p (i) and q (smallpos) entries */
      if (i != smallpos) {
        j = q[0];
        q[0] = p[0];
        p[0] = j;
        j = q[1];
        q[1] = p[1];
        p[1] = j;
        j = q[2];
        q[2] = p[2];
        p[2] = j;
        j = q[3];
        q[3] = p[3];
        p[3] = j;
      }
      /* smallval entry is now in position i */
      if (smallval != previouscol) {
        netindex[previouscol] = (startpos + i) >> 1;
        for (j = previouscol + 1; j < smallval; j++)
          netindex[j] = i;
        previouscol = smallval;
        startpos = i;
      }
    }
    netindex[previouscol] = (startpos + maxnetpos) >> 1;
    for (j = previouscol + 1; j < 256; j++)
      netindex[j] = maxnetpos; /* really 256 */
  }

  /*
   * Main Learning Loop ------------------
   */
  public void learn() {

    int i, j, b, g, r;
    int radius, rad, alpha, step, delta, samplepixels;
    byte[] p;
    int pix, lim;

    if (lengthcount < minpicturebytes)
      samplefac = 1;
    alphadec = 30 + ((samplefac - 1) / 3);
    p = thepicture;
    pix = 0;
    lim = lengthcount;
    samplepixels = lengthcount / (3 * samplefac);
    delta = samplepixels / ncycles;
    alpha = initalpha;
    radius = initradius;

    rad = radius >> radiusbiasshift;
    if (rad <= 1)
      rad = 0;
    for (i = 0; i < rad; i++)
      radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));

    // fprintf(stderr,"beginning 1D learning: initial radius=%d\n", rad);

    if (lengthcount < minpicturebytes)
      step = 3;
    else if ((lengthcount % prime1) != 0)
      step = 3 * prime1;
    else {
      if ((lengthcount % prime2) != 0)
        step = 3 * prime2;
      else {
        if ((lengthcount % prime3) != 0)
          step = 3 * prime3;
        else
          step = 3 * prime4;
      }
    }

    i = 0;
    while (i < samplepixels) {
      b = (p[pix + 0] & 0xff) << netbiasshift;
      g = (p[pix + 1] & 0xff) << netbiasshift;
      r = (p[pix + 2] & 0xff) << netbiasshift;
      j = contest(b, g, r);

      altersingle(alpha, j, b, g, r);
      if (rad != 0)
        alterneigh(rad, j, b, g, r); /* alter neighbours */

      pix += step;
      if (pix >= lim)
        pix -= lengthcount;

      i++;
      if (delta == 0)
        delta = 1;
      if (i % delta == 0) {
        alpha -= alpha / alphadec;
        radius -= radius / radiusdec;
        rad = radius >> radiusbiasshift;
        if (rad <= 1)
          rad = 0;
        for (j = 0; j < rad; j++)
          radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));
      }
    }
    // fprintf(stderr,"finished 1D learning: final alpha=%f
    // !\n",((float)alpha)/initalpha);
  }

  /*
   * Search for BGR values 0..255 (after net is unbiased) and return colour
   * index
   * ----------------------------------------------------------------------------
   */
  public int map(int b, int g, int r) {

    int i, j, dist, a, bestd;
    int[] p;
    int best;

    bestd = 1000; /* biggest possible dist is 256*3 */
    best = -1;
    i = netindex[g]; /* index on g */
    j = i - 1; /* start at netindex[g] and work outwards */

    while ((i < netsize) || (j >= 0)) {
      if (i < netsize) {
        p = network[i];
        dist = p[1] - g; /* inx key */
        if (dist >= bestd)
          i = netsize; /* stop iter */
        else {
          i++;
          if (dist < 0)
            dist = -dist;
          a = p[0] - b;
          if (a < 0)
            a = -a;
          dist += a;
          if (dist < bestd) {
            a = p[2] - r;
            if (a < 0)
              a = -a;
            dist += a;
            if (dist < bestd) {
              bestd = dist;
              best = p[3];
            }
          }
        }
      }
      if (j >= 0) {
        p = network[j];
        dist = g - p[1]; /* inx key - reverse dif */
        if (dist >= bestd)
          j = -1; /* stop iter */
        else {
          j--;
          if (dist < 0)
            dist = -dist;
          a = p[0] - b;
          if (a < 0)
            a = -a;
          dist += a;
          if (dist < bestd) {
            a = p[2] - r;
            if (a < 0)
              a = -a;
            dist += a;
            if (dist < bestd) {
              bestd = dist;
              best = p[3];
            }
          }
        }
      }
    }
    return (best);
  }

  public byte[] process() {
    learn();
    unbiasnet();
    inxbuild();
    return colorMap();
  }

  /*
   * Unbias network to give byte values 0..255 and record position i to prepare
   * for sort
   * -----------------------------------------------------------------------------------
   */
  public void unbiasnet() {

    int i;

    for (i = 0; i < netsize; i++) {
      network[i][0] >>= netbiasshift;
      network[i][1] >>= netbiasshift;
      network[i][2] >>= netbiasshift;
      network[i][3] = i; /* record colour no */
    }
  }

  /*
   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in
   * radpower[|i-j|]
   * ---------------------------------------------------------------------------------
   */
  protected void alterneigh(int rad, int i, int b, int g, int r) {

    int j, k, lo, hi, a, m;
    int[] p;

    lo = i - rad;
    if (lo < -1)
      lo = -1;
    hi = i + rad;
    if (hi > netsize)
      hi = netsize;

    j = i + 1;
    k = i - 1;
    m = 1;
    while ((j < hi) || (k > lo)) {
      a = radpower[m++];
      if (j < hi) {
        p = network[j++];
        try {
          p[0] -= (a * (p[0] - b)) / alpharadbias;
          p[1] -= (a * (p[1] - g)) / alpharadbias;
          p[2] -= (a * (p[2] - r)) / alpharadbias;
        } catch (Exception e) {
        } // prevents 1.3 miscompilation
      }
      if (k > lo) {
        p = network[k--];
        try {
          p[0] -= (a * (p[0] - b)) / alpharadbias;
          p[1] -= (a * (p[1] - g)) / alpharadbias;
          p[2] -= (a * (p[2] - r)) / alpharadbias;
        } catch (Exception e) {
        }
      }
    }
  }

  /*
   * Move neuron i towards biased (b,g,r) by factor alpha
   * ----------------------------------------------------
   */
  protected void altersingle(int alpha, int i, int b, int g, int r) {

    /* alter hit neuron */
    int[] n = network[i];
    n[0] -= (alpha * (n[0] - b)) / initalpha;
    n[1] -= (alpha * (n[1] - g)) / initalpha;
    n[2] -= (alpha * (n[2] - r)) / initalpha;
  }

  /*
   * Search for biased BGR values ----------------------------
   */
  protected int contest(int b, int g, int r) {

    /* finds closest neuron (min dist) and updates freq */
    /* finds best neuron (min dist-bias) and returns position */
    /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */
    /* bias[i] = gamma*((1/netsize)-freq[i]) */

    int i, dist, a, biasdist, betafreq;
    int bestpos, bestbiaspos, bestd, bestbiasd;
    int[] n;

    bestd = ~(((int) 1) << 31);
    bestbiasd = bestd;
    bestpos = -1;
    bestbiaspos = bestpos;

    for (i = 0; i < netsize; i++) {
      n = network[i];
      dist = n[0] - b;
      if (dist < 0)
        dist = -dist;
      a = n[1] - g;
      if (a < 0)
        a = -a;
      dist += a;
      a = n[2] - r;
      if (a < 0)
        a = -a;
      dist += a;
      if (dist < bestd) {
        bestd = dist;
        bestpos = i;
      }
      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));
      if (biasdist < bestbiasd) {
        bestbiasd = biasdist;
        bestbiaspos = i;
      }
      betafreq = (freq[i] >> betashift);
      freq[i] -= betafreq;
      bias[i] += (betafreq << gammashift);
    }
    freq[bestpos] += beta;
    bias[bestpos] -= betagamma;
    return (bestbiaspos);
  }
}

// ==============================================================================
// Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.
// K Weiner 12/00

class LZWEncoder {

  private static final int EOF = -1;

  private int imgW, imgH;

  private byte[] pixAry;

  private int initCodeSize;

  private int remaining;

  private int curPixel;

  // GIFCOMPR.C - GIF Image compression routines
  //
  // Lempel-Ziv compression based on 'compress'. GIF modifications by
  // David Rowley (mgardi@watdcsu.waterloo.edu)

  // General DEFINEs

  static final int BITS = 12;

  static final int HSIZE = 5003; // 80% occupancy

  // GIF Image compression - modified 'compress'
  //
  // Based on: compress.c - File compression ala IEEE Computer, June 1984.
  //
  // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)
  // Jim McKie (decvax!mcvax!jim)
  // Steve Davies (decvax!vax135!petsd!peora!srd)
  // Ken Turkowski (decvax!decwrl!turtlevax!ken)
  // James A. Woods (decvax!ihnp4!ames!jaw)
  // Joe Orost (decvax!vax135!petsd!joe)

  int n_bits; // number of bits/code

  int maxbits = BITS; // user settable max # bits/code

  int maxcode; // maximum code, given n_bits

  int maxmaxcode = 1 << BITS; // should NEVER generate this code

  int[] htab = new int[HSIZE];

  int[] codetab = new int[HSIZE];

  int hsize = HSIZE; // for dynamic table sizing

  int free_ent = 0; // first unused entry

  // block compression parameters -- after all codes are used up,
  // and compression rate changes, start over.
  boolean clear_flg = false;

  // Algorithm: use open addressing double hashing (no chaining) on the
  // prefix code / next character combination. We do a variant of Knuth's
  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
  // secondary probe. Here, the modular division first probe is gives way
  // to a faster exclusive-or manipulation. Also do block compression with
  // an adaptive reset, whereby the code table is cleared when the compression
  // ratio decreases, but after the table fills. The variable-length output
  // codes are re-sized at this point, and a special CLEAR code is generated
  // for the decompressor. Late addition: construct the table according to
  // file size for noticeable speed improvement on small files. Please direct
  // questions about this implementation to ames!jaw.

  int g_init_bits;

  int ClearCode;

  int EOFCode;

  // output
  //
  // Output the given code.
  // Inputs:
  // code: A n_bits-bit integer. If == -1, then EOF. This assumes
  // that n_bits =< wordsize - 1.
  // Outputs:
  // Outputs code to the file.
  // Assumptions:
  // Chars are 8 bits long.
  // Algorithm:
  // Maintain a BITS character long buffer (so that 8 codes will
  // fit in it exactly). Use the VAX insv instruction to insert each
  // code in turn. When the buffer fills up empty it and start over.

  int cur_accum = 0;

  int cur_bits = 0;

  int masks[] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF,
      0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };

  // Number of characters so far in this 'packet'
  int a_count;

  // Define the storage for the packet accumulator
  byte[] accum = new byte[256];

  // ----------------------------------------------------------------------------
  LZWEncoder(int width, int height, byte[] pixels, int color_depth) {
    imgW = width;
    imgH = height;
    pixAry = pixels;
    initCodeSize = Math.max(2, color_depth);
  }

  // Add a character to the end of the current packet, and if it is 254
  // characters, flush the packet to disk.
  public void char_out(byte c, OutputStream outs) throws IOException {
    accum[a_count++] = c;
    if (a_count >= 254)
      flush_char(outs);
  }

  // Clear out the hash table

  // table clear for block compress
  public void cl_block(OutputStream outs) throws IOException {
    cl_hash(hsize);
    free_ent = ClearCode + 2;
    clear_flg = true;

    output(ClearCode, outs);
  }

  // reset code table
  public void cl_hash(int hsize) {
    for (int i = 0; i < hsize; ++i)
      htab[i] = -1;
  }

  public void compress(int init_bits, OutputStream outs) throws IOException {
    int fcode;
    int i /* = 0 */;
    int c;
    int ent;
    int disp;
    int hsize_reg;
    int hshift;

    // Set up the globals: g_init_bits - initial number of bits
    g_init_bits = init_bits;

    // Set up the necessary values
    clear_flg = false;
    n_bits = g_init_bits;
    maxcode = MAXCODE(n_bits);

    ClearCode = 1 << (init_bits - 1);
    EOFCode = ClearCode + 1;
    free_ent = ClearCode + 2;

    a_count = 0; // clear packet

    ent = nextPixel();

    hshift = 0;
    for (fcode = hsize; fcode < 65536; fcode *= 2)
      ++hshift;
    hshift = 8 - hshift; // set hash code range bound

    hsize_reg = hsize;
    cl_hash(hsize_reg); // clear hash table

    output(ClearCode, outs);

    outer_loop: while ((c = nextPixel()) != EOF) {
      fcode = (c << maxbits) + ent;
      i = (c << hshift) ^ ent; // xor hashing

      if (htab[i] == fcode) {
        ent = codetab[i];
        continue;
      } else if (htab[i] >= 0) // non-empty slot
      {
        disp = hsize_reg - i; // secondary hash (after G. Knott)
        if (i == 0)
          disp = 1;
        do {
          if ((i -= disp) < 0)
            i += hsize_reg;

          if (htab[i] == fcode) {
            ent = codetab[i];
            continue outer_loop;
          }
        } while (htab[i] >= 0);
      }
      output(ent, outs);
      ent = c;
      if (free_ent < maxmaxcode) {
        codetab[i] = free_ent++; // code -> hashtable
        htab[i] = fcode;
      } else
        cl_block(outs);
    }
    // Put out the final code.
    output(ent, outs);
    output(EOFCode, outs);
  }

  // ----------------------------------------------------------------------------
  public void encode(OutputStream os) throws IOException {
    os.write(initCodeSize); // write "initial code size" byte

    remaining = imgW * imgH; // reset navigation variables
    curPixel = 0;

    compress(initCodeSize + 1, os); // compress and write the pixel data

    os.write(0); // write block terminator
  }

  // Flush the packet to disk, and reset the accumulator
  public void flush_char(OutputStream outs) throws IOException {
    if (a_count > 0) {
      outs.write(a_count);
      outs.write(accum, 0, a_count);
      a_count = 0;
    }
  }

  public final int MAXCODE(int n_bits) {
    return (1 << n_bits) - 1;
  }

  // ----------------------------------------------------------------------------
  // Return the next pixel from the image
  // ----------------------------------------------------------------------------
  private int nextPixel() {
    if (remaining == 0)
      return EOF;

    --remaining;

    byte pix = pixAry[curPixel++];

    return pix & 0xff;
  }

  public void output(int code, OutputStream outs) throws IOException {
    cur_accum &= masks[cur_bits];

    if (cur_bits > 0)
      cur_accum |= (code << cur_bits);
    else
      cur_accum = code;

    cur_bits += n_bits;

    while (cur_bits >= 8) {
      char_out((byte) (cur_accum & 0xff), outs);
      cur_accum >>= 8;
      cur_bits -= 8;
    }

    // If the next entry is going to be too big for the code size,
    // then increase it, if possible.
    if (free_ent > maxcode || clear_flg) {
      if (clear_flg) {
        maxcode = MAXCODE(n_bits = g_init_bits);
        clear_flg = false;
      } else {
        ++n_bits;
        if (n_bits == maxbits)
          maxcode = maxmaxcode;
        else
          maxcode = MAXCODE(n_bits);
      }
    }

    if (code == EOFCode) {
      // At EOF, write the rest of the buffer.
      while (cur_bits > 0) {
        char_out((byte) (cur_accum & 0xff), outs);
        cur_accum >>= 8;
        cur_bits -= 8;
      }

      flush_char(outs);
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////
/////////Contains functions specific to animations called in the main sketch/////////
/////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////
// Function allowing movie playback
//////////////////////////////////////////

//void movieEvent(Movie m) {
//  m.read();
//}

//Create animation files during the initial setup  
public void initialize_video_animations() {
  //In the latest version, the remaining videos were replaced by cold hard code
  //Use the syntax below to create a movie object
  //String confSpecific = NUMBER_OF_PANELS + "_panels/";
  //Noise = new Movie(this, confSpecific + "Cross/Noise.mov");
  
  //To play a movie :
  //image(Noise, 0, 0)
  
  //Add to the setup function :
  //Noise.stop();
  //Noise.play();
}

//////////////////////////////////////////
// Class for animating png/jpeg/gif files
//////////////////////////////////////////

class Animation {
  PImage[] images;
  int imageCount;
  int frame;
  boolean rightorder;
  
  Animation(String imagePrefix, int counterSuffix, String fileFormat, int count, boolean order) {
    imageCount = count;
    images = new PImage[imageCount];
    rightorder = order;
    for (int t = 0; t < imageCount; t++) {
      // Use nf() to number format 't' into counterSuffix digits
      String filename = imagePrefix + nf(t, counterSuffix) + "." + fileFormat;
      images[t] = loadImage(filename);
      outputLog.println(filename);
    }
  }
  
  Animation(String imagePrefix, String fileFormat, int count, boolean order) {
    imageCount = count;
    images = new PImage[imageCount];
    rightorder = order;
    for (int t = 0; t < imageCount; t++) {
      // Use nf() to number format 't' into 4 digits
      String filename = imagePrefix + nf(t, 4) + "." + fileFormat;
      images[t] = loadImage(filename);
    }
  }
  
  Animation(String imagePrefix, int count, boolean order) {
    imageCount = count;
    images = new PImage[imageCount];
    rightorder = order;
    for (int t = 0; t < imageCount; t++) {
      // Use nf() to number format 't' into 4 digits
      String filename = imagePrefix + nf(t, 4) + ".png";
      images[t] = loadImage(filename);
    }
  }

  public void display(float xpos, float ypos) {
    if (rightorder == true) 
      {
        frame = (frame+1) % imageCount;
    }
    else 
      {
        if (frame == 0) {
          frame = imageCount - 1;
        }
        else {
        frame = (frame-1);
        }
      }
    image(images[frame], xpos, ypos);
  }
  
  public int getWidth() {
    return images[0].width;
  }
  
  public int getFrame() {
    return frame; 
  }
  
  public int getImageCount() {
    return imageCount;
  }
  
  public void setRightOrder(boolean booly) {
    rightorder = booly;
  }
}

//////////////////////////////////////////
// Open the image specified by the imagenumber argument
//////////////////////////////////////////
 
public PImage getimage(int imagenumber)
{
  PImage temp;
  temp = getConfigSpecificImage("voidImage.jpg");  //Initialize temp
  switch(imagenumber)
  {
    case -1: temp = getConfigSpecificImage("Startup_1.jpg");break;
    case -2: temp = getConfigSpecificImage("Startup_2.jpg");break;
    case -3: temp = getConfigSpecificImage("Startup_3.jpg");break;
    case -4: temp = getConfigSpecificImage("Startup_4.jpg");break;
    case -5: temp = getConfigSpecificImage("Startup_5.jpg");break;
    
    case 0 : temp = getConfigSpecificImage("Startup.jpg");break;
    case 1 : temp = getConfigSpecificImage("Startup_1.jpg");break;
    case 2 : temp = getConfigSpecificImage("Startup_2.jpg");break;
    case 3 : temp = getConfigSpecificImage("Startup_3.jpg");break;
    case 4 : temp = getConfigSpecificImage("Startup_4.jpg");break;
    case 5 : temp = getConfigSpecificImage("Startup_5.jpg");break;
    case 6 : temp = getConfigSpecificImage("Degeneration/01.png");break;
    case 7 : temp = getConfigSpecificImage("Degeneration/02.png");break;
    case 8 : temp = getConfigSpecificImage("Degeneration/03.png");break;
    case 9 : temp = getConfigSpecificImage("Degeneration/04.png");break;
    case 10: temp = getConfigSpecificImage("Degeneration/05.png");break;
    case 11: temp = getConfigSpecificImage("Degeneration/06.png");break;
    case 12: temp = getConfigSpecificImage("Degeneration/07.png");break;
    case 13: temp = getConfigSpecificImage("Degeneration/08.png");break;
    case 14: temp = getConfigSpecificImage("DTL/04.02. You.png");break;
    case 15: temp = getConfigSpecificImage("DTL/04.03. Want.png");break;
    case 16: temp = getConfigSpecificImage("DTL/04.04. Me.png");break;
    case 17: temp = getConfigSpecificImage("DTL/04.05. To.png");break;
    case 18: temp = getConfigSpecificImage("DTL/05.01. An.png");break;
    case 19: temp = getConfigSpecificImage("DTL/05.02. O.png");break;
    case 20: temp = getConfigSpecificImage("DTL/05.03. Ther.png");break;
    case 21: temp = getConfigSpecificImage("DTL/05.04. De.png");break;
    case 22: temp = getConfigSpecificImage("DTL/05.05. Feat.png");break;
    case 23: temp = getConfigSpecificImage("DTL/06.01. Just.png");break;
    case 24: temp = getConfigSpecificImage("DTL/06.02. To.png");break;
    case 25: temp = getConfigSpecificImage("DTL/06.03. Clear.png");break;
    case 26: temp = getConfigSpecificImage("DTL/06.04. This.png");break;
    case 27: temp = getConfigSpecificImage("DTL/06.05. Up.png");break;
    case 28: temp = getConfigSpecificImage("DTL/07.01. Don't.png");break;
    case 29: temp = getConfigSpecificImage("DTL/07.02. Want.png");break;
    case 30: temp = getConfigSpecificImage("DTL/07.03. To.png");break;
    case 31: temp = getConfigSpecificImage("DTL/07.04. Please.png");break;
    case 32: temp = getConfigSpecificImage("DTL/07.05. You.png");break;
    case 33: temp = getConfigSpecificImage("DTL/08.01. Not.png");break;
    case 34: temp = getConfigSpecificImage("DTL/08.02. That.png");break;
    case 35: temp = getConfigSpecificImage("DTL/08.03. It.png");break;
    case 36: temp = getConfigSpecificImage("DTL/08.04. Matt.png");break;
    case 37: temp = getConfigSpecificImage("DTL/08.05. Ers.png");break;
    case 38: temp = getConfigSpecificImage("DTL/09.01. Might.png");break;
    case 39: temp = getConfigSpecificImage("DTL/09.02. As.png");break;
    case 40: temp = getConfigSpecificImage("DTL/09.03. Well.png");break;
    case 41: temp = getConfigSpecificImage("DTL/09.04. Draw.png");break;
    case 42: temp = getConfigSpecificImage("DTL/09.05. The.png");break;
    case 43: temp = getConfigSpecificImage("DTL/09.06. Line.png");break;
    case 44: temp = getConfigSpecificImage("DTL/10.01. Be.png");break;
    case 45: temp = getConfigSpecificImage("DTL/10.02. Fore.png");break;
    case 46: temp = getConfigSpecificImage("DTL/10.03. We.png");break;
    case 47: temp = getConfigSpecificImage("DTL/10.04. Lose.png");break;
    case 48: temp = getConfigSpecificImage("DTL/10.05. Our.png");break;
    case 49: temp = getConfigSpecificImage("DTL/10.06. Minds.png");break;
    case 50: temp = getConfigSpecificImage("Generic/01. Red.jpg");break;
    case 51: temp = getConfigSpecificImage("Generic/02. Red.jpg");break;
    case 52: temp = getConfigSpecificImage("Generic/03. Red.jpg");break;
    case 53: temp = getConfigSpecificImage("Generic/04. Red.jpg");break;
    case 54: temp = getConfigSpecificImage("Generic/05. Red.jpg");break;
    case 55: temp = getConfigSpecificImage("Generic/06. Red.jpg");break;
    case 56: temp = getConfigSpecificImage("Generic/07. Red.jpg");break;
    case 57: temp = getConfigSpecificImage("Generic/08. Red.jpg");break;
    case 58: temp = getConfigSpecificImage("Generic/09. Red.jpg");break;
    case 59: temp = getConfigSpecificImage("Generic/10. Red.jpg");break;
    case 60: temp = getConfigSpecificImage("Generic/11. Red.jpg");break;
    case 61: temp = getConfigSpecificImage("Generic/12. Red.jpg");break;
    case 62: temp = getConfigSpecificImage("Generic/13. Red.jpg");break;
    case 63: temp = getConfigSpecificImage("Generic/14. Red.jpg");break;
    case 64: temp = getConfigSpecificImage("Generic/15. Red.jpg");break;
    case 65: temp = getConfigSpecificImage("Generic/16. Red.jpg");break;
    case 66: temp = getConfigSpecificImage("Generic/17. Red.jpg");break;
    case 67: temp = getConfigSpecificImage("Generic/18. Red.jpg");break;
    case 69: temp = getConfigSpecificImage("Generic/19. Red.jpg");break;
    case 70: temp = getConfigSpecificImage("Generic/20. Red.jpg");break;
    case 71: temp = getConfigSpecificImage("Generic/21. Red.jpg");break;
    case 72: temp = getConfigSpecificImage("Generic/22. Red.jpg");break;
    case 73: temp = getConfigSpecificImage("Generic/23. Red.jpg");break;
    case 74: temp = getConfigSpecificImage("Generic/01. Custom.jpg");break;
    case 75: temp = getConfigSpecificImage("Generic/02. Custom.jpg");break;
    case 76: temp = getConfigSpecificImage("Generic/03. Custom.jpg");break;
    case 77: temp = getConfigSpecificImage("Generic/04. Custom.jpg");break;
    case 78: temp = getConfigSpecificImage("Generic/05. Custom.jpg");break;
    case 79: temp = getConfigSpecificImage("PlayMe/01.P-white-black.jpg");break;
    case 80: temp = getConfigSpecificImage("PlayMe/02.L-white-black.jpg");break;
    case 81: temp = getConfigSpecificImage("PlayMe/03.A-white-black.jpg");break;
    case 82: temp = getConfigSpecificImage("PlayMe/04.Y-white-black.jpg");break;
    case 83: temp = getConfigSpecificImage("PlayMe/05.M-white-black.jpg");break;
    case 84: temp = getConfigSpecificImage("PlayMe/06.E-white-black.jpg");break;
    case 85: temp = getConfigSpecificImage("PlayMe/07.P-black-white.jpg");break;
    case 86: temp = getConfigSpecificImage("PlayMe/08.L-black-white.jpg");break;
    case 87: temp = getConfigSpecificImage("PlayMe/09.A-black-white.jpg");break;
    case 88: temp = getConfigSpecificImage("PlayMe/10.Y-black-white.jpg");break;
    case 89: temp = getConfigSpecificImage("PlayMe/11.M-black-white.jpg");break;
    case 90: temp = getConfigSpecificImage("PlayMe/12.E-black-white.jpg");break;
    case 91: temp = getConfigSpecificImage("PlayMe/13.P-red-black.jpg");break;
    case 92: temp = getConfigSpecificImage("PlayMe/14.L-red-black.jpg");break;
    case 93: temp = getConfigSpecificImage("PlayMe/15.A-red-black.jpg");break;
    case 94: temp = getConfigSpecificImage("PlayMe/16.Y-red-black.jpg");break;
    case 95: temp = getConfigSpecificImage("PlayMe/17.M-red-black.jpg");break;
    case 96: temp = getConfigSpecificImage("PlayMe/18.E-red-black.jpg");break;

    case 123:break;
    default: outputLog.println("Could not find the case inside the switch");
  }
  
  return temp;
}

public PImage getConfigSpecificImage(String path) {
  String confSpecific = NUMBER_OF_PANELS + "_panels/";
  return loadImage(confSpecific + path);
}

//////////////////////////////////////////
//Specific actions to be done to render an image file on the canvas
//////////////////////////////////////////

public void draw_image() {
    noSmooth();     //Do not smoothen the lines, for pixel art this setting looks best
    PImage a;
    a = getimage(imagenumber);
    
    //Transform a 24*16 image into a 64*64 image
    scale(4,4);
    image(a, 0, 0);
}

//////////////////////////////////////////
// Specific actions for the InitFlasher animation
//////////////////////////////////////////

public void draw_initFlasher() {
  if (initFlasher_progress == initFlasher_startNoise) {
    frameRate(18);
  }
  if (initFlasher_progress == initFlasher_startNoise2) {
    frameRate(35);
  }
  if (initFlasher_progress == initFlasher_startNoise3) {
    frameRate(12);
  }
  if (initFlasher_progress == initFlasher_startNoise3) {
    frameRate(35);
  }
  
  if (initFlasher_progress >= 0) {
    noStroke();
    fill(max(0,255-initFlasher_progress));
    rect(0,0,width,height);
  }
  if (initFlasher_progress >= initFlasher_startNoise) {
    noStroke();
    for (int i=0; i<width/initFlasher_pixelSize; i++) {
      for (int j=0; j<height/initFlasher_pixelSize; j++) {
        fill(random(min(255,initFlasher_noiseBrightness)));
        rect(i*initFlasher_pixelSize,j*initFlasher_pixelSize,initFlasher_pixelSize,initFlasher_pixelSize);
      }
    }
    
    if (initFlasher_noiseBrightness < 255) {
      initFlasher_noiseBrightness += 1;
    }
  }
  
  if (initFlasher_progress >= initFlasher_startBlackout) {
    if (initFlasher_blackoutProbability >= random(1)) {
      initFlasher_randomFlash(0);
    }
    if (initFlasher_blackoutProbability == initFlasher_blackoutProbability_max) {
      if (initFlasher_blackoutProbability/2 >= random(1)) {
        initFlasher_randomFlash(0);
      }
    }
    if (initFlasher_blackoutProbability < initFlasher_blackoutProbability_max) {
      initFlasher_blackoutProbability += initFlasher_blackoutProbability_speed;
    }
  }
  
  if (initFlasher_progress >= initFlasher_startWhiteout) {
    if (initFlasher_whiteoutProbability >= random(1)) {
      initFlasher_randomFlash(255);
    }
    if (initFlasher_whiteoutProbability == initFlasher_whiteoutProbability_max) {
      if (initFlasher_whiteoutProbability/2 >= random(1)) {
        initFlasher_randomFlash(255);
      }
    }
    if (initFlasher_whiteoutProbability < initFlasher_whiteoutProbability_max) {
      initFlasher_whiteoutProbability += initFlasher_whiteoutProbability_speed;
    }
  }
  
  if (initFlasher_progress >= initFlasher_startMegawhiteout) {
    initFlasher_randomFlash(255);
    initFlasher_randomFlash(255);
  }
  
  if (initFlasher_progress >= initFlasher_startStrobo) {
    if (initFlasher_flashProbability < initFlasher_flashProbability_max) {
      if (initFlasher_flashProbability >= random(1)) {
        initFlasher_flash();
      }
    }
    else {
      if (frameCount % 2 == 0) {
        initFlasher_flash();
      }
    }
    
    if (initFlasher_flashProbability <= initFlasher_flashProbability_max) {
      initFlasher_flashProbability += initFlasher_flashProbability_speed;
    }
  }
  
  initFlasher_progress += 1;
}

public void initFlasher_randomFlash(int intensity) {
  int panel;
  int position;
  panel = PApplet.parseInt(random(NUMBER_OF_PANELS));
  if (random(1) > 0.5f) {
    position = 1;
  }
  else {
    position = 0;
  }  
  fill(intensity);
  rect(panel*(width/NUMBER_OF_PANELS), position*(height/2), width/NUMBER_OF_PANELS, height/2);
}

public void initFlasher_flash() {
  fill(255);
  rect(0,0,width,height);
}

//////////////////////////////////////////
// Specific actions for the Spiraluality animation
//////////////////////////////////////////

public void draw_spiraluality() {
      background(255);
      translate(width/2, height/2);
      pushMatrix();
      rotate(spiraluality_i);
      for(int j = 0; j < spiraluality_numCircles; j++) 
        {
          if(j % 2 == 0) fill(255, 0, 0); else fill(j * 255/(spiraluality_numCircles*2), 0, 0);
          rotate(spiraluality_i);
          ellipse(0, 0, spiraluality_1stdiameter - j * spiraluality_diameterDiff, spiraluality_1stdiameter - j * spiraluality_diameterDiff);
          translate(spiraluality_xArticulation, spiraluality_yArticulation);
        }
      popMatrix();
      spiraluality_i += spiraluality_speed;
      translate(-width/2, -height/2);
}

//////////////////////////////////////////
// Specific actions for the Shadows animation
//////////////////////////////////////////

public void draw_shadows() {
    rand+=.01f;
    float n=noise(rand);
    
    background(255);
    for(int i=150; i>0; i-=5){
        pushMatrix();
        translate(width/2,height/2);
        rotate(radians(frameCount*i/5.f));
 
        fill(i%2==0?0:255);
        ellipse(0,0,5+i*5*sin(n*TWO_PI),15+i*10*cos(n*TWO_PI));
        popMatrix();
    }
}

//////////////////////////////////////////
// Specific actions for the Vertical lines animation
//////////////////////////////////////////

public void draw_carglass() {
  noStroke();
  fill(0,15);
  rect(0,0,width,height);
  stroke(255);
  pushMatrix();
  translate(0,height/2);
  rotate(carglass_progress-(carglass_speed/3));
  line(0,0,carglass_linelength,0);
  rotate(carglass_speed/3);
  line(0,0,carglass_linelength,0);
  rotate(carglass_speed/3);
  line(0,0,carglass_linelength,0);
  popMatrix();
  
  pushMatrix();
  translate(width,height/2);
  rotate(carglass_progress-(carglass_speed/3));
  line(0,0,carglass_linelength,0);
  rotate(carglass_speed/3);
  line(0,0,carglass_linelength,0);
  rotate(carglass_speed/3);
  line(0,0,carglass_linelength,0);
  popMatrix();
  
  carglass_progress += carglass_speed;
}

//////////////////////////////////////////
// Specific actions for the Va et Vient animation
//////////////////////////////////////////

public void draw_va_et_vient_1() {
  pushStyle();
  noStroke();
  fill(0,15);
  rect(0,0,width,height);
  stroke(255);
  strokeCap(SQUARE);
  for (int i=0;i<NUMBER_OF_PANELS*2;i++) {
    if (i%2 == 0) {
      line(i*width/(2*NUMBER_OF_PANELS),va_et_vient_progress,(i+1)*width/(2*NUMBER_OF_PANELS),va_et_vient_progress);
    }
    else {
      line(i*width/(2*NUMBER_OF_PANELS),height - va_et_vient_progress,(i+1)*width/(2*NUMBER_OF_PANELS),height - va_et_vient_progress);
    }
  }
  popStyle();
  va_et_vient_progress += va_et_vient_speed_vertical;
}

public void draw_va_et_vient_2() {
  pushStyle();
  noStroke();
  fill(0,15);
  rect(0,0,width,height);
  stroke(255);
  strokeCap(SQUARE);
  for (int i=0;i<height/4;i++) {
    if (i%2 == 0) {
      line(va_et_vient_progress,i*(height/4),va_et_vient_progress,(i+1)*(height/4));
    }
    else {
      line(width - va_et_vient_progress,i*(height/4),width - va_et_vient_progress,(i+1)*(height/4));
    }
  }  
  popStyle();
  va_et_vient_progress += va_et_vient_speed_horizontal;
}

//////////////////////////////////////////
// Specific actions for the RedGlowingBall animation
//////////////////////////////////////////

public void draw_redGlowingBalls() {
  noStroke();
  fill(255,0,0);
  rect(0,0,width,height);
  
  for (int i = 0; i < NUMBER_OF_PANELS; i++) {
    fill(255*noise(frameCount*redGlowingBalls_noiseSpeed + i*100));
    ellipse(i*width/NUMBER_OF_PANELS + width/(2*NUMBER_OF_PANELS),
            height/2,
            redGlowingBalls_size*(0.5f + noise(frameCount*redGlowingBalls_noiseSpeed + i*100)),
            redGlowingBalls_size*(0.5f + noise(frameCount*redGlowingBalls_noiseSpeed + i*100)));
  }
}

public void draw_redGlowingBalls2() {
  noStroke();
  fill(255,0,0);
  rect(0,0,width,height);
  
  for (int i = 0; i < NUMBER_OF_PANELS; i++) {
    fill(255*noise(frameCount*redGlowingBalls_noiseSpeed + i*100));
    ellipse(i*width/NUMBER_OF_PANELS + width/(2*NUMBER_OF_PANELS),
            height/4,
            redGlowingBalls_size*(0.5f + noise(frameCount*redGlowingBalls_noiseSpeed + i*100)),
            redGlowingBalls_size*(0.5f + noise(frameCount*redGlowingBalls_noiseSpeed + i*100)));
  
    fill(255*noise(frameCount*redGlowingBalls_noiseSpeed + i*200));
    ellipse(i*width/NUMBER_OF_PANELS + width/(2*NUMBER_OF_PANELS),
            3*height/4,
            redGlowingBalls_size*(0.5f + noise(frameCount*redGlowingBalls_noiseSpeed + i*200)),
            redGlowingBalls_size*(0.5f + noise(frameCount*redGlowingBalls_noiseSpeed + i*200)));
  }  
}


//////////////////////////////////////////
// Specific actions for the Rotating Circles animation
//////////////////////////////////////////

public void draw_rotating_circles(){
  background (background_color);
  distance = 30;
  noStroke ();
  fill (circle_color);
  for (int i = 0; i<objNum; i++) {
    float xOffset = cos(radians(degrees*i + angleOffset)) * distance;
    float yOffset = sin(radians(degrees*i + angleOffset)) * distance;
    ellipse (positionX + xOffset, positionY + yOffset, diameter, diameter);
  }
  angleOffset+=2;
}

//////////////////////////////////////////
// Specific actions for the Waveform animation
//////////////////////////////////////////

public void draw_waveform(){
  background(0);
  
  int tempcolor[] = colorwheel(frameCount % 255);
  fill(tempcolor[0],tempcolor[1],tempcolor[2]);

  // We are going to draw a polygon out of the wave points
  beginShape(); 
  
  float xoff = 0;       // Option #1: 2D Noise
  // float xoff = yoff; // Option #2: 1D Noise
  
  // Iterate over horizontal pixels
  for (float x = -24; x <= width; x += 4) {
    // Calculate a y value according to noise, map to 
    float y = map(noise(xoff, yoff), 0, 1, 0,32*NUMBER_OF_PANELS); // Option #1: 2D Noise
    // float y = map(noise(xoff), 0, 1, 200,300);    // Option #2: 1D Noise
    
    // Set the vertex
    vertex(x, y+waveform_y_growing); 
    // Increment x dimension for noise
    xoff += 0.15f;
  }
  // increment y dimension for noise
  yoff += 0.04f;
  if (waveform_y_growing > -16){
  waveform_y_growing -= 0.2f;}
  vertex(width, height);
  vertex(0, height);
  endShape(CLOSE);
}

//////////////////////////////////////////
// Specific actions for the Fadeout animation
//////////////////////////////////////////

public void draw_fadeout(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  fill(0, 20) ;
  rect(0, 0, width, height) ;

}

//////////////////////////////////////////
// Specific actions for the FadeoutLeft animation
//////////////////////////////////////////

public void draw_fadeoutextremeleft(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  rect(0*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
  fill(0, 15) ;
}

public void draw_fadeoutleft(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  rect((NUMBER_OF_PANELS/2 - 1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
  fill(0, 15) ;
}

//////////////////////////////////////////
// Specific actions for the FadeoutCenter animation
//////////////////////////////////////////

public void draw_fadeoutcenter(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
  fill(0, 15) ;
}

//////////////////////////////////////////
// Specific actions for the FadeoutRight animation
//////////////////////////////////////////

public void draw_fadeoutright(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  if (NUMBER_OF_PANELS == 3) {
    rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
  }
  else if (NUMBER_OF_PANELS == 5) {
    rect((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
  }
  fill(0, 15) ;
}

public void draw_fadeoutextremeright(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
  fill(0, 15) ;
}

//////////////////////////////////////////
// Specific actions for the Fadein animation
//////////////////////////////////////////

public void draw_fadein(){
  resetMatrix() ;
  // White out background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  fill(255, 40) ;
  rect(0, 0, width, height) ;

}


//////////////////////////////////////////
// Specific actions for the Worms animation
//////////////////////////////////////////

public void draw_worms(){  
    fill (0, 35);
    noStroke ();
    rect (0, 0, width, height);
    pushStyle();
    colorMode(HSB);
  //background(0);
  for (int i=0; i<numWorms; i++) {
    fill(map(noise(0.01f*worms[i].loc.x,0.01f*worms[i].loc.y),0,1,130,190),158,255);
    ellipse(worms[i].loc.x,worms[i].loc.y,8,8);
    if (pulsed) {
      worms[i].move(pulse);
    }
    else
      worms[i].move();
  }
  popStyle();
  pulsed = false;
}

class Worm {
  PVector dir;
  PVector loc;
  float angle;
  float speed=random(2,3);
  float agility = 0.2f;
  
  public Worm(float x, float y, float angle) {
    this.angle = angle;
    loc = new PVector(x,y);
    dir = new PVector(cos(angle),sin(angle));
    dir.normalize();
    dir.mult(speed);
  }
 
  public void move() {
    angle += random(-agility,agility);
    updateDir();
  }
  public void updateDir() {
    dir = new PVector(cos(angle),sin(angle));
    dir.normalize();
    dir.mult(speed);
    if (loc.x+dir.x<0 || loc.x+dir.x>width) {
      angle = PI-angle;
      //move();
    }
    else if (loc.y+dir.y<0 || loc.y+dir.y>height) {
      angle = 2*PI-angle;
      //move();
    }
    else
      loc.add(dir); 
  }
 public void move(PVector pulse) {
    if (PVector.dist(pulse,loc)<100) {
      PVector d = new PVector(loc.x,loc.y);
      d.sub(pulse);
      angle = atan(d.y/d.x);
      //angle = PVector.angleBetween(d,new PVector(1,0));
    }
   updateDir();   
 }
}

//////////////////////////////////////////
// Specific actions for the Upwards Line animation
//////////////////////////////////////////

public void draw_upwards_line(){  

  background(0);
  //line(0, line_height-1, width, line_height-1);
  line(0, line_height, width, line_height);
  //line(0, line_height+1, width, line_height+1);
  //line(0, line_height+2, width, line_height+2);
  
  line_height = line_height - 1;
  if (line_height < -2) { 
    line_height = height+2; 
  }
}

//////////////////////////////////////////
// Specific actions for the Wind particles animation
//////////////////////////////////////////

public void draw_wind_particles() {
  fade( color(0), 15 ) ;
  for ( int i = 0 ; i < NUMPARTICLES ; i++ ) {
    particle[i].render() ;
    particle[i].addToVector(wind.windAtLocation(particle[i].x(),particle[i].y(),frameCount)) ;
    particle[i].updateLocation() ;
   // particle[i].steerToTarget(new PVector(mouseX, mouseY)) ;
  } 
  filter(DILATE) ;
}
 
// Fades the screen towards colour fadeColour, with opacity fadeLevel
public void fade( int fadeColor , int fadeLevel ) {
  noStroke(); fill(fadeColor, fadeLevel) ;
  rect(0,0, width,height) ;
}

// ==================== PARTICLE CLASS =======================
  
class Particle {
  int MAXVELOCITY = 4 ;
  PVector location ;
  PVector vector ;
  int particleColor ;
   
 // Creates an particle at location (x,y), with vector v and color c
  Particle(int x, int y, PVector v, int c) {
    location = new PVector(x,y) ;
    vector = v ;
    particleColor =  c ;
  }
   
  public void addToVector(PVector vectorToAdd) {
    vector.add(vectorToAdd) ;
    //NOTE - PLAYING AROUND WEIRD WAYS WITH SPEED ACCORDING TO COLOUR
    vector.limit(MAXVELOCITY*(1.5f+red(particleColor)/255.0f-blue(particleColor)/255.0f)) ;
//    vector.limit(MAXVELOCITY) ;
  }
   
  public void updateLocation() {
    location.add( vector ) ;
    location.x = ( location.x + width ) % width ;
    location.y = ( location.y + height ) % height ;
  }
   
  public void steerToTarget(PVector target) {
    vector.limit(PVector.dist(target,location)) ;
     
    PVector targetVector = PVector.sub(target, location) ;
    targetVector.limit(0.2f) ;
    addToVector( targetVector ) ;
  }
   
  public void render() {
    stroke ( particleColor ) ;
    strokeWeight(0.2f) ;
    if(location.x<width/2+10){
      line ( location.x,location.y, location.x+vector.x,location.y+vector.y ) ;
      line ( (width-location.x),location.y, (width-(location.x+vector.x)),location.y+vector.y ) ;
    }
  }
   
  public int x() {
    return PApplet.parseInt(location.x) ;
  }
   
  public int y() {
    return PApplet.parseInt(location.y) ;
  }
}
 
// ==================== WIND CLASS =======================
 
class Wind {
  int horizontalSeed ;
  int verticalSeed ;
  float SCALE = 0.002f ;
  PVector directionalWind = new PVector(0,0) ;
 
  Wind() {
    horizontalSeed = PApplet.parseInt(random(0,10000)) ;
    verticalSeed = PApplet.parseInt(random(0,10000)) ;
  }
   
  public PVector windAtLocation(int x, int y, int time) {
    PVector returnWind ;
    returnWind = new PVector( noise(x*SCALE, y*SCALE, (horizontalSeed + time)*SCALE) - 0.5f,
                        noise(x*SCALE, y*SCALE, (verticalSeed + time)*SCALE) - 0.5f) ;
    returnWind.add(directionalWind) ;
    return returnWind ;
  }   
}

//////////////////////////////////////////
// Specific actions for the StroboNormal animation
//////////////////////////////////////////

public void draw_strobonormal() {
  if (frameCount % 2 == 0)
  {
    //fill(int(random(50,255)),int(random(50,255)),int(random(50,255)));
    fill(255);
    rect(0,0,width,height);
  }
  else
  {
    fill(0);
    rect(0,0,width,height);
  }
}


//////////////////////////////////////////
// Specific actions for the PanelFillLine animation
//////////////////////////////////////////

class PanelFillLineClass{
  
  int squareSize;
  int panelfilllines_x;
  int panelfilllines_y;
  int panelfilllines_speed = 6;
  int lineWidth = width/(4*NUMBER_OF_PANELS);
  boolean moveup;
  int type = frameCount %2;

 public PanelFillLineClass(int x, int y, int type)
 {
  panelfilllines_x = x;
  panelfilllines_y = y;
  moveup = false;
  this.type = type;
  if (type == 1) {
    panelfilllines_x = -84;
  }
 }
 
 public void move() {
   if (NUMBER_OF_PANELS == 3) {
     if (type == 0) {
       if (panelfilllines_x > 0){panelfilllines_x -= panelfilllines_speed;}
         else{panelfilllines_y += panelfilllines_speed;}
     }
     else
     {if (panelfilllines_x < 0){panelfilllines_x += panelfilllines_speed;}
        else{panelfilllines_y += panelfilllines_speed;}
     }     
   }
   else {
     if (type == 0) {
       if (panelfilllines_x > width/NUMBER_OF_PANELS){panelfilllines_x -= panelfilllines_speed;}
         else{panelfilllines_y += panelfilllines_speed;}
     }
     else
     {if (panelfilllines_x < width/NUMBER_OF_PANELS){panelfilllines_x += panelfilllines_speed;}
        else{panelfilllines_y += panelfilllines_speed;}
     }     

   }
 }
 
 public void display() {
     fill(255,0,0);
     rect(this.panelfilllines_x, -this.panelfilllines_y, lineWidth, height);
     fill(255);
     rect(this.panelfilllines_x + 12, this.panelfilllines_y, lineWidth, height);
     fill(255,0,0);   
     rect(this.panelfilllines_x + 24, -this.panelfilllines_y, lineWidth, height);
     fill(255);
     rect(this.panelfilllines_x + 36, this.panelfilllines_y, lineWidth, height);
     fill(255,0,0);
     rect(this.panelfilllines_x + 48, -this.panelfilllines_y, lineWidth, height);
     fill(255);
     rect(this.panelfilllines_x + 60, this.panelfilllines_y, lineWidth, height);
     fill(255,0,0);
     rect(this.panelfilllines_x + 72, -this.panelfilllines_y, lineWidth, height);
     fill(255);
     rect(this.panelfilllines_x + 84, this.panelfilllines_y, lineWidth, height);     
     move();

 }
}

  
public void draw_panelfillline() {
  background(0);
  
  if (panelfilllines_draw == true) {
    panelFillLinesList.add(new PanelFillLineClass(width, 0, panelfilllines_randtype));
    panelfilllines_randtype = (panelfilllines_randtype+1)%2;
    panelfilllines_draw = false;
  }
  
  for (PanelFillLineClass element: panelFillLinesList) {
    element.display();
  }
  for (PanelFillLineClass element: panelFillLinesList) {
    if (element.panelfilllines_y > height*2) {
      panelFillLinesList.remove(element);
      break;
    }
  }
}
  

//////////////////////////////////////////
// Specific functions for the Symmetry animation
//////////////////////////////////////////

class Ribbon {
 
  // ----------------------------------------------------------------- Constants and variables
 
  int displacement = height/70 ;  // Sets the change made to the position of ribbons drawn
                                  // in each cycle relative to screen height
  int strokeWidth;                // Sets the maximum possible width of the ribbon
                                  // relative to screen size
 
  int positionX, positionY, lastX, lastY ; // Stores the current and previous position
                                           // of the ribbon
  int index ;  // Stores the number of the ribbon (ribbon closest to centre is 1, next
               // is 2, etc)
 
  int pattern ;// Stores which pattern the ribbon is required to draw.
 
  // ---------------------------------------------------------------------------- Constructors
 
  Ribbon(int indx, int pattn) {
 
    index = indx + 1 ; // Save the number of the ribbon (as counted from the centre of the
                       // display
    pattern = pattn ;
    updatePosition() ; // Set the initial location of the ribbon
 
      strokeWidth = 2*index * ((height/8) / numRibbons) ;  //Set ribbon width
  }
 
  // --------------------------------------------------------------------------- Public methods
 
 
  // Update the position of the ribbon according to which pattern it is following 
  public int updatePosition() {
 
    // Save the previous position of the ribbon so a line can be drawn between the previous
    // and the current position
    lastX = positionX ;
    lastY = positionY ;
 
    if (pattern == CIRCLE_PATTERN) {
 
      // Update the position of the ribbon according to the 'circle' pattern
      positionX = round((height/2)*(index/PApplet.parseFloat(numRibbons)) * sin(delta) * cos(delta)) ;
      positionY = round((height/2)*(index/PApplet.parseFloat(numRibbons)) * sin(delta) * sin(delta) + displacement * (delta/PI)) ;
      //Do the flower pattern instead of the circle pattern !
      //positionX = round((height/2)*(index/float(numRibbons)) * sin(delta) * sin(delta) * sin(delta) * cos(delta)) ;
      //positionY = round((height/2)*(index/float(numRibbons)) * cos(delta) + displacement * (delta/PI)) ;
  }
    else if (pattern == SPIKE_PATTERN) {
 
      // Update the position of the ribbon according to the 'spike' pattern
      positionX = round((height/2)*(index/PApplet.parseFloat(numRibbons)) * sin(delta)) ;
      positionY = round((height/2)*(index/PApplet.parseFloat(numRibbons)) * sin(delta) * sin(delta) * (delta)) ;
    }
    else if (pattern == FLOWER_PATTERN) {
 
      // Update the position of the ribbon according to the 'flower' pattern
      positionX = round((height/2)*(index/PApplet.parseFloat(numRibbons)) * sin(delta) * sin(delta) * sin(delta) * cos(delta)) ;
      positionY = round((height/2)*(index/PApplet.parseFloat(numRibbons)) * cos(delta) + displacement * (delta/PI)) ;
    }
 
    return 0 ;
 
  }
 
 
  public int drawRibbon(int colour) {
 
    stroke(colour) ;
    strokeWeight(index * (strokeWidth/numRibbons)) ;
 
    // Draw a line between the previous position and the current position of the ribbon
    line(positionX,positionY, lastX,lastY) ;
    return 0 ;
  }
}

public void draw_symmetry() {
 
  // Increment counters
  delta = delta + PI/framesToCycle ;
  frames++ ;
   
  // Increment mode once the specified number of cycles have been passed through
  // Add a random change parameter
  if (frames % (CYCLESBEFORECHANGE*framesToCycle) == 0) {
    incrementMode();
  }
 
  // If fadeFrames is greater than zero, fade the image on screen slightly
  // and decrement the fadeFrames counter
  if (fadeFrames > 0) {
    fade() ;
    fadeFrames-- ;
  }
   
  // Set the colour used to draw the ribbon on this frame
  redVal = min(round(50 + sin((redChange/(CYCLESBEFORECHANGE*10)) * delta) * SHADES), 255 );
  greenVal = min(round(50 + sin((greenChange/(CYCLESBEFORECHANGE*10))* delta) * SHADES), 255 ) ;
  blueVal = min(round(50 + sin((blueChange/(CYCLESBEFORECHANGE*10)) * delta) * SHADES), 255 ) ;
   
  // update the location of the ribbons
  for ( int i = 0 ; i < numRibbons ; i++ ) {
    ribbons[i].updatePosition() ;
  }
   
  // draw each segment (i.e. each reflection of the ribbon)
  for ( int i = 0 ; i < numSegments ; i++ ) {
    drawSegment(numSegments,i) ;
  }  
}
 
// ------------------------------------------------------------------------------ Soubroutines
 
// Change to the next mode that is displayed
public void incrementMode() {
 
  // Reset delta counter
  delta = 0 ;
   
  // Updated 'mode' variables according to the values stored in the MODES matrix
  numSegments = MODES[mode % NUM_MODES][0] ;
  numRibbons = MODES[mode % NUM_MODES][1] ;
  redChange = MODES[mode % NUM_MODES][2] ;
  greenChange = MODES[mode % NUM_MODES][3] ;
  blueChange = MODES[mode % NUM_MODES][4] ;
   
  // Clear the ribbons array and create new ribbons to correspond to the
  // current mode
  ribbons = new Ribbon[numRibbons] ;
  for (int i = 0 ; i < numRibbons ; i++) {
    ribbons[i] = new Ribbon(i,(mode % NUM_PATTERNS)) ;
  }
     
  // Set the fadeFrames variable to cause a fade for 120 frames
  fadeFrames = 60 ;
   
  // increment mode counter
  mode++ ;
 
}
 
// Draw a single segment (reflection) of each ribbon
 
public void drawSegment (int totalSegments, int segmentNum) {
   
  // initialise matrix with its origin at the centre of the screen, and rotated
  // according to the number of segments to ensure an even rotation around the
  // origin
  resetMatrix() ;
  translate(width/2, height/2) ;
  rotate(segmentNum * TWO_PI/totalSegments) ;
 
  // Draw each ribbon
  for (int i = 0; i < numRibbons; i++) {
    ribbons[i].drawRibbon(color(redVal, greenVal, blueVal)) ;
  }
}
 
 
// Fade the screen
public void fade() {
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  fill(0, 4) ;
  rect(0, 0, width, height) ;
}

//////////////////////////////////////////
// Specific actions for the FlashExtremeLeft animation
//////////////////////////////////////////

public void draw_flashextremeleft() {
  if (drawextremeleft >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255) ;
    rect(0*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    drawextremeleft --;

  }
  else {
    draw_fadeout();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}  
}

//////////////////////////////////////////
// Specific actions for the FlashLeft animation
//////////////////////////////////////////

public void draw_flashleft() {
  if (drawleft >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke();
    fill(255) ;
    if (NUMBER_OF_PANELS == 3) {
      rect(0*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    } else {
      rect(1*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    }
    
    drawleft --;

  }
  else {
    draw_fadeout();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}  
}

//////////////////////////////////////////
// Specific actions for the FlashCenter animation
//////////////////////////////////////////

public void draw_flashcenter() {
  if (drawcenter >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255);
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;    
    drawcenter--;
  }
  else {
    draw_fadeout();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

//////////////////////////////////////////
// Specific actions for the FlashRight animation
//////////////////////////////////////////

public void draw_flashright() {
  if (drawright >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255);
    if (NUMBER_OF_PANELS == 3) {
      rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    } else {
      rect((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    }
    
    drawright--;

  }
  else {
    draw_fadeout();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

//////////////////////////////////////////
// Specific actions for the FlashExtremeRight animation
//////////////////////////////////////////

public void draw_flashextremeright() {
  if (drawextremeright >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke();
    fill(255);
    if (NUMBER_OF_PANELS == 3) {
      rect(3*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    } else {
      rect(4*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    }
    
    drawextremeright --;

  }
  else {
    draw_fadeout();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

//////////////////////////////////////////
// Specific actions for the WideFlash animation
//////////////////////////////////////////

public void draw_wideflash() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    rect(0, 0, width, height) ;
    fill(255) ;
        drawwide --;

  }
  else {
    draw_fadeout();
  }
}

public void draw_wideflashred() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255,0,0) ;
    rect(0, 0, width, height) ;
    drawwide --;

  }
  else {
    draw_fadeout();
  }
}


//////////////////////////////////////////
// Specific actions for the FlashLeftRed animation
//////////////////////////////////////////

public void draw_flashextremeleftred() {
  if (drawleft >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;

    fill(255,0,0) ;
    rect(0*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    drawleft --;
  }
  else {
    draw_fadeout();
  }
}

public void draw_flashleftred() {
  if (drawleft >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;

    fill(255,0,0) ;
    if (NUMBER_OF_PANELS == 3) {
      rect(0*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    } else {
      rect(1*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    }
    
    drawleft --;
  }
  else {
    draw_fadeout();
  }
}

//////////////////////////////////////////
// Specific actions for the FlashCenterRed animation
//////////////////////////////////////////

public void draw_flashcenterred() {
  if (drawcenter >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255,0,0) ;
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    drawcenter  --;
  }
  else {
    draw_fadeout();
  }
}

//////////////////////////////////////////
// Specific actions for the FlashRightRed animation
//////////////////////////////////////////

public void draw_flashrightred() {
  if (drawright >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255,0,0) ;
    if (NUMBER_OF_PANELS == 3) {
      rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    } else {
      rect((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    }
    
    drawright --;

  }
  else {
    draw_fadeout();
  }
}

public void draw_flashextremerightred() {
  if (drawright >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    fill(255,0,0) ;
    rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, height) ;
    drawright --;

  }
  else {
    draw_fadeout();
  }
}



//////////////////////////////////////////
// Specific actions for the Rhombus animation
//////////////////////////////////////////

public void diamond(float x, float y, float r, float s) {
    quad(x - r, y, x, y - s, x + r, y, x, y + s);
}
 
public void diatri(float x, float y, float r1, float r2, float s) {
    triangle(x, y, x + r1, y - s, x + r2, y + s);
}
 
public float rotFactor(float y, float t) {
    return sin(4 * y / height - t);
}

public void draw_rhombus() {
    float t = millis() * 0.001f;
    background(00);
    noStroke();
    for (int y = 0; y < height + rhombus_diaS; y += 2 * rhombus_diaS) {
        float p = rotFactor(y, t);
        fill(0xcc + 0x33 * p, 0x99, 0xcc - 0x33 * p);
        diamond(rhombus_diaX, y, rhombus_diaR * p, rhombus_diaS);
        float pp = rotFactor(y + 2 * rhombus_diaS, t);
        fill(0x00);
        diatri(rhombus_diaX, y + rhombus_diaS, +rhombus_diaR * p, +rhombus_diaR * pp, rhombus_diaS);
    }
}

//////////////////////////////////////////
// Specific actions for the KaleidoTriangle animation
//////////////////////////////////////////

public void draw_kaleidotriangle() {
    trianglepos += 0.005f;
    
    float x0 = (1.2f * width*cos(trianglepos)) % (0.5f * width);
    float x1 = (1.5f * width*cos(trianglepos)) % (0.5f * width);
    float x2 = (1.8f * width*cos(trianglepos)) % (0.5f * width);
    float y0 = (1.2f * height*sin(trianglepos)) % (0.5f * height);
    float y1 = (1.5f * height*sin(trianglepos)) % (0.5f * height);
    float y2 = (1.8f * height*sin(trianglepos)) % (0.5f * height);
 
    translate(0.5f * width, 0.5f * height);
    background(00);
    fill(0, 172, 255);
    noStroke();
    triangle(+x0, +y0, +x1, +y1, +x2, +y2);
    triangle(+y0, +x0, +y1, +x1, +y2, +x2);
    triangle(-x0, +y0, -x1, +y1, -x2, +y2);
    triangle(-y0, +x0, -y1, +x1, -y2, +x2);
    triangle(+x0, -y0, +x1, -y1, +x2, -y2);
    triangle(+y0, -x0, +y1, -x1, +y2, -x2);
    triangle(-x0, -y0, -x1, -y1, -x2, -y2);
    triangle(-y0, -x0, -y1, -x1, -y2, -x2);
}

//////////////////////////////////////////
// Specific actions for the Glitch animation
//////////////////////////////////////////

public PImage createChannel(float r, float g, float b, int mode) {
    PGraphics pg = createGraphics(width, height);
    pg.beginDraw();
    pg.background(0x00);
    pg.stroke(r, g, b);
    pg.strokeWeight(10);
    pg.noFill();
    if (mode == 0) {
      //Display a triangle
      if (NUMBER_OF_PANELS == 3) {
        pg.triangle(pg.width/6, 7*pg.height/8, pg.width/2, pg.height/8, 5*pg.width/6, 7*pg.height/8);
      }
      else {
        pg.triangle(3*pg.width/10, 7*pg.height/8, pg.width/2, pg.height/8, 7*pg.width/10, 7*pg.height/8);
      }

    }
    else if (mode == 1) {
      for (int i = 0; i < NUMBER_OF_PANELS; i++) {
        pg.line((2*i+1)*(pg.width/(2*NUMBER_OF_PANELS)), pg.height/4, (2*i+1)*(pg.width/(2*NUMBER_OF_PANELS)), 3*pg.height/4);
      }
    }
    pg.endDraw();
    return pg;
}
 
public void drawChannel(PImage img, float x, float y) {
    float u = img.width;
    float v = img.height;
    blend(img, 0, 0, PApplet.parseInt(u), PApplet.parseInt(v), PApplet.parseInt(x - 0.5f * u), PApplet.parseInt(y - 0.5f * v), PApplet.parseInt(u), PApplet.parseInt(v), SUBTRACT);
}
 
public void draw_glitch() {
    if (random(1) > 0.6f) { 
    sincounter += 2;
    }
    else {
    sincounter -= 1;    
    }
    float x0 = 0.5f * width;
    float y0 = 0.5f * height;
    background(0xff);
    drawChannel(redImg, x0 - random(sincounter % 20), y0 - 0.3f*random(sincounter % 20));
    drawChannel(greenImg, x0, y0);
    drawChannel(blueImg, x0 + random(sincounter % 20), y0 + 0.3f*random(sincounter % 20));
}

//////////////////////////////////////////
// Specific actions for the Snow animation
//////////////////////////////////////////

public void draw_snow()
{
  background(0);
  for(snowflakecounter=0; snowflakecounter<snowMatrix.length; snowflakecounter=snowflakecounter+1)
  {
    snowMatrix[snowflakecounter].snow();
  }
}
 
class Floco
{
  float posx;
  float posy;
  float valx;
  float valy;
  int c;
   
  Floco(float tposx, float tposy, float tvalx, float tvaly, int tc)
  {
    posx=tposx;
    posy=tposy;
    valx=tvalx;
    valy=tvaly;
    c=tc;
  }
   
  public void snow()
  {
    if(posx>=0 && posx<=width)
    {posx=posx+valx;}
    else
    {
      if(posx>0)
      {posx=0;}
      else
      {posx=width;}
    }
    if(posy<height)
    {posy=posy+valy;}
    else
    {posy=0;}
    noStroke();
    fill(c);
    ellipse(posx, posy, snowflakeSize, snowflakeSize);
  }
}

//////////////////////////////////////////
// Specific actions for the MechanicLines animation
//////////////////////////////////////////

public void draw_mechaniclines(){
 display_mechaniclines();
  move_mechaniclines();
  bounce_mechaniclines();
  }
   
 public void display_mechaniclines(){
  background(255);
    stroke(0);
line( mechaniclines_w,height/2, width ,height/2);
line( width/2,0,width/2,mechaniclines_h);
line( 0,height/3,mechaniclines_w,height/3);
line( width/5,mechaniclines_h, width/5 ,height);
//line( width-100,mechaniclines_h, width-100 ,height);
stroke(255,0,0);
line( width,mechaniclines_h, 0 ,mechaniclines_h);}
 
public void move_mechaniclines(){
mechaniclines_h = mechaniclines_h + mechaniclines_hspeed;
mechaniclines_w = mechaniclines_w + mechaniclines_wspeed;
}
 
public void bounce_mechaniclines(){
if (mechaniclines_w>width || mechaniclines_w<0) {
   mechaniclines_wspeed = mechaniclines_wspeed* -1;
  }
  if ( mechaniclines_h>height || mechaniclines_h<0) {
    mechaniclines_hspeed = mechaniclines_hspeed*-1;
  }
}

//////////////////////////////////////////
// Specific actions for the RedvsBlackvsWhite animation
//////////////////////////////////////////

public void draw_redvsblackvswhite() {
  background(255,0,0);
  redvsblackvswhite_frameCount += 1;
  redvsblackvswhite_i=0;
  for (int x = PApplet.parseInt(- redvsblackvswhite_incr/2); x < width; x += redvsblackvswhite_incr) {
    for (int y = 0; y < height *1.3f; y+= redvsblackvswhite_incr) { 
      Pulse dot = (Pulse) dots.get(redvsblackvswhite_i);
      dot.display();
      redvsblackvswhite_i++;
    }
  }
}
class Pulse {
  float x, y, theta1;
  float sz, sz2;
  float theta=0;
  float offset;
 
  Pulse(float _x, float _y) {
    x = _x;
    y = _y;
    offset = .5f*redvsblackvswhite_incr;
    theta = noise(x+y/100)*PI;
    noStroke();
  }
 
  public void display() {
    if (redvsblackvswhite_frameCount > 20) {
      fill(255, 0, 0);
      translate((x+offset), y);
      sz = map(sin(theta), -1, 1, 0, redvsblackvswhite_incr);
      ellipse(0, 0, sz, sz);
      resetMatrix();
   
      fill(0);
      translate((x+ offset), y + offset*1.1f);
      if (sz2 - (redvsblackvswhite_incr - abs(sz)) < 0) {
        sz2 = redvsblackvswhite_incr - abs(sz);
      }
      else {
        sz2 += 0.2f;
      }
      ellipse(0, 0, sz2, sz2);
      resetMatrix();
      
      theta += noise((x+y)/10)*.045f;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the RotatingSquare animation
//////////////////////////////////////////
public void draw_rotatingsquare() {
  fill(color(0xffD60B0B),50);
  background(color(0xffD60B0B));
  fill(color(0xffD60B0B),50);
  beginShape();
  
  for(float y = 0; y < width; y += 1) {
    vertex(5*width/6+18
    *sin(v+(y/map(5*height/6,0,height,1,100)))
    *(tan(w+(y/map(8,0,height,0,400))))
    *sin(v+(y/map(8,0,width,1,100)))
    , y);
  }
  endShape();

  pushMatrix();
  TriRotElem[0].display();
  popMatrix();

  v -= 0.025f;
  w += 0.05f;

}
  
class TriRot {
  float rectangle_x, rectangle_y;
  float rectangle_size, rectangle_size_var; //size
  float rectangle_strokeweight; //strokeWeight
  float theta, thetaIncr;
  float col; //color
 
  TriRot(float _rectangle_x, float _rectangle_y, float _rectangle_size, float _rectangle_strokeweight, float _col ) {
    rectangle_x = _rectangle_x;
    rectangle_y = _rectangle_y;
    rectangle_size = _rectangle_size;
    rectangle_strokeweight = _rectangle_strokeweight;
    col = _col;
    theta = thetaStart;
    thetaIncr = .03f;
    thetaStart += 0.2f;
  }
 
  public void display() {
    fill(col);
    rotate(theta);
    //translate(rectangle_x, rectangle_y);
    rectangle_size_var = map(sin(theta), -1,1,1,1.5f)*rectangle_size;
    //rectangle_size_var = rectangle_size;
    rect(-rectangle_size_var/2, -rectangle_size_var/2, rectangle_size_var, rectangle_size_var);
    resetMatrix();
    theta += thetaIncr;
  }
}


//////////////////////////////////////////
// Specific actions for the MovingSine animation
//////////////////////////////////////////

public void draw_movingsine() {
  background(0);
  for (int i = 0; i < SineElem.length; i++) {
    SineElem[i].display();
  }
  if (random(50) > 49) {
    movingsine_speed = -movingsine_speed * random(0.8f,1.2f);
  }  
}
class ExLine {
  float x, y, y2, y3;
  float rad, theta;
 
  ExLine(float _x, float _theta) {
    x = _x;
    y = height;
    y2 = y - 0;
    rad = 64;
    theta = _theta;
  }
 
  public void display() {
    line(x, y, x, y2);
    line(x, y2, x, y3);
 
    y3 = y2 - map(sin(theta), -1, 1, 0, 1) * rad;

    theta += movingsine_speed;
  }
}


//////////////////////////////////////////
// Specific actions for the SineFuckedUp animation
//////////////////////////////////////////

public void draw_sinefuckedup(int sinefuckedupmode) {
int sine_fuckedup_mode = sinefuckedupmode;
noStroke(); 
fill(0,50);
rect(0,0,width,height);
stroke(255);

if (sine_fuckedup_mode == 0) {
  beginShape();
  
  for(float x = 0; x < width; x += 1) {
    vertex(x, height/2+8
    *sin(v+(x/map(5*width/6,0,width,1,100)))
    *tan(w+(x/map(8,0,width,100,400)))
    *sin(v+(x/map(8,0,height,1,100)))
    );
  }
  endShape();
}
else if (sine_fuckedup_mode == 1)
{
  beginShape();
  for(float x = 0; x < width; x += 1) {
    vertex(x, height/2+5*height/6
    *sin(v+(x/map(5,0,width,1,100)))
    *tan(w+(x/map(5*height/6,0,width,100,400)))
    *sin(v+(x/map(5*height/6,0,height,1,100)))
    );
  }
  endShape();  
}
else if (sine_fuckedup_mode == 2)
{
  float sine_x = map(sin(sine_fuckedup_counter*0.01f),-1,1,0,width);
  float sine_y = map(sin(sine_fuckedup_counter*0.02f),-1,1,0,height);
  beginShape();
  for(float x = 0; x < width; x += 1) {
    vertex(x, height/2+sine_y
    *sin(v+(x/map(sine_x,0,width,1,100)))
    *tan(w+(x/map(sine_y,0,width,100,400)))
    *sin(v+(x/map(sine_y,0,height,1,100)))
    );
  }
  endShape(); 
}
v -= 0.025f;
w += 0.05f;
sine_fuckedup_counter++;
}


//////////////////////////////////////////
// Specific actions for the AutomaticCircle and ManualCircle animation
//////////////////////////////////////////

public void draw_manualcircle() {
  background(0);
  for (int i = 0; i < rings.size() ; i ++) {
    CirclePulse ring = (CirclePulse) rings.get(i);
    ring.display();
    if (dropcircle_kill) {
      rings.remove(dropcircle_j);
      dropcircle_kill = false;
    }
  }
}

public void draw_automaticcircle() {
  background(0);
  for (int i = 0; i < rings.size() ; i ++) {
    CirclePulse ring = (CirclePulse) rings.get(i);
    ring.display();
    if (dropcircle_kill) {
      rings.remove(dropcircle_j);
      dropcircle_kill = false;
    }
  }
  if (frameCount == 1) {
    rings.add(new CirclePulse(dropcircle_x, dropcircle_y, dropcircle_sz));
  }
  if (frameCount % 45 == 0) {
    rings.add(new CirclePulse(dropcircle_x, dropcircle_y, dropcircle_sz));
  }  
}

class CirclePulse {
  float dropcircle_x, dropcircle_y;
  float dropcircle_sz, dropcircle_store_sz;
  float dropcircle_theta=0;
 
  CirclePulse(float _x, float _y, float _sz) {
    dropcircle_x = _x;
    dropcircle_y = _y;
    dropcircle_sz = _sz;
    dropcircle_store_sz = _sz;
  }
 
  public void display() {
 
    translate(dropcircle_x, dropcircle_y);
    ellipse(0, 0, dropcircle_sz, dropcircle_sz);
    resetMatrix();
    dropcircle_sz +=1;
 
    if (dropcircle_sz>2*sqrt(sq(width)+sq(width))) {
      dropcircle_kill = true;
    }
  }
}


//////////////////////////////////////////
// Specific actions for the Rain animation
//////////////////////////////////////////

public void draw_rain() {
  //background(0);
  fill(0,15);
      noStroke();
  rect(0,0,width, height);
 
  int raindrops_i = 0;
  while (raindrops_i < howManyRainDrops) {
    fill(150*raindrops_speed[raindrops_i]);
    ellipse(raindrops_x[raindrops_i], raindrops_y[raindrops_i],4*raindrops_speed[raindrops_i],4*raindrops_speed[raindrops_i]);
    raindrops_y[raindrops_i] += raindrops_speed[raindrops_i]/2;
    if (raindrops_y[raindrops_i] > height) {
      raindrops_y[raindrops_i] = 0;
    }
    raindrops_i +=1;
  }
}


//////////////////////////////////////////
// Specific actions for the Pong animation
//////////////////////////////////////////

 //Keyboards commands, useful for debug, or for fun
/*
void keyPressed()
{
  if (keyCode == LEFT)
  {command_p1_left = true;}
  if (keyCode == RIGHT)
  {command_p1_right = true;}
  if (key == 'a')
  {command_p2_left=true;}
  if (key == 'z' )
  {command_p2_right=true;}
}
void keyReleased()
{
  if (keyCode == LEFT)
  {command_p1_left = false;}
  if (keyCode==RIGHT)
  {command_p1_right = false;}
  if (key=='a')
  {command_p2_left=false;}
  if (key=='z')
  {command_p2_right=false;}
}
*/

public void pong_gameRestart() {
  pongball.posx=(random((width/2) - randomarea, (width/2) + randomarea));
  pongball.posy=(random((height/2) - randomarea, (height/2) + randomarea));
  int xdirection=PApplet.parseInt(random(2));
  int ydirection=PApplet.parseInt(random(2));
  if (xdirection==0)
  {
    pongball.right=true;
  }
  else //xidrection==1
  {
    pongball.right=false;
  }
  if (ydirection==0)
  {
    pongball.up=true;
  }
  else //ydirection==1
  {
    pongball.up=false;
  }
  gameover=false;
  pong_sideFactor = 0;
}

public void draw_pong()
{
  if (gamestart == true) {
    if (gameover==false)
    {
      background(0);
      bottom.show();
      top.show();
      if (command_p1_left==true)
      {
        bottom.moveleft();
      }
      if (command_p1_right==true)
      {
        bottom.moveright();
      }
      if (command_p2_left==true)
      {
        top.moveleft();
      }
      if (command_p2_right==true)
      {
        top.moveright();
      }
      pongball.move();
      pongball.bounce();
      pongball.show();
      if (pongball.y<-8)
      {
        gameover=true;
        bottomscore++;
        if (bottomscore == 10) {
          bottomscore = 0;
          bottommatchcount++;
        }
      }
      if (pongball.y>height + 8)
      {
        gameover=true;
        topscore++;
        if (topscore == 10) {
          topscore = 0;
          topmatchcount++;
        }
      }
    }
    else //gameover==true
    {
      background(0);
      fill(255, 0, 0);
      changespeed=0;
      text(topscore, width/2 - PIXELS_X/NUMBER_OF_PANELS, height/2+4);
      text(bottomscore, width/2 + PIXELS_X/NUMBER_OF_PANELS, height/2+4);
      
      for (int j=0; j<bottommatchcount;j++) {
        rect(width/NUMBER_OF_PANELS + 4, j*pong_rectspacing + pong_rectheight, pong_rectwidth, pong_rectheight);
      }
      for (int j=0; j<topmatchcount;j++) {
        rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS - pong_rectwidth - 4, j*pong_rectspacing + pong_rectheight, pong_rectwidth, pong_rectheight);
      }
      
      if (command_p1_left | command_p1_right | command_p2_left | command_p2_right)
      {
        pongball.posx=(random((width/2) - randomarea, (width/2) + randomarea));
        pongball.posy=(random((height/2) - randomarea, (height/2) + randomarea));
        int xdirection=PApplet.parseInt(random(2));
        int ydirection=PApplet.parseInt(random(2));
        if (xdirection==0)
        {
          pongball.right=true;
        }
        else //xidrection==1
        {
          pongball.right=false;
        }
        if (ydirection==0)
        {
          pongball.up=true;
        }
        else //ydirection==1
        {
          pongball.up=false;
        }
        gameover=false;
      }
    }
  }
}
class Paddle
{
  int x, y;
  int paddle_height = 4;
  int paddle_width = 20;
  Paddle()
  {
    x=width/2;
    y=height - paddle_height;
  }
  public void show()
  {
    fill(255);
    rect(x, y, paddle_width, paddle_height);
  }
  public void moveleft()
  {
    if (x>=0)
    {
      x-=4;
    }
  }
  public void moveright()
  {
    if (x<=width - paddle_width)
    {
      x+=4;
    }
  }
}
class Ball
{
  int x, y;
  float posx, posy;
  int ball_size = 8;
  boolean up, right;
  Ball()
  {
    x=ball_size;
    y=height - ball_size;
    posx = x;
    posy = y;
    up=true;
    right=true;
  }
  public void move()
  {
    if (up==true)
    {
      posy=posy-0.5f*(2+changespeed/4);
      y=PApplet.parseInt(posy);
    }
    else  //up==false
    {
      posy=posy+0.5f*(2+changespeed/4);
      y=PApplet.parseInt(posy);
    }
    if (right==true)
    {
      posx=posx+0.5f*(1+changespeed/8 + abs(pong_sideFactor));
      x=PApplet.parseInt(posx);
    }
    else  //right==false
    {
      posx=posx-0.5f*(1+changespeed/8 + abs(pong_sideFactor));
      x=PApplet.parseInt(posx);
    }
  }
  public void bounce()
  {
    if (get(PApplet.parseInt(x)-(ball_size/2), PApplet.parseInt(y))!=color(0))
    {
      right=true;
    }
    if (get(PApplet.parseInt(x)+(ball_size/2), PApplet.parseInt(y))!=color(0))
    {
      right=false;
    }
    if (get(PApplet.parseInt(x), PApplet.parseInt(y)-PApplet.parseInt(1.4f*(ball_size/2.0f)))==color(255))
    {
      //Has the ball hit the left or the right side of the paddle ?
      pong_sideFactor = (2.0f*(x - (top.x + top.paddle_width/2.0f)))/(float)top.paddle_width;
      if (pong_sideFactor > 0) {right = true;}
                          else {right = false;}
      up=false;
      changespeed=min(changespeed+0.7f, 10);
    }
    if (get(PApplet.parseInt(x), PApplet.parseInt(y)+PApplet.parseInt(1.4f*(ball_size/2)))==color(255))
    {
      pong_sideFactor = (2*(x - (bottom.x + bottom.paddle_width/2.0f)))/(float)bottom.paddle_width;
      if (pong_sideFactor > 0) {right = true;}
                          else {right = false;}
      up=true;
      changespeed=min(changespeed+0.7f, 10);
    }
    
  }
  public void show()
  {
    fill(255,0,0);
    ellipse(x, y, ball_size, ball_size);
  }
}


//////////////////////////////////////////
// Specific actions for the PulseStar animation
//////////////////////////////////////////

public void drawGlobe(float r, int n, float phi) {
    for (int i = 0; i < n; i++) {
        float theta = i * PI / n + (phi % (PI / n));
        float s = r * cos(theta);
        if (s > 0) {
            arc(width/2, height/2, +2 * s, 2 * r, -HALF_PI, +HALF_PI);
        }
        else {
            arc(width/2, height/2, -2 * s, 2 * r, +HALF_PI, TWO_PI - HALF_PI);
        }
    }
}
 
public void drawPulsar(float pulsestar_t) {
    pulsestar_r = map(sin(pulsestar_t * 3) + sin(pulsestar_t * 4) + sin(pulsestar_t * 5), -3, +3, 0.8f * pulsestar_R, pulsestar_R);
    strokeWeight(pulsestar_r);
    point(width/2, height/2);
}

public void draw_pulsestar() {
    pulsestar_t = millis() * 0.002f;
    background(0x00);
    noFill();
     
    strokeWeight(1);
    strokeWeight(3);
    stroke(0x99);
    drawGlobe(pulsestar_R, pulsestar_N, ((-pulsestar_OMEGA * pulsestar_t) % TWO_PI) + TWO_PI);
    stroke(0xff);
    drawPulsar(pulsestar_t);
    strokeWeight(3);
    stroke(0x66);
    drawGlobe(pulsestar_R, pulsestar_N, +pulsestar_OMEGA * pulsestar_t);
}


//////////////////////////////////////////
// Specific actions for the ArrowShape animation
//////////////////////////////////////////

public void drawChevron(float d, float s, float offset, float angle) {
    pushMatrix();
    rotate(angle);
    translate(offset, 0);
    beginShape();
    vertex(0, 0);
    vertex(-d, -d);
    vertex(-d + s, -d);
    vertex(s, 0);
    vertex(-d + s, +d);
    vertex(-d, +d);
    endShape(CLOSE);
    popMatrix();
}
 
 
public void draw_arrowshape() {
    background(0x00);
    noStroke();
    translate(0.5f * width, 0.5f * height);
     
    fill(0xff);
    for (int i = 0; i < 7; i++) {
        float offset = (frameCount % 40) + 40 * i;
        for (int j = 0; j < 8; j++) {
            drawChevron(15, 10, offset, j * QUARTER_PI);
        }
    }
    /*
    fill(0x00);
    ellipse(0, 0, 45, 45);
    fill(0xff);
    ellipse(0, 0, 35, 35);
    fill(0x00);
    ellipse(0, 0, 25, 25);
    fill(0xff);
    ellipse(0, 0, 15, 15);
    */
}


//////////////////////////////////////////
// Specific actions for the Star animation
//////////////////////////////////////////

public void draw_star(int branches) {
  background(0);
  pushMatrix();
  translate(width*0.5f, height*0.5f);
  rotate(frameCount / 100.0f);
  star(0, 0, 8, 2000, branches); 
  popMatrix();
  
}

public void star(float x, float y, float radius1, float radius2, int npoints) {
  float angle = TWO_PI / npoints;
  float halfAngle = angle/2.0f;
  beginShape();
  for (float a = 0; a < TWO_PI; a += angle) {
    float sx = x + cos(a) * radius2;
    float sy = y + sin(a) * radius2;
    vertex(sx, sy);
    sx = x + cos(a+halfAngle) * radius1;
    sy = y + sin(a+halfAngle) * radius1;
    vertex(sx, sy);
  }
  endShape(CLOSE);
}


//////////////////////////////////////////
// Specific actions for the MovingLines animation
//////////////////////////////////////////

public void draw_movinglines() {
  background(0);
  for (MovingLine movingline: movingLines) {
    movingline.display();
  }

  for (MovingLine movingline: movingLines) {
    if (movingline.movingline_kill == true) {
      movingLines.remove(movingline);
      break;
    }
  }  
  
  int speed = PApplet.parseInt(random(1,movingline_maxspeed));
  if (frameCount == 1) {
    movingLines.add(new MovingLine(speed, speed, 0));
  }
  if (frameCount % movingline_frequency == 0) {
    movingLines.add(new MovingLine(speed, speed, 0));
  }

  if (frameCount % movingline_frequency-1 == 0) {
    movingLines.add(new MovingLine(speed, speed, 1));
  }
  
  if (frameCount % movingline_frequency-2 == 0) {
    movingLines.add(new MovingLine(speed, speed, 2));
  }
  
  if (frameCount % movingline_frequency-3 == 0) {
    movingLines.add(new MovingLine(speed, speed, 3));
  }

}

class MovingLine{
  
  int movingline_x;
  int movingline_y;
  int movingline_speedx;
  int movingline_speedy;
  int direction;
  boolean movingline_kill = false;

 public MovingLine(int speedx, int speedy, int direc)
 {
    this.movingline_speedx = speedx;
    this.movingline_speedy = speedx;
    this.direction = direc;
    if (direc == 0) {
      movingline_x = 0;
      movingline_y = 0;
    }
    else if (direc == 1) {
      movingline_x = width;
      movingline_y = 0;
    }
    else if (direc == 2) {
      movingline_x = width;
      movingline_y = height;
    }
    else if (direc == 3) {
      movingline_x = 0;
      movingline_y = height;
    }
 }
 
 public void move() {
    if (this.direction == 0)
    {
      this.movingline_x+=this.movingline_speedx*5; 
      this.movingline_y+=this.movingline_speedy*5;
    } 
    if (this.direction == 1)
    {
      this.movingline_x-=this.movingline_speedx*5; 
      this.movingline_y+=this.movingline_speedy*5;
    }
    if (this.direction == 2)
    {
      this.movingline_x-=this.movingline_speedx; 
      this.movingline_y-=this.movingline_speedy;
    } 
    if (this.direction == 3)
    {
      this.movingline_x+=this.movingline_speedx*2; 
      this.movingline_y-=this.movingline_speedy*2;
    }
 }
 
 public void display() {
    fill(255);
    if (this.direction == 0){
    line(this.movingline_x, 0, 0, this.movingline_y);}
    if (this.direction == 1){
    line(this.movingline_x, 0, width, this.movingline_y);}
    if (this.direction == 2){
    line(3*this.movingline_x, 3*this.movingline_y, 3*this.movingline_y, 3*this.movingline_x);}
    if (this.direction == 3){
    line(0, 3*this.movingline_y, 2*this.movingline_x, width);}

    move();
   
   if (this.movingline_x > 5*width | this.movingline_x < -5*width | this.movingline_y > 5*height | this.movingline_y < -5*width) {
     this.movingline_kill = true;
   }
 }
}


//////////////////////////////////////////
// Specific actions for the MovingSquares animation
//////////////////////////////////////////

public void draw_movingsquares() {
  background(0);
  for (MovingSquare movingsquare: movingSquares) {
    movingsquare.display();
  }
  for (MovingSquare movingsquare: movingSquares) {
    if (movingsquare.movingsquare_kill == true) {
      movingSquares.remove(movingsquare);
      break;
    }
  }
  if (frameCount == 1) {
    movingSquares.add(new MovingSquare(PApplet.parseInt(random(0,width)), 0, 4*PApplet.parseInt(random(0,movingsquare_maxsize)), PApplet.parseInt(random(1,movingsquare_maxspeed)), 0));
  }
  if (frameCount % movingsquare_frequency == 0) {
    movingSquares.add(new MovingSquare(PApplet.parseInt(random(0,width)), 0, 4*PApplet.parseInt(random(0,movingsquare_maxsize)), PApplet.parseInt(random(1,movingsquare_maxspeed)), 1));
  }
  if (frameCount % movingsquare_frequency-3 == 0) {
    movingSquares.add(new MovingSquare(0, PApplet.parseInt(random(0,height)), 4*PApplet.parseInt(random(0,movingsquare_maxsize)), PApplet.parseInt(random(1,movingsquare_maxspeed)), 0));
  }
  if (frameCount % movingsquare_frequency-1 == 0) {
    movingSquares.add(new MovingSquare(width, PApplet.parseInt(random(0,height)), 4*PApplet.parseInt(random(0,movingsquare_maxsize)), PApplet.parseInt(random(1,movingsquare_maxspeed)), 2));
  }
  if (frameCount % movingsquare_frequency-2 == 0) {
    movingSquares.add(new MovingSquare(PApplet.parseInt(random(0,width)), height, 4*PApplet.parseInt(random(0,movingsquare_maxsize)), PApplet.parseInt(random(1,movingsquare_maxspeed)), 3));
  }

  }

class MovingSquare{
  
  int squareSize;
  int movingsquare_x;
  int movingsquare_y;
  int movingsquare_speed;
  int direction;
  boolean movingsquare_kill = false;

 public MovingSquare(int x, int y, int size, int speed, int direc)
 {
  this.movingsquare_x = x;
  this.movingsquare_y = y;
  this.squareSize = size;
  this.movingsquare_speed = speed;
  this.direction = direc;
 }
 
 public void move() {
    if (this.direction == 0)
    {
      this.movingsquare_x+=this.movingsquare_speed; 
    } 
    if (this.direction == 1)
    {
      this.movingsquare_y+=this.movingsquare_speed;
    }
    if (this.direction == 2)
    {
      this.movingsquare_x-=this.movingsquare_speed; 
    } 
    if (this.direction == 3)
    {
      this.movingsquare_y-=this.movingsquare_speed;
    }
 }
 
 public void display() {
   fill(255);
   rect(this.movingsquare_x, this.movingsquare_y, this.squareSize, this.squareSize);
   move();
   
   if (this.movingsquare_x > width + 16 || this.movingsquare_x < - 16 || this.movingsquare_y > height + 16 || this.movingsquare_y < - 16) {
     this.movingsquare_kill = true;
   }
 }
}

//////////////////////////////////////////
// Specific actions for the UpwardsGlitchLine animation
//////////////////////////////////////////

public void draw_upwardsglitchlines() {
  // On ecrit les lignes
  background(0);
  upwards_glitchlines_count ++;
  
  stroke(255);
  line(0, upwards_glitchlines_a, width, upwards_glitchlines_a);
  line(0, upwards_glitchlines_b, width, upwards_glitchlines_b); 
  line(0, upwards_glitchlines_c, width, upwards_glitchlines_c); 
    
  if((upwards_glitchlines_count)%upwards_glitchlines_freq == 0){    
    // On ecrit les inter-lignes
    stroke(255,0,0);
    line(0, upwards_glitchlines_a-upwards_glitchlines_interligne-upwards_glitchlines_glitch_y, width-upwards_glitchlines_glitch_x, upwards_glitchlines_a-upwards_glitchlines_interligne-upwards_glitchlines_glitch_y);
    line(0, upwards_glitchlines_b-upwards_glitchlines_interligne-upwards_glitchlines_glitch_y, width-upwards_glitchlines_glitch_x, upwards_glitchlines_b-upwards_glitchlines_interligne-upwards_glitchlines_glitch_y); 
    line(0, upwards_glitchlines_c-upwards_glitchlines_interligne-upwards_glitchlines_glitch_y, width-upwards_glitchlines_glitch_x, upwards_glitchlines_c-upwards_glitchlines_interligne-upwards_glitchlines_glitch_y); 
  }else if((upwards_glitchlines_count+upwards_glitchlines_freq/2)%upwards_glitchlines_freq == 0){           
    // On ecrit les inter-lignes
    stroke(255,0,0);
    line(upwards_glitchlines_glitch_x, upwards_glitchlines_a-upwards_glitchlines_interligne+upwards_glitchlines_glitch_y, width, upwards_glitchlines_a-upwards_glitchlines_interligne+upwards_glitchlines_glitch_y);
    line(upwards_glitchlines_glitch_x, upwards_glitchlines_b-upwards_glitchlines_interligne+upwards_glitchlines_glitch_y, width, upwards_glitchlines_b-upwards_glitchlines_interligne+upwards_glitchlines_glitch_y); 
    line(upwards_glitchlines_glitch_x, upwards_glitchlines_c-upwards_glitchlines_interligne+upwards_glitchlines_glitch_y, width, upwards_glitchlines_c-upwards_glitchlines_interligne+upwards_glitchlines_glitch_y); 
  } else { 
  // On ecrit les inter-lignes
  stroke(255,0,0);
  line(0, upwards_glitchlines_a-upwards_glitchlines_interligne, width, upwards_glitchlines_a-upwards_glitchlines_interligne);
  line(0, upwards_glitchlines_b-upwards_glitchlines_interligne, width, upwards_glitchlines_b-upwards_glitchlines_interligne); 
  line(0, upwards_glitchlines_c-upwards_glitchlines_interligne, width, upwards_glitchlines_c-upwards_glitchlines_interligne); 
  }
    
  // On deplace les lignes pour le prochain passage
  upwards_glitchlines_a -= upwards_glitchlines_speed;
  if (upwards_glitchlines_a < 0) { 
    upwards_glitchlines_a = height; 
  }
  upwards_glitchlines_b -= upwards_glitchlines_speed;
  if (upwards_glitchlines_b < 0) { 
    upwards_glitchlines_b = height; 
  }
  upwards_glitchlines_c -= upwards_glitchlines_speed;
  if (upwards_glitchlines_c < 0) { 
    upwards_glitchlines_c = height; 
  }
}


//////////////////////////////////////////
// Specific actions for the DiagonalGlitchLine animation
//////////////////////////////////////////


public void draw_diagonalglitchlines() {
  // On ecrit les lignes
  background(0);
  diagonal_glitchlines_count ++;
  
  float russianroulette = random(1);
  
  if(russianroulette < 0.04f){ 
    // On ecrit les autres lignes
    stroke(255,0,0);
    line(0, diagonal_glitchlines_a-height/8, width, diagonal_glitchlines_a-height/8);
    line(0, diagonal_glitchlines_b-height/8, width, diagonal_glitchlines_b-height/8); 
    line(0, diagonal_glitchlines_c-height/8, width, diagonal_glitchlines_c-height/8); 
  }else if(russianroulette < 0.12f){       
    // On ecrit les autres lignes
    stroke(255,0,0);
    line(0, diagonal_glitchlines_a-height/8, width, diagonal_glitchlines_a+height/8);
    line(0, diagonal_glitchlines_b-height/8, width, diagonal_glitchlines_b+height/8); 
    line(0, diagonal_glitchlines_c-height/8, width, diagonal_glitchlines_c+height/8); 
  }else{       
    stroke(255);
    line(0, diagonal_glitchlines_a, width, diagonal_glitchlines_a);
    line(0, diagonal_glitchlines_b, width, diagonal_glitchlines_b); 
    line(0, diagonal_glitchlines_c, width, diagonal_glitchlines_c); 
  }
  
  // On deplace les lignes pour le prochain passage
  diagonal_glitchlines_a = diagonal_glitchlines_a - diagonal_glitchlines_speed;
  if (diagonal_glitchlines_a < 0) { 
    diagonal_glitchlines_a = height; 
  }
  diagonal_glitchlines_b = diagonal_glitchlines_b - diagonal_glitchlines_speed;
  if (diagonal_glitchlines_b < 0) { 
    diagonal_glitchlines_b = height; 
  }
  diagonal_glitchlines_c = diagonal_glitchlines_c - diagonal_glitchlines_speed;
  if (diagonal_glitchlines_c < 0) { 
    diagonal_glitchlines_c = height; 
  }
}

//////////////////////////////////////////
// Specific actions for the CompressedLines animation
//////////////////////////////////////////

public void draw_compressedlines() {
  background(0);
  line(0, compressedlines_ratio/4, width, compressedlines_ratio/4); 
  line(0, compressedlines_ratio/2, width, compressedlines_ratio/2); 
  line(0, 3*compressedlines_ratio/4, width, 3*compressedlines_ratio/4); 
  line(0, compressedlines_ratio, width, compressedlines_ratio);
  compressedlines_ratio = compressedlines_ratio - 4;
  if (compressedlines_ratio < 0) { 
    compressedlines_ratio = height; 
  }
}

//////////////////////////////////////////
// Specific actions for the PanelFillRight, Center and Left animation
//////////////////////////////////////////

class PanelFillClass{
  
  int squareSize;
  int panelfill_x;
  int panelfill_y;
  int panelfill_speed;
  int type;
  boolean panelfill_kill;

 public PanelFillClass(int x, int y, int type)
 {
  this.panelfill_x = x;
  this.panelfill_y = y;
  this.type = type;          //Available arguments, Left panel : 0, Middle panel : 1, Right panel : 2 
  this.panelfill_kill = false;
 }
 
 public void move() {
   if (type == 0 | type == 1) {
     if (this.panelfill_y > 0)
     {this.panelfill_y -= 4;}
     else
     {this.panelfill_x += 4;}
   }
   
   if (type == 2) {
     if (this.panelfill_y > 0)
     {this.panelfill_y -= 4;}
     else
     {this.panelfill_x -= 4;}
   }
 }
 
 public void display() {
   fill(255);
   if (type == 1)
   {
     //rect(width/(2*NUMBER_OF_PANELS) + this.panelfill_x, this.panelfill_y, width/(2*NUMBER_OF_PANELS), height);
     //rect(width/(2*NUMBER_OF_PANELS) + width/2 - this.panelfill_x, this.panelfill_y, width/(2*NUMBER_OF_PANELS), height);
     rect(width/(2*NUMBER_OF_PANELS) + this.panelfill_x, this.panelfill_y, width/(2*NUMBER_OF_PANELS), height);
     rect(2*((NUMBER_OF_PANELS-1)/2)*width/(NUMBER_OF_PANELS) - this.panelfill_x, this.panelfill_y, width/(2*NUMBER_OF_PANELS), height);
   }

   if (type == 0 | type == 2)
   {
     rect(this.panelfill_x, this.panelfill_y, width/NUMBER_OF_PANELS, height);
   }
   move();
   
  if (type == 0 | type == 1) {
     if (this.panelfill_x > width*2) {
       this.panelfill_kill = true;
     }
  }
  else if (type == 2) {
     if (this.panelfill_x < -width) {
       this.panelfill_kill = true;
     }
  }
 }
}

public void draw_panelfillleft() {
  background(0);
  fill(255);
  noStroke();
  for (PanelFillClass panel: panelFillList) {
    panel.display();
  }

  for (PanelFillClass panel: panelFillList) {
    if (panel.panelfill_kill) {
      panelFillList.remove(panel);
      break;
    }
  }
  if (panelfill_draw == true) {
//    if (NUMBER_OF_PANELS == 3) {
//      panelFillList.add(new PanelFillClass(0*(width/NUMBER_OF_PANELS), height, 0));
//    }
//    else {
//      panelFillList.add(new PanelFillClass(1*(width/NUMBER_OF_PANELS), height, 0));
//    }
  }
  panelfill_draw = false;
  }
  
public void draw_panelfillcenter() {
  background(0);
  fill(255);
  noStroke();
  for (PanelFillClass panel: panelFillList) {
    panel.display();
  }

  for (PanelFillClass panel: panelFillList) {
    if (panel.panelfill_kill) {
      panelFillList.remove(panel);
      break;
    }
  }
  
  if (panelfill_draw == true) {
//    if (NUMBER_OF_PANELS == 3) {
//      panelFillList.add(new PanelFillClass(1*(width/NUMBER_OF_PANELS), height, 1));
//    }
//    else {
//      panelFillList.add(new PanelFillClass(2*(width/NUMBER_OF_PANELS), height, 1));
//    }
  }
  panelfill_draw = false;
}
  
public void draw_panelfillright() {
  background(0);
  fill(255);
  noStroke();
  for (PanelFillClass panel: panelFillList) {
    panel.display();
  }

  for (PanelFillClass panel: panelFillList) {
    if (panel.panelfill_kill) {
      panelFillList.remove(panel);
      break;
    }
  }
  
  if (panelfill_draw == true) {
//    if (NUMBER_OF_PANELS == 3) {
//      panelFillList.add(new PanelFillClass(2*(width/NUMBER_OF_PANELS), height, 2));
//    }
//    else {
//      panelFillList.add(new PanelFillClass(3*(width/NUMBER_OF_PANELS), height, 2));
//    }
  }
  panelfill_draw = false;
  }
  
  
//////////////////////////////////////////
// Specific actions for the MixedLines animation
//////////////////////////////////////////

public void init_mixedlines(int position_horizontal_lines, int position_vertical_lines, int position_circle)
{
  mixedlines_ellipsewidth = 20;
  mixedlines_speed = 2;
  mixedlines_strokeWeight = 8;
  strokeWeight(mixedlines_strokeWeight);
  strokeCap(SQUARE);  
  
  mixedlines_horizontal1 = 0;
  mixedlines_horizontal2 = height/3;
  mixedlines_horizontal3 = 2*height/3;
  
  if (position_vertical_lines == 1 || position_vertical_lines == 2 || position_vertical_lines == 3) {  
    mixedlines_vertical1 = -mixedlines_strokeWeight/2; 
    mixedlines_vertical2 = width/(NUMBER_OF_PANELS*2);
    mixedlines_vertical3 = width/NUMBER_OF_PANELS + mixedlines_strokeWeight/2;
  }

  if (position_circle == 1) {
  mixedlines_circlex = width/(NUMBER_OF_PANELS*2);    
  }
  else if (position_circle == 2) {
  mixedlines_circlex = width/2;    
  }
  else if (position_circle == 3) {
  mixedlines_circlex = (2*(NUMBER_OF_PANELS-1)+1)*width/(NUMBER_OF_PANELS*2);    
  }  
}

public void draw_mixedlines(int position_horizontal_lines, int position_vertical_lines, int position_circle)
{
  //  Position : possible values are
  //  -> 0 : Do not show
  //  -> 1 : left panel
  //  -> 2 : middle panel
  //  -> 3 : right panel
 
  background(0);
  
  //Draw horizontal lines
  if (position_horizontal_lines == 1) {
    line(0, mixedlines_horizontal1, width/NUMBER_OF_PANELS, mixedlines_horizontal1);
    line(0, mixedlines_horizontal2, width/NUMBER_OF_PANELS, mixedlines_horizontal2); 
    line(0, mixedlines_horizontal3, width/NUMBER_OF_PANELS, mixedlines_horizontal3); 
  }
  else if (position_horizontal_lines == 2) {
    line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, mixedlines_horizontal1, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS, mixedlines_horizontal1);
    line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, mixedlines_horizontal2, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS, mixedlines_horizontal2); 
    line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, mixedlines_horizontal3, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS, mixedlines_horizontal3); 
  }
  else if (position_horizontal_lines == 3) {
    line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, mixedlines_horizontal1, width, mixedlines_horizontal1);
    line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, mixedlines_horizontal2, width, mixedlines_horizontal2); 
    line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, mixedlines_horizontal3, width, mixedlines_horizontal3); 
  }  

  //Draw vertical lines  
  if (position_vertical_lines != 0) {
    
    PGraphics lineImage = createGraphics(width/NUMBER_OF_PANELS,height);
    lineImage.beginDraw();
    lineImage.fill(0);
    lineImage.noStroke();
    lineImage.rect(0,0,width/NUMBER_OF_PANELS,height);
    lineImage.stroke(255);
    lineImage.strokeWeight(mixedlines_strokeWeight);
    lineImage.line(mixedlines_vertical1, 0, mixedlines_vertical1, height);
    lineImage.line(mixedlines_vertical2, 0, mixedlines_vertical2, height);
    lineImage.line(mixedlines_vertical3, 0, mixedlines_vertical3, height);
    lineImage.endDraw();
    
    if (position_vertical_lines == 1) {
      image(lineImage,0,0);
    }
    else if (position_vertical_lines == 2) {
      if (NUMBER_OF_PANELS == 5) {
        image(lineImage,2*width/NUMBER_OF_PANELS,0);
      }
      else {
        image(lineImage,width/NUMBER_OF_PANELS,0);
      }
    }
    else if (position_vertical_lines == 3) {
      image(lineImage,(NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);
    }

  } 

  fill(255);
  //Draw the circle
  if (position_circle == 1) {
    ellipse(width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
  }
  if (position_circle == 2) {
    ellipse(width/2, height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
  }
  if (position_circle == 3) {
    ellipse((2*(NUMBER_OF_PANELS-1)+1)*width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
  }
  if (position_circle == 4) {
    ellipse(width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
    ellipse((2*(NUMBER_OF_PANELS-1)+1)*width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
  }
  if (position_circle == 5) {
    ellipse(width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
    ellipse(width/2, height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
  }
  if (position_circle == 6) {
    ellipse(width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
    ellipse(width/2, height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);
    ellipse((2*(NUMBER_OF_PANELS-1)+1)*width/(NUMBER_OF_PANELS*2), height/2, sin(millis()*0.1f)*mixedlines_ellipsewidth, sin(millis()*0.1f)*mixedlines_ellipsewidth);  
}

  
  // Update line coordinates for the next frame
  mixedlines_horizontal1 = mixedlines_horizontal1 - mixedlines_speed;
  if (mixedlines_horizontal1 < 0) { 
    mixedlines_horizontal1 = height; 
  }
  mixedlines_horizontal2 = mixedlines_horizontal2 - mixedlines_speed;
  if (mixedlines_horizontal2 < 0) { 
    mixedlines_horizontal2 = height; 
  }
  mixedlines_horizontal3 = mixedlines_horizontal3 - mixedlines_speed;
  if (mixedlines_horizontal3 < 0) { 
    mixedlines_horizontal3 = height; 
  }

  if (position_vertical_lines == 1 || position_vertical_lines == 2 || position_vertical_lines == 3) {
    mixedlines_vertical1 += mixedlines_speed/2;
    if (mixedlines_vertical1 >= width/(NUMBER_OF_PANELS) + mixedlines_strokeWeight/2) { 
      mixedlines_vertical1 -= width/NUMBER_OF_PANELS + mixedlines_strokeWeight;
    }  
    mixedlines_vertical2 += mixedlines_speed/2;
    if (mixedlines_vertical2 >= width/(NUMBER_OF_PANELS) + mixedlines_strokeWeight/2) { 
      mixedlines_vertical2 -= width/NUMBER_OF_PANELS + mixedlines_strokeWeight;
    }
    mixedlines_vertical3 += mixedlines_speed/2;
    if (mixedlines_vertical3 >= width/(NUMBER_OF_PANELS) + mixedlines_strokeWeight/2) { 
      mixedlines_vertical3 -= width/NUMBER_OF_PANELS + mixedlines_strokeWeight;
    }
  }

}

//////////////////////////////////////////
// Specific actions for the StroboX animation
//////////////////////////////////////////

public void draw_stroboX() {
  if (frameCount % 2 == 0)
  {
    line(0,0,width,height);
    line(0,height,width,0);
  }
  else
  {
    fill(0);
    rect(0,0,width,height);
  }
}

//////////////////////////////////////////
// Specific actions for the DoubleGradient animation
//////////////////////////////////////////

public void draw_doublegradient() {
  doublegradient_a++;
  if(doublegradient_a > width) {
    doublegradient_a = 0;
    doublegradient_direction = !doublegradient_direction;
  }
  if(doublegradient_direction == true){
    stroke(255*doublegradient_a/width);
  } else {
    stroke(255*(width-doublegradient_a)/width);
  }
  line(doublegradient_a, 0, doublegradient_a, height/2);

  doublegradient_b--;
  if(doublegradient_b < 0) {
    doublegradient_b = width;
  }
  if(doublegradient_direction == true) {
    stroke(255*(width-doublegradient_b)/width);
  } else {
    stroke(255*doublegradient_b/width);
  }
  line(doublegradient_b, height/2+1, doublegradient_b, height);
}


//////////////////////////////////////////
// Specific actions for the CarreMarshall animation
//////////////////////////////////////////

public void draw_carremarshall() {
  background(0);
  carreMarshall_compteur ++;
  
  for (int i = 0; i<NUMBER_OF_PANELS; i++) {
    dessinerCarre(carreMarshall_a, i*carreMarshall_largeurCarre, 0);
    dessinerCarre(carreMarshall_a, i*carreMarshall_largeurCarre, carreMarshall_largeurCarre);
  }
  
  carreMarshall_a = carreMarshall_a + carreMarshall_vitesseLigne;

}

public void dessinerCarre(float carreMarshall_a, float carreMarshall_x, float carreMarshall_y){
  if(0 + carreMarshall_interligne <= carreMarshall_a && carreMarshall_a <= carreMarshall_largeurCarre - 2*carreMarshall_interligne){    
    line(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_a+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne);
  }
  else if(carreMarshall_largeurCarre - 2*carreMarshall_interligne <= carreMarshall_a && carreMarshall_a <= 2*(carreMarshall_largeurCarre-2*carreMarshall_interligne)){
    line(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_a-(carreMarshall_largeurCarre-2*carreMarshall_interligne) + carreMarshall_interligne + carreMarshall_y);
  }  
  else if(2*(carreMarshall_largeurCarre - 2*carreMarshall_interligne) <= carreMarshall_a && carreMarshall_a <= 3*(carreMarshall_largeurCarre-2*carreMarshall_interligne)){
    line(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne, carreMarshall_largeurCarre-(carreMarshall_a-2*(carreMarshall_largeurCarre - 2*carreMarshall_interligne))+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
  }
  else if(3*(carreMarshall_largeurCarre - 2*carreMarshall_interligne) <= carreMarshall_a && carreMarshall_a <= 4*(carreMarshall_largeurCarre-2*carreMarshall_interligne)){
    line(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne, 0+carreMarshall_x+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
    line(0+carreMarshall_x+carreMarshall_interligne, carreMarshall_largeurCarre-(carreMarshall_a-3*(carreMarshall_largeurCarre - 2*carreMarshall_interligne))+carreMarshall_y-carreMarshall_interligne, 0+carreMarshall_x+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
  }
  else if(4*(carreMarshall_largeurCarre - 2*carreMarshall_interligne) <= carreMarshall_a && carreMarshall_a <= 5*(carreMarshall_largeurCarre-2*carreMarshall_interligne)){
    line(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
    line(carreMarshall_largeurCarre+carreMarshall_x-carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne, 0+carreMarshall_x+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne);
    line(0+carreMarshall_x+carreMarshall_interligne, carreMarshall_largeurCarre+carreMarshall_y-carreMarshall_interligne, 0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne);
    
    rect(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre-2*carreMarshall_interligne, carreMarshall_a-4*(carreMarshall_largeurCarre - 2*carreMarshall_interligne));
  }
  else if(5*(carreMarshall_largeurCarre-2*carreMarshall_interligne) <= carreMarshall_a){
    rect(0+carreMarshall_x+carreMarshall_interligne, 0+carreMarshall_y+carreMarshall_interligne, carreMarshall_largeurCarre-2*carreMarshall_interligne, carreMarshall_largeurCarre-2*carreMarshall_interligne);
  }
}


//////////////////////////////////////////
// Specific actions for the Fusee animations
//////////////////////////////////////////

public void fusee_init(int direction)
{
  frameRate(60);
  fusee_a = 0;
  // initialisation des parametres
  fusee_epaisseurLigne = 4;
  strokeWeight(fusee_epaisseurLigne);
  //stroke(255);
  //fill(255);
  colorMode(RGB);
  strokeCap(SQUARE);
  
  if (direction == 0) {
    fusee_vitesseLigne = 6;
    fusee_tab1 = new int[width/4];
    fusee_tab2 = new int[width/4];
    for(int j=0; j<width/4; j++){
      fusee_tab1[j] = height+PApplet.parseInt(height-random(20,height));
      fusee_tab2[j] = height+PApplet.parseInt(height+random(0,height));
    }
  }
  else if (direction == 1) {
    fusee_vitesseLigne = 6;
    fusee_tab1 = new int[width/4];
    fusee_tab2 = new int[width/4];
    for(int j=0; j<width/4; j++){
      fusee_tab1[j] = PApplet.parseInt(-height+random(20,height));
      fusee_tab2[j] = PApplet.parseInt(-height-random(0,height));
    }
  }
  else if (direction == 2) {
    fusee_vitesseLigne = 8*(NUMBER_OF_PANELS/3);
    fusee_tab1 = new int[height/4];
    fusee_tab2 = new int[height/4];
    for(int j=0; j<height/4; j++){
      fusee_tab1[j] = PApplet.parseInt(-height+random(20,height));
      fusee_tab2[j] = PApplet.parseInt(-height-random(0,height));
    }
  }
  else if (direction == 3) {
    fusee_vitesseLigne = 8*(NUMBER_OF_PANELS/3);
    fusee_tab1 = new int[height/4];
    fusee_tab2 = new int[height/4];
    for(int j=0; j<height/4; j++){
      fusee_tab1[j] = PApplet.parseInt(height-random(20,width));
      fusee_tab2[j] = PApplet.parseInt(height+random(0,width));
    }
  }
  else if (direction == 4) {
    fusee_vitesseLigne = 8*(NUMBER_OF_PANELS/3);
    fusee_tab1 = new int[height/4];
    for(int j=0; j<height/4; j++){
      fusee_tab1[j] = PApplet.parseInt(random(0,width));
    }
  }
  else if (direction == 5) {
    fusee_vitesseLigne = 6;
    fusee_tab1 = new int[width/4];
    for(int j=0; j<width/4; j++){
      fusee_tab1[j] = PApplet.parseInt(random(0,height));
    }
  }
}

public void draw_fusee_up() {
  stroke(255);
  for(int i=0; i<width/4; i++){
    line(i*4+2, fusee_tab2[i] - fusee_a, i*4+2, fusee_tab1[i] - fusee_a);
    }
  stroke(0);
  for(int i=0; i<width/4; i++){
    line(i*4+2, height+fusee_tab1[i] - fusee_a, i*4+2, 2*height);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_down() {
  stroke(255);
  for(int i=0; i<width/4; i++){
    line(i*4+2, fusee_tab2[i] + fusee_a, i*4+2, fusee_tab1[i] + fusee_a);
    }
  stroke(0);
  for(int i=0; i<width/4; i++){
    line(i*4+2, -height , i*4+2, -height +fusee_tab1[i] + fusee_a);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_left() {
  stroke(255);
  for(int i=0; i<height/4; i++){
    line(fusee_tab2[i] + fusee_a, i*4+2, fusee_tab1[i] + fusee_a, i*4+2);

    }
  stroke(0);
for(int i=0; i<height/4; i++){
    line(-width, i*4+2, -width +fusee_tab1[i] + fusee_a, i*4+2);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_right() {
  stroke(255);
  for(int i=0; i<height/4; i++){
    line(width + fusee_tab2[i] - fusee_a, i*4+2, width + fusee_tab1[i] - fusee_a, i*4+2);
    }
  stroke(0);
  for(int i=0; i<height/4; i++){
    line(2*width+fusee_tab1[i] - fusee_a, i*4+2, 2*width, i*4+2);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_centerhorizontal(){
  background(0);
  stroke(255);
  fill(255);
  for(int i=0; i<height/4; i++){
      line(fusee_tab1[i] + fusee_a, i*4+2, width, i*4+2);
      line(fusee_tab1[i] - fusee_a, i*4+2, 0, i*4+2);  
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_centervertical(){
  background(0);
  stroke(255);
  fill(255);
  for(int i=0; i<width/4; i++){
      line(i*4+2, height, i*4+2, fusee_tab1[i] + fusee_a);
      line(i*4+2, 0, i*4+2, fusee_tab1[i] - fusee_a); 
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}


public void draw_fusee_up_red() {
  stroke(255,0,0);
  for(int i=0; i<width/4; i++){
    line(i*4+2, fusee_tab2[i] - fusee_a, i*4+2, fusee_tab1[i] - fusee_a);
    }
  stroke(0);
  for(int i=0; i<width/4; i++){
    line(i*4+2, height+fusee_tab1[i] - fusee_a, i*4+2, 2*height);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_down_red() {
  stroke(255,0,0);
  for(int i=0; i<width/4; i++){
    line(i*4+2, fusee_tab2[i] + fusee_a, i*4+2, fusee_tab1[i] + fusee_a);
    }
  stroke(0);
  for(int i=0; i<width/4; i++){
    line(i*4+2, -height , i*4+2, -height +fusee_tab1[i] + fusee_a);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_left_red() {
  stroke(255,0,0);
  for(int i=0; i<height/4; i++){
    line(fusee_tab2[i] + fusee_a, i*4+2, fusee_tab1[i] + fusee_a, i*4+2);

    }
  stroke(0);
for(int i=0; i<height/4; i++){
    line(-width, i*4+2, -width +fusee_tab1[i] + fusee_a, i*4+2);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_right_red() {
  stroke(255,0,0);
  for(int i=0; i<height/4; i++){
    line(width + fusee_tab2[i] - fusee_a, i*4+2, width + fusee_tab1[i] - fusee_a, i*4+2);
    }
  stroke(0);
  for(int i=0; i<height/4; i++){
    line(2*width+fusee_tab1[i] - fusee_a, i*4+2, 2*width, i*4+2);
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_centerhorizontal_red(){
  background(0);
  stroke(255,0,0);
  fill(255);
  for(int i=0; i<height/4; i++){
      line(fusee_tab1[i] + fusee_a, i*4+2, width, i*4+2);
      line(fusee_tab1[i] - fusee_a, i*4+2, 0, i*4+2);  
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}

public void draw_fusee_centervertical_red(){
  background(0);
  stroke(255,0,0);
  fill(255);
  for(int i=0; i<width/4; i++){
      line(i*4+2, height, i*4+2, fusee_tab1[i] + fusee_a);
      line(i*4+2, 0, i*4+2, fusee_tab1[i] - fusee_a); 
  }
  fusee_a = fusee_a + fusee_vitesseLigne;
}


//////////////////////////////////////////
// Specific actions for the Spots animation
//////////////////////////////////////////


public void draw_spots() {
  if ((frameCount % PApplet.parseInt(random(3,4)) == 0))
  {
    background(0);
    int nombreSpotDroite = (int)random(0, 5);
    int nombreSpotGauche = (int)random(0, 2);
    for(int i=0;i<nombreSpotDroite;i++){
      float x1 = random(width/3, width);
      float x2 = random(-width/4, width);
      line(x1, 0, x2, height);
      line(x1, 0, x2+spots_tailleCone, height);
      line(x1, 0, x2-spots_tailleCone, height);
    }
    for(int i=0;i<nombreSpotGauche;i++){
      float x3 = random(-width/3, 0);
      float x4 = random(0, 2*width/3);    
      line(x3, 0, x4, height);
      line(x3, 0, x4+spots_tailleCone, height);
      line(x3, 0, x4-spots_tailleCone, height);
    }  
  }
  }

//////////////////////////////////////////
// Specific actions for the MarshallStrobo animation
//////////////////////////////////////////

public void draw_marshallstrobo() {
  // On ecrit les lignes
  background(0);
  carreMarshall_compteur ++;
  
  if (NUMBER_OF_PANELS == 3) {
    int random16 = (int)random(1,7);
    
    if(random16 == 1){
      dessinerCarre(0,0);
    }
    if(random16 == 2){
      dessinerCarre(0,carreMarshall_largeurCarre);
    }
    if(random16 == 3){
      dessinerCarre(carreMarshall_largeurCarre,0);
    }
    if(random16 == 4){
      dessinerCarre(carreMarshall_largeurCarre,carreMarshall_largeurCarre);
    }
    if(random16 == 5){
      dessinerCarre(2*carreMarshall_largeurCarre,0);
    }  
    if(random16 == 6){
      dessinerCarre(2*carreMarshall_largeurCarre,carreMarshall_largeurCarre);
    }
  }
  else if (NUMBER_OF_PANELS == 5) {
    
    int random16 = (int)random(1,6);
    
    if(random16 == 1){
      dessinerCarre(0,0);
    }
    if(random16 == 2){
      dessinerCarre(0,carreMarshall_largeurCarre);
    }
    if(random16 == 3){
      dessinerCarre(carreMarshall_largeurCarre,0);
    }
    if(random16 == 4){
      dessinerCarre(carreMarshall_largeurCarre,carreMarshall_largeurCarre);
    }
    if(random16 == 5){
      dessinerCarre(2*carreMarshall_largeurCarre,0);
    }  

    random16 = (int)random(1,6);
    
    if(random16 == 1){
      dessinerCarre(2*carreMarshall_largeurCarre,carreMarshall_largeurCarre);
    }
    if(random16 == 2){
      dessinerCarre(3*carreMarshall_largeurCarre,0);
    }
    if(random16 == 3){
      dessinerCarre(3*carreMarshall_largeurCarre,carreMarshall_largeurCarre);
    }
    if(random16 == 4){
      dessinerCarre(4*carreMarshall_largeurCarre,0);
    }
    if(random16 == 5){
      dessinerCarre(4*carreMarshall_largeurCarre,carreMarshall_largeurCarre);
    }
  
  }


  // On deplace les lignes pour le prochain passage
  carreMarshall_a = carreMarshall_a + carreMarshall_vitesseLigne;

}

public void dessinerCarre(float x, float y){
  
    rect(0+x+carreMarshall_interligne, 0+y+carreMarshall_interligne, carreMarshall_largeurCarre-2*carreMarshall_interligne, carreMarshall_largeurCarre-2*carreMarshall_interligne);
}
 
//////////////////////////////////////////
// Specific actions for the LineStrobo animation
//////////////////////////////////////////

public void draw_stroboline() {
  fill(255);

  if (frameCount % PApplet.parseInt(random(3,5)) == 0)
{
  background(0);  
  int nombreRectangle = (int)random(0, 10);
  for(int i=0;i<nombreRectangle;i++){
    rect(random(0,width), 0, random(1, width/10), height);
    }
  }
}

//////////////////////////////////////////
// Specific actions for the UpwardsGlitchMixedLines animation
//////////////////////////////////////////

public void draw_upwardsglitchmixedlines() {
  background(0);

  int startPointMidLeft = ((NUMBER_OF_PANELS - 1)/2) * width/NUMBER_OF_PANELS;
  int startPointMidRight = ((NUMBER_OF_PANELS - 1)/2 + 1) * width/NUMBER_OF_PANELS;
    
  // Center panel
  line(startPointMidLeft, upwards_glitch_mixedlines_b, startPointMidRight, upwards_glitch_mixedlines_b); 
  line(startPointMidLeft, upwards_glitch_mixedlines_c, startPointMidRight, upwards_glitch_mixedlines_c); 
  line(startPointMidLeft, upwards_glitch_mixedlines_d, startPointMidRight, upwards_glitch_mixedlines_d); 
  line(startPointMidLeft, upwards_glitch_mixedlines_e, startPointMidRight, upwards_glitch_mixedlines_e); 
  line(startPointMidLeft, upwards_glitch_mixedlines_f, startPointMidRight, upwards_glitch_mixedlines_f); 
  line(startPointMidLeft, upwards_glitch_mixedlines_g, startPointMidRight, upwards_glitch_mixedlines_g);   
    
  // Side panels - left
  line(0, upwards_glitch_mixedlines_ac, startPointMidLeft, upwards_glitch_mixedlines_ac); 
  line(0, 2*upwards_glitch_mixedlines_ac, startPointMidLeft, 2*upwards_glitch_mixedlines_ac); 
  line(0, 3*upwards_glitch_mixedlines_ac, startPointMidLeft, 3*upwards_glitch_mixedlines_ac); 
  line(0, 4*upwards_glitch_mixedlines_ac, startPointMidLeft, 4*upwards_glitch_mixedlines_ac);
  
  // Side panels - right
  line(startPointMidRight, upwards_glitch_mixedlines_ac, width, upwards_glitch_mixedlines_ac); 
  line(startPointMidRight, 2*upwards_glitch_mixedlines_ac, width, 2*upwards_glitch_mixedlines_ac); 
  line(startPointMidRight, 3*upwards_glitch_mixedlines_ac, width, 3*upwards_glitch_mixedlines_ac); 
  line(startPointMidRight, 4*upwards_glitch_mixedlines_ac, width, 4*upwards_glitch_mixedlines_ac);
    
  // Update position
  upwards_glitch_mixedlines_b = upwards_glitch_mixedlines_b - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_b < height/4) { 
    upwards_glitch_mixedlines_b = height; 
  }
  upwards_glitch_mixedlines_c = upwards_glitch_mixedlines_c - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_c < height/4) { 
    upwards_glitch_mixedlines_c = height; 
  }
  upwards_glitch_mixedlines_d = upwards_glitch_mixedlines_d - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_d < height/4) { 
    upwards_glitch_mixedlines_d = height; 
  }  
  upwards_glitch_mixedlines_e = upwards_glitch_mixedlines_e - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_e < height/4) { 
    upwards_glitch_mixedlines_e = height; 
  }
  upwards_glitch_mixedlines_f = upwards_glitch_mixedlines_f - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_f < height/4) { 
    upwards_glitch_mixedlines_f = height; 
  }
  upwards_glitch_mixedlines_g = upwards_glitch_mixedlines_g - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_g < height/4) { 
    upwards_glitch_mixedlines_g = height; 
  }  
  upwards_glitch_mixedlines_ac = upwards_glitch_mixedlines_ac - upwards_glitch_mixedlines_speed*2;
  if (upwards_glitch_mixedlines_ac < 0) { 
    upwards_glitch_mixedlines_ac = height; 
  }
}


public void draw_upwardsglitchmixedlines2() {
  background(0);

  int startPointMidLeft = ((NUMBER_OF_PANELS - 1)/2) * width/NUMBER_OF_PANELS;
  int startPointMidRight = ((NUMBER_OF_PANELS - 1)/2 + 1) * width/NUMBER_OF_PANELS;
  
  // Center panel
  line(startPointMidLeft, upwards_glitch_mixedlines_b, startPointMidRight, upwards_glitch_mixedlines_b); 
  line(startPointMidLeft, upwards_glitch_mixedlines_c, startPointMidRight, upwards_glitch_mixedlines_c); 
  line(startPointMidLeft, upwards_glitch_mixedlines_d, startPointMidRight, upwards_glitch_mixedlines_d); 
  line(startPointMidLeft, upwards_glitch_mixedlines_e, startPointMidRight, upwards_glitch_mixedlines_e); 
  line(startPointMidLeft, upwards_glitch_mixedlines_f, startPointMidRight, upwards_glitch_mixedlines_f); 
  line(startPointMidLeft, upwards_glitch_mixedlines_g, startPointMidRight, upwards_glitch_mixedlines_g); 
    
  // Side panels - left
  line(0, upwards_glitch_mixedlines_ac, startPointMidLeft, upwards_glitch_mixedlines_ac);
  line(0, upwards_glitch_mixedlines_bc, startPointMidLeft, upwards_glitch_mixedlines_bc); 
  line(0, upwards_glitch_mixedlines_cc, startPointMidLeft, upwards_glitch_mixedlines_cc); 
  line(0, upwards_glitch_mixedlines_dc, startPointMidLeft, upwards_glitch_mixedlines_dc); 
  
  // Side panels - right
  line(startPointMidRight, upwards_glitch_mixedlines_ac, width, upwards_glitch_mixedlines_ac);
  line(startPointMidRight, upwards_glitch_mixedlines_bc, width, upwards_glitch_mixedlines_bc); 
  line(startPointMidRight, upwards_glitch_mixedlines_cc, width, upwards_glitch_mixedlines_cc); 
  line(startPointMidRight, upwards_glitch_mixedlines_dc, width, upwards_glitch_mixedlines_dc); 
    
  // Update position
  upwards_glitch_mixedlines_b = upwards_glitch_mixedlines_b - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_b < height/4) { 
    upwards_glitch_mixedlines_b = height; 
  }
  upwards_glitch_mixedlines_c = upwards_glitch_mixedlines_c - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_c < height/4) { 
    upwards_glitch_mixedlines_c = height; 
  }
  upwards_glitch_mixedlines_d = upwards_glitch_mixedlines_d - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_d < height/4) { 
    upwards_glitch_mixedlines_d = height; 
  }  
  upwards_glitch_mixedlines_e = upwards_glitch_mixedlines_e - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_e < height/4) { 
    upwards_glitch_mixedlines_e = height; 
  }
  upwards_glitch_mixedlines_f = upwards_glitch_mixedlines_f - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_f < height/4) { 
    upwards_glitch_mixedlines_f = height; 
  }
  upwards_glitch_mixedlines_g = upwards_glitch_mixedlines_g - upwards_glitch_mixedlines_speed;
  if (upwards_glitch_mixedlines_g < height/4) { 
    upwards_glitch_mixedlines_g = height; 
  }    

  upwards_glitch_mixedlines_ac = upwards_glitch_mixedlines_ac - upwards_glitch_mixedlines_speed*2;
  if (upwards_glitch_mixedlines_ac < 0) { 
    upwards_glitch_mixedlines_ac = height; 
  }
  upwards_glitch_mixedlines_bc = upwards_glitch_mixedlines_bc - upwards_glitch_mixedlines_speed*2;
  if (upwards_glitch_mixedlines_bc < 0) { 
    upwards_glitch_mixedlines_bc = height; 
  }
  upwards_glitch_mixedlines_cc = upwards_glitch_mixedlines_cc - upwards_glitch_mixedlines_speed*2;
  if (upwards_glitch_mixedlines_cc < 0) { 
    upwards_glitch_mixedlines_cc = height; 
  }
  upwards_glitch_mixedlines_dc = upwards_glitch_mixedlines_dc - upwards_glitch_mixedlines_speed*2;
  if (upwards_glitch_mixedlines_dc < 0) { 
    upwards_glitch_mixedlines_dc = height; 
  }    
}


//////////////////////////////////////////
// Specific actions for the Tetris  game
//////////////////////////////////////////


public void setup_tetris() {
  score = 0;
  lines = 0;
  level = 1;
  shapes[0] = new Shape(4, new int[] {8,9,10,11}, CYAN);  // I
  shapes[1] = new Shape(3, new int[] {0,3,4,5}, BLUE);  // J
  shapes[2] = new Shape(3, new int[] {2,3,4,5}, ORANGE);  // L
  shapes[3] = new Shape(2, new int[] {0,1,2,3}, YELLOW);  // O
  shapes[4] = new Shape(4, new int[] {5,6,8,9}, GREEN);  // S
  shapes[5] = new Shape(3, new int[] {1,3,4,5,}, PURPLE);  // T
  shapes[6] = new Shape(4, new int[] {4,5,9,10}, RED);  // Z  
  next = shapes[(int)random(7)];
  init = true;
  board.clear();
  loadNext();
}
 
public void draw_tetris() {
  if (init) 
  {
    background(0);
    if (game_over) {
      text("G A M E", width/2, height/3 - 4);
      text("O V E R", width/2, 2*height/3 + 4);
      
      if (command_p1_left | command_p1_right | command_p2_left | command_p2_right)
      {
        game_over = false;
        show_score = true;
      }
      return;
    }
    else if (show_score) {
      text("SCORE", width/2, height/3 - 4);
      text(lines, width/2, 2*height/3 + 4);
      if (command_p1_left | command_p1_right | command_p2_left | command_p2_right)
      {
        setup_tetris();
        show_score = false;
      }
      return;    
    }
    currTime++;
    if (currTime >= timer && board.animateCount == -1)
      curr.stepDown();
        
    board.draw();
    if (curr != null)
      curr.draw();
    fill(255);
  }
}
 
public void loadNext() {
  curr = new Tetromino(next);
  next = shapes[(int)random(7)];
  currTime = 0;
}

public void play(int value) {
  board.clear();
  loadNext();
}


 
class Shape {
  boolean[][] matrix;
  int c;
   
  Shape(int n, int[] blockNums, int c) {
    matrix = new boolean[n][n];
    for (int x = 0; x < n; ++x)
      for (int y = 0; y < n; ++y)
        matrix[x][y] = false;
    for (int i = 0; i < blockNums.length; ++i)
      matrix[blockNums[i]%n][blockNums[i]/n] = true;
    this.c = c;
  }
   
  Shape(Shape other) {
    matrix = new boolean[other.matrix.length][other.matrix.length];
    for (int x = 0; x < matrix.length; ++x)
      for (int y = 0; y < matrix.length; ++y)
        matrix[x][y] = other.matrix[x][y];
    this.c = other.c;
  }
   
}


class Tetromino {
  Shape shape;
  int x, y;
  int final_row;
   
  Tetromino(Shape shape) {
    this.shape = new Shape(shape);
    x = 3 + (NUMBER_OF_PANELS-3)*3;
    y = -2;
    final_row = getFinalRow();
    game_over = !isLegal(this.shape.matrix, 3, -1);
  }
   
  public int getColor() { return shape.c; }
   
  public void left() {
    if (isLegal(shape.matrix, x - 1, y))
      x--;
    else if (isLegal(shape.matrix, x - 2, y))
      x -= 2;
    update();
  }
   
  public void right() {
    if (isLegal(shape.matrix, x + 1, y))
      x++;
    else if (isLegal(shape.matrix, x + 2, y))
      x += 2;
    update();
  }
   
  public void update() {
    final_row = getFinalRow();
    // reset the timer if player is at the bottom, for wiggle room before it locks
    if (y == final_row)
      currTime = -20;
  }
   
  // used when player presses down.
  public void down() {
    if (y >= final_row) {
      // if already at the bottom, down shortcuts to lock current and load next block
      board.endTurn();
    } else {
      stepDown();
      score += 1;  // get a point for manual down
    }
  }
   
  // used when automatically moving the block down.
  public void stepDown() {
    if (y >= final_row) {
      board.endTurn();
    } else {
      y++;
      currTime = 0;
    }
  }
   
  // move block all the way to the bottom
  public void hardDown() {
    score += (board.rows - y);
    y = final_row;
    board.endTurn();
  }
   
  public void rotate() {
    boolean[][] ret = new boolean[shape.matrix.length][shape.matrix.length];
    for (int x = 0; x < ret.length; ++x)
        for (int y = 0; y < ret.length; ++y)
            ret[x][y] = shape.matrix[y][ret.length - 1 - x];
    if (isLegal(ret, x, y)) {
      shape.matrix = ret;
      update();
    } else if (isLegal(ret, x + 1, y) || isLegal(ret, x + 2, y)) {
      shape.matrix = ret;
      right();
    } else if (isLegal(ret, x - 1, y) || isLegal(ret, x - 2, y)) {
      shape.matrix = ret;
      left();
    }
    command_p2_left=false;
  }
   
  public int getFinalRow() {
    int start = max (0, y);
    for (int row = start; row <= board.rows; ++row)
      if (!isLegal(shape.matrix, x, row))
        return row - 1;
    return -1;
  }
   
  public boolean isLegal(boolean[][] matrix, int col, int row) {
    for (int i = 0; i < matrix.length; ++i)
      for (int j = 0; j < matrix.length; ++j)
        if (matrix[i][j] && board.isOccupied(col + i, row + j))
          return false;
    return true;
  }
   
  public void draw() {
    if (command_p1_left==true)
    {
      curr.left();
    }
    if (command_p1_right==true)
    {
      curr.right();
    }
    if (command_p2_left==true)
    {
      curr.rotate();
    }
    if (command_p2_right==true)
    {
      curr.down();
    }

    for (int i = 0; i < shape.matrix.length; ++i) {
      for (int j = 0; j < shape.matrix.length; ++j) {
        if (shape.matrix[i][j]) {
          board.fillSquare(x + i, y + j, shape.c);
        }
      }
    }
  }
   
}


class Grid {
  int x, y;
  int myWidth, myHeight;
  int rows, cols;
  int[][] colors;
  ArrayList<Integer> clearedRows = new ArrayList<Integer>();
  int animateCount = -1;
   
  Grid(int x, int y, int w, int h, int rows, int cols) {
    this.x = x;
    this.y = y;
    myWidth = w;
    myHeight = h;
    this.rows = rows;
    this.cols = cols;
    colors = new int[cols][rows];
    for (int i = 0; i < cols; ++i)
      for (int j = 0; j < rows; ++j)
        colors[i][j] = 0;
  }
   
  public void clear() {
    for (int i = 0; i < cols; ++i)
      for (int j = 0; j < rows; ++j)
        colors[i][j] = 0;
  }
   
  public void draw() {
    stroke(255);
    strokeWeight(2);
    rect(x, y, myWidth, myHeight);
    for (int i = 0; i < cols; ++i)
      for (int j = 0; j < rows; ++j)
        fillSquare(i, j, colors[i][j]);
    // line clear animation
    if (animateCount >= 0) {
      //calculate a background that smoothly oscillates between black and white
      int c = (animateCount < 255) ? animateCount : 255 - animateCount%255;
      if (clearedRows.size() == 4)
        c = color(0, c, c); // cyan animation for a Tetris
      for (int row : clearedRows)
        for (int i = 0; i < cols; ++i)
          fillSquare(i, row, color(c, 200));
      animateCount += 30;
      if (animateCount > 2*255) {
        // stop animation, clear the lines, and load the next Tetromino
        animateCount = -1;
        eraseCleared();
        loadNext();
      }
    }
  }
   
  public void fillSquare(int col, int row, int c) {
    if (col < 0 || col >= cols || row < 0 || row >= rows)
      return;
    noStroke();
    fill(c);
    rect(x + col*(myWidth/cols), y + row*(myHeight/rows), myWidth/cols, myHeight/rows);
  }
      
  public void endTurn() {
    for (int i = 0; i < curr.shape.matrix.length; ++i)
      for (int j = 0; j < curr.shape.matrix.length; ++j)
        if (curr.shape.matrix[i][j] && j + curr.y >= 0)
          colors[i + curr.x][j + curr.y] = curr.getColor();
    if (checkLines()) {
      curr = null;
      animateCount = 0;
    } else
      loadNext();
  }
   
  public boolean checkLines() {
    clearedRows.clear();
    for (int j = 0; j < rows; ++j) {
      int count = 0;
      for (int i = 0; i < cols; ++i)
        if (isOccupied(i, j))
          count++;
      if (count >= cols)
        clearedRows.add(j);
    }
    if (clearedRows.isEmpty())
      return false;
       
    if (lines/10 < (lines + clearedRows.size())/10) {
      level++;
      timer -= SPEED_DECREASE;
    }
    lines += clearedRows.size();
    score += (1 << clearedRows.size() - 1)*100;
    return true;
  }
   
  public void eraseCleared() {
    for (int row : clearedRows) {
      for (int j = row - 1; j > 0; --j) {
        int[] rowCopy = new int[cols];
        for (int i = 0; i < cols; ++i)
          rowCopy[i] = colors[i][j];
        for (int i = 0; i < cols; ++i)
          colors[i][j + 1] = rowCopy[i];
      }
    }
  }
   
  public boolean isOccupied(int x, int y) {
    if (y < 0 && x < cols && x >= 0) // allow movement/flipping to spaces above the board
      return false;
    return (x >= cols || x < 0 || y >= rows || colors[x][y] != 0);
  }
}


//////////////////////////////////////////
// Specific actions for the Scope animation
//////////////////////////////////////////

public void draw_scope()
{
  background(0);
  scope(width/2, height/2);
}

public void scope(int mX, int mY) {

  scope_arc_b_r += 10;
  if (scope_arc_b_r > width*9/10) {
    scope_arc_b_r = width*9/10;
    scope_flg1 = 1;
  }
  scope_arc_s_r += 10;
  if (scope_arc_s_r > width * 3/5) {
    scope_arc_s_r = width * 3/5;
    scope_flg2 = 1;
  }
 
  scope_rotationcounter+=0.25f;
  if (scope_rotationcounter > TWO_PI) {
    scope_rotationcounter = TWO_PI;
    scope_flg3  = 1;
  }

  if (scope_freqcounter == 100) {
    scope_decrease = true;
    scope_rotationcounter=0;
    scope_flg3  = 0;
  }
  if (scope_freqcounter == 0) {
    scope_decrease = false;
  }  
  if (scope_decrease == true) {
    scope_freqcounter -= 1;
  }
  else {
    scope_freqcounter += 1;
  }

  scope_g = PApplet.parseInt(255*sin(scope_freqcounter*TWO_PI/100));
  scope_b = PApplet.parseInt(255*sin(scope_freqcounter*TWO_PI/100));
  scope_color = color(255, scope_g, scope_b);
  
  pushMatrix();
  translate(mX, mY);
  noFill();
  stroke(scope_color);
  strokeWeight(5);
  pushMatrix();
  translate(0, 0);
  rotate(scope_rotationcounter);
  arc(0, 0, scope_arc_s_r, scope_arc_s_r, radians(-20), radians(20));
  arc(0, 0, scope_arc_s_r, scope_arc_s_r, radians(-20+180), radians(20+180));
  popMatrix();
  strokeWeight(10);
  arc(0, 0, scope_arc_b_r, scope_arc_b_r, radians(-40), radians(40));
  arc(0, 0, scope_arc_b_r, scope_arc_b_r, radians(-40+180), radians(40+180));
  fill(scope_color);
  strokeWeight(4);
  ellipse(0, 0, sin(scope_freqcounter)*scope_ellipsewidth, sin(scope_freqcounter)*scope_ellipsewidth);
  noStroke();
  popMatrix();
}


//////////////////////////////////////////
// Specific actions for the SquareWaveGenerator animation
//////////////////////////////////////////

public void traceBooleanSignal (int [] signal, int ypos, int amplitude, int c1) {
  stroke(c1);
  for (int i = 1; i < width; i++) {
    line(i, ypos+amplitude-signal[i]*amplitude, i, ypos+amplitude-signal[i-1]*amplitude);
  }
}
 
public void updateBooleanSignal (int [] signal) {
  for (int i = 1; i < width; i++) {
    signal[i-1] = signal[i];
  }
}

public void draw_squarewavegenerator()
{
  background(0);
 
  if (squarewave_signalpulse) {
    squarewave_button[width-1] = 1;
  }
  else {
    squarewave_button[width-1] = 0;
  }
  
  if (frameCount > squarewave_signalframecounter + 8)
  {
    squarewave_signalpulse = false;
  }
 
  switch (squarewave_step) {
  case 0:
    if (squarewave_button[width-1] == 1) {
      squarewave_step = 1;
    }
    squarewave_timer[width-1] = 0;
    break;
  case 1:
    if (squarewave_button[width-1] == 0) {
      squarewave_step = 2;
    }
    squarewave_timer[width-1] = 1;
    break;
  case 2:
    if (squarewave_button[width-1] == 1) {
      squarewave_step = 3;
    }
    squarewave_timer[width-1] = 0;
    squarewave_tA++;
    break;
  case 3:
    if (squarewave_button[width-1] == 0) {
      squarewave_step = 4;
    }
    squarewave_timer[width-1] = 1;
    squarewave_tB++;
    break;
  case 4:
    squarewave_timer[width-1] = 0;
    squarewave_tC++;
    if (squarewave_tC>=squarewave_tA) {
      squarewave_tC=0;
      squarewave_step=5;
    }
    break;
  case 5:
    squarewave_timer[width-1] = 1;
    squarewave_tC++;
    if (squarewave_tC>=squarewave_tB) {
      squarewave_tC=0;
      squarewave_step=4;
    }
    break;
  }
  
  updateBooleanSignal(squarewave_button);
  traceBooleanSignal(squarewave_button, height/2-26, 24, color(255, 0, 0));
  updateBooleanSignal(squarewave_timer);
  traceBooleanSignal(squarewave_timer, height-26, 24, color(0, 255, 0));
}


//////////////////////////////////////////
// Specific actions for the PixelLines animation
//////////////////////////////////////////

 public void draw_pixellines(){
   if (NUMBER_OF_PANELS == 5) {
     for (int i = 3*height/2; i>0;i-=4) {
       stroke(pixellines_color1.get((i/4) % 5));
       
       pushMatrix();
       translate(0,0);
       line(0,i,width/NUMBER_OF_PANELS,i-width/NUMBER_OF_PANELS);
       popMatrix();
       
       pushMatrix();
       translate(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS,0);
       line(0,i,width/NUMBER_OF_PANELS,i-width/NUMBER_OF_PANELS);
       popMatrix();
       
       pushMatrix();
       translate((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);
       line(0,i,width/NUMBER_OF_PANELS,i-width/NUMBER_OF_PANELS);
       popMatrix();
       
     }
     
     for (int j = 0; j<3*height/2;j+=4) {
       stroke(pixellines_color2.get((j/4) % 5));
       
       pushMatrix();
       translate(width/NUMBER_OF_PANELS,0);
       line(0,j-width/NUMBER_OF_PANELS,width/NUMBER_OF_PANELS,j);
       popMatrix();
       
       pushMatrix();
       translate((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS,0);
       line(0,j-width/NUMBER_OF_PANELS,width/NUMBER_OF_PANELS,j);
       popMatrix();
     }
   }
   else {
     for (int i = 3*height/2; i>0;i-=4) {
       stroke(pixellines_color1.get((i/4) % 5));
       
       pushMatrix();
       translate(0,0);
       line(0,i,width/NUMBER_OF_PANELS,i-width/NUMBER_OF_PANELS);
       popMatrix();
       
       
       pushMatrix();
       translate((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);
       line(0,i,width/NUMBER_OF_PANELS,i-width/NUMBER_OF_PANELS);
       popMatrix();
       
     }
     
     for (int j = 0; j<3*height/2;j+=4) {
       stroke(pixellines_color2.get((j/4) % 5));
       
       pushMatrix();
       translate(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS,0);
       line(0,j-width/NUMBER_OF_PANELS,width/NUMBER_OF_PANELS,j);
       popMatrix();
       
     }
   }
   
   int colortemp1 = pixellines_color1.get(0);
   pixellines_color1.remove(0);
   pixellines_color1.append(colortemp1);
   int colortemp2[] = {pixellines_color2.get(4),pixellines_color2.get(0),pixellines_color2.get(1),pixellines_color2.get(2),pixellines_color2.get(3)};
   pixellines_color2.clear();
   pixellines_color2.append(colortemp2);
   
 }
 
//////////////////////////////////////////
// Specific actions for the SpiralTriangle animation
//////////////////////////////////////////

public void draw_spiraltriangle()
{
  background(0);
  noStroke();
  //smooth();
  frameRate(50);
  int layers = 4*NUMBER_OF_PANELS;
   
  for(int i=layers; i>0; i--)
  {
    if(i%2 == 0)
      fill(255);
    else
      fill(0);
       
    pushMatrix();
    translate(width/2, height/2);
    rotate(radians(0.3f * frameCount*(layers+1-i)));
     
    float delta = 10;
    polygon(3, 0, 0, i*delta);
     
    popMatrix();
  }
}
 
public void polygon(int sides, float x, float y, float rad)
{
  beginShape();
  PVector orig = new PVector(x, y);
  for(int i=0; i<sides; i++)
  {
    float angle = i*360.0f / sides;
    PVector newPt = new PVector(orig.x + rad*sin(radians(angle)), orig.y + rad*cos(radians(angle)));
    vertex(newPt.x, newPt.y);
  }
  endShape();
}


//////////////////////////////////////////
// Specific actions for the Sonar animation
//////////////////////////////////////////

public void draw_sonar(boolean allwhite){
  float rond = map(millis(), 0, 6000, 0, TWO_PI);
  strokeWeight(2);
  float f = 0.01f;
  for(int i = 38; i>=1; i--){
    if (allwhite) {
      stroke(0,10);
      line(width/2, height/2, (width/2 + cos((rond-f-1)) * 100), (height/2 + sin(2*(rond-f-1)) * 100));  
    }
    else {
      
    }
    stroke(255, 2*i);
    line(width/2, height/2, (width/2 + cos(2*(rond-f)) * 100), (height/2 + sin(2*(rond-f)) * 100));
    
    f += 0.01f;
  }
}

//////////////////////////////////////////
// Specific actions for the Rorschach animation
//////////////////////////////////////////

public void resetParams(int movementmode){
  movementMode = movementmode;
  invertAlpha = false;
  blackBackground = false;
  //randomColor = false;
   
  nBalls = 30;
  nSteps = 6;
  thresh = .1f;
  vMax = 3;
  balls = new float[nBalls][4];
  backgroundColor = color(0);
  //ballColor = color(255);
  radius = 8;
}
 
public void draw_rorschach(){
  moveBalls();

  if(randomColor){
    //int tempcolor[] = colorwheel(frameCount % 255);
    backgroundColor = color(0);
    //ballColor = color(tempcolor[0],tempcolor[1],tempcolor[2]);
    ballColor = color(255,0,0);
  }
  
  background(0);
  for(int i=0; i<nBalls; i++){
    image(ballImage,(width-balls[i][0])-radius,balls[i][1]-radius);
    image(ballImage,balls[i][0]-radius,balls[i][1]-radius);
  }
 
  
  filter(THRESHOLD,thresh);
  
  //apply color changes
  loadPixels();
  for(int i=0; i<pixels.length;i++){
    pixels[i] = pixels[i] << 16; 
  }
  updatePixels();
  if(blackBackground)
    filter(INVERT);
    
}
 
 
 
public void generateBalls(){
  for(int i=0; i<nBalls; i++)
    generateBall(i);
}
 
public void generateBall(int i){
  balls[i][0] = random(radius,width-radius);
  balls[i][1] = random(radius,height-radius);
  balls[i][2] = random(-vMax,vMax);
  balls[i][3] = random(-vMax,vMax);
}


//Input a value 0 to 255 to get a color value.
//The colours are a transition r - g -b - back to r
public int[] colorwheel(int WheelPos) {
  if (WheelPos < 85) {
    int wheelcolor[] = {WheelPos * 3, 255 - WheelPos * 3, 0};
    return wheelcolor;
  } 
  else if (WheelPos < 170) {
    WheelPos -= 85;
    int wheelcolor[] = {255 - WheelPos * 3, 0, WheelPos * 3};
    return wheelcolor;
  } 
  else {
    WheelPos -= 170; 
    int wheelcolor[] = {0, WheelPos * 3, 255 - WheelPos * 3};
    return wheelcolor;
  }
}


public void moveBalls(){
  //bouncing off edges!
  if(movementMode ==0){
    for(int i=0; i<nBalls; i++){
      if(balls[i][0]-radius <= 0 || balls[i][0]+radius >= width)
        balls[i][2] = -balls[i][2];
   
      if(balls[i][1]-radius <= 0 || balls[i][1]+radius >= height)
        balls[i][3] = -balls[i][3];
       
      balls[i][2]+=random(-.1f,.1f);
      balls[i][3]+=random(-.1f,.1f);
      balls[i][2] = constrain(balls[i][2],-vMax,vMax);
      balls[i][3] = constrain(balls[i][3],-vMax,vMax);
       
      balls[i][0] +=balls[i][2];
      balls[i][1] +=balls[i][3];
    }
  }
 
  //a fountain!
  if(movementMode ==1){
    float v = -(height+radius)/50;
    float theta = 0;
    for(int i=0; i<nBalls; i++){
      if(balls[i][0] < -2*radius || balls[i][0] > width+radius ||
         balls[i][1] > height+radius){
        v += random(-2,2);
        theta = random(-.2f,.2f);
        balls[i][0] = width/2;
        balls[i][1] = height-radius;
        balls[i][2] = v*sin(theta);
        balls[i][3] = v*cos(theta);
      }
       
      balls[i][3]-= v/50;
       
      balls[i][0] +=balls[i][2];
      balls[i][1] +=balls[i][3];
    }
  }
      
  //swirl in!
  if(movementMode == 2){
    float rSquared = 0;
    float theta = 0;
    float rSquaredMax = (width/2+radius)*(width/2+radius);
    for(int i=0; i<nBalls; i++){
      rSquared = (balls[i][0]-width/2)*(balls[i][0]-width/2)+
                 (balls[i][1]-height/2)*(balls[i][1]-height/2);
      theta = atan2(balls[i][1]-height/2,balls[i][0]-width/2);
       
      if(rSquared > rSquaredMax || rSquared < 200.0f){
        rSquared = (width/2+radius/2)*(width/2+radius/2);//rSquaredMax*.9;
        theta = random(TWO_PI);
        balls[i][0] = width/2+sqrt(rSquared)*cos(theta);
        balls[i][1] = height/2+sqrt(rSquared)*sin(theta);
        balls[i][2] = 0;
        balls[i][3] = 0;
       }
 
      balls[i][0]-= (4*cos(theta+PI/2)+cos(theta)*(1+rSquared/rSquaredMax));
      balls[i][1]-= (4*sin(theta+PI/2)+sin(theta)*(1+rSquared/rSquaredMax));
    }
  }
   
  //They're all repulsive!
  if(movementMode == 3){
    float rSquared = 0;
    float theta = 0;
    for(int i=0; i<nBalls; i++){
      for(int j=0; j<nBalls; j++)
        if(i!=j){
          rSquared = (balls[i][0]-balls[j][0])*(balls[i][0]-balls[j][0])+
                     (balls[i][1]-balls[j][1])*(balls[i][1]-balls[j][1]);
          theta = atan2(balls[j][1]-balls[i][1],balls[j][0]-balls[i][0]);
     
          balls[i][2]+= -1/rSquared*cos(theta)*2e2f;
          balls[i][3]+= -1/rSquared*sin(theta)*2e2f;
      }
      balls[i][2] += (1/balls[i][0]+1/((balls[i][0]-width )))*nBalls/10;
      balls[i][3] += (1/balls[i][1]+1/((balls[i][1]-height)))*nBalls/10;
       
      balls[i][2] = balls[i][2]*.95f;
      balls[i][3] = balls[i][3]*.95f;
       
      balls[i][0] += balls[i][2];
      balls[i][1] += balls[i][3];
    }
  }
   
  //They're repulsive, attractive!
  if(movementMode == 4){
    float rSquared = 0;
    float theta = 0;
    for(int i=0; i<nBalls; i++){
      for(int j=0; j<nBalls; j++)
        if(i!=j){
          rSquared = (balls[i][0]-balls[j][0])*(balls[i][0]-balls[j][0])+
                     (balls[i][1]-balls[j][1])*(balls[i][1]-balls[j][1]);
          theta = atan2(balls[j][1]-balls[i][1],balls[j][0]-balls[i][0]);
     
          balls[i][2]+= -(3*radius/rSquared-1/sqrt(rSquared))*cos(theta)*20.0f/nBalls;
          balls[i][3]+= -(3*radius/rSquared-1/sqrt(rSquared))*sin(theta)*20.0f/nBalls;
      }
      balls[i][2] += (1/balls[i][0]+1/((balls[i][0]-width )))*nBalls/10;
      balls[i][3] += (1/balls[i][1]+1/((balls[i][1]-height)))*nBalls/10;
       
      balls[i][2] = balls[i][2]*.99f;
      balls[i][3] = balls[i][3]*.99f;
       
      balls[i][0] += balls[i][2];
      balls[i][1] += balls[i][3];
    }
  }
}


   
public void generateCircleImage(){
  ballImage = createImage(radius*2,radius*2,ARGB);
  int thisColor = color(0,0,0,0);
  float rSquared = 0;
  for(int x= 0; x<=radius; x++)
    for(int y= 0; y<=radius; y++){
      rSquared = pow(x-radius,2)+pow(y-radius,2);
      if(rSquared<radius*radius){
          if(invertAlpha)
            thisColor = color(255,0,0,
                        255*(rSquared/(radius*radius)));
          else
            thisColor = color(255,0,0,
                        255*(1-rSquared/(radius*radius)));
        
        ballImage.set(x,y,thisColor);
        ballImage.set(2*radius-x,y,thisColor);
        ballImage.set(2*radius-x,2*radius-y,thisColor);
        ballImage.set(x,2*radius-y,thisColor);
      }
      else
        ballImage.set(x,y,color(255,0,0,0));
    }
}


//////////////////////////////////////////
// Specific actions for the StroboRed animation
//////////////////////////////////////////

public void draw_strobored() {
  if (frameCount % 2 == 0)
  {
    fill(255,0,0);
    rect(0,0,width,height);
  }
  else
  {
    fill(0);
    rect(0,0,width,height);
  }
}

//////////////////////////////////////////
// Specific actions for the Individual Panels animation
//////////////////////////////////////////

public void draw_fillextremelowleft(){
  rect(0*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,height/2);
}

public void draw_fillextremehileft(){
  rect(0*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2);
}

public void draw_filllowleft(){
  rect(((NUMBER_OF_PANELS-1)/2 - 1)*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,height/2);
}

public void draw_fillhileft(){
  rect(((NUMBER_OF_PANELS-1)/2 - 1)*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2);
}

public void draw_filllowmid(){
  rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,height/2);
}

public void draw_fillhimid(){
  rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2);
}

public void draw_filllowright(){
  rect(((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,height/2);
}

public void draw_fillhiright(){
  rect(((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2);
}

public void draw_fillextremelowright(){
  rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,height/2);
}

public void draw_fillextremehiright(){
  rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2);
}

//////////////////////////////////////////
// Specific actions for the White Out and Blackout animation
//////////////////////////////////////////

public void draw_whiteout(){
  noStroke();
  fill(255);
  rect(-width,-height,3*width,3*height);
}

public void draw_blackout(){
  noStroke();
  fill(0);
  rect(-width,-height,3*width,3*height);
}

//////////////////////////////////////////
// Specific actions for the Lines animations
//////////////////////////////////////////

public void draw_lines1() {
  line(0,height/3,width/3,0);
}

public void draw_lines2() {
  line(0,2*height/3,2*width/3,0);
}

public void draw_lines3() {
  line(0,3*height/3,3*width/3,0);
}

public void draw_lines4() {
  line(0,4*height/3,4*width/3,0);
}

public void draw_lines5() {
  line(0,5*height/3,5*width/3,0);
}

public void draw_lines6() {
  line(width-width/3,0,width,height/3);
}

public void draw_lines7() {
  line(width-2*width/3,0,width,2*height/3);
}

public void draw_lines8() {
  line(width-3*width/3,0,width,3*height/3);
}

public void draw_lines9() {
  line(width-4*width/3,0,width,4*height/3);
}

public void draw_lines10() {
  line(width-5*width/3,0,width,5*height/3);
}


//////////////////////////////////////////
// Specific actions for the Upwards Line White Out animation
//////////////////////////////////////////

public void draw_upwards_line_whiteout(){  
  background(255);
  line(0, line_height, width, line_height);
  
  if (line_height < 8) {
   line(0,height + line_height, width, height + line_height); 
  }
  
  line_height = line_height - 1;
  if (line_height < -8) { 
    line_height = height-8; 
  }
}

//////////////////////////////////////////
// Specific actions for the Unfolding Lines animation
//////////////////////////////////////////

public void draw_unfoldinglines() {
  background(0);
  supposed_height += 1;  
  for(float x=height;x>height-supposed_height+5;x=x-supposed_height/10) 
  {line(0,0,width,x);}
  for(float x=1;x<supposed_height;x=x+supposed_height/10)
  {line(width,height,0,x);}
}

//////////////////////////////////////////
// Specific actions for the Superformula animation
//////////////////////////////////////////

public void draw_superformula() 
{
   
  fill(0,5);
  rect(-10, -10, width+20, height+20);
  superformula_counter1++;
  if (superformula_counter1 == 500 | superformula_counter1 == -1) {
    superformula_change();
  }
  translate(width/2, height/2);
  stroke(superformula_colorL,120);
  noFill();
  beginShape();
  for(int i=1; i < superformula_num; i++) {
    superformula_r = superformula_epi*pow(((pow(abs(cos(superformula_m*superformula_th/4)/superformula_a),superformula_n2))+(pow(abs(sin(superformula_m*superformula_th/4)/superformula_b),superformula_n3))),(-1/superformula_n1)); 
    superformula_th = superformula_th + superformula_step;
    superformula_x = superformula_r*cos(superformula_th);
    superformula_y = superformula_r*sin(superformula_th);
    curveVertex(superformula_x,superformula_y);
  }
  endShape();
 
}

public void superformula_change()
{
  superformula_m=PApplet.parseInt(random(3,40));
  superformula_n1=random(.5f);
  superformula_n2=random(6.f);
  //n3=random(6.);
  superformula_epi=random(35,70);
  superformula_step=random(.05f,50);
  superformula_counter1 = 0;
  background(0);
  fill(0);
  noStroke();
  rect(-width/2,-height/2,width*2,height*2);
}

//////////////////////////////////////////
// Specific actions for the Growing Triangles animation
//////////////////////////////////////////

public void draw_growingtriangles() {
    background(0);
    
    stroke(255);
    for (int i = 0;i<trianglelist.size();i++) {
      growingTriangle triangle = (growingTriangle) trianglelist.get(i);
      triangle.display();
      triangle.move();    
    }
}
 
class growingTriangle {
  float x1, y1, x2, y2, x3, y3;
  float growingrate;
  
  growingTriangle() {
    x1 = width/2;
    y1 = height/2;
    x2 = width/2;
    y2 = height/2;
    x3 = width/2;
    y3 = height/2;
    growingrate = 1;
  }
  
  public void move() {
    y1-=growingrate;
    x2-=growingrate;
    y2+=growingrate/2;
    x3+=growingrate;
    y3+=growingrate/2;     
  }
  
  public void display() {
     triangle(x1, y1, x2, y2, x3, y3);
  }
}


//////////////////////////////////////////
// Specific actions for the Moire animation
//////////////////////////////////////////

public void draw_moire(){
  background(255);
  float fSpeed = 0.015f;
  moireOne.drawSegments(-1*((float)frameCount)*fSpeed*QUARTER_PI);
  moireTwo.drawSegments(((float)frameCount)*fSpeed*QUARTER_PI);
}


class moire{
  int posX;
  int posY;
  int type;
  int divs;
  float angle;
 
  moire()
  {
  }
  moire(int iPosX, int iPosY, int iType, int iDivs)
  {
    resetProperties(iPosX, iPosY, iType, iDivs);
  }
 
  public void resetProperties(int iPosX, int iPosY, int iType, int iDivs)
  {
    posX = iPosX;
    posY = iPosY;
    divs = iDivs;
    angle = PI / 1.0f / ((float)divs); 
  }
 
  public void drawSegment(float fAngle, float fAngleOffset)
  {
    int posV1X = posX + PApplet.parseInt(width * cos(fAngle + fAngleOffset));
    int posV1Y = posY + PApplet.parseInt(height * sin(fAngle + fAngleOffset));
    int posV2X = posX + PApplet.parseInt(width * cos(fAngle + angle + fAngleOffset));
    int posV2Y = posY + PApplet.parseInt(height * sin(fAngle + angle + fAngleOffset));
    fill(0);
    stroke(0);
    strokeWeight(0);
 
    beginShape();
    vertex(posX,posY);
    vertex(posV1X,posV1Y);
    vertex(posV2X,posV2Y);
 
    endShape(CLOSE);
 
  }
 
  public void drawSegments(float fAngleOffset)
  {
    for(int i = 0; i < divs; i++)
      drawSegment(((float)i)*angle*2.0f,fAngleOffset); 
  }
}

//////////////////////////////////////////
// Specific actions for the Responsive Circles animations
//////////////////////////////////////////

public void draw_responsivecircles(){
   background(0);
   for(int i=0; i<=width; i+=8){
      for(int j=0; j<=height; j+=8){
        //using dist() in a nested for loop
        //creates a halftone spotlight effect
         float diameter = dist(responsiveCircles_x,responsiveCircles_y, i, j) / 2.3f;
         fill(colortheme[PApplet.parseInt(map(i+j,0,width+height,0,7))], diameter*4); //added alpha channel
         ellipse(i,j, diameter, diameter);
      }
   }
  if (responsiveCircles_forward) {
  responsiveCircles_x += 3;}
  else {
  responsiveCircles_x -= 3;}
  if (responsiveCircles_x >= (NUMBER_OF_PANELS+1)*width/NUMBER_OF_PANELS) {
   responsiveCircles_forward = false; 
  }
  if (responsiveCircles_x <= -width/NUMBER_OF_PANELS) {
   responsiveCircles_forward = true; 
  }}
  
  
public void draw_responsivecirclesbw(){
   background(230);
   for(int i=0; i<=width; i+=8){
      for(int j=0; j<=height; j+=8){
        //using dist() in a nested for loop
        //creates a halftone spotlight effect
         float diameter = dist(responsiveCircles_x,responsiveCircles_y, i, j) / 2.3f;
         fill(0, diameter*4); //added alpha channel
         ellipse(i,j, diameter, diameter);
      }
   }
  if (responsiveCircles_forward) {
  responsiveCircles_x += 3;}
  else {
  responsiveCircles_x -= 3;}
  if (responsiveCircles_x >= width+48) {
   responsiveCircles_forward = false; 
  }
  if (responsiveCircles_x <= -44) {
   responsiveCircles_forward = true; 
  }}
  
//////////////////////////////////////////
// Specific actions for the ParticlesExplode animations
//////////////////////////////////////////

public void draw_particlesexplode(){
  background(0,0,0);
  for(int i = 0; i < arr.size(); i++){
    ParticleExplode p = (ParticleExplode) arr.get(i);
    p.run();
  }
  for(int i = 0; i < arr.size(); i++){
    ParticleExplode p = (ParticleExplode) arr.get(i);
    if(p.isDead()){
      arr.remove(i);
    }
  
  }
  
}
  
  
class ParticleExplode {
  PVector location;
  PVector velocity;
  PVector acceleration;
  float lifespan;
  int particleC;
 
  ParticleExplode(PVector l, int pC) {
    acceleration = new PVector(0,0.05f);
    velocity = new PVector(random(-4,4),random(-8,0));
    location = l.get();
    lifespan = 255.0f;
    particleC = pC;
  }
 
  public void run() {
    update();
    display();
  }
 
  public void update() {
    velocity.add(acceleration);
    location.add(velocity);
    lifespan -= 2.0f;
  }
 
  public void display() {
    fill(particleC);
    noStroke();
    smooth();
    ellipse(location.x,location.y,(lifespan/2)/10,(lifespan/2)/10);
  }
 
  public boolean isDead(){
    if(lifespan < 0.0f){
    return true;
    } else {
    return false;
    }
  }
  
}

//////////////////////////////////////////
// Specific actions for the Starfield animations
//////////////////////////////////////////


class StarPoint {
  //position
  float x, y;
  //size, speed, color, alpha
  float t, v; int c; int b;
   
  StarPoint(float x, float y, float t, float v, int c, int b){
    this.x = x;  this.y = y;
    this.t = t;  this.v = v;
    this.c = c;  this.b = b;
  }
   
  StarPoint(float x, float y, float t, float v, int c){
    this.x = x;  this.y = y;
    this.t = t;  this.v = v;
    this.c = c;
  }
   
  public void draw_stars(){
    x=x-v;
    if(x < -t*2){
      x = width + t * random(t);
    }
     
    fill(c, b);
    ellipse(x, y, t, t);
  }
}

 
public void starfield_initialize(final StarPoint[] arr, float v, float t, int c){
  starfield_initialize(arr, v, t, c, 255);
}
 
public void starfield_initialize(final StarPoint[] arr, float v, float t, int c, int b){
  for(int i = 0; i < arr.length; i++){
    float x = random(-50, width+50);
    float y = random(10, height-10);
    arr[i] = new StarPoint(x, y, t, v, c, b);
  }
}

public void starfield_initialize(final StarPoint[] arr, float v, float t, int c, float x, float y){
  for(int i = 0; i < arr.length; i++){
    arr[i] = new StarPoint(x, y, t, v, c, 255);
  }
}
 
public void specificdraw_stars(final StarPoint[] arr){
for(int i = 0; i < arr.length; i++){
    arr[i].draw_stars();
  }
}
 
public void draw_starfield(){
  background(0xff012326);
   
  //specificdraw_stars(asteroids3);
  specificdraw_stars(starfield_planet);
  specificdraw_stars(starfield_asteroids2);
  specificdraw_stars(starfield_satellite);
  specificdraw_stars(starfield_asteroids1);
}


//////////////////////////////////////////
// Specific actions for the ColorVertex animation
//////////////////////////////////////////

public void draw_colorvertex()
{
  background(255);
  translate(width/2, height/2);
  pushStyle();
  fill(0);
  stroke(0,50);
  ellipse(0,0,200,200);
  popStyle();
  //----------------
  for (int i=0;i<colorvertex_pointarray.size();i++) {
    colorvertex_Dots dots1 = (colorvertex_Dots) colorvertex_pointarray.get(i);
    dots1.update();
    for (int j=i+1;j<colorvertex_pointarray.size();j++) {
      colorvertex_Dots dots2 = (colorvertex_Dots) colorvertex_pointarray.get(j);
      dots2.update();
      if (dist(dots1.location.x, dots1.location.y, dots2.location.x, dots2.location.y)<colorvertex_distance) {
        for (int k=j+1;k<colorvertex_pointarray.size();k++) {
          colorvertex_Dots dots3 = (colorvertex_Dots) colorvertex_pointarray.get(k);
          dots3.update();
          fill(dots3.c, 50);
          noStroke();
          if (dist(dots3.location.x, dots3.location.y, dots2.location.x, dots2.location.y)<colorvertex_distance) {
            beginShape();
            vertex(dots3.location.x, dots3.location.y);
            vertex(dots2.location.x, dots2.location.y);
            vertex(dots1.location.x, dots1.location.y);
            endShape();
          }
        }
      }
    }
  }
  //----------------
}

class colorvertex_Dots {
  PVector location;
  PVector velocity;
  int c;
  int radius=200;
  colorvertex_Dots(PVector _PV)
  {
    location = _PV;
    int j = (int)random(0, 5);
    if (j==0) c = color(0xff05CDE5);
    if (j==1) c = color(0xffFFB803);
    if (j==2) c = color(0xffFF035B);
    if (j==3) c = color(0xff3D3E3E);
    if (j==4) c = color(0xffD60FFF);
    float xt = random(-0.05f, 0.05f);
    float yt = random(-0.05f, 0.05f);
    velocity = new PVector(xt, yt );
  }
 
  public void update()
  {
    if (dist(location.x, location.y, 0, 0)>radius) {
      velocity.mult(-1);
      location.add(velocity);
    }
    else {
      location.add(velocity);
    }
  }
}


//////////////////////////////////////////
// Specific actions for the ParticlesFmow animation
//////////////////////////////////////////


public void draw_particlesflow() { 
  particlesflow_noiseZ += 2*particlesflow_noiseScale;
   
  imgProc.blur(particlesflow_prevFrame, particlesflow_tempFrame, width, height);
  imgProc.scaleBrightness(particlesflow_tempFrame, particlesflow_tempFrame, width, height, 0.995f); 
  arrayCopy(particlesflow_tempFrame, particlesflow_currFrame);
   
  for(int i=0; i<particlesflow_particles.length; i++) {
    try {
      particlesflow_particles[i].update();
      particlesflow_particles[i].draw();
    }
    catch (Exception e) {
    }
  } 
  imgProc.drawPixelArray(particlesflow_currFrame, 0, 0, width, height);
  arrayCopy(particlesflow_currFrame, particlesflow_prevFrame);
}
 
class ParticleFlow {
  float x;
  float y;
  int c;
  float speed = 2;
  ParticleFlow(int x, int y, int c) {
    this.x = x;
    this.y = y;
    this.c = c;
  }
  public void update() {
    float noiseVal = noise(x*particlesflow_noiseScale, y*particlesflow_noiseScale, particlesflow_noiseZ);
    float angle = noiseVal*2*PI;
    x += speed * cos(angle);
    y += speed * sin(angle);
     
    if (x < -particlesflow_particleMargin/4){
      x += width + particlesflow_particleMargin/4;
    } else if (x > width + particlesflow_particleMargin/4){
      x -= width + particlesflow_particleMargin/4;
    }
     
    if (y < -particlesflow_particleMargin/4){
      y += height + particlesflow_particleMargin/4;
    } else if (y > height + particlesflow_particleMargin/4){
      y -= height + particlesflow_particleMargin/4;
    }
  }
  public void draw() {
    if ((x >= 0) && (x < width-1) && (y >= 0) && (y < height-1)) {
      //int currC = particlesflow_currFrame[(int)x + ((int)y)*width];
      particlesflow_currFrame[(int)x + ((int)y)*width] = c;
    }
  }
}

public class ImgProc {
   
//void ImgProc() {
//}
   
public void drawPixelArray(int[] src, int dx, int dy, int w, int h) { 
  //backBuf.loadPixels();
  //arraycopy(src, backBuf.pixels);
  //backBuf.updatePixels();
  //image(backBuf, dx, dy);
  loadPixels();
  int x;
  int y;
  for(int i=0; i<w*h; i++) {
    x = dx + i % w;
    y = dy + i / w;
    pixels[x  + y * w] = src[i];
  }
  updatePixels();
}
 
public void blur(int[] src, int[] dst, int w, int h) {
  int c;
  int r;
  int g;
  int b;
  for(int y=1; y<h-1; y++) {
    for(int x=1; x<w-1; x++) {     
      r = 0;
      g = 0;
      b = 0;
      for(int yb=-1; yb<=1; yb++) {
        for(int xb=-1; xb<=1; xb++) {
          c = src[(x+xb)+(y-yb)*w];     
          r += (c >> 16) & 0xFF;
          g += (c >> 8) & 0xFF;
          b += (c) & 0xFF;
        }
      }     
      r /= 9;
      g /= 9;
      b /= 9;
      dst[x + y*w] = 0xFF000000 | (r << 16) | (g << 8) | b;
    }
  }
}
 
//you must be in RGB colorModel
public void scaleBrightness(int[] src, int[] dst, int w, int h, float s) {
  int r;
  int g;
  int b;
  int c;
  for(int y=0; y<h; y++) {
    for(int x=0; x<w; x++) {
      c = src[x + y*w];
      r = (int)(s * ((c >> 16) & 0xFF));
      g = (int)(s *((c >> 8) & 0xFF));
      b = (int)(s *((c) & 0xFF));     
      dst[x + y*w] = 0xFF000000 | (r << 16) | (g << 8) | b;
      //ch = hue(c);
      //cs = saturation(c);
      //cb = brightness(c) * s;
      //dst[x + y*w] = color(ch, cs, cb);
      //dst[x + y*w] = src[x + y*w];
    }
  }
}
 
}

//////////////////////////////////////////
// Specific actions for the BezierFlowers animation
//////////////////////////////////////////

class ControlPoint{
  float angle;       //  Angle
  float angleSpeed;  //  Rotation speed 
  float angleSpeed2; //  Rotation acceleration
  float angleOffset; //  Angle offset
  float r;           //  Length of the leaves
  float rSpeed;      //  Length change speed
  float rSpeed2;     //  Length change acceleration
   
  ControlPoint(){
    init();
  }
   
  
  public void init(){
    angle = random(360);
    angleSpeed = random(6) - 4;
    angleSpeed2 = (random(2) - 1) / 100.0f;
    r = random(5);
    rSpeed = random(8) - 4;
    rSpeed2 = (random(2) - 1) / 100.0f;
  }
   
  //  Offset definition
  public void setAngle(float offset){
    angleOffset = offset;
  }
   
  //  Get control point X value
  public float getX(){
    return cos(radians(angle + angleOffset)) * r + width / 2;
  }
   
  //  Get control point Y value
  public float getY(){
    return sin(radians(angle + angleOffset)) * r + height / 2;
  }
   
  //  Move the control point
  public void act(){
    angle += angleSpeed;
    angleSpeed += angleSpeed2;
    r += rSpeed;
    rSpeed += rSpeed2;
  }
}

public void draw_bezierflowers(){
  fill(bezierflowers_col, 360, 360, bezierflowers_deep);
  stroke(bezierflowers_col, 360, 360);
 
  float cx = width / 2; 
  float cy = height / 2; 
  float angleOffset = 360 / bezierflowers_leaf;
   
  //  Draw the leaves
  for(int i = 0; i <= bezierflowers_leaf; i++){
    float angle = i * angleOffset - 90;          //  Direction
    float x = cos(radians(angle)) * 80 + cx;    //  Leaves - X coordinates
    float y = sin(radians(angle)) * 80 + cy;    //  Leaves - Y coordinates
    bezierflowers_controlpoints[0].setAngle(angle);
    bezierflowers_controlpoints[1].setAngle(angle);
     
    //  Draw the Bezier line
    bezier(cx, cy, bezierflowers_controlpoints[0].getX(), bezierflowers_controlpoints[0].getY(), bezierflowers_controlpoints[1].getX(), bezierflowers_controlpoints[1].getY(), x, y);
  }
   
  //  Move the control point
  for(int i = 0; i < bezierflowers_MAX_POINT; i++){
    bezierflowers_controlpoints[i].act();
  }
   
  //  Fadeout
  fill(0, 50);
  noStroke();
  rect(0, 0, width, height);
   
  //  Change the flower after some time
  //bezierflowers_timer++;
  //if(bezierflowers_timer >= 200){
  //  bezierflowers_initialize();
  //}
 
}
 
//  Re-init
public void bezierflowers_initialize(){
  bezierflowers_leaf = PApplet.parseInt(random(7)) + 3;
  bezierflowers_col = PApplet.parseInt(random(360));
  bezierflowers_deep = PApplet.parseInt(random(10));
  bezierflowers_deep = bezierflowers_deep * bezierflowers_deep;
  bezierflowers_timer = 0;
  for(int i = 0; i < bezierflowers_MAX_POINT; i++){
    bezierflowers_controlpoints[i].init();
  } 
}


//////////////////////////////////////////
// Specific actions for the JointCircles animation
//////////////////////////////////////////


public void draw_jointcircles(){
  background(0);
  for(int i = 0; i < 360; i+= 10){
    float x = cos(radians(i)) * 30 + width / 2;
    float y = sin(radians(i)) * 30 + height / 2;
    float w = cos(radians(jointcircles_time + i)) * 30;
    w = abs(w);
    ellipse(x, y, w, w);
  }
  jointcircles_time++;
}

//////////////////////////////////////////
// Specific actions for the Tunnel animation
//////////////////////////////////////////

public void draw_tunnel() {
  background(0);
  float r = sqrt(width*width+height*height)/tunnel_num;
  pushMatrix();
  translate(width/2, height/2);
  for (int i=tunnel_num; i>0; i--) {
    tunnel_fillcolor(i);
    ellipse(0, 0, r*i, r*i);
  }
  popMatrix();
  tunnel_counter++;
  if (tunnel_counter == tunnel_grises.length) {
    tunnel_counter = 0;
  }
}
 
public void tunnel_fillcolor(int i) {
  int d = 0;
  if (tunnel_color_counter == 0) {
    fill(tunnel_grises[(i + tunnel_counter) % tunnel_grises.length]);
  } else if (tunnel_color_counter == 1) {
    fill(tunnel_grises[(i + tunnel_counter) % tunnel_grises.length], d, d);
  }
}

//////////////////////////////////////////
// Specific actions for the CosmoCurve animation
//////////////////////////////////////////


public void draw_cosmocurve() {
  fill(0, 30);
  rect(0, 0, width, height);
  
  for (int cosmoscurve_t = 0; cosmoscurve_t < 360*2;cosmoscurve_t++) {
    cosmoscurve_r = cosmoscurve_a * sin(radians(cosmoscurve_t * cosmoscurve_n / cosmoscurve_d));
    cosmoscurve_point.set(cos(radians(cosmoscurve_t)),sin(radians(cosmoscurve_t)),0);
    cosmoscurve_point.mult(cosmoscurve_r);
    cosmoscurve_point.add(cosmoscurve_center);
  
    if (cosmoscurve_t % 5 == 0) {
      fill(255 - cosmoscurve_t/18.0f, 0, 0, 120);
    } else {  
      fill(360, 50);
    }
    ellipse(cosmoscurve_point.x, cosmoscurve_point.y, 10, 10);
  }
  
  cosmoscurve_n += 0.015f;
  cosmoscurve_d += 0.0005f;
}

//////////////////////////////////////////
// Specific actions for the PerlinColor animation
//////////////////////////////////////////


public void draw_perlincolor(){
  fill(160,0,0);
  rect(0,0,width,height);
  for(int i=0; i<colorperlin_myAngleThing.length; i++){
    int theLength = colorperlin_myAngleThing[0].length;
    for(int j=0; j<theLength; j++){
      colorperlin_myAngleThing[i][j].update();
      colorperlin_myAngleThing[i][j].render();
    }
  }
  colorperlin_noiseCount += .01f;
}

 
class AngleThing{
  float wigCo = 12.0f;
  PVector pos;
  PVector wiggle;
  float lookingTheta;
  float openedTheta;
  float arcHue = 5;
  float ellipHue = 5;
  //float sen = 3.24;
  float sen = 10;
  float radius = 50;
  
  
  AngleThing(int x_, int y_){
    pos = new PVector(x_, y_);
    wiggle = new PVector(0, 0);
  }
  public void update(){
    lookingTheta = noise(pos.x/width*.5f, pos.y/height*.5f, colorperlin_noiseCount)*2*PI;
    openedTheta = noise(pos.x/width*5.0f, pos.y/height*5.0f, colorperlin_noiseCount)*PI;
    arcHue = (1.75f*noise(pos.x/width, pos.y/height, colorperlin_noiseCount*.2f))%1.0f;
    ellipHue = 1.75f*noise(pos.x/width, pos.y/height, colorperlin_noiseCount*.2f+4.0f);
    radius = colorperlin_LOOKER_RADIUS*(2.0f-(1.0f/(1.0f+sen))-(2.0f-(1.0f/(sen+1.0f))*2.0f)*noise(pos.x/width*5.0f, pos.y/height*5.0f, colorperlin_noiseCount*1.5f));
    wiggle.x = wigCo*noise(pos.x/width*.25f, pos.y/height*.25f, colorperlin_noiseCount*.07f+10.0f);
    wiggle.y = wigCo*noise(pos.x/width*.25f, pos.y/height*.25f, colorperlin_noiseCount*.07f+20.0f);
  }
  public void render(){
    fill((((20-20*cos(2*PI*ellipHue))/2.0f+15.0f)-26), 255, 255, 255);
    ellipse(pos.x+wigCo*wiggle.x*cos(wiggle.y), pos.y+wigCo*wiggle.x*sin(wiggle.y), radius, radius);
    fill((((20-20*cos(2*PI*arcHue))/2.0f+15.0f)-26), 180, 255, 255);
    arc(pos.x+wigCo*wiggle.x*cos(wiggle.y), pos.y+wigCo*wiggle.x*sin(wiggle.y), radius, radius, lookingTheta-openedTheta, lookingTheta+openedTheta);
  }
}


//////////////////////////////////////////
// Specific actions for the LineFlash animations
//////////////////////////////////////////

public void draw_linewideflash() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    rect(0, 5*height/12, width, height/6) ;
    fill(255) ;
    drawwide --;

  }
  else {
    draw_fadeout();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

public void draw_lineleftflash() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    rect(0, 5*height/12, width/NUMBER_OF_PANELS, height/6) ;
    fill(255) ;
    drawwide --;

  }
  else {
    draw_fadeout_short();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}

}

public void draw_linecenterflash() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, 5*height/12, width/NUMBER_OF_PANELS, height/6) ;
    fill(255) ;
    drawwide --;
  }
  else {
    draw_fadeout_short();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

public void draw_linerightflash() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 5*height/12, width/NUMBER_OF_PANELS, height/6) ;
    fill(255) ;
    drawwide --;

  }
  else {
    draw_fadeout_short();
  }
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

public void draw_longwideflash() {
  if (drawwide >= 0) {
    resetMatrix() ;
    // Fade background by drawing a partially transparent black rectangle over the screen
    noStroke() ;
    rect(0, 0, width, height) ;
    fill(255) ;
        drawwide --;

  }
  else {
    draw_fadeout_long();
  }
  
  //Reset oppositelines x
  oppositeLinesNoBackground_x = 0;
  
  if (oppositeLinesNoBackground_rightside)
    {oppositeLinesNoBackground_x += 0.3f;}
  else
    {oppositeLinesNoBackground_x -= 0.3f;}
}

public void draw_fadeout_long(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  fill(0, 4) ;
  rect(0, 0, width, height) ;

}

public void draw_fadeout_short(){
  resetMatrix() ;
  // Fade background by drawing a partially transparent black rectangle over the screen
  noStroke() ;
  fill(0, 30) ;
  rect(0, 0, width, height) ;

}

//////////////////////////////////////////
// Specific actions for the OppositeLinesNoBackground animations
//////////////////////////////////////////

public void draw_oppositelinesnobackground() {
    if (oppositeLinesNoBackground_reinit) {
      oppositeLinesNoBackground_rightside = true;
      oppositeLinesNoBackground_x = 0;
      oppositeLinesNoBackground_reinit = false;
    }
  
    fill(255);
    if (oppositeLinesNoBackground_rightside){
    rect(0, 2*height/12, PApplet.parseInt(oppositeLinesNoBackground_x), height/8) ;
    rect(width-PApplet.parseInt(oppositeLinesNoBackground_x), 8*height/12, PApplet.parseInt(oppositeLinesNoBackground_x), height/8) ;
    }
    else {
    rect(width-PApplet.parseInt(oppositeLinesNoBackground_x), 2*height/12, PApplet.parseInt(oppositeLinesNoBackground_x), height/8) ;
    rect(0, 8*height/12, PApplet.parseInt(oppositeLinesNoBackground_x), height/8) ;
    }
    
    if (oppositeLinesNoBackground_rightside)
      {oppositeLinesNoBackground_x += 0.4f;}
    else
      {oppositeLinesNoBackground_x -= 0.4f;}
      
    if (oppositeLinesNoBackground_x < -1) {
      oppositeLinesNoBackground_rightside = true;
    }
    if (oppositeLinesNoBackground_x > width) {
      oppositeLinesNoBackground_rightside = false;
    }
    fill(0, 10) ;
    rect(0, 0, width, height) ;
  
}


//////////////////////////////////////////
// Specific actions for the OpeningLines animations
//////////////////////////////////////////

public void draw_openinglines() {
  background(0);
    for (int x = 0; x <= (openinglines_x); x+=24) {
      line(width/2 + openinglines_x - x,0,width/2 + openinglines_x - x,height);
      line(width/2 - openinglines_x + x,0,width/2 - openinglines_x + x,height);
    }
  openinglines_x += 1;
}

//////////////////////////////////////////
// Specific actions for the WhiteNoise animation
//////////////////////////////////////////

public void draw_whitenoise() {
  for (int i = 0; i<width/4;i++) {
    for (int j = 0; j<height/4;j++) {
      fill(random(60,255));
      rect(i*4,j*4,i*4+4,j*4+4);
    }
  }
}

//////////////////////////////////////////
// Specific actions for the SingleSquareSpiral animation
//////////////////////////////////////////
public void draw_singlesquarespiral(){
  noStroke();
  singleSquareSpiral_tick = frameCount/100.0f * PI;
   for(int boxRadius_i = singleSquareSpiral_windowSize*2;  boxRadius_i > 5; boxRadius_i -=singleSquareSpiral_boxSize-singleSquareSpiral_boxSize/2){
     for(int windowRadius_i = -singleSquareSpiral_windowSize;  windowRadius_i <= singleSquareSpiral_windowSize; windowRadius_i +=singleSquareSpiral_windowSize){
                  
        singleSquareSpiral_altCol = !singleSquareSpiral_altCol;
        int col = singleSquareSpiral_altCol ? 0 : 1;
        fill(
        255 * col,
        12 * col,
        12 * col
        );
       
      pushMatrix();
      translate(windowRadius_i+width/2, height/2);
      rotate(singleSquareSpiral_tick*boxRadius_i/40);
      quad( -boxRadius_i/2, 0,
             0, boxRadius_i/2,
             boxRadius_i/2, 0,
             0, -boxRadius_i/2
          );       
       popMatrix();
   }
 } 
}

public void draw_singlesquarespiralwhite(){
  noStroke();
  singleSquareSpiral_tick = frameCount/100.0f * PI;
   for(int boxRadius_i = singleSquareSpiral_windowSize*2;  boxRadius_i > 5; boxRadius_i -=singleSquareSpiral_boxSize-singleSquareSpiral_boxSize/2){
     for(int windowRadius_i = -singleSquareSpiral_windowSize;  windowRadius_i <= singleSquareSpiral_windowSize; windowRadius_i +=singleSquareSpiral_windowSize){
                  
        singleSquareSpiral_altCol = !singleSquareSpiral_altCol;
        int col = singleSquareSpiral_altCol ? 0 : 1;
        fill(
        255 * col,
        255 * col,
        255 * col
        );
       
      pushMatrix();
      translate(windowRadius_i+width/2, height/2);
      rotate(singleSquareSpiral_tick*boxRadius_i/40);
      quad( -boxRadius_i/2, 0,
             0, boxRadius_i/2,
             boxRadius_i/2, 0,
             0, -boxRadius_i/2
          );       
       popMatrix();
   }
 } 
}

//////////////////////////////////////////
// Specific actions for the DualSquareSpiral animation
//////////////////////////////////////////

public void draw_dualsquarespiral(){
  noStroke();
  dualSquareSpiral_tick = frameCount/100.0f * PI;
   for(int boxRadius_i = width*2;  boxRadius_i > 5; boxRadius_i -=dualSquareSpiral_boxSize-dualSquareSpiral_boxSize/2){
     for(int windowRadius_i = -width;  windowRadius_i <= width; windowRadius_i +=dualSquareSpiral_windowSize){
                  
        dualSquareSpiral_altCol = !dualSquareSpiral_altCol;
        int col = dualSquareSpiral_altCol ? 0 : 1;
        fill(
        255 * col,
        12 * col,
        12 * col
        );
      
      pushMatrix();
      translate(windowRadius_i, height/2);
      rotate(dualSquareSpiral_tick*boxRadius_i/40);
      quad( -boxRadius_i/2, 0,
             0, boxRadius_i/2,
             boxRadius_i/2, 0,
             0, -boxRadius_i/2
          );       
       popMatrix();
   }
 } 
}

public void draw_dualsquarespiralwhite(){
  noStroke();
  dualSquareSpiral_tick = frameCount/100.0f * PI;
   for(int boxRadius_i = width*2;  boxRadius_i > 5; boxRadius_i -=dualSquareSpiral_boxSize-dualSquareSpiral_boxSize/2){
     for(int windowRadius_i = -width;  windowRadius_i <= width; windowRadius_i +=dualSquareSpiral_windowSize){
                  
        dualSquareSpiral_altCol = !dualSquareSpiral_altCol;
        int col = dualSquareSpiral_altCol ? 0 : 1;
        fill(
        255 * col,
        255 * col,
        255 * col
        );
      
      pushMatrix();
      translate(windowRadius_i, height/2);
      rotate(dualSquareSpiral_tick*boxRadius_i/40);
      quad( -boxRadius_i/2, 0,
             0, boxRadius_i/2,
             boxRadius_i/2, 0,
             0, -boxRadius_i/2
          );       
       popMatrix();
   }
 } 
}

//////////////////////////////////////////
// Specific actions for the ComplexSpiral animation
//////////////////////////////////////////

public void draw_complexspiral() {
  strokeWeight(6);
  stroke(0,0,0);
  fill(0);
  background(5*sin(complexspiral_counter*0.01f), 245 + 10*sin(complexspiral_counter*0.05f),230 + 25*sin(complexspiral_counter*0.1f));
  translate(width/2,height/2);
  pushMatrix();  
  for(int i=0; i < 100; i++) {
    if (i > 24) {
      rect(i/2,(100)*tan(i+sin(complexspiral_counter/43f)),(i+17.5f)*0.02f,i);
    }
    rotate(complexspiral_counter/(1250f));
  }
  popMatrix();
  complexspiral_counter += 1;  
}

//////////////////////////////////////////
// Specific actions for the BeatCircle animation
//////////////////////////////////////////

public void draw_beatcircle() {
  background(0);
  if (beatcircle_radius >= 0) {
    ellipse(width/2, height/2, PApplet.parseInt(beatcircle_radius), PApplet.parseInt(beatcircle_radius));
    beatcircle_radius -= 6;
  }
}
  
public void draw_beatcirclelines() {
  background(0);
  noStroke();
  if (beatcircle_radius >= 0) {
    ellipse(width/2, height/2, PApplet.parseInt(beatcircle_radius), PApplet.parseInt(beatcircle_radius));
    beatcircle_radius -= 6;
  }
  stroke(255);
  if (beatcircles_linepos <= width){
    line(0,height/4,beatcircles_linepos,height/4);
    line(width,3*height/4,width-beatcircles_linepos,3*height/4);
  }
  if (beatcircles_linepos > width & beatcircles_linepos <= 2*width){
    line(beatcircles_linepos-width,height/4,width,height/4);
    line(0,3*height/4,2*width-beatcircles_linepos,3*height/4);
  }
    if (beatcircles_linepos > 2*width & beatcircles_linepos <= 2*width+height){
    line(width/6,height,width/6,(2*width+height)-beatcircles_linepos);
    line(5*width/6,0,5*width/6,beatcircles_linepos-(2*width));
  }
  if (beatcircles_linepos > 2*width+height & beatcircles_linepos <= 2*width+2*height){
    line(width/6,(2*width+2*height)-beatcircles_linepos,width/6,0);
    line(5*width/6,beatcircles_linepos-(2*width+height),5*width/6,height);
}
  if (beatcircles_linepos > 2*width+2*height) {
    beatcircles_linepos = 0;  
  }

  beatcircles_linepos += 1;
}

public void draw_beatcirclecolorlines(int pos) {
  background(0);
  noStroke();
  if (beatcircle_radius >= 0) {
    
    fill(155+7.2f*beatcircle_radius,333-4.6f*beatcircle_radius,0,255);
    if (pos == 1) {
      ellipse(width/(2*NUMBER_OF_PANELS),3*height/4,beatcircle_radius,beatcircle_radius);
      ellipse((2*(NUMBER_OF_PANELS-1)+1)*width/(2*NUMBER_OF_PANELS),height/4,beatcircle_radius,beatcircle_radius);
      if (NUMBER_OF_PANELS == 5) {
        ellipse(width/2,height/2,beatcircle_radius,beatcircle_radius);
      }
      beatcircle_radius -= 6;
    }
    else if (pos == 2) {
      ellipse((2*(NUMBER_OF_PANELS-1)+1)*width/(2*NUMBER_OF_PANELS),3*height/4,beatcircle_radius,beatcircle_radius);
      ellipse(width/(2*NUMBER_OF_PANELS),height/4,beatcircle_radius,beatcircle_radius);
      if (NUMBER_OF_PANELS == 5) {
        ellipse(width/2,height/2,beatcircle_radius,beatcircle_radius);
      }      
      beatcircle_radius -= 6;
    }
  }
  stroke(255);
  if (beatcircles_linepos <= width){
    line(0,height/4,beatcircles_linepos,height/4);
    line(width,3*height/4,width-beatcircles_linepos,3*height/4);
  }
  if (beatcircles_linepos > width & beatcircles_linepos <= 2*width){
    line(beatcircles_linepos-width,height/4,width,height/4);
    line(0,3*height/4,2*width-beatcircles_linepos,3*height/4);
  }
    if (beatcircles_linepos > 2*width & beatcircles_linepos <= 2*width+height){
    line(width/(2*NUMBER_OF_PANELS),height,width/(2*NUMBER_OF_PANELS),(2*width+height)-beatcircles_linepos);
    line((2*(NUMBER_OF_PANELS-1)+1)*width/(2*NUMBER_OF_PANELS),0,(2*(NUMBER_OF_PANELS-1)+1)*width/(2*NUMBER_OF_PANELS),beatcircles_linepos-(2*width));
  }
  if (beatcircles_linepos > 2*width+height & beatcircles_linepos <= 2*width+2*height){
    line(width/(2*NUMBER_OF_PANELS),(2*width+2*height)-beatcircles_linepos,width/(2*NUMBER_OF_PANELS),0);
    line((2*(NUMBER_OF_PANELS-1)+1)*width/(2*NUMBER_OF_PANELS),beatcircles_linepos-(2*width+height),(2*(NUMBER_OF_PANELS-1)+1)*width/(2*NUMBER_OF_PANELS),height);
}
  if (beatcircles_linepos > 2*width+2*height) {
    beatcircles_linepos = 0;  
  }

  beatcircles_linepos += 1;
}

//////////////////////////////////////////
// Specific actions for the Blue and RedDiagonalLines animations
//////////////////////////////////////////

public void draw_reddiagonallines() {
  background(0);
  line(-width/3,height,redposx-width/3,height+redposy);
  line(0,height,redposx,height+redposy);
  line(width/3,height,redposx+width/3,height+redposy);
  line(2*width/3,height,redposx+2*width/3,height+redposy);

  redposx+=width/12;
  redposy-=height/8;

}

public void draw_bluediagonallines() {
  line(width,0,width-blueposx,blueposy);
  blueposx+=width/12;
  blueposy+=height/8;
}

public void draw_bluediagonallines2() {
  line(width/3,0,width/3-blueposx,blueposy);
  line(2*width/3,0,2*width/3-blueposx,blueposy);
  line(width,0,width-blueposx,blueposy);
  line(4*width/3,0,4*width/3-blueposx,blueposy);

  blueposx+=width/12;
  blueposy+=height/8;

}

public void draw_whitediagonallines() {
  stroke(255);
  line(width/3,0,width/3-blueposx,blueposy);
  line(2*width/3,0,2*width/3-blueposx,blueposy);
  line(width,0,width-blueposx,blueposy);
  line(4*width/3,0,4*width/3-blueposx,blueposy);

  blueposx+=width/12;
  blueposy+=height/8;

}


public void draw_bluediagonallines3() {
  line(0,0,blueposx,blueposy);
  line(-width/3,0,blueposx-width/3,blueposy);
  line(width/3,0,blueposx+width/3,blueposy);
  line(2*width/3,0,blueposx+2*width/3,blueposy);

  blueposx+=width/12;
  blueposy+=height/8;

}

public void draw_reddiagonallines2() {
  line(4*width/3,height,4*width/3-redposx,height-redposy);
  line(width,height,width-redposx,height-redposy);
  line(2*width/3,height,2*width/3-redposx,height-redposy);
  line(width/3,height,width/3-redposx,height-redposy);

  redposx+=width/12;
  redposy+=height/8;
}

public void draw_whitediagonallines2() {
  stroke(255);
  line(4*width/3,height,4*width/3-redposx,height-redposy);
  line(width,height,width-redposx,height-redposy);
  line(2*width/3,height,2*width/3-redposx,height-redposy);
  line(width/3,height,width/3-redposx,height-redposy);

  redposx+=width/12;
  redposy+=height/8;
}

public void draw_whitestraightlines() {
  background(0);
  line(0,height/4,redposx,height/4);
  line(width-redposx,2*height/4,width,2*height/4);
  line(0,3*height/4,redposx,3*height/4);
  redposx+=width/12;
  redposy+=width/8;

}

//////////////////////////////////////////
// Specific actions for the WhiteNoiseCrescendo animation
//////////////////////////////////////////

public void draw_whitenoisecrescendo() {
  for (int i = 0; i<width/4;i++) {
    for (int j = 0; j<height/4;j++) {
      fill(random(0,whitenoisecrescendo_brightness));
      rect(i*4,j*4,i*4+4,j*4+4);
    }
  }
  if (whitenoisecrescendo_brightness < 255) {
    whitenoisecrescendo_brightness += 3;
  }
}

//////////////////////////////////////////
// Specific actions for the TriangleStrobo animation
//////////////////////////////////////////



public void draw_trianglestrobo() {
  background(0);
  
  if(frameCount%8 == 0 || (frameCount+1)%8 == 0){
    line(0, height/4, width, height/4);
    line(0, height/2, width, height/2);
    line(0, 3*height/4, width, 3*height/4);
  }
  if((frameCount+4)%8 == 0 || (frameCount+5)%8 == 0 || (frameCount+6)%8 == 0){
    line(0, height, width/2, 0);
    line(width, height, width/2, 0);
  }  
  if((frameCount+7)%8 == 0){
    line(width/6, height, 0, 2*height/3);
    line(width/3, height, 0, height/3);
    line(2*width/3, height, width, height/3);
    line(5*width/6, height, width, 2*height/3);
  }  
}

//////////////////////////////////////////
// Specific actions for the InwardsSpiral animation
//////////////////////////////////////////

public void draw_inwardsspiral() {
  background(0);
  noStroke();
  float tempradius = inwardsspiral_radius;

  for (int i=0;i<inwardsspiral_counter;i++){
    if (tempradius > 0) {
      fill(255,0,0);
      ellipse(width/2-tempradius*cos(i*inwardsspiral_speed),height/2-tempradius*sin(i*inwardsspiral_speed),inwardsspiral_size,inwardsspiral_size);
      fill(0,0,255);
      ellipse(width/2+tempradius*cos(i*inwardsspiral_speed),height/2+tempradius*sin(i*inwardsspiral_speed),inwardsspiral_size,inwardsspiral_size);

      tempradius-=inwardsspiral_ratio;
    }
  }    
  inwardsspiral_counter+=1;
}

public void draw_inwardsspiralreverse() {
  float tempradius = 0;
  noStroke();
  for (int i=0;i<inwardsspiral_counter;i++){
    if (tempradius < width) {
      fill(255,0,0);
      ellipse(width/2-tempradius*cos(i*inwardsspiral_speed),height/2-tempradius*sin(i*inwardsspiral_speed),inwardsspiral_size,inwardsspiral_size);
      fill(0,0,255);
      ellipse(width/2+tempradius*cos(i*inwardsspiral_speed),height/2+tempradius*sin(i*inwardsspiral_speed),inwardsspiral_size,inwardsspiral_size);

      tempradius+=inwardsspiral_ratio;
    }
  }    
  inwardsspiral_counter+=1;
}

//////////////////////////////////////////
// Specific actions for the ExplodingCircle animation
//////////////////////////////////////////

public void draw_explodingcircle() {
  background(0);
  fill(0);
  stroke(255);
  strokeWeight(28);
  ellipse(width/2, height/2, explodingcircle_counter, explodingcircle_counter);
  explodingcircle_counter += explodingcircle_speed; 
}

//////////////////////////////////////////
// Specific actions for the RotozoomWhite animation
//////////////////////////////////////////

public void draw_rotozoomblue(){
background(0);
float a=0,b=0,c=rotozoom_c,d=rotozoom_c++*1,e=sin(d*0.05f),f=e++*-tan(d*0.01f);
for(rotozoom_b=0;rotozoom_b++<rotozoom_w;a=d+=f,b=c+=-e)
  for(rotozoom_a=0;rotozoom_a<rotozoom_w;rotozoom_d=PApplet.parseInt(a+=e)) {
    int temp = (rotozoom_d*rotozoom_w+PApplet.parseInt(b+=f)^rotozoom_d)&255;
    int tempcolor = color(temp,temp,temp);
    //set(rotozoom_a++,rotozoom_b,(rotozoom_d*rotozoom_w+int(b+=f)^rotozoom_d)&255);
    set(rotozoom_a++,rotozoom_b,tempcolor);
    }
  }
  
//////////////////////////////////////////
// Specific actions for the NewtonPendulum animation
//////////////////////////////////////////

  
public void draw_newtonpendulum() {
  background(0);
  //update current time
  newtonpendulum_t+=0.0002f;
  for(int i = 0;i<newtonpendulum_pends.size();i++){
    newtonpendulum_p = (WavePendulum) newtonpendulum_pends.get(i);
    // fetch position of current WavePendulum at time newtonpendulum_t
    newtonpendulum_p.update(newtonpendulum_t);
    // draw WavePendulum
    newtonpendulum_p.render();
  }
}

class WavePendulum{
 
  float theta_0;
  float theta;
  PVector leng = new PVector(0,0);
  float newtonpendulum_g = 9.8f;
  int conv = 4000000; //conversion factor from physics units to pixels
   
  WavePendulum(float length_, float theta_0_){
    theta_0 = theta_0_;
    leng.y = length_;
  }
   
  public void update(float time){
    theta = theta_0*cos(sqrt(newtonpendulum_g/leng.mag())*time);
  }
   
  public void render(){
    pushMatrix();
    translate(width/2,-2.4f*height);
    rotate(theta);
    ellipse(conv*leng.x,conv*leng.y,10,10);
    popMatrix();
  }
}


//////////////////////////////////////////
// Specific actions for the HypnoPendulum animation
//////////////////////////////////////////

public void draw_hypnopendulum() {
//  background(255);
  fill(255,255,255,20);
  rect(0,0,width,height);
  //update current time
  hypnopendulum_t+=0.001f;
  for(int i = 0 ; i< hypnopendulum_pends.size(); i++){
    hypnopendulum_p = (HypnoWheelPendulum) hypnopendulum_pends.get(i);
    // fetch position of current HypnoWheelPendulum at time t
    hypnopendulum_p.update(hypnopendulum_t);
    // draw HypnoWheelPendulum
    hypnopendulum_p.render();
  }
  
  if (hypnopendulum_fadein < 255) {
    fill(0, 255 - hypnopendulum_fadein);
    rect(0,0,width,height);
    hypnopendulum_fadein += hypnopendulum_fadeinSpeed;
  }
}


class HypnoWheelPendulum{
 
  float theta;
  PVector leng = new PVector(0,0);
  float g = 9.8f;
  int c;
   
  HypnoWheelPendulum(float length_, int c_){
    leng.y = length_;
    c = c_;
  }
   
  public void update(float time){
    theta = time*leng.mag();
  }
   
  public void render(){
    pushMatrix();
    translate(width/2,height/2);
    rotate(theta);
    translate(leng.x/10,leng.y/10);
     
    fill(c);
    noStroke();
    ellipse(0,0,leng.mag(),leng.mag());
    popMatrix();
  }
}

//////////////////////////////////////////
// Specific actions for the LargeWheelPendulum animation
//////////////////////////////////////////

public void draw_largewheelpendulum() {
  fill(0,0,0,20);
  rect(0,0,width,height);
  //update current time
  wheelpendulum_t+=0.001f;
  for(int i = 0;i<wheelpendulum_pends.size();i++){
    wheelpendulum_p = (LargeWheelPendulum) wheelpendulum_pends.get(i);
    // fetch position of current LargeWheelPendulum at time t
    wheelpendulum_p.update(wheelpendulum_t);
    // draw LargeWheelPendulum
    wheelpendulum_p.render();
  }
}


class LargeWheelPendulum{
 
  float theta;
  PVector leng = new PVector(0,0);
  float g = 9.8f;
  int c;
   
  LargeWheelPendulum(float length_, int c_){
    leng.y = length_;
    c = c_;
  }
   
  public void update(float time){
    theta = time*leng.mag();
  }
   
  public void render(){
    pushMatrix();
    translate(width/2,height/2);
    rotate(theta);
    fill(c);
    noStroke();
    ellipse(leng.x,leng.y,8,8);
    popMatrix();
  }
}


//////////////////////////////////////////
// Specific actions for the Mugen animation
//////////////////////////////////////////

public void draw_mugen(){
  mugen_px = mugen_x;
  mugen_py = mugen_y;
  pushMatrix();
  translate(width/2, height/2);
 
  float m = (float)millis()/100 + PI;
  mugen_x = cos(m/2)*mugen_xamp;
  mugen_y = sin(m/1)*mugen_yamp;
   

   
  stroke(255);
  strokeWeight(12);
 
  line(mugen_px, mugen_py, mugen_x, mugen_y);
  popMatrix();
  velo();
  
}
 
public void velo(){
  noStroke();
  fill(0, 5);
  rect(0, 0, width, height);
}


//////////////////////////////////////////
// Specific actions for the ArcWave animation
//////////////////////////////////////////


public void draw_arcwave(){
  arcwave_ray+=0.9f;
  if(arcwave_ray>32){
    arcwave_ray=0;
    for(int a=0;a<arcwave_arcs.length;a++){
      arcwave_arcs[a].r+=32;
    }

    arcwave_arcs = (ArcWaveClass[]) append (arcwave_arcs, new ArcWaveClass(width/2,height/2,16));
    if(arcwave_arcs[0].r>arcwave_maxi)
    {
      arcwave_arcs = (ArcWaveClass[]) subset (arcwave_arcs, 1);
    }
  }
  background(0);
  for(int a=0;a<arcwave_arcs.length;a++){
    arcwave_arcs[a].draw_wave();
  }
  fill(255);
  ellipse(width/2,height/2,4,4);
  noFill();

}
  
class ArcWaveClass{
  int x,y;
  movement m;
  float r,a,l,v;
  ArcWaveClass(int _x, int _y, int _r){
    m = new movement();
    x=_x;
    y=_y;
    r=_r;
    a=random(TWO_PI);
    l=random(0.3f,0.7f);
    v=random(-0.04f,0.04f);
  }
  public void draw_wave(){
    arc(x, y, r+arcwave_ray, r+arcwave_ray, a, a+l*PI);
    arc(x, y, r+arcwave_ray, r+arcwave_ray, a+PI, a+PI+l*PI);
    l=l+(1-l)*0.002f;
    a+=m.move();
  }
}
  
class movement{
  float n,v,v2;
  movement(){
    n=0;v=PI/100;v2=random(0.01f,0.05f);
  }
  public float move(){
    n+=v;
    return cos(n)*v2;
  }
}

//////////////////////////////////////////
// Specific actions for the OutwardSpiral animation
//////////////////////////////////////////


public void outwardspiral_init() {
  outwardspiral_x = width/2;
  outwardspiral_y = height/2;
  outwardspiral_theta = 0; 
  outwardspiral_r = 0;
  
  background(0);
  frameRate(50);
  colorMode(RGB); 
}

public void draw_whiteoutwardspiral() {
 
  float outwardspiral_x = width/2 + outwardspiral_r * cos(outwardspiral_theta);
  float outwardspiral_y = height/2 + outwardspiral_r * sin(outwardspiral_theta);
 
  // Draw an ellipse at x,y
  noStroke();
  outwardspiral_c = PApplet.parseInt(0+(6*outwardspiral_theta));
  fill(outwardspiral_c);
  noStroke();
  // Adjust for center of window
  ellipse(outwardspiral_x, outwardspiral_y, 12, 12);
  // Increment the angle
  outwardspiral_theta += .3f;
  // Increment the radius
  outwardspiral_r += 0.3f;
 
}

public void draw_blueoutwardspiral() {
 
  float outwardspiral_x = width/2 + outwardspiral_r * cos(outwardspiral_theta);
  float outwardspiral_y = height/2 + outwardspiral_r * sin(outwardspiral_theta);
 
  // Draw an ellipse at x,y
  noStroke();
  outwardspiral_c = PApplet.parseInt(0+(6*outwardspiral_theta));
  fill(0,0,outwardspiral_c);
  noStroke();
  // Adjust for center of window
  ellipse(outwardspiral_x, outwardspiral_y, 12, 12);
  // Increment the angle
  outwardspiral_theta += .3f;
  // Increment the radius
  outwardspiral_r += 0.3f;
 
}

public void draw_redoutwardspiral() {
 
  float outwardspiral_x = width/2 + outwardspiral_r * cos(outwardspiral_theta);
  float outwardspiral_y = height/2 + outwardspiral_r * sin(outwardspiral_theta);
 
  // Draw an ellipse at x,y
  noStroke();
  outwardspiral_c = PApplet.parseInt(0+(6*outwardspiral_theta));
  fill(outwardspiral_c,0,0);
  noStroke();
  // Adjust for center of window
  ellipse(outwardspiral_x, outwardspiral_y, 12, 12);
  // Increment the angle
  outwardspiral_theta += .3f;
  // Increment the radius
  outwardspiral_r += 0.3f;
 
}

//////////////////////////////////////////
// Specific actions for the Columns animation
//////////////////////////////////////////

public void draw_columns() 
{
   noStroke();
   if (columns_shift == false) 
   {
     background(255);
     fill(0);
   }
   else {
     background(0);
     fill(255);   
   }
    
   //Left, or centerLeft column
   pushMatrix();
   if (NUMBER_OF_PANELS == 3)      {}
   else if (NUMBER_OF_PANELS == 5) {translate(width/NUMBER_OF_PANELS,0);}   
   
   if (columns_shift)
   {
     rect(columns_offsetx, columns_firsty - columns_firstheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight1);
   }
   rect(columns_offsetx, columns_firsty - columns_firstheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight2);
   rect(columns_offsetx, columns_firsty, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight1);
   rect(columns_offsetx, columns_firsty + columns_firstheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight2);
   rect(columns_offsetx, columns_firsty + columns_firstheight1 + columns_firstheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight1);
   rect(columns_offsetx, columns_firsty + 2*columns_firstheight1 + columns_firstheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight2); 
   
   popMatrix();
   
   
   //Center, and extreme columns
   if (NUMBER_OF_PANELS == 3) {
     for (int i=1; i<2;i++) {
       pushMatrix();
       translate(2*i*width/NUMBER_OF_PANELS,0);
       if (!columns_shift)
       { 
         rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       }
       rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_secondheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + 2*columns_secondheight1 + columns_secondheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2); 
       
       popMatrix();
     }   
   }
   else if (NUMBER_OF_PANELS == 5) {
     for (int i=0; i<3;i++) {
       pushMatrix();
       translate(2*i*width/NUMBER_OF_PANELS,0);
       if (!columns_shift)
       { 
         rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       }
       rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_secondheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + 2*columns_secondheight1 + columns_secondheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2); 
       
       popMatrix();
     }
   }
   
   
   //Right, or centerRight column
   pushMatrix();
   if (NUMBER_OF_PANELS == 3)      {translate((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);}
   else if (NUMBER_OF_PANELS == 5) {translate((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS,0);}   
   
   if (columns_shift)
   {
     rect(columns_offsetx, columns_thirdy - columns_thirdheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight1);
   }
   rect(columns_offsetx, columns_thirdy - columns_thirdheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight2);
   rect(columns_offsetx, columns_thirdy, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight1);
   rect(columns_offsetx, columns_thirdy + columns_thirdheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight2);
   rect(columns_offsetx, columns_thirdy + columns_thirdheight1 + columns_thirdheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight1);
   rect(columns_offsetx, columns_thirdy + 2*columns_thirdheight1 + columns_thirdheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight2); 
  
   popMatrix();
  
   //////////////////////////////////
   //Update positions
  
   if (columns_shift == true) {
     if (columns_firsty < columns_firstheight1 - height - 1)
     { columns_firsty = columns_firstheight1; }
     else
     { columns_firsty -= 1.2f; }
  
     if (columns_secondy > height + 1 - columns_secondheight1)
     { columns_secondy = -columns_secondheight1; }
     else
     { columns_secondy += 1.8f; }
     
     if (columns_thirdy < columns_thirdheight1 - height - 1)
     { columns_thirdy = columns_thirdheight1; }
     else
     { columns_thirdy -= 2.4f; }   
  
   }
   else {
     if (columns_firsty > height + 1 - columns_firstheight1)
     { columns_firsty = -columns_firstheight1; }
     else
     { columns_firsty += 1.2f; }
  
     if (columns_secondy < columns_secondheight1 - height - 1)
     { columns_secondy = columns_secondheight1; }
     else
     { columns_secondy -= 1.8f; }
     
     if (columns_thirdy > height + 1 - columns_thirdheight1)
     { columns_thirdy = -columns_thirdheight1; }
     else
     { columns_thirdy += 2.4f; }   
   }
}


public void draw_columnsred() 
{
   noStroke();
   if (columns_shift == false) 
   {
     background(255,0,0);
     fill(0);
   }
   else {
     background(0);
     fill(255,0,0);   
   }
    
   
   //Left, or centerLeft column
   pushMatrix();
   if (NUMBER_OF_PANELS == 3)      {}
   else if (NUMBER_OF_PANELS == 5) {translate(width/NUMBER_OF_PANELS,0);}   
   
   if (columns_shift)
   {
     rect(columns_offsetx, columns_firsty - columns_firstheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight1);
   }
   rect(columns_offsetx, columns_firsty - columns_firstheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight2);
   rect(columns_offsetx, columns_firsty, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight1);
   rect(columns_offsetx, columns_firsty + columns_firstheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight2);
   rect(columns_offsetx, columns_firsty + columns_firstheight1 + columns_firstheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight1);
   rect(columns_offsetx, columns_firsty + 2*columns_firstheight1 + columns_firstheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_firstheight2); 
   
   popMatrix();
   
   
   //Center, and extreme columns
   if (NUMBER_OF_PANELS == 3) {
     for (int i=1; i<2;i++) {
       pushMatrix();
       translate(2*i*width/NUMBER_OF_PANELS,0);
       if (!columns_shift)
       { 
         rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       }
       rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_secondheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + 2*columns_secondheight1 + columns_secondheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2); 
       
       popMatrix();
     }   
   }
   else if (NUMBER_OF_PANELS == 5) {
     for (int i=0; i<3;i++) {
       pushMatrix();
       translate(2*i*width/NUMBER_OF_PANELS,0);
       if (!columns_shift)
       { 
         rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       }
       rect(columns_offsetx, columns_secondy - columns_secondheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2);
       rect(columns_offsetx, columns_secondy + columns_secondheight1 + columns_secondheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight1);
       rect(columns_offsetx, columns_secondy + 2*columns_secondheight1 + columns_secondheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_secondheight2); 
       
       popMatrix();
     }
   }
   
   
   //Right, or centerRight column
   pushMatrix();
   if (NUMBER_OF_PANELS == 3)      {translate((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);}
   else if (NUMBER_OF_PANELS == 5) {translate((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS,0);}   
   
   if (columns_shift)
   {
     rect(columns_offsetx, columns_thirdy - columns_thirdheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight1);
   }
   rect(columns_offsetx, columns_thirdy - columns_thirdheight2 - columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight2);
   rect(columns_offsetx, columns_thirdy, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight1);
   rect(columns_offsetx, columns_thirdy + columns_thirdheight1 + columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight2);
   rect(columns_offsetx, columns_thirdy + columns_thirdheight1 + columns_thirdheight2 + 2*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight1);
   rect(columns_offsetx, columns_thirdy + 2*columns_thirdheight1 + columns_thirdheight2 + 3*columns_offsety, width/NUMBER_OF_PANELS-columns_offsetx*2,columns_thirdheight2); 
  
   popMatrix();
   
     
   if (columns_shift == true) {
     if (columns_firsty < columns_firstheight1 - height - 1)
     { columns_firsty = columns_firstheight1; }
     else
     { columns_firsty -= 1.2f; }
  
     if (columns_secondy > height + 1 - columns_secondheight1)
     { columns_secondy = -columns_secondheight1; }
     else
     { columns_secondy += 1.8f; }
     
     if (columns_thirdy < columns_thirdheight1 - height - 1)
     { columns_thirdy = columns_thirdheight1; }
     else
     { columns_thirdy -= 2.4f; }   
  
   }
   else {
     if (columns_firsty > height + 1 - columns_firstheight1)
     { columns_firsty = -columns_firstheight1; }
     else
     { columns_firsty += 1.2f; }
  
     if (columns_secondy < columns_secondheight1 - height - 1)
     { columns_secondy = columns_secondheight1; }
     else
     { columns_secondy -= 1.8f; }
     
     if (columns_thirdy > height + 1 - columns_thirdheight1)
     { columns_thirdy = -columns_thirdheight1; }
     else
     { columns_thirdy += 2.4f; }   
   }
}


//////////////////////////////////////////
// Specific actions for the CircleContour animation
//////////////////////////////////////////

public void draw_circlecontour() { 
  
  fill(0, 20);
  rect (0, 0, width, height);
   
  circlecontour_turn = circlecontour_turn + 1  ;
  if (circlecontour_turn > 200) {
    circlecontour_turn=0;
  }

  circlecontour_phase = circlecontour_phase + .01f;
  circlecontour_amp2 = circlecontour_amp2 + 0.1f;
  float spacing = TWO_PI/circlecontour_elements;
  translate(width*0.5f, height*0.5f);
  for (int i = 0; i < circlecontour_elements;i++) {
    stroke(144,130,137,200);
    strokeWeight(circlecontour_lineweight); 
    fill(244, 212, 220, 200);
    noFill();
    
    for (int j = 0; j < circlecontour_amp ;j++) {       
      rotate(-3*TWO_PI/(circlecontour_turn));

      line(sin(spacing*i+sin(360))*(sin(360)),
      sin(spacing*i)*(cos(spacing*i)*(circlecontour_amp*j)),
      (sin(spacing*i)*(circlecontour_amp*1.5f)),
      cos(spacing*(i))*(sin(spacing*(i)*circlecontour_phase)*(circlecontour_amp*1))
      );
    }
  }
}

//////////////////////////////////////////
// Specific actions for the ColorExplode animation
//////////////////////////////////////////

public void draw_colorexplode() {
  background(0,5);
  filter(INVERT);
  
  for(int i = 0; i < colorexplode_Z.length; i++) {
    if( colorexplode_intcounter < 200 ) {
      colorexplode_Z[i].gravitate( new colorexplode_particle( width/2, height/2, 0, 0, 1 ) );
      colorexplode_intcounter += 1;
    }
    else if( colorexplode_intcounter < 300  ) {
      colorexplode_Z[i].repel( new colorexplode_particle( width/2, height/2, 0, 0, 1 ) );
      colorexplode_intcounter += 1;  
    }
    else {
      colorexplode_Z[i].deteriorate();
    }
    colorexplode_Z[i].update();
    colorexplode_r = PApplet.parseFloat(i)/colorexplode_Z.length;
    stroke( colorexplode_colour, pow(colorexplode_r,0.1f)*255, (1.25f-colorexplode_r)*255, 0.7f*255);//Just a "touch" more vibrant. XD
    //stroke(colorexplode_colour);
    colorexplode_Z[i].display();
  }
    
  colorexplode_colour+=(1);
  if( colorexplode_colour > 255 ) {colorexplode_colour = colorexplode_colour %255;}
  
  filter(INVERT);
  loadPixels(); //copy window contents -> pixels[]==g.pixels[]
  fastSmallShittyBlur(g,g); //g=PImage of main window. Draws the results of the blur directly back to the main buffer.
}

public void fastSmallShittyBlur(PImage a, PImage b){ //a=src, b=dest img
  int pa[]=a.pixels;
  int pb[]=b.pixels;
  int h=a.height;
  int w=a.width;
  final int mask=(0xFF&(0xFF<<2))*0x01010101;
  for(int y=1;y<h-1;y++){ //edge pixels ignored
    int rowStart=y*w  +1;
    int rowEnd  =y*w+w-1;
    for(int i=rowStart;i<rowEnd;i++){
      pb[i]=(
        ( (pa[i-w]&mask) // sum of neighbours only, center pixel ignored
         +(pa[i+w]&mask)
         +(pa[i-1]&mask)
         +(pa[i+1]&mask)
        )>>2)
        |0x01010101 //alpha -> opaque
        ;
    }
  }
}
 

class colorexplode_particle {
   
 
  float x;
  float y;
  float px;
  float py;
  float magnitude;
  float angle;
  float mass;
  //declare these to save a tad bit of memory and performance.
  float F, mX, mY, A;
    
  colorexplode_particle( float dx, float dy, float V, float A, float M ) {
    x = dx;
    y = dy;
    px = dx;
    py = dy;
    magnitude = V;
    angle = A;
    mass = M;
  }
    
  public void reset( float dx, float dy, float V, float A, float M ) {
    x = dx;
    y = dy;
    px = dx;
    py = dy;
    magnitude = V;
    angle = A;
    mass = M;
  }
    
  public void gravitate( colorexplode_particle Z ) {
    if( sq( x - Z.x ) + sq( y - Z.y ) != 0 ) {
      F = mass * Z.mass;
      mX = ( mass * x + Z.mass * Z.x ) / ( mass + Z.mass );
      mY = ( mass * y + Z.mass * Z.y ) / ( mass + Z.mass );
      A = findAngle( mX - x, mY - y );
        
      mX = F * cos(A);
      mY = F * sin(A);
        
      mX += magnitude * cos(angle);
      mY += magnitude * sin(angle);
        
      magnitude = sqrt( sq(mX) + sq(mY) );
      angle = findAngle( mX, mY );
    }
  }
  
  public void repel( colorexplode_particle Z ) {
     
    if( sq( x - Z.x ) + sq( y - Z.y ) != 0 ) {
      F = mass * Z.mass;
      mX = ( mass * x + Z.mass * Z.x ) / ( mass + Z.mass );
      mY = ( mass * y + Z.mass * Z.y ) / ( mass + Z.mass );
      A = findAngle( x - mX, y - mY );
        
      mX = F * cos(A);
      mY = F * sin(A);
        
      mX += magnitude * cos(angle);
      mY += magnitude * sin(angle);
        
      magnitude = sqrt( sq(mX) + sq(mY) );
      angle = findAngle( mX, mY );
    }
  }
    
  public void deteriorate() {
    magnitude *= 0.995f;
  }
    
  public void update() {
    if(x<0||x>width) {magnitude*=-1;}//Bounces off
    if(y<0||y>height){magnitude*=-1;}//the edges of the screen.
    x += magnitude * cos(angle);
    y += magnitude * sin(angle);
      
  }
    
  public void display() {
    line(x, y, px, py);
    px = x;
    py = y;
  }
    
    
}
  
public float findAngle( float x, float y ) {
  float theta;
  if(x == 0) {
    if(y > 0) {
      theta = HALF_PI;
    }
    else if(y < 0) {
      theta = 3*HALF_PI;
    }
    else {
      theta = 0;
    }
  }
  else {
    theta = atan( y / x );
    if(( x < 0 ) && ( y >= 0 )) { theta += PI; }
    if(( x < 0 ) && ( y < 0 )) { theta -= PI; }
  }
  return theta;
}



//////////////////////////////////////////
// Specific actions for the ColorRain animation
//////////////////////////////////////////


public void draw_colorrain(){
  colorrain_cells.staticActivity();
  for(int i = 0; i < 2; i++)
  colorrain_cells.mouseAction();
  colorrain_cells.handle();
}


public class Cell{
  float locX, locY;
  float sizeX, sizeY;
  float cBrightness;
  float cHue;
   
  public Cell(float locX, float locY, float cHue, float sizeX, float sizeY){
    this.locX = locX;
    this.locY = locY;
    this.sizeX = sizeX;
    this.sizeY = sizeY;
    cBrightness = 0;
    this.cHue = cHue;
  }
   
  public void spark(){
    cBrightness = 255;
  }
  public void spark(float bright){
    cBrightness += bright;
  }
   
  public void handle(float degredation){
 
    cBrightness /= degredation;
    fill(cHue, 255, cBrightness);
    rect(locX, locY, sizeX, sizeY);
  }
}

public class colorrain_CellArray{
  float arrayWidth;
  float arrayHeight;
  float numVert;
  float numHoriz;
  Cell[][] colorrain_cells;
  int[] offset;
   
  public colorrain_CellArray(float arrayWidth, float arrayHeight, int numHoriz, int numVert){
    this.arrayWidth = arrayWidth;
    this.arrayHeight = arrayHeight;
    this.numVert = numVert;
    this.numHoriz = numHoriz;
     
    float cellHeight = arrayHeight/numVert;
    float cellWidth  = arrayWidth/numHoriz;
    colorrain_cells = new Cell[numHoriz][numVert];
    for(int i = 0; i < colorrain_cells.length; i++){
      for(int k = 0; k < colorrain_cells[0].length; k++){
        colorrain_cells[i][k] = new Cell(cellHeight*i, cellWidth*k, 100, cellWidth, cellHeight);
      }
    }
    offset = new int[numHoriz];
    for(int i = 0; i < offset.length; i++){
      offset[i] = (int)random(numVert);
    }
  }
   
  public void mouseAction(){
    for(int i = 0; i < colorrain_cells.length; i++){
      colorrain_cells[i][((frameCount/2)+offset[i])%colorrain_cells[0].length].spark();
    }
  }
   
  public void staticActivity(){
    for(int i = 0; i < colorrain_cells.length; i++){
      for(int k = 0; k < colorrain_cells[0].length; k++){
        colorrain_cells[i][k].spark(random(5));
      }
    }
  }
   
  public void handle(){
    for(int i = 0; i < colorrain_cells.length; i++){
      for(int k = 0; k < colorrain_cells[0].length; k++){
        colorrain_cells[i][k].handle(1.08f);
        colorrain_cells[i][k].cHue=255*abs(sin(frameCount*.005f));
      }
    }
  }
}


//////////////////////////////////////////
// Specific actions for the WarpSpeed animation
//////////////////////////////////////////

public void draw_warpspeed()
{
if((warpspeed_i++%2222)<1)
  for(warpspeed_y=0;warpspeed_y<height;warpspeed_y++)
    for(warpspeed_x=0;warpspeed_x<width;warpspeed_x++)
      set(warpspeed_x,warpspeed_y,(int)random(0xFCFCFC));
      filter(BLUR);
      warpspeed_b=4;
      blend(0,0,width,height,warpspeed_b,warpspeed_b,width-1-warpspeed_b-warpspeed_b,height-1-warpspeed_b-warpspeed_b,512);
      filter(DILATE);
      filter(ERODE);
  }
  
  
//////////////////////////////////////////
// Specific actions for the BWTriangles animation
//////////////////////////////////////////

public void draw_bwtriangles() {
  bwtriangles_particles.update();
}
 

public void createParticleSystem() {
  background(0);
  bwtriangles_particles = new ParticleSystem ();
  bwtriangles_particles.setBorderBounce(true, true, true, true);
 
  for (int i = 0; i < bwtriangles_nbrParticles; i ++) {
    BWTriangleParticle particle = new BWTriangleParticle(
    new PVector (random(8, width-20), random(8, height-20)),
    new PVector (random(-bwtriangles_vit, bwtriangles_vit), random(-bwtriangles_vit, bwtriangles_vit))                                      
      );
    bwtriangles_particles.addParticle(particle);
  }
}
 

public void verifDistance(int nbPart){
  if (bwtriangles_particles.traceTriangles) {
    //Verifier taille triangles / nombres de particules pour ne pas ralentir l'ordinateur
    if (nbPart<=70)bwtriangles_particles.distPoint = bwtriangles_boxDist;
    else if (nbPart>70 && nbPart <=130)bwtriangles_particles.distPoint = bwtriangles_boxDist * 0.8f;
    else if (nbPart>130 && nbPart <=300)bwtriangles_particles.distPoint = bwtriangles_boxDist * 0.6f;
    else bwtriangles_particles.distPoint = bwtriangles_boxDist * 0.4f;
  }
  else bwtriangles_particles.distPoint = bwtriangles_boxDist;
}



class BWTriangleParticle {
  PVector pos;
  public PVector vel;
  PVector acc;
  float max_vel = 800;
  float bounce = -1;
  int taille = 5;
  Boolean affBoules = true;
   

  BWTriangleParticle (PVector p, PVector v, PVector a, float _bounce) {
    pos = p.get();
    vel = v.get();
    acc = a.get();
    bounce = _bounce;
  }
   

  BWTriangleParticle (PVector p, PVector v, PVector a) {
    pos = p.get();
    vel = v.get();
    acc = a.get();
  }
   

  BWTriangleParticle (PVector p, PVector v) {
    pos = p.get();
    vel = v.get();
    acc = new PVector(0, 0);
  }
   

  BWTriangleParticle (PVector p) {
    pos = p.get();
    vel = new PVector(0, 0);
    acc = new PVector(0, 0);
  }
   
  public void update() {
    vel.add(acc);
    vel.limit(max_vel);
    pos.add(vel);
  }

  public void render(Boolean aff) {
    update();
    noStroke();
    fill(255,70);
    if (aff)ellipse (pos.x, pos.y, taille, taille);
  }
}


class ParticleSystem {
 
  ArrayList bwtriangles_particles;
  boolean ps_up, ps_right, ps_down, ps_left;
  ArrayList history;
 
  //DIFFERENTS PARAMETRES D AFFICHAGE
  Boolean traceTraits = false;
  Boolean traceTriangles = true;
  Boolean traceParticle = false;
  Boolean changeVit = false; 
 
  int nbBWTriangleParticle = 8;
  float bwtriangles_vitesse = 3;
  float shadowLevel = 255;
  float distPoint = 1;
  float contourTriangle = 10;

  ParticleSystem() {
    bwtriangles_particles = new ArrayList();
    history = new ArrayList();
  }

  ParticleSystem(PVector origine, int nbr) {
    bwtriangles_particles = new ArrayList();
    for (int i = 0; i < nbr; i++)bwtriangles_particles.add( new BWTriangleParticle(origine) );
  }
 

  ParticleSystem( PVector origine, PVector vel, int nbr) {
    bwtriangles_particles = new ArrayList();
    for (int i = 0; i < nbr; i++)bwtriangles_particles.add( new BWTriangleParticle(origine, vel) );
  }
 

  ParticleSystem( PVector origine, PVector vel, PVector acc, int nbr) {
    bwtriangles_particles = new ArrayList();
    for (int i = 0; i < nbr; i++)bwtriangles_particles.add( new BWTriangleParticle(origine, vel, acc) );
  }

  public void update() {
    history = new ArrayList();// on vide le tableau precedent
 
    fill(0, shadowLevel);
    rect(0, 0, width, height);
 
    //On  deplace les particules
    if (changeVit) {
      changeVit = false;
      for (int i = bwtriangles_particles.size()-1; i >= 0; i--) {
        BWTriangleParticle p = (BWTriangleParticle) bwtriangles_particles.get(i);
        PVector t = p.pos;
        history.add(t);
        border(p);
        p.vel = new PVector (random(-bwtriangles_vitesse, bwtriangles_vitesse), random(-bwtriangles_vitesse, bwtriangles_vitesse));
        p.render(traceParticle);
      }
    }
    else {
      for (int i = bwtriangles_particles.size()-1; i >= 0; i--) {
        BWTriangleParticle p = (BWTriangleParticle) bwtriangles_particles.get(i);
        PVector t = p.pos;
        history.add(t);
        border(p);
        p.render(traceParticle);
      }
    }
    verifTraits();//si on veut des traits entre les points
  }
   

  public void verifTraits() { //function pour tracer les traits entre les diff\u00e9rents points
    for (int i=0; i<history.size();i++) {
      ArrayList joints = new ArrayList();
      PVector t = (PVector) history.get(i);
 
      for (int q=0; q<history.size(); q++) {
        if (q != i) {
          PVector v = (PVector) history.get(q);
          float joinchance = q/history.size() + t.dist(v)/60;
          //stroke(255, 70);
 
          //On trace la ligne et on ajoute le point pour la verif triangle
          if (joinchance < distPoint) {
            //if (traceTraits)line(t.x, t.y, v.x, v.y);
            if (traceTriangles)joints.add(q);
          }
          //si la boucle est finit on verifie pour le point les triangles
          if (q == history.size()-1)if (joints.size()>=2)traceTriangle(i, joints);
        }
      }
    }
  }
 

  public void traceTriangle(int num, ArrayList joints) { //function pour tracer les triangles entre les points
    // num correspond au point trait\u00e9 au d\u00e9but & le array au diff\u00e9rents points avec lesquels il se racodent
    // On doit donc v\u00e9rifier si les diff\u00e9rents points se racordent entre eux
    PVector p = (PVector)history.get(num);
 
    for (int i=0; i<joints.size();i++) {
      int p1 = (Integer) joints.get(i);
      PVector t = (PVector)history.get(p1);
      for (int l = i+1; l<joints.size(); l++) {
        int p2 = (Integer) joints.get(l);
        PVector v = (PVector)history.get(p2);
        float joinchance = l/history.size() + t.dist(v)/60;
        if (joinchance < distPoint) {
          //stroke(255, 40);
          fill(255, 40);
          triangle(t.x, t.y, v.x, v.y, p.x, p.y);
        }
      }
    }
  }
 

  public void addParticle(BWTriangleParticle p) {
    bwtriangles_particles.add(p);
  }
 

  public void addParticles(int nb) {
    for (int i = 1; i<=nb ; i++) {
      BWTriangleParticle p = new BWTriangleParticle(new PVector (random(150, width-20), random(20, height-20)), new PVector (random(-bwtriangles_vit, bwtriangles_vit), random(-bwtriangles_vit, bwtriangles_vit)));
      bwtriangles_particles.add(p);
      nbBWTriangleParticle = bwtriangles_particles.size();
    }
  }
   

  public void removeParticles(int nb) {
    for (int i = 1; i <= nb; i++) {
      bwtriangles_particles.remove(i);
      nbBWTriangleParticle = bwtriangles_particles.size();
    }
  }
 

  public void setBorderBounce( boolean _up, boolean _right, boolean _down, boolean _left) {
    ps_up = _up;
    ps_right = _right;
    ps_down = _down;
    ps_left = _left;
  }
 

  public void border(BWTriangleParticle p) {
    if ( p.pos.x < 0 && ps_left ) p.vel.x*= p.bounce;
    if ( p.pos.x > width && ps_right ) p.vel.x*= p.bounce;
    if ( p.pos.y < 0 && ps_up ) p.vel.y*= p.bounce;
    if ( p.pos.y > height && ps_down ) p.vel.y*= p.bounce;
  }
}


//////////////////////////////////////////
// Specific actions for the GlitchDiagonalLines animation
//////////////////////////////////////////


public void draw_glitchdiagonallines() {
  background(0);
  for (int i = 0; i < glitchdiagonallines_num; i++) {
    glitchdiagonallines_particleArray[i].particleMove();
    glitchdiagonallines_particleArray[i].particleDisplay();
  }
}
 
class glitchdiagonallines_Particle {  
  int x;            
  int y;
 
  glitchdiagonallines_Particle(int tempX, int tempY) {       //constructor
    x = tempX;
    y = tempY;
  }
 
  public void particleDisplay() {   //function to that displays initial location of particle objects
    //noStroke();
    stroke(75,150,175, 200);
    fill(75, 150, 175, 200);
    //ellipse(x, y, 5, 7);
    line(x,y,y,x); 
}
  public void particleMove() {      //function that moves particle objects
    int choice = PApplet.parseInt(random(4));
 
    if (choice == 0) {         //particle objects move according random number generated before
      x = x + 1;
    }
    else if (choice == 1) {
      x = x - 1;
    }
    else if (choice == 2) {
      y = y + 1;
    }
    else {
      y = y - 1;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the FlashingDotsBorder animation
//////////////////////////////////////////

public void draw_flashingdotsborder () {
  background(0);
  
  update_position();
   
  for (int j=0; j<flashingdotsborder_y.length; j++) {
    for (int i=0; i<flashingdotsborder_x.length; i++) {        //create row for each flashingdotsborder_y-position
      //float r = width/24;
      fill(255);
      float r = ((width/(dist(flashingdotsborder_posx, flashingdotsborder_posy, flashingdotsborder_x[i], flashingdotsborder_y[j])+4))*(width/24));
      
      if (dist(flashingdotsborder_posx, flashingdotsborder_posy, flashingdotsborder_x[i], flashingdotsborder_y[j])<width/10) {    //check if the distance is minimal
        r = width/12 - 0.5f*dist(flashingdotsborder_posx, flashingdotsborder_posy, flashingdotsborder_x[i], flashingdotsborder_y[j])*(width/12);
        //r = width/8;
        fill(255);
      }
      

      noStroke();
      
      ellipse(flashingdotsborder_x[i], flashingdotsborder_y[j], r, r);              //draw circle at grid point
    }
  }
}

public void update_position() {
 if (flashingdotsborder_posx >= width && flashingdotsborder_posy > 0)
 {
   flashingdotsborder_posy-=1;  
 }
 else if (flashingdotsborder_posx > 0 && flashingdotsborder_posy <= 0)
 {
   flashingdotsborder_posx-=1;  
 }
 else if (flashingdotsborder_posx <= 0 && flashingdotsborder_posy < height)
 {
   flashingdotsborder_posy+=1;  
 }
 else if (flashingdotsborder_posx < width && flashingdotsborder_posy <= height)
 {
   flashingdotsborder_posx+=1;  
 }
}

//////////////////////////////////////////
// Specific actions for the FallingCircles animation
//////////////////////////////////////////
 
public void draw_fallingcircles() {
  fallingcircles_fadeOut(fallingcircles_fade); 
  fallingCircles.draw_fallingcircles();
  fallingCircles.clearInv();
}
 
public void fallingcircles_fadeOut(int fallingcircles_fade) {
  fill(0, 0, 0, fallingcircles_fade);
  noStroke();
   
  rect(0, 0, width, height);
}
 




class FallingCircle {
  int x;
  int y;
  int size;
   
  float phase;
  float freq;
  float rad;
  float v;
   
  float t, dt;
   
  int fcolor;
  int scolor;
 
  public FallingCircle() {
    x = (int) random(width);
    y = (int) - random(height);
    size = (int) random(4, 20);
     
    phase = random(0, PI);
    freq = random(0, 10);
    rad = random(5, 10);
    v = random(60, 180);
     
    fcolor = color(
      240 + random(0, 10),
      170 + random(0, 65),
      200 + random(0, 25),
      (int) random(3, 180)
    );
     
    scolor = color(
      240 + random(0, 10),
      140 + random(0, 55),
      200 + random(0, 50),
      25
    );
     
    t = 0;
    dt = 0.01f;
  }
   
  public void fallingcircle_draw(float T, boolean inverted) {
    int cx = (int) (x + rad * cos(freq * (t - phase)));
    int cy = (int) (y + v * t);
       
    calcColor(T, inverted);
    ellipse(cx, cy, size, size);
    fill(0, 0, 0, 180);
    ellipse(cx, cy, size-6, size-6);
     
    calcColor(T, inverted);
     
    t += dt;
     
    if (cy > height + size) t = 0;
  }
   
  public void calcColor(float T, boolean inverted) {
    fill(
      (hue(fcolor) + 127 * cos(0.3f * T)) % 256,
      saturation(fcolor),
      brightness(fcolor),
      alpha(fcolor)
    );
     
    if (inverted)
      stroke(0, 0, 0, 100 + alpha(fcolor));
    else
      noStroke();
  } 
}
 
class FallingCircles {
  FallingCircle[] FallingCircles;
  float t;
  float dt;
  boolean inverted;
 

  public FallingCircles(int count) {
    FallingCircles = new FallingCircle[count];
     
    for (int i = 0; i < FallingCircles.length; i++) {
      FallingCircles[i] = new FallingCircle();
    }
     
    // Set waktu = 0
    t = 0;
    dt = 0.01f;
     
    clearInv();
  }

  public void draw_fallingcircles() {
    for (int i = 0; i < FallingCircles.length; i++) {
      FallingCircles[i].fallingcircle_draw(t, inverted);
    }
     
    next();
  }
   
  public void next() {
    t += dt;
  }
   
  public void setInv() {
    inverted = true;
  }
   
  public void clearInv() {
    inverted = false;
  }
}

//////////////////////////////////////////
// Specific actions for the ExplodingParticles animation
//////////////////////////////////////////
 
public void draw_explodingparticles() {
  background(0);
  explodingparticle_asp++;
  for (int i=0;i<nbExplodingParticles;i++) {
    if (ExplodingParticles_explodeflag == true) {
      explodingparticle[i].cometogether();
    }
    else{
      explodingparticle[i].move();       
    }
  }
  for (int i=0;i<nbExplodingParticles;i++) {
    explodingparticle[i].trace();
  }
}


class ExplodingParticles {
  float x,px;
  float y,py;
  float a;
  float v;
  float d;
  int c;
  float numer;
  float denom;
 
  ExplodingParticles() {
    this.x=random(width);
    this.y=random(height);
    this.d=random(0,5);
    this.c=color(180,random(40,200),random(100,256));
    this.denom=100;
    this.numer=floor(random(denom));
  }
 
  public void move() {
    explodingparticle_asp=0;
    px=x;
    py=y;
    a=atan2(height/2-y,width/2-x);
    v=v*numer/denom;
    v+=(sqrt(sq(width/2-x)+sq(height/2-y))-((width+height)/d))*(denom-numer)/denom;
    x+=cos(a)*v;
    y+=sin(a)*v;
  }
 
  public void cometogether() {
    px=x;
    py=y;
    a=atan2(height/2-y,width/2-x);
    x+=4*cos(a)*(explodingparticle_asp);
    y+=4*sin(a)*(explodingparticle_asp);
  }
 
  public void trace() {
    stroke(c);
    line(x,y,px-(px-x)/2,py-(py-y)/2);
  }
}
 
//////////////////////////////////////////
// Specific actions for the RandomBWFlow animation
//////////////////////////////////////////



public void draw_randombwflow() {
  fill(0);
  rect(0, 0, width, height);
  int zoom = min(width / randomBWFlow_resolutionX, height / randomBWFlow_resolutionY);
   
  for (int y = 0; y < randomBWFlow_resolutionY; y ++) {
    for (int x = 0; x < randomBWFlow_resolutionX; x ++) {
      randomBWFlow_density[x][y] = 0;
    }
  }
   
  // RandomBWFlowParticles?
  stroke(255);
  for (int i = 0; i < randomBWFlow_particleCount; i ++) {
    bwflowparticle[i].Update();
    //bwflowparticle[i].Draw(zoom);
  
  }
   
  noStroke();
  for (int y = 0; y < randomBWFlow_resolutionY; y ++) {
    for (int x = 0; x < randomBWFlow_resolutionX; x ++) {
//      fill(
//        min(255, int(255 * abs(randomBWFlow_flow[x][y].x) / 0.2)),
//        min(255, int(255 * abs(randomBWFlow_flow[x][y].y / 0.2))),
//        int(max(0, min(255, 255 * randomBWFlow_density[x][y]))));
//      println(randomBWFlow_flow[x][y].x + "  -  " + randomBWFlow_flow[x][y].y + " ------ " + noise(0.01*randomBWFlow_flow[x][y].x,0.01*randomBWFlow_flow[x][y].y));
      fill(
        map(noise(0.4f*randomBWFlow_flow[x][y].x * width,0.4f*randomBWFlow_flow[x][y].y * height),0,1,110,220),120,
        PApplet.parseInt(max(0, min(180, 180 * randomBWFlow_density[x][y]))));
        

      rect(x * zoom, y * zoom, zoom, zoom);
    }
  }
   
  // Randomization of randomBWFlow_flow
  randomBWFlow_flow[PApplet.parseInt(random(randomBWFlow_resolutionX))][PApplet.parseInt(random(randomBWFlow_resolutionY))]
    = new PVector(-1 + random(2), -1 + random(2));
     
  // Painting
  int cellX = PApplet.parseInt(map(cos(frameCount*randomBWFlow_varSpeed),-1,1, 0, width));

  int cellY = PApplet.parseInt(map(sin(frameCount*randomBWFlow_varSpeed),-1,1, 0, height)); 
   
  float dX = cellX - randomBWFlow_oldMouseX;
  float dY = cellY - randomBWFlow_oldMouseY;
  for (int y = -8; y < 8; y ++) {
    for (int x = -8; x < 8; x ++) {
      randomBWFlow_flow[max(0, min(randomBWFlow_resolutionX - 1, cellX + x))]
        [max(0, min(randomBWFlow_resolutionY - 1, cellY + y))].add
        (new PVector(dX, dY));
    }
  }
  randomBWFlow_oldMouseX = cellX;
  randomBWFlow_oldMouseY = cellY;
  
  if (randomBWFlow_alpha > 0) {
    fill(0,randomBWFlow_alpha);
    rect(0,0,width,height);
    randomBWFlow_alpha -= 5;
  }
}


class RandomBWFlowParticle {
 
  PVector position;
  PVector velocity;
  int timer;
 
 
  RandomBWFlowParticle (float x, float y) {
    position = new PVector(x, y);
    // velocity = new PVector();
    velocity = new PVector(0.01f - random(0.02f), 0.01f - random(0.02f));
    timer = PApplet.parseInt(random(120));
  }
 
 
  public void Update() {
    int cellX = PApplet.parseInt(position.x);
    int cellY = PApplet.parseInt(position.y);
 
 
    randomBWFlow_flow[cellX][cellY].x = randomBWFlow_flow[cellX][cellY].x * 0.95f + velocity.x * 0.05f;
    randomBWFlow_flow[cellX][cellY].y = randomBWFlow_flow[cellX][cellY].y * 0.95f + velocity.y * 0.05f;
    randomBWFlow_density[cellX][cellY] += 0.1f;
    randomBWFlow_flow[cellX][cellY].limit(1);
 
    velocity.x += 0.2f * randomBWFlow_flow[cellX][cellY].x;
    velocity.y += 0.2f * randomBWFlow_flow[cellX][cellY].y;
    //velocity.y += 0.01 * randomBWFlow_wind[cellY];
 
    velocity.mult(0.9f);
 
    position.x = (position.x + velocity.x + randomBWFlow_resolutionX) % randomBWFlow_resolutionX;
    position.y = (position.y + velocity.y + randomBWFlow_resolutionY) % randomBWFlow_resolutionY;
 
    timer ++;
    if (timer > 240) {
      timer = PApplet.parseInt(random(120));
      position = new PVector(random(randomBWFlow_resolutionX),
      random(randomBWFlow_resolutionY));
      velocity = new PVector(-1 + random(2), -1 + random(2));
    }
  }
 
 
  public void Draw(float zoom) {
    stroke(0, min(255, PApplet.parseInt(255 * abs(velocity.x) / 0.2f)),
      min(255, PApplet.parseInt(255 * abs(velocity.y / 0.2f))));
    line(zoom * position.x, zoom * position.y,
    zoom * (position.x + velocity.x),
    zoom * (position.y + velocity.y));
  }
}

//////////////////////////////////////////
// Specific actions for the Tesselate animation
//////////////////////////////////////////

public void draw_tesselate()
{
   
  tesselate_size_b = 48 * tesselate_size_point_x/width;
  tesselate_size_a = 48 - tesselate_size_b;
  if (tesselate_cont == tesselate_size_time_den)
    tesselate_size_dir = -1;
  if (tesselate_cont == 0)
    tesselate_size_dir = 1;
  tesselate_cont += tesselate_size_dir; 
   
  rectMode(CENTER);
  background(0);
   
  // Heart of the animation
  pushMatrix();
  translate(width/2,height/2);
  rotate(-tesselate_cont*PI/tesselate_size_time_den);
  for (int i=0; i<4; i++)
  {
    rotate(PI/2);
    pushMatrix();
    translate(-tesselate_size_b/2,-tesselate_size_b/2);
    rotate(3*PI/2 + tesselate_cont*PI/tesselate_size_time_den);
    drawSquare(-tesselate_size_a/2,-tesselate_size_a/2,tesselate_size_a,tesselate_size_a,tesselate_SMALL);
    translate(-tesselate_size_a,-tesselate_size_a);
    rotate(PI/2 - tesselate_cont*PI/tesselate_size_time_den);
    translate(-tesselate_size_b,0);
    drawSquare(tesselate_size_b/2,-tesselate_size_b/2,tesselate_size_b,tesselate_size_b,tesselate_BIG);
    rotate(-3*PI/2 + tesselate_cont*PI/tesselate_size_time_den);
    translate(0,-tesselate_size_a);
    drawSquare(tesselate_size_a/2,tesselate_size_a/2,tesselate_size_a,tesselate_size_a,tesselate_SMALL);
    rotate(-PI/2 - tesselate_cont*PI/tesselate_size_time_den);
    drawSquare(tesselate_size_b/2,tesselate_size_b/2,tesselate_size_b,tesselate_size_b,tesselate_BIG);
    translate(0,tesselate_size_b);
    rotate(-3*PI/2 + tesselate_cont*PI/tesselate_size_time_den);
    drawSquare(tesselate_size_a/2,-tesselate_size_a/2,tesselate_size_a,-tesselate_size_a,tesselate_SMALL);
    translate(0,tesselate_size_b);
    popMatrix();
  }
  drawSquare(0,0,tesselate_size_b,tesselate_size_b,tesselate_BIG);
  popMatrix();
  rectMode(CORNER);    //Reinitialize rectMode for other functions
  
}
 
// Draw a Square given its coordinates
// The last parameter identify the kind of Square (BIG or SMALL)
public void drawSquare(float x1, float y1, float x2, float y2, int index)
{
  fill(tesselate_palette[index+2*tesselate_size_c_pal]);
  rect(x1, y1, x2, y2);
}

//////////////////////////////////////////
// Specific actions for the DigitalHexParticles animation
//////////////////////////////////////////

public void draw_digitalhexparticles(){
  if (digitalhexparticleSystem.digitalparticles.size() < 6 ) {
    for (int i = 0; i < random(30,80); i++) {
      digitalhexparticleSystem.digitalparticles.add(new DigitalParticle());
    }
  }
  digitalhexparticleSystem.update();
  digitalhexparticleSystem.render();
}
 

class DigitalHexParticleSystem {
  ArrayList digitalparticles;
  float z = random(6);
    
  DigitalHexParticleSystem(int initialNumber) {
    digitalparticles = new ArrayList(initialNumber);
    for(int i = 0; i < initialNumber; i++) {
      digitalparticles.add(new DigitalParticle());
    }
    for(int i = 0; i < digitalparticles.size()-1; i++) {
      DigitalParticle digitalparticle = (DigitalParticle)digitalparticles.get(i);
      digitalparticle.position.z = z;
    }
  }
    
  public void update() {
    for(int i = 0; i < digitalparticles.size()-1; i++) {
      DigitalParticle digitalparticle = (DigitalParticle)digitalparticles.get(i);
      if (digitalparticle.lifetime > 0) {
        digitalparticle.update();
      }
      else {
        //remove particle
        digitalparticles.remove(i);
      }
    }
  }
    
  public void render() {
    for(int i = 0; i < digitalparticles.size() - 1; i++) {
      DigitalParticle digitalparticle = (DigitalParticle)digitalparticles.get(i);
      digitalparticle.render();
    }
  }
}
 
 
class DigitalParticle {
  PVector position, velocity;
  int particleColor = 255;
  int lifetime = floor(random(3000));
 
  DigitalParticle()
  {
    position = new PVector(random(width),random(height),0);
    velocity = new PVector();
  }
    
  public void update() {
    float angle = radians(60*floor(6*noise(0.05f*position.x,0.05f*position.y,0.1f*position.z)));
    velocity.x = 1.2f*cos(angle);
    velocity.y = 1.2f*sin(angle);
    position.add(velocity);
    lifetime--;
 
    //deal with edge cases    
    if (position.x<0) {
       position.x+=width;
    }
 
    if (position.x>width) {
       position.x-=width;
    }
 
    if (position.y<0) {
       position.y+=height;
    }
 
    if (position.y>height) {
       position.y-=height;
    }
  }
  
  public void render() {
    stroke(0,particleColor,0,16);
    line(position.x,position.y,position.x-velocity.x,position.y-velocity.y);
  }
}


//////////////////////////////////////////
// Specific actions for the RedArcTransition and BlueArcTransition animations
//////////////////////////////////////////


public void draw_redarctransition(){
   
  line(redarctransition_topleftx,redarctransition_toplefty-((width-height)/2),redarctransition_toprightx,redarctransition_toprighty-((width-height)/2));
  redarctransition_toplefty = redarctransition_toplefty + redarctransition_increment;
  redarctransition_toprightx = redarctransition_toprightx - redarctransition_increment;
  line(redarctransition_x1,redarctransition_y1-((width-height)/2),redarctransition_x2,redarctransition_y2-((width-height)/2));
  redarctransition_y1 = redarctransition_y1 + redarctransition_increment;
  redarctransition_x2 = redarctransition_x2 + redarctransition_increment;
  line(redarctransition_x21,redarctransition_y21-((width-height)/2),redarctransition_x22,redarctransition_y22-((width-height)/2));
  redarctransition_x21 = redarctransition_x21 + redarctransition_increment;
  redarctransition_y22 = redarctransition_y22 + redarctransition_increment;
  line(redarctransition_bottomtopx,redarctransition_bottomtopy-((width-height)/2),redarctransition_bottomdownx,redarctransition_bottomdowny-((width-height)/2));
  redarctransition_bottomtopy = redarctransition_bottomtopy - redarctransition_increment;
  redarctransition_bottomdownx = redarctransition_bottomdownx + redarctransition_increment;
}


//////////////////////////////////////////
// Specific actions for the LightBlobs animation
//////////////////////////////////////////

public void draw_lightblobs() { 
  for (int i=0; i<lightblobs_numBlobs-1; ++i) {
    lightblobs_b[i].update(i); 
  }
   
 // Output into a buffered image for reuse
 lightblobs_pg.loadPixels();
 for (int y=0; y<lightblobs_h; y++) 
 {
   for (int x=0; x<lightblobs_w; x++) 
   { 
     int m = 1;
       for (int i=0; i <lightblobs_numBlobs-1; i++) {
         // Increase this number to make your blobs bigger
         m += lightblobs_b[i].getbs()*1000/(lightblobs_b[i].bx[x] + lightblobs_b[i].by[y] + 1); }
         lightblobs_pg.pixels[x+y*lightblobs_w] = color(255-dist(x,y,width*.5f,height*.5f), m+dist(x,y,width*.5f,height*.5f)*.3f, (x+m+y)*lightblobs_scale); //in HSB mode: color((m+x+y),255,255);
   } 
 } 
 lightblobs_pg.updatePixels();
  
 // Display the results
image(lightblobs_pg,0,0,width,height);
}
  
  
class lightblobs_Blob {
 float blobsize;
 float force=.001f;
 float fluid=.0005f;
 float forcerad=120;
 float x,y, vx,vy;
 int[] bx,by;
 
 public float getx() { return x; } 
 public float gety() { return y; } 
 public float getbs() { return blobsize; }
 
 lightblobs_Blob(float x, float y, float vx, float vy, float bs) {
   this.x = x;
   this.y = y;
   this.vx = vx;
   this.vy = vy;
   this.bx = new int[lightblobs_w];
   this.by = new int[lightblobs_h];
   blobsize=bs;
 }
   
 public void update(int num) {
   x+=vx; y+=vy;
   vx*=.995f;vy*=.99f;
   if (x<blobsize*.5f || x>lightblobs_w-blobsize*.5f) vx=-vx*.9f;
   if (y<blobsize*.5f || y>lightblobs_h-blobsize*.5f) vy=-vy*.9f;
   
   for (int i=0; i<lightblobs_w; i++) bx[i] = PApplet.parseInt(sq(x-i));
   for (int i=0; i<lightblobs_h; i++) by[i] = PApplet.parseInt(sq(y-i));
   
  lightblobs_Blob bi = (lightblobs_Blob) lightblobs_b[(num+1)];
  
 float tx = bi.getx();float ty = bi.gety();
 float radius = dist(x, y, tx, ty);
if (radius < blobsize*11) {float ang = atan2(ty-y, tx-x); vx += radius * fluid * cos(ang); vy += radius * fluid * sin(ang);
if (radius < blobsize*.5f) { vx -= radius * fluid*3 * cos(ang); vy -= radius * fluid*3 * sin(ang); }
} }}


//////////////////////////////////////////
// Specific actions for the RandomSmokeParticles animation
//////////////////////////////////////////

public void draw_randomsmokeparticles() {
  clear_smoke(smokeparticles_t);
   
  random(smokeparticles_seed);
   
  for (int i = 0; i < smokeparticles_count; i++) {
    smokeparticle(smokeparticles_t);
  }

  smokeparticles_t += smokeparticles_dt;
  filter(GRAY);
}
 
public void smokeparticle(float t) {
   
  float x = random(-1, 1);
  float y = random(-1, 1);

  float a = atan2(y, x);
   
  float xx = x * cos(t - y);
  float yy = sin(y * t);
  float aa = atan2(yy, xx);
   
   
  stroke(
    (aa - a + TWO_PI * 100) % 255,
    255,
    0,
    (0.1f + 0.1f * cos(aa + t))*255
  );
   
  float d;
  d = 1 + 5 * dist(xx, yy, 0, 0);
  strokeWeight(d);
   
  float spin = random(-smokeparticles_spinSpeed, smokeparticles_spinSpeed) * t + random(0, PI);
   
  float px = map(xx, -1, 1, 0, width);
  float py = map(yy, -1, 1, 0, height);
   
  line(
    px - d * cos(spin),
    py - d * sin(spin),
    px + d * cos(spin),
    py + d * sin(spin)
  );
}
 
public void clear_smoke(float t) {
  noStroke();
  fill(t/3 % 255, 13, 255, 13);
  rect(0, 0, width, height);
}


//////////////////////////////////////////
// Specific actions for the RedMetaBalls animation
//////////////////////////////////////////


public void draw_redmetaballs() {
  for (int i=0; i<redmetaballs_numBlobs; ++i) {
    redmetaballs_b[i].update();
  }
   
  // Output into a buffered image for reuse
  redmetaballs_pg.beginDraw();
  redmetaballs_pg.loadPixels();
  for (int y=0; y<redmetaballs_h; y++) {
    for (int x=0; x<redmetaballs_w; x++) {
      int m = 1;
      for (int i=0; i <redmetaballs_numBlobs; i++) {
        // Increase this number to make your blobs bigger
        m += 20000/(redmetaballs_b[i].bx[x] + redmetaballs_b[i].by[y] + 1);
      }
      redmetaballs_pg.pixels[x+y*redmetaballs_w] = color(0, m+x, (x+m+y)/2); //in HSB mode: color((m+x+y),255,255);
    }
  }
  redmetaballs_pg.updatePixels();
  redmetaballs_pg.endDraw();
 
  // Display the results
  image(redmetaballs_pg, 0, 0, width, height);
}


class redmetaballs_Blob {
  float x,y;
  float vx,vy;
  int[] bx,by;
   
  redmetaballs_Blob(float x, float y, float vx, float vy) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.bx = new int[redmetaballs_w];
    this.by = new int[redmetaballs_h];
  }
   
  public void update() {
    x+=vx;
    y+=vy;
     
    if (x<0 || x>redmetaballs_w) vx=-vx;
    if (y<0 || y>redmetaballs_h) vy=-vy;
     
    for (int i=0; i<redmetaballs_w; i++) bx[i] = PApplet.parseInt(sq(x-i));
    for (int i=0; i<redmetaballs_h; i++) by[i] = PApplet.parseInt(sq(y-i));
  }
}


//////////////////////////////////////////
// Specific actions for the Butterfly animation
//////////////////////////////////////////


public void draw_butterfly() {
  translate(width/2, height/2 + height/16);
  butterfly_p=butterfly_t+butterfly_formFactor;
  butterfly_k = exp(cos(butterfly_t)) - 2*cos(4*butterfly_t) - pow(sin(butterfly_t/12), 5.0f);
  butterfly_l = exp(cos(butterfly_p)) - 2*cos(4*butterfly_p) - pow(sin(butterfly_p/12), 5.0f);
  butterfly_x = sin(butterfly_t)*butterfly_k*butterfly_s;
  butterfly_y = -cos(butterfly_t)*butterfly_k*butterfly_s;
  butterfly_x2 = sin(butterfly_p)*butterfly_l*butterfly_s;
  butterfly_y2 = -cos(butterfly_p)*butterfly_l*butterfly_s;
  butterfly_x3 = sin(-butterfly_t)*butterfly_k*butterfly_s;
  butterfly_y3 = -cos(-butterfly_t)*butterfly_k*butterfly_s;
  butterfly_x4 = sin(-butterfly_p)*butterfly_l*butterfly_s;
  butterfly_y4 = -cos(-butterfly_p)*butterfly_l*butterfly_s;
  butterfly_a1 = butterfly_s*1.62f+ cos(butterfly_t)*(butterfly_s/3);
  butterfly_b1 = -butterfly_s*1.78f+ sin(butterfly_t)*(butterfly_s/3);
  butterfly_a2 = butterfly_s*1.62f+ cos(butterfly_p*2)*(butterfly_s/3);
  butterfly_b2 = -butterfly_s*1.78f+ sin(butterfly_p*2)*(butterfly_s/3);
  butterfly_a3 = -butterfly_s*1.62f- cos(butterfly_t)*(butterfly_s/3);
  butterfly_b3 = -butterfly_s*1.78f- sin(-butterfly_t)*(butterfly_s/3);
  butterfly_a4 = -butterfly_s*1.62f- cos(butterfly_p*2)*(butterfly_s/3);
  butterfly_b4 = -butterfly_s*1.78f- sin(-butterfly_p*2)*(butterfly_s/3);
  stroke(dist(butterfly_x, butterfly_y, 0, 0), 0, 255, 4000/dist(butterfly_x, butterfly_y, 0, 0));
  line(butterfly_x*butterfly_scale, butterfly_y*butterfly_scale, 0, 0);
  stroke(0, 0, 10*dist(butterfly_x3, butterfly_y3, 0, 0), 4000/dist(butterfly_x3, butterfly_y3, 0, 0));
  line(butterfly_x3*butterfly_scale, butterfly_y3*butterfly_scale, 0, 0);
  stroke(0, 10*dist(butterfly_x3, butterfly_y3, butterfly_x4, butterfly_y4), 255, 1000/dist(butterfly_x3, butterfly_y3, butterfly_x4, butterfly_y4));
  line(butterfly_x3*butterfly_scale, butterfly_y3*butterfly_scale, butterfly_x4*butterfly_scale, butterfly_y4*butterfly_scale);   
  stroke(10*dist(butterfly_x, butterfly_y, butterfly_x2, butterfly_y2), 0, 255, 1000/dist(butterfly_x, butterfly_y, butterfly_x2, butterfly_y2));
  line(butterfly_x*butterfly_scale, butterfly_y*butterfly_scale, butterfly_x2*butterfly_scale, butterfly_y2*butterfly_scale);
  stroke(255, 10*dist(butterfly_a1, butterfly_b1, butterfly_a2, butterfly_b2), 0, 200/dist(butterfly_a1, butterfly_b1, butterfly_a2, butterfly_b2));
  line(butterfly_a1*butterfly_scale, butterfly_b1*butterfly_scale, butterfly_a2*butterfly_scale, butterfly_b2*butterfly_scale);
  stroke(255, 10*dist(butterfly_a3, butterfly_b3, butterfly_a4, butterfly_b4), 0, 200/dist(butterfly_a3, butterfly_b3, butterfly_a4, butterfly_b4));
  line(butterfly_a3*butterfly_scale, butterfly_b3*butterfly_scale, butterfly_a4*butterfly_scale, butterfly_b4*butterfly_scale);
  butterfly_t+=butterfly_speedFactor;
}


//////////////////////////////////////////
// Specific actions for the CirclePusher animation
//////////////////////////////////////////


public void circlepusher_initialize_circles() {

  //Initialize circle data arrays
  circlepusher_loc = new PVector[circlepusher_num];
  circlepusher_rad = new float[circlepusher_num];
  
  // Generate the circles
  for(int i=0;i<circlepusher_num;i++){
    circlepusher_loc[i] = new PVector();
    circlepusher_rad[i] = 0;
  }
  for(int i=0;i<circlepusher_num;i++){
    circlepusher_getCircle(i);
  }
  
}

public void draw_circlepusher(){
  
//  pushStyle();
//  rectMode(CENTER);
  background(0);
  strokeWeight(1);
  noStroke();

  for(int i=0;i<circlepusher_num;i++){
    ellipse(width/2+circlepusher_loc[i].x,height/2+circlepusher_loc[i].y,2*circlepusher_rad[i],2*circlepusher_rad[i]);
    
    //rect(width/2+circlepusher_loc[i].x,height/2+circlepusher_loc[i].y,2*circlepusher_rad[i],2*circlepusher_rad[i]);
//    pushMatrix();
//    translate(width/2,height/2);
//    rotate(atan2(circlepusher_loc[i].y,circlepusher_loc[i].x));
//    rect(circlepusher_loc[i].x,circlepusher_loc[i].y,2*circlepusher_rad[i],circlepusher_rad[i]);
//    popMatrix();
    
    float circlepusher_angle;
    if (circlepusher_setAngleRotate) {
      circlepusher_angle = atan2(circlepusher_loc[i].y,circlepusher_loc[i].x)+((width/3)*10)*PI/10000;
    }
    else {
      circlepusher_angle = atan2(circlepusher_loc[i].y,circlepusher_loc[i].x);
    }
    // find the circles location and expand it at the magnification rate
    float circlepusher_distance = mag(circlepusher_loc[i].y,circlepusher_loc[i].x)*circlepusher_rate;
    // recombine the location from polar to cartesian coordinates
    circlepusher_loc[i] = new PVector(circlepusher_distance*cos(circlepusher_angle),circlepusher_distance*sin(circlepusher_angle));
    // expand the circle size by the magnification rate
    circlepusher_rad[i]*=circlepusher_rate;
    // if the circle has grown to be not visible on the screen
    if(circlepusher_loc[i].mag()-circlepusher_rad[i]>mag(width/2,height/2)){
      // reset the circle to be a new one
      circlepusher_getCircle(i);
    }
  }
  
}


public void circlepusher_getCircle(int i){
  // This method makes a new circle that does not overlap any other circle
  // Only make 10000 attempts, else give up
  int circlepusher_attempt = 0;
  // stop makeing attempts when a good circle is found
  boolean circlepusher_solution = false;
  while(circlepusher_attempt<10000 && circlepusher_solution==false){
    circlepusher_attempt++;
    // Make a circle so small it isnt visible
    float circlepusher_newRad = random(0,0.2f);

    // Generate a circle very close to the center of the screen
    float circlepusher_distance = random(0,0.4f);
    
    // Do not make a circle that envelops the center of the screen because it would expand to envelop the entire screen
    if(circlepusher_distance>circlepusher_newRad){
      // Make a circle with uniform probability density over angular coordinate
      float circlepusher_angle = random(0,TWO_PI);
      // Combine the location from polar to cartesian coordinates
      PVector circlepusher_newLoc = new PVector(circlepusher_distance*cos(circlepusher_angle),circlepusher_distance*sin(circlepusher_angle));
      // Test to see if the new circle is on top of any of the existing ones
      boolean circlepusher_intersection = false;
      for(int j=0;j<circlepusher_num;j++){
        // If the circle being tested is its self don't do the test
        if(i!=j){
          // Find the relative location of two circles
          PVector circlepusher_delta = PVector.sub(circlepusher_newLoc,circlepusher_loc[j]);
          // If the magnitude of their relative location is less than the sum of their radiuses
          if(circlepusher_delta.mag()<circlepusher_newRad+circlepusher_rad[j]){
            // Then they are overlapping
            circlepusher_intersection = true;
          }
        }
      }
      // If the new circle is not overlapping with any of the old ones
      if(circlepusher_intersection==false){
        // Stop making attempts
        circlepusher_solution = true;
        // Set the circle to the new circle params
        circlepusher_loc[i] = circlepusher_newLoc.get();
        circlepusher_rad[i] = circlepusher_newRad;
      }
    }
  }
}


//////////////////////////////////////////
// Specific actions for the Shutter animation
//////////////////////////////////////////

public void draw_shutter() {
  pushStyle();
  rectMode(CENTER);
  
  PGraphics temp = createGraphics(width,height);
  temp.beginDraw();
  
  temp.background(0);
  temp.noStroke();  
  temp.fill(255); 
  temp.pushMatrix();
  temp.translate(width/2,height/2);
  temp.ellipse(0,0,5,5);
  temp.rotate(shutter_angle*PI);
  temp.triangle(-5,-5, -shutter_distance/2 - 2, shutter_distance/sqrt(2), shutter_distance/2 + 2, shutter_distance/sqrt(2));   
  temp.rotate(2*PI/5);
  temp.triangle(-5,-5, -shutter_distance/2 - 2, shutter_distance/sqrt(2), shutter_distance/2 + 2, shutter_distance/sqrt(2));
  temp.rotate(2*PI/5);
  temp.triangle(-5,-5, -shutter_distance/2 - 2, shutter_distance/sqrt(2), shutter_distance/2 + 2, shutter_distance/sqrt(2));
  temp.rotate(2*PI/5);
  temp.triangle(-5,-5, -shutter_distance/2 - 2, shutter_distance/sqrt(2), shutter_distance/2 + 2, shutter_distance/sqrt(2));
  temp.rotate(2*PI/5);
  temp.triangle(-5,-5, -shutter_distance/2 - 2, shutter_distance/sqrt(2), shutter_distance/2 + 2, shutter_distance/sqrt(2));
  temp.popMatrix();
    
  temp.endDraw();  
  
  loadPixels();
  temp.loadPixels();
  if (shutter_colorMode == 0){
    for (int i=0; i<pixels.length; i++) {
      if (temp.pixels[i] != -1) {
        pixels[i] = color(255);
      }
    }
  }
  else if (shutter_colorMode == 1){
    for (int i=0; i<pixels.length; i++) {
      if (temp.pixels[i] != -1) {
        pixels[i] = color(0);
      }
    }
  }
  else if (shutter_colorMode == 2){
    for (int i=0; i<pixels.length; i++) {
      if (temp.pixels[i] != -1) {
        pixels[i] = color(255,0,0);
      }
    }
  }
  updatePixels();

  shutter_angle += shutter_angleIncrement;
  if (shutter_distance > shutter_distanceLimit) {
    shutter_distance -= shutter_speedIncrement; 
  }
  else {
    shutter_colorMode = (shutter_colorMode + 1) % 3;
    shutter_distance = shutter_distanceInit;
  }
  
  popStyle();
}

//////////////////////////////////////////
// Specific actions for the OrbitingParticles animation
//////////////////////////////////////////

public void orbitingparticles_changefocus() {
  orbitingparticles_state ++;
  if (orbitingparticles_state % 5 == 0) {
    orbitingparticles_globalx = width/2;
    orbitingparticles_globaly = height/2;
  }
  else if (orbitingparticles_state % 5 == 1) {
    orbitingparticles_globalx = width/6;
    orbitingparticles_globaly = height/6;
  }
  else if (orbitingparticles_state % 5 == 2) {
    orbitingparticles_globalx = 5*width/6;
    orbitingparticles_globaly = height/6;
  }
  else if (orbitingparticles_state % 5 == 3) {
    orbitingparticles_globalx = width/6;
    orbitingparticles_globaly = 5*height/6;
  }
  else {
    orbitingparticles_globalx = 5*width/6;
    orbitingparticles_globaly = 5*height/6;
  }

}

public void draw_orbitingparticles() {
  background(0);
  for (int i = 0; i< orbitingparticles_number;i++) { 
    stroke(orbitingparticles_particlelist[i].particleColor);
    orbitingparticles_particlelist[i].draworbitingparticles();
    orbitingparticles_particlelist[i].moveorbitingparticles();
  }  
}


class OrbitingParticle {
 
 float x, y, dispersion, speed;
 float dx, dy;
 int particleColor;
  
 OrbitingParticle(float x, float y, float dispersion, float speed, int col) {
  this.x = x;
  this.y = y;
  this.dispersion = dispersion;
  this.speed = speed;
  this.dx = random(-this.dispersion,this.dispersion);
  this.dy = random(-this.dispersion,this.dispersion);
  this.particleColor = col;
 } 
 
 public void draworbitingparticles() {
   point(this.x, this.y);
 }
 
 public void moveorbitingparticles() {
   this.x += dx;
   this.y += dy;
   
   float distance = dist(this.x, this.y, orbitingparticles_globalx, orbitingparticles_globaly);

   if (dist(this.x + dx, this.y + dy, orbitingparticles_globalx, orbitingparticles_globaly) > distance) {
     dx += orbitingparticles_pullback * this.speed * ((orbitingparticles_globalx-this.x)/distance);
     dy += orbitingparticles_pullback * this.speed * ((orbitingparticles_globaly-this.y)/distance);
   }
   else {
     dx += this.speed * ((orbitingparticles_globalx-this.x)/distance);
     dy += this.speed * ((orbitingparticles_globaly-this.y)/distance);
   }
 }
  
}

//////////////////////////////////////////
// Specific actions for the Vines animation
//////////////////////////////////////////

public void draw_vines() {
  background(0);
  flowing_lines_Path.update();
  for(int i=0;i<flowing_lines_lines.length;i++) {
    flowing_lines_lines[i].update();
    flowing_lines_lines[i].draw();
  }
}
 
class FlowingLinePath {
  FlowingLinePoint points[];
  FlowingLinePoint lastPoint;
  float lastAngle;
  int counter;
   
  FlowingLinePath() {
    points = new FlowingLinePoint[4];
 
    counter = 0;
    points[0] = new FlowingLinePoint(width/2,height/2);
    points[1] = generate_destination(points[0],270);
    for(int i=2;i<points.length;i++)
      points[i] = generate_destination(points[i-1],angle(points[i-2],points[i-1]));
  }
   
  public float getLastAngle() {
    return lastAngle;
  }
   
  public FlowingLinePoint getLastPoint() {
    return lastPoint;
  }
   
  public void update() {
    generate_point(counter++);
    if(counter == flowing_lines_FRAMES_PER_DISTANCE) {
      counter = 0;
      for(int i=1;i<points.length;i++)
        points[i-1] = points[i];
      points[3] = generate_destination(points[2],angle(points[1],points[2]));
    }
    pan_camera();
  }
   
  public void center_camera() {
    flowing_lines_screen_x = PApplet.parseInt(points[counter].x - width/2);
    flowing_lines_screen_y = PApplet.parseInt(points[counter].y - height/2);
  }
   
  public void pan_camera() {
    FlowingLinePoint p = lastPoint;
    if(p.x + flowing_lines_screen_x <= flowing_lines_MARGIN)
      flowing_lines_screen_x = flowing_lines_MARGIN - PApplet.parseInt(p.x);
    else if(p.x + flowing_lines_screen_x >= width - flowing_lines_MARGIN)
      flowing_lines_screen_x = width - flowing_lines_MARGIN - PApplet.parseInt(p.x);
    if(p.y + flowing_lines_screen_y <= flowing_lines_MARGIN)
      flowing_lines_screen_y = flowing_lines_MARGIN - PApplet.parseInt(p.y);
    else if(p.y + flowing_lines_screen_y >= height - flowing_lines_MARGIN)
      flowing_lines_screen_y = height - flowing_lines_MARGIN - PApplet.parseInt(p.y);
  }
   
  public FlowingLinePoint generate_destination(FlowingLinePoint base, float prev_angle) {
    float angle = prev_angle + random(-flowing_lines_MAX_ANGLE,flowing_lines_MAX_ANGLE);
    return new FlowingLinePoint(base.x + flowing_lines_DISTANCE * cos(angle), base.y + flowing_lines_DISTANCE * sin(angle));
  }
   
  public void generate_point(int counter) {
    float t = counter / PApplet.parseFloat(flowing_lines_FRAMES_PER_DISTANCE);
    float x = curvePoint(points[0].x, points[1].x, points[2].x, points[3].x, t);
    float y = curvePoint(points[0].y, points[1].y, points[2].y, points[3].y, t);
    lastPoint = new FlowingLinePoint(x,y);
    float tx = curveTangent(points[0].x, points[1].x, points[2].x, points[3].x, t);
    float ty = curveTangent(points[0].y, points[1].y, points[2].y, points[3].y, t);
    lastAngle = atan2(ty, tx) + HALF_PI;
  }
   
  public float angle(FlowingLinePoint p1, FlowingLinePoint p2) {
    return atan2(p2.y - p1.y, p2.x - p1.x);
  }
   
  public float flowing_lines_DISTANCE(FlowingLinePoint p1, FlowingLinePoint p2) {
    return sqrt(sq(p1.x-p2.x) + sq(p1.y-p2.y));
  }
   
  public void draw() {
    curve(flowing_lines_screen_x + points[0].x,flowing_lines_screen_y + points[0].y,flowing_lines_screen_x + points[1].x,flowing_lines_screen_y + points[1].y,
      flowing_lines_screen_x + points[2].x,flowing_lines_screen_y + points[2].y,flowing_lines_screen_x + points[3].x,flowing_lines_screen_y + points[3].y);
  }
}
 
class FlowingLine {
  FlowingLinePoint points[];
  float angles[];
  float amplitude, starting_thickness;
  float angle_inc, angle;
  int col;
  int counter;
   
  FlowingLine(int col, float amplitude, int period, float starting_thickness) {
    points = new FlowingLinePoint[flowing_lines_NUM_POINTS];
    angles = new float[flowing_lines_NUM_POINTS];
    this.col = col;
    this.amplitude = amplitude;
    this.starting_thickness = starting_thickness;
    this.angle_inc = TWO_PI / (float)period;
    angle = 0;
  }
  
  public void draw() {
    fill(col);
    stroke(col);
    beginShape(QUAD_STRIP);
    float thickness = 1;
    for(int i=counter;i!=(counter+1)%flowing_lines_NUM_POINTS;i=(i-1+flowing_lines_NUM_POINTS)%flowing_lines_NUM_POINTS) {
      if(points[i] == null) continue;
       
      float val_x = thickness * cos(angles[i]);
      float val_y = thickness * sin(angles[i]);
      vertex(flowing_lines_screen_x + points[i].x + val_x,flowing_lines_screen_y + points[i].y + val_y);
      vertex(flowing_lines_screen_x + points[i].x - val_x,flowing_lines_screen_y + points[i].y - val_y);
      thickness += starting_thickness / flowing_lines_NUM_POINTS;
    }
 
    endShape();
  }
   
  public void update() {
    FlowingLinePoint p = flowing_lines_Path.getLastPoint();
    counter = (counter + 1) % flowing_lines_NUM_POINTS;
    angles[counter] = flowing_lines_Path.getLastAngle();
    float val = amplitude * cos(angle);
    angle += angle_inc;
    points[counter] = new FlowingLinePoint(p.x +  val * cos(angles[counter]), p.y + val * sin(angles[counter]));
  }
}
 
class FlowingLinePoint {
  float x,y;
  FlowingLinePoint(float x, float y) {
    this.x = x;
    this.y = y;
  }
}

//////////////////////////////////////////
// Specific actions for the ArrowStyle animation
//////////////////////////////////////////


public void draw_arrowstyle() {
  background(0);
  beginShape(); 
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS - width/(2*NUMBER_OF_PANELS), PApplet.parseInt(arrowstyle_pos));
  vertex(width/2, PApplet.parseInt((arrowstyle_pos) + arrowstyle_height));
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS + 3*width/(2*NUMBER_OF_PANELS), PApplet.parseInt(arrowstyle_pos));
  endShape();

  beginShape();
  vertex(PApplet.parseInt(arrowstyle_pos) + (width-height)/2, 0);
  vertex(PApplet.parseInt((arrowstyle_pos) + arrowstyle_height) + (width-height)/2, height/2);
  vertex(PApplet.parseInt(arrowstyle_pos) + (width-height)/2, height);
  endShape();  
  
  beginShape();
  vertex(width - PApplet.parseInt(arrowstyle_pos) - (width-height)/2, 0);
  vertex(width - PApplet.parseInt((arrowstyle_pos) + arrowstyle_height) - (width-height)/2, height/2);
  vertex(width - PApplet.parseInt(arrowstyle_pos) - (width-height)/2, height);
  endShape();  
  
  beginShape();
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS - width/(2*NUMBER_OF_PANELS), height - PApplet.parseInt(arrowstyle_pos));
  vertex(width/2, height - PApplet.parseInt((arrowstyle_pos) + arrowstyle_height));
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS + 3*width/(2*NUMBER_OF_PANELS), height - PApplet.parseInt(arrowstyle_pos));
  endShape();  
  
  arrowstyle_pos += arrowstyle_increment;
  if (arrowstyle_pos >= 1.7f*height + 0.15f*(NUMBER_OF_PANELS-3)*width) {
    arrowstyle_pos = - 0.9f*height -  0.15f*(NUMBER_OF_PANELS-3)*width; 
  }
}

//////////////////////////////////////////
// Specific actions for the SingleArrow animations
//////////////////////////////////////////

public void singlearrow_setup() {
  noFill();
  frameRate(50);
  colorMode(RGB); 
  strokeWeight(singlearrow_strokeCap);
  strokeCap(SQUARE);
  stroke(255);
  if (singlearrow_initialized == false) {
    singlearrow_arrowlist = new ArrayList<SingleArrow>();
  } 
  singlearrow_initialized = true;
}


public void draw_singlearrow() {
  background(0);
  for (int i = singlearrow_arrowlist.size()-1; i >= 0; i--) {
    singlearrow_arrowlist.get(i).drawArrow();
    singlearrow_arrowlist.get(i).moveArrow();
  }
  killDeadArrows();
  
}


public void killDeadArrows() {
  for (int i = singlearrow_arrowlist.size()-1; i >= 0; i--) {
    if (singlearrow_arrowlist.get(i).arrowPos > 2*width) {
      singlearrow_arrowlist.remove(i);
      break;
    }
  }
}

class SingleArrow {
  
int arrowType;
float arrowSize;
float arrowPos;
int arrowColor;
float arrowIncrement = 8;

  
  SingleArrow(int type, float size, int col){
    this.arrowType = type;
    this.arrowSize = size;
    this.arrowColor = col;
    
    switch(type){
      case 0: this.arrowPos = -this.arrowSize-singlearrow_strokeCap;break;         //Down
      case 1: this.arrowPos = -this.arrowSize-singlearrow_strokeCap*2;break;       //Left
      case 2: this.arrowPos = -this.arrowSize-singlearrow_strokeCap*2;break;       //Right
      case 3: this.arrowPos = -this.arrowSize-singlearrow_strokeCap;break;         //Up
    }
  }
  
  public void drawArrow() {
    stroke(this.arrowColor);
    switch (this.arrowType){
      case 0: singlearrow_down();break;
      case 1: singlearrow_left();break;
      case 2: singlearrow_right();break;
      case 3: singlearrow_up();break;
    }
  }

  public void moveArrow() {
    arrowPos += arrowIncrement;
  }
  
public void singlearrow_down() {
  beginShape();
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS - width/(2*NUMBER_OF_PANELS), PApplet.parseInt(arrowPos));
  vertex(width/2, PApplet.parseInt((arrowPos) + arrowSize));
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS + 3*width/(2*NUMBER_OF_PANELS), PApplet.parseInt(arrowPos));
  endShape();

}

public void singlearrow_left() {
  beginShape();
  vertex(PApplet.parseInt(arrowPos) + (width-height)/2, 0);
  vertex(PApplet.parseInt((arrowPos) + arrowSize) + (width-height)/2, height/2);
  vertex(PApplet.parseInt(arrowPos) + (width-height)/2, height);
  endShape();
}

public void singlearrow_right() {
  beginShape();
  vertex(width - PApplet.parseInt(arrowPos) - (width-height)/2, 0);
  vertex(width - PApplet.parseInt((arrowPos) + arrowSize) - (width-height)/2, height/2);
  vertex(width - PApplet.parseInt(arrowPos) - (width-height)/2, height);
  endShape(); 
}

public void singlearrow_up() {
  beginShape();
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS - width/(2*NUMBER_OF_PANELS), height - PApplet.parseInt(arrowPos));
  vertex(width/2, height - PApplet.parseInt((arrowPos) + arrowSize));
  vertex((NUMBER_OF_PANELS-1)/2*width/NUMBER_OF_PANELS + 3*width/(2*NUMBER_OF_PANELS), height - PApplet.parseInt(arrowPos));
  endShape();  
}  

}

//////////////////////////////////////////
// Specific actions for the Rotozoom animation
//////////////////////////////////////////

public void draw_rotozoom() {
  try {
    int x,y,offs=0,soffs;
    float tx,ty,txx=0,tyy=0,ca,sa;
    loadPixels();
    for (y=0;y<height;y++) {
      ca=rotozoom_scalee*cos(rotozoom_angle);
      sa=rotozoom_scalee*sin(rotozoom_angle);
      txx+=-sa;
      tyy+=ca;
      ty=tyy;
      tx=txx;
      for (x=0;x<width;x++) {
        tx+=ca;
        ty+=sa;
        soffs=PApplet.parseInt(ty)<<8;
        soffs+=PApplet.parseInt(tx);
        pixels[offs++]=rotozoom_img.pixels[soffs&0xffff];
      }
    }  
    
    updatePixels();
    rotozoom_angle-=0.03f;
    rotozoom_scalee+=rotozoom_dscalee;
    if (rotozoom_scalee<0.15f || rotozoom_scalee>6) {
      rotozoom_dscalee*=-1;
    }
  }
  catch(Exception e) {
    outputLog.println("Rotozoom animation had a NullPointerException thrown - better debug that out for the future");
    outputLog.println(e); 
  }
}


//////////////////////////////////////////
// Specific actions for the MilkTank animation
//////////////////////////////////////////

public void draw_milktank() {
  
  colorMode(HSB);
  for(int i = 0; i < milktank_blobs.length; i++) {
    for(int x = PApplet.parseInt(milktank_blobs[i].x-40); x < PApplet.parseInt(milktank_blobs[i].x+40); x++) {
      for(int y = PApplet.parseInt(milktank_blobs[i].y-40); y < PApplet.parseInt(milktank_blobs[i].y+40); y++) {
        if(x<milktank_w&&y<milktank_h&&x>0&&y>0&&i<milktank_numberofparticles) {
          milktank_pixi[x][y] += PApplet.parseInt(3000/(((milktank_blobs[i].x-x)*(milktank_blobs[i].x-x))+((milktank_blobs[i].y-y)*(milktank_blobs[i].y-y))));
        }
      }
    }
    milktank_blobs[i].milktank_move();
  }
  for(int x = 0; x < milktank_w; x++) {
    for(int y = 0; y < milktank_h; y++) {
      if(milktank_pixi[x][y]>1000){
      fill(0, 0, 255, 160);
      }else{
      fill(0, 0, 0, 160);
      }
      rect(x*4, y*4, 4, 4);
      milktank_pixi[x][y] = 0;
    }
  }
  loadPixels();
  milktank_blur(3);
  updatePixels();
  colorMode(RGB);
  milktank_f += 0.01f;
  for(int i = 0; i < pixels.length; i++) {
    if(!((pixels[i] >> 16 & 0xFF)<100))
    pixels[i] = color(255, 255, 255);
  }
  
  filter(POSTERIZE, 4);
  
}
 
class milktank_blob {
  float x;
  float y;
  float xv;
  float yv;
  float z;
  
  milktank_blob() {
    z = random(0.003f, 0.007f);
    x = random(width);
    y = random(height);
  }
  public void milktank_move() {
    xv += z*(milktank_regroupX/4-x);
    yv += z*(milktank_regroupY/4-y);
    x += xv;
    y += yv;
    if(PApplet.parseInt(milktank_contraction / milktank_numberofparticles) < milktank_contractiontime) {
      milktank_contraction ++;
      xv /= 1.1f;
      yv /= 1.1f;
    }
  }

}
 
public void milktank_blur(int dd) {
   int[] px = new int[pixels.length];
   for(int d=1<<--dd; d>0; d>>=1) {
      for(int x=0;x<width;x++) for(int y=0;y<height;y++) {
        int p = y*width + x;
        int e = x >= width-d ? 0 : d;
        int w = x >= d ? -d : 0;
        int n = y >= d ? -width*d : 0;
        int s = y >= (height-d) ? 0 : width*d;
        int r = ( milktank_r(pixels[p+w]) + milktank_r(pixels[p+e]) + milktank_r(pixels[p+n]) + milktank_r(pixels[p+s]) ) >> 2;
        int g = ( milktank_g(pixels[p+w]) + milktank_g(pixels[p+e]) + milktank_g(pixels[p+n]) + milktank_g(pixels[p+s]) ) >> 2;
        int b = ( milktank_b(pixels[p+w]) + milktank_b(pixels[p+e]) + milktank_b(pixels[p+n]) + milktank_b(pixels[p+s]) ) >> 2;
        px[p] = 0xff000000 + (r<<16) | (g<<8) | b;
      }
      arrayCopy(px,pixels);
   }
}
  
 
public int milktank_r(int c) {return (c >> 16) & 255; }
public int milktank_g(int c) {return (c >> 8) & 255;}
public int milktank_b(int c) {return c & 255; }
 
public void changeFocus() {
  float startup = random(1);
  if (startup <= 0.2f) {
    milktank_regroupX = 2*width/6;
    milktank_regroupY = height/6;  
  }
  else if (startup > 0.2f && startup <= 0.4f) {
    milktank_regroupX = 5*width/6;
    milktank_regroupY = height/6;
  }
  else if (startup > 0.4f && startup <= 0.6f) {
    milktank_regroupX = 2*width/6;
    milktank_regroupY = 5*height/6;
  }
  else if (startup > 0.6f && startup <= 0.8f) {
    milktank_regroupX = 5*width/6;
    milktank_regroupY = 5*height/6;
  }
  else if (startup > 0.8f && startup <= 1) {
    milktank_regroupX = width/2;
    milktank_regroupY = height/2;
  }
}

//////////////////////////////////////////
// Specific actions for the FireNoiseSquares animation
//////////////////////////////////////////

public void draw_firenoisesquares()
{
  background(0);
  noStroke();
  smooth();
   
  for (int index=0; index < squares.length; index = index + 1){       
    if(squares[index] != null){
      squares[index].upAndDown();
      squares[index].draw();
    }
  }
}

class FireNoiseSquare
{
  // width in pixels
  int w;
  int x;
  int y;
  int c;
  boolean decrement;
 
  FireNoiseSquare()
  {
    x = 0;
    y = 0;
    w = width/(NUMBER_OF_PANELS*8);
    c = 0;
    decrement = false;
  }
   
  FireNoiseSquare(int _x, int _y, int _w, int _c)
  {
    x = _x;
    y = _y;
    w = _w;
    c = _c;
  }
 
  public void draw()
  {   
    switch(c){
        case 0:fill(0xff0d0000);break;
        case 1:fill(0xff200001);break;
        case 2:fill(0xff3f0002);break;
        case 3:fill(0xff400000);break;
        case 4:fill(0xff520000);break;
        case 5:fill(0xff5A0202);break;
        case 6:fill(0xff600303);break;
        case 7:fill(0xff5d0201);break;
        case 8:fill(0xff5b0000);break;
        case 9:fill(0xff610000);break;
        case 10:fill(0xff680000);break;
        case 11:fill(0xff730000);break;
        case 12:fill(0xff7e0000);break;
        case 13:fill(0xff900101);break;
        case 14:fill(0xffa60101);break;
        case 15:fill(0xffb10202);break;
        case 16:fill(0xffc10202);break;
        case 17:fill(0xffc71102);break;
        case 18:fill(0xffcb2204);break;
        case 19:fill(0xffcc1102);break;
        case 20:fill(0xffcd0101);break;
        case 21:fill(0xffd12003);break;
        case 22:fill(0xffd83004);break;
        case 23:fill(0xffda2902);break;
        case 24:fill(0xffdc2904);break;
        case 25:fill(0xffe03a05);break;
        case 26:fill(0xffe24e06);break;
        case 27:fill(0xffe35805);break;
        case 28:fill(0xffe46c05);break;
        case 29:fill(0xffe67c05);break;
        case 30:fill(0xffe78605);break;
        case 31:fill(0xfff36606);break;
        case 32:fill(0xfffd4606);break;
        case 33:fill(0xfffe8007);break;
        case 34:fill(0xffffc407);break;
      }
    rect(x, y, w, w); 
  }
   
  public void upAndDown(){
    if(decrement){
      c--;
      if(c<0){
        decrement = false;
        c = 0;
      }
    } else {
      c++;
      if(c>34){
        decrement = true;
        c = 34;
      }
    }
  }
}

//////////////////////////////////////////
// Specific actions for the Slasher animation
//////////////////////////////////////////

public void draw_slasher() {
    background(0);
    for (int i=0;i<slasher_nb;i++) {
        slash[i].draw();
    }
    for (int i=0;i<slasher_nb;i++) {
        slash[i].draw();
    }
}
 
 
class Slash {
    float x1, x2, y1, y2, tarX1, tarX2, tarY1, tarY2, easing = random(0.02f,0.15f);
    int timer, tMax, taille=width/16, delta=width/3;
    boolean vertical;
    int c;
 
    Slash(int _c) {
        c=_c;
        initSlash();
    }
 
    public void initSlash() {
        timer=0;
        tMax= (int) random(30, 75);
        vertical=random(1)>.5f;
 
        x1=x2=(int)random(1, PApplet.parseInt(width/4)-1)*4;
        y1=y2=(int)random(1, PApplet.parseInt(height/4)-1)*4;
 
        if(x1<width/2) tarX2=x1+delta;
        else tarX2=x1-delta;
 
        if(y1<height/2) tarY2=y1+delta;
        else tarY2=y1-delta;
    }
 
    public void draw() {
        x2=ease(x2, tarX2, easing);
        y2=ease(y2, tarY2, easing);
        if (abs(x2-tarX2)<=1) {
            timer++;
 
            if (timer>tMax) {
                tarX1=tarX2;
                tarY1=tarY2;
                x1=ease(x1, tarX1, easing);//
                y1=ease(y1, tarY1, easing);
 
                if (abs(x1-tarX1)<=1) {
                    initSlash();
                }
            }
        }
 
        noStroke();
        fill(c,200);
        if (vertical) quad(x1, y1-taille, x1, y1+taille, x2, y2+taille, x2, y2-taille);
        else quad(x1-taille, y1, x1+taille, y1, x2+taille, y2, x2-taille, y2);
    }
 
    public float ease(float value, float target, float easingVal) {
        float d = target - value;
        if (abs(d)>1) value+= d*easingVal;
        return value;
    }
}


//////////////////////////////////////////
// Specific actions for the NekoJiru animation
//////////////////////////////////////////


public void draw_nekojiru() {
  
  background(0);
  smooth();
  noStroke();

  nekojiru_machine.determineState();
  nekojiru_machine.specificActionsForCurrentState();

  nekojiru_draweyes();
  nekojiru_drawpupils(); 
  nekojiru_drawblink();
}


public void nekojiru_draweyes() {
 
  //Change eye color
  if(nekojiru_angry) {
    nekojiru_fillr = 255;
    nekojiru_fillg = 210;
    nekojiru_fillb = 0;
  }
  else{
    nekojiru_fillr = 50;
    nekojiru_fillg = 255;
    nekojiru_fillb = 200;
  }
   
  fill(nekojiru_fillr,nekojiru_fillg,nekojiru_fillb);
   
  pushMatrix();
  translate((width-nekojiru_eyedistance)/2,height/3);
  rotate(PI/8);
  ellipse(0,0,nekojiru_eyesizeX,nekojiru_eyesizeY);
  popMatrix();
   
  fill(nekojiru_fillr,nekojiru_fillg,nekojiru_fillb);
  pushMatrix();
  translate((width-nekojiru_eyedistance)/2 + nekojiru_eyedistance,height/3);
  rotate(-PI/8);
  ellipse(0,0,nekojiru_eyesizeX,nekojiru_eyesizeY);
  popMatrix();
  
}

public void nekojiru_drawpupils() {
 
  //Pupil movement
  float targetx = constrain(nekojiru_posX, 19*width/(NUMBER_OF_PANELS*8), 22*width/(NUMBER_OF_PANELS*3));
  float targety = constrain(nekojiru_posY, 7*height/24,9*height/24);
  float easing = 0.15f;
  nekojiru_mx = nekojiru_mx + (targetx-nekojiru_mx)*easing;
  nekojiru_my = nekojiru_my + (targety-nekojiru_my)*easing;
 
  fill(0);
  smooth();
 
  if((nekojiru_surprise) && (nekojiru_bulge <= nekojiru_bulgesize)) {
    nekojiru_bulge += 1;
  }
  else{
    if(nekojiru_bulge > 0){
      nekojiru_bulge -= 1;
    }
  }
  nekojiru_leftdist = dist(nekojiru_posX, nekojiru_posY, nekojiru_mx-nekojiru_eyedistance,nekojiru_my);
  nekojiru_rightdist = dist(nekojiru_posX,nekojiru_posY, nekojiru_mx, nekojiru_my);
  if((nekojiru_rightdist < nekojiru_bulgedistance) || (nekojiru_leftdist < nekojiru_bulgedistance )){
    if(nekojiru_bulge > -nekojiru_bulgesize){
      nekojiru_bulge -= 1;
    }
  }
  else{
    if(nekojiru_bulge < 0){
      nekojiru_bulge += 1;
    }
  }
 
  arc(nekojiru_mx,nekojiru_my,nekojiru_eyearcparam1 + nekojiru_bulge,nekojiru_eyearcparam2 + nekojiru_bulge,-PI/2+1,3*PI/2);
  arc(nekojiru_mx-nekojiru_eyedistance,nekojiru_my,nekojiru_eyearcparam1 + nekojiru_bulge,nekojiru_eyearcparam2 + nekojiru_bulge,-PI/2+1,3*PI/2);  
  
}

public void nekojiru_drawblink() {
  if (nekojiru_blink == true && nekojiru_blinkNasty == false) {
    if (nekojiru_blinky < nekojiru_blinkyMax) {
      nekojiru_blinky += height/32;
    }
  }
  else if (nekojiru_blink == false && nekojiru_blinkNasty == true) {
    if (nekojiru_blinky < nekojiru_blinkyNasty) {
      nekojiru_blinky += height/32;    
    }
  }
  else {
    if (nekojiru_blinky > 0) {
      nekojiru_blinky -= height/32;
    }
  }
  
  fill(0);
  beginShape();
  vertex(-nekojiru_blinky,0);
  vertex(width/2, nekojiru_blinky);
  vertex(nekojiru_blinky+width,0);
  endShape();  
}


public void nekojiru_initStateMachine() {
  nekojiru_machine = new NekoJiruStateMachine();
  nekojiru_machine.addState(new int[]{0,25});
  nekojiru_machine.addState(new int[]{1,25});
  nekojiru_machine.addState(new int[]{2,50});
  nekojiru_machine.addState(new int[]{3,30});
  nekojiru_machine.addState(new int[]{4,50});
  nekojiru_machine.addState(new int[]{1,50});
  nekojiru_machine.addState(new int[]{5,50});
  nekojiru_machine.addState(new int[]{0,25});
  nekojiru_machine.addState(new int[]{1,25});
  nekojiru_machine.addState(new int[]{0,25});
  nekojiru_machine.addState(new int[]{6,10});
  nekojiru_machine.addState(new int[]{7,10});
  nekojiru_machine.addState(new int[]{2,50});
  nekojiru_machine.addState(new int[]{3,30});  
  nekojiru_machine.addState(new int[]{4,50});
  nekojiru_machine.addState(new int[]{1,60});
  nekojiru_machine.addState(new int[]{2,20});
  nekojiru_machine.addState(new int[]{8,5});
  nekojiru_machine.addState(new int[]{5,30});
  nekojiru_machine.addState(new int[]{4,5});
  nekojiru_machine.addState(new int[]{9,30});  
}


class NekoJiruStateMachine {
 
  ArrayList<int[]> stateMachine;
  int stateMachineSize;            //Number of states
  int stateMachineLength;          //Number of frames for the complete animation
  int[] stateCountInfo;            //Contains the first frame counter for each animation
  
  NekoJiruStateMachine() {
    stateMachine = new ArrayList<int[]>();
    stateMachineSize = 0;
    stateMachineLength = 0;
    stateCountInfo = new int[]{};
  }
  
  public void addState(int[] state) {
    this.stateMachine.add(state);
    this.update_machinesize();
    this.update_machinelength(); 
    this.update_statecountinfo();
  }
  
  public void update_machinesize() {
    stateMachineSize = this.stateMachine.size();
  }
  
  public void update_machinelength() {
    stateMachineLength = 0;
    for (int i = 0; i<this.stateMachine.size();i++) {
      stateMachineLength += this.stateMachine.get(i)[1];
    }
  }
  
  public void update_statecountinfo() {
    stateCountInfo = new int[this.stateMachine.size()];
    int temp = 0;
    for (int i = 0; i<this.stateMachine.size();i++) {
      temp += this.stateMachine.get(i)[1];
      stateCountInfo[i] = temp;
    }
  }
  
  public void determineState() {
    
    for (int i = 0; i<this.stateMachine.size();i++) {
      if (frameCount % stateMachineLength < stateCountInfo[i]) {
        nekojiru_currentState = this.stateMachine.get(i)[0];
        break;
      }
    }
  }
  
  public void specificActionsForCurrentState() {
    if (nekojiru_currentState == 0) {          //Look left 
      if (nekojiru_posY < height) {
        nekojiru_posY += height/16; 
      }
      if (nekojiru_posX > 0) {
        nekojiru_posX -= width/24; 
      }
    }
    if (nekojiru_currentState == 1) {          //Watch right
      if (nekojiru_posY < height) {
        nekojiru_posY += height/16; 
      }
      if (nekojiru_posX < width) {
        nekojiru_posX += width/24; 
      }      
    }
    if (nekojiru_currentState == 2) {          //Look left slowly 
      if (nekojiru_posY < height) {
        nekojiru_posY += height/48; 
      }
      if (nekojiru_posX > 0) {
        nekojiru_posX -= width/64; 
      }
    }
    if (nekojiru_currentState == 3) {          //Close completely the eyes 
      nekojiru_blink = true;
      nekojiru_blinkNasty = false;
    }
    if (nekojiru_currentState == 4) {          //Open the eyes 
      nekojiru_blink = false;
      nekojiru_blinkNasty = false;
    }    
    if (nekojiru_currentState == 5) {          //Close halfway the eyes, be angry
      nekojiru_blinkNasty = true;
      nekojiru_blink = false;
    }    
    if (nekojiru_currentState == 6) {          //Big eyes ! 
      nekojiru_surprise = true;
    }        
    if (nekojiru_currentState == 7) {          //Calm down, small eyes
      nekojiru_surprise = false;
    }
    if (nekojiru_currentState == 8) {          //Be angry ! Orange eyes 
      nekojiru_angry = true;
    }
    if (nekojiru_currentState == 9) {          //Calm down, blue eyes 
      nekojiru_angry = false;
    }
            
  }
  
}

//////////////////////////////////////////
// Specific actions for the LetterExplode animation
//////////////////////////////////////////

public void draw_letterexplode() {
  background(0);
  if (!particleletters_buffer.equals("") && !particleletters_printing) {
    char particleletters_let = particleletters_buffer.charAt(0);
    pushLetterParticles(particleletters_let);
    particleletters_buffer = particleletters_buffer.substring(1);
    particleletters_idle = false;
    particleletters_printing = true;
    particleletters_counter = 0;
    
    //Set the color corresponding to the letter
    determineColor(particleletters_let);

  }
  if (particleletters_buffer.equals("")) {
    particleletters_buffer = particleletters_wordToPrint; 
  }
  if (!particleletters_idle || particleletters_printing) {
    particleletters_counter++;
  }
 
  if (particleletters_idle) {
    particleletters_idleUpdate();
  }
 
  if (!particleletters_idle && particleletters_counter > particleletters_activeTime) {
    particleletters_idle = true;
  }
 
  if (particleletters_printing && particleletters_counter > particleletters_printTime) {
    particleletters_printing = false;
  }
 
  if (frameCount % 2 == 0) {
    noStroke();
    //fill(0, 55);
    //rect(0, 0, width, height);
  } 
  
  
  for (LetterParticle particleletters_p : particleletters_parts) {
    particleletters_p.update();
    noStroke();   
    particleletters_p.drawparticle();
  }
}
 
public void particleletters_idleUpdate() {
  ListIterator<LetterParticle> particleletters_it = particleletters_parts.listIterator();
  while (particleletters_it.hasNext ()) {
    LetterParticle particleletters_p = particleletters_it.next();
    particleletters_p.vx += (width/2-particleletters_p.x)*particleletters_contraction;
    particleletters_p.vy += (height/2-particleletters_p.y)*particleletters_contraction;
 
    // iterate over the particles which the current particle has not interacted with yet
    ListIterator<LetterParticle> particleletters_forward = particleletters_parts.listIterator(particleletters_it.nextIndex());
    while (particleletters_forward.hasNext ()) {
      LetterParticle particleletters_np = particleletters_forward.next();
      float p2npx = particleletters_np.x-particleletters_p.x;
      float p2npy = particleletters_np.y-particleletters_p.y;
      float sqdist = p2npx*p2npx + p2npy*p2npy;
 
      //apply repulsive forces
      particleletters_p.vx -= p2npx/sqdist * particleletters_repulsion;
      particleletters_np.vx+= p2npx/sqdist * particleletters_repulsion;
      particleletters_p.vy -= p2npy/sqdist * particleletters_repulsion;
      particleletters_np.vy+= p2npy/sqdist * particleletters_repulsion;
    }
 
    // apply a random force
    float nscale = 0.01f;
    float offset = 500;
    particleletters_p.vx += ((noise(particleletters_p.x*nscale, particleletters_p.y*nscale, frameCount*nscale) - 0.5f) / particleletters_p.s)*particleletters_drift;
    particleletters_p.vy += ((noise(particleletters_p.x*nscale+offset, particleletters_p.y*nscale+offset, frameCount*nscale*0.2f) - 0.5f) / particleletters_p.s)*particleletters_drift;
  }
}
 
// give all particles a push toward a random pixel of the letter
public void pushLetterParticles(char c) {
   
  // put the letter in a PGraphics and get its pixels
  particleletters_letter = createGraphics(width, height);
  particleletters_letter.textFont(particleletters_font);
  particleletters_letter.beginDraw();
  particleletters_letter.textAlign(CENTER, CENTER);
  particleletters_letter.textSize(height*1.1f);
  particleletters_letter.text(c, width/2, height/3);
  particleletters_letter.endDraw();
  particleletters_letter.loadPixels();
  
  //determine the number of pixels in the letter
  int[] lPixels = particleletters_letter.pixels;
  
  int nnz = 0;
  for (int i=0; i<lPixels.length; i++) {
    if (lPixels[i] != 0)
      nnz++;
  }
 
  // create a list of indices that correspond to pixels of the letter
  int[] index = new int[nnz];
  int idx = 0;
  for (int i=0; i<lPixels.length; i++) {
    if (lPixels[i] != 0) {
      index[idx] = i;
      idx++;
    }
  }
  for (LetterParticle particleletters_p : particleletters_parts) {
     
    // pick a random pixel of the letter and push the particle towards it
    int targPixel = (int) random(0, nnz);
    int targX = index[targPixel]%width;
    int targY = index[targPixel]/width;
    float dx = targX - particleletters_p.x;
    float dy = targY - particleletters_p.y;
    float factor = (1-particleletters_damping)/(1-pow(particleletters_damping, particleletters_impulse));
    particleletters_p.vx = dx*factor;
    particleletters_p.vy = dy*factor;
  }
}

//Print only the character 'P' as red
public void determineColor(char c) {
  if (c == 'P') {
    fill(0,255,255);
  }
  else {
    fill(0,0,255);
  }
    
}
 
class LetterParticle {
  float x,y;
  float vx = 0, vy = 0;
  float s = 5;
  float speedSq = 0;
     
  LetterParticle(float xx, float yy) {
    x = xx;
    y = yy;
  }
   
  LetterParticle(float xx, float yy, float vxx, float vyy) {
    x = xx;
    y = yy;
    vx = vxx;
    vy = vyy;
  }
   
  public void update() {
    x += vx;
    y += vy;
    vx *= particleletters_damping;
    vy *= particleletters_damping;
    speedSq = vx*vx + vy*vy;
     
    if (x < 0) {
      x = 0;
      vx = -vx;
    } else if (x > width) {
      x=width;
      vx = -vx;
    }
     
    if (y < 0) {
      y = 0;
      vy = -vy;
    } else if (y > height) {
      y=height;
      vy = -vy;
    }
    
  }
   
  public void drawparticle() {
    //fill(0,0,255);
    ellipse(x,y,s,s);
  }
}


//////////////////////////////////////////
// Specific actions for the TriangleStroboColor animation
//////////////////////////////////////////

public void draw_trianglestrobocolor() {
  if (frameCount % 2 == 0)
  {
    background(255);
    //fill(int(random(50,255)),int(random(50,255)),int(random(50,255)));
    fill(0);
    if (random(1) < 0.6f) {
      stroke(random(170,255),0,0);
    }
    else {
      stroke(0,0,random(140,220));
    }
    beginShape();
    vertex(width/6, 5*height/6);
    vertex(width/2, height/6);
    vertex(5*width/6, 5*height/6);
    endShape(CLOSE);
  }
  else
  {
    fill(0);
    noStroke();
    rect(0,0,width,height);
  }
}

//////////////////////////////////////////
// Specific actions for the ExplodingCircleLeft animation
//////////////////////////////////////////

public void draw_explodingcircleleft() {
  background(0);
  fill(0);
  ellipse(0, 0, explodingcircle_counter, explodingcircle_counter);
  explodingcircle_counter += 12; 
}

//////////////////////////////////////////
// Specific actions for the ExplodingCircleRight animation
//////////////////////////////////////////

public void draw_explodingcircleright() {
  background(0);
  fill(0);
  ellipse(width, height, explodingcircle_counter, explodingcircle_counter);
  explodingcircle_counter += 12; 
}


//////////////////////////////////////////
// Specific actions for the Thunderlines animation
//////////////////////////////////////////

public void setup_thunderlines() {
  if (thunderline_init == false) {
    thunderline_list = new ArrayList<ThunderLine>();
    for (int i = 0; i < thunderline_density; i++) {
      thunderline_list.add(new ThunderLine());
    }
  }
  else {
    while( thunderline_list.size() <= thunderline_density) {
      thunderline_list.add(new ThunderLine());
    }
    while( thunderline_list.size() > thunderline_density) {
      thunderline_list.remove(thunderline_list.size() - 1);
    }
  }
  
}

public void draw_thunderlines() {
  if (thunderline_setupcomplete == true) {
    noStroke();
    fill(0,thunderline_refreshrate);
    rect(0,0, width, height);
  
    for (int i = 0; i < thunderline_list.size(); i++) {
      stroke(thunderline_list.get(i).linecolor);
      for (int l = thunderline_persistance; l > 1; l--) {
        line(thunderline_list.get(i).thunderline_previousx[l-1], thunderline_list.get(i).thunderline_previousy[l-1], thunderline_list.get(i).thunderline_previousx[l-2], thunderline_list.get(i).thunderline_previousy[l-2]);
      }
      line(thunderline_list.get(i).thunderline_previousx[0], thunderline_list.get(i).thunderline_previousy[0], thunderline_list.get(i).thunderline_x, thunderline_list.get(i).thunderline_y);
      
      for (int j = thunderline_persistance; j > 1; j--) {
        thunderline_list.get(i).thunderline_previousx[j-1] = thunderline_list.get(i).thunderline_previousx[j - 2];
        thunderline_list.get(i).thunderline_previousy[j-1] = thunderline_list.get(i).thunderline_previousy[j - 2];
      }
      thunderline_list.get(i).thunderline_previousx[0] = thunderline_list.get(i).thunderline_x;
      thunderline_list.get(i).thunderline_previousy[0] = thunderline_list.get(i).thunderline_y;
      thunderline_list.get(i).thunderline_x += thunderline_list.get(i).flowspeed;
      //thunderline_list.get(i).thunderline_y += random(- thunderline_list.get(i).perturbation, thunderline_list.get(i).perturbation);
      thunderline_list.get(i).thunderline_y += noise(frameCount * thunderline_list.get(i).perturbation) - 0.5f;
  
    }
    thunderlines_deleteoldlines();
  }
}

public void thunderlines_deleteoldlines() {
  for (int i = 0; i < thunderline_list.size(); i++) {
    if (thunderline_list.get(i).thunderline_x > width*2.5f) {
       thunderline_list.remove(thunderline_list.get(i));
       thunderline_list.add(new ThunderLine());
       break;
    }
  }
}

class ThunderLine {
 
 float thunderline_x; 
 float thunderline_y;
 float[] thunderline_previousx; 
 float[] thunderline_previousy;

 float flowspeed;
 float perturbation;
 int linecolor;
 
 ThunderLine() {
  thunderline_x = random(-width, 0);
  thunderline_y = random(height/3, 2*height/3);
  
  thunderline_previousx = new float[thunderline_persistance];
  thunderline_previousy = new float[thunderline_persistance];

  for (int i = 0; i < thunderline_persistance; i++) {
    thunderline_previousx[i] = thunderline_x;
    thunderline_previousy[i] = thunderline_y;
  }
  flowspeed = random(thunderline_maxspeed/6, thunderline_maxspeed);
  perturbation = random(0, thunderline_maxperturbation)*flowspeed;
  linecolor = color(random(150,255));
 } 
 
}


//////////////////////////////////////////
// Specific actions for the OpeningWhiteout animation
//////////////////////////////////////////

public void draw_openingWhiteOut() {
  if (openingWhiteout_verticalCpt <= height) {
    fill(170);
    rect(width/2,height - openingWhiteout_verticalCpt,4,height);
    rect(width/2,height - openingWhiteout_verticalCpt,-4,height);
    openingWhiteout_verticalCpt += openingWhiteout_verticalSpeed;
  }
  else {
    fill(min(170 + openingWhiteout_cpt, 255));
    rect(width/2,0,openingWhiteout_cpt,height);
    rect(width/2,0,-openingWhiteout_cpt,height);
    openingWhiteout_cpt += openingWhiteout_speed;
  } 
}

//////////////////////////////////////////
// Specific actions for the DoubleFusee animation
//////////////////////////////////////////

public void doublefusee_init()
{
  frameRate(50);
  doublefusee_a = 0;
  // initialisation des parametres
  doublefusee_epaisseurLigne = 4;
  strokeWeight(doublefusee_epaisseurLigne);
  stroke(255);
  fill(255);
  strokeCap(SQUARE);
  
  doublefusee_vitesseLigne = 6;
  doublefusee_tab1 = new int[width/4];
  doublefusee_tab2 = new int[width/4];
  for(int j=0; j<width/4; j++){
    doublefusee_tab1[j] = height+PApplet.parseInt(height-random(20,height));
    doublefusee_tab2[j] = height+PApplet.parseInt(height+random(0,height));
  }
  doublefusee_tab3 = new int[width/4];
  doublefusee_tab4 = new int[width/4];
  for(int j=0; j<width/4; j++){
    doublefusee_tab3[j] = PApplet.parseInt(-height+random(20,height));
    doublefusee_tab4[j] = PApplet.parseInt(-height-random(0,height));
  }

}

public void draw_doublefusee() {
  stroke(255);
  for(int i=0; i<(width/4)/3; i++){
    line(i*4+2, doublefusee_tab2[i] - doublefusee_a, i*4+2, doublefusee_tab1[i] - doublefusee_a);
    }
  stroke(0);
  for(int i=0; i<(width/4)/3; i++){
    line(i*4+2, height+doublefusee_tab1[i] - doublefusee_a, i*4+2, 2*height);
  }
  stroke(255);
  for(int i=0; i<(width/4)/3; i++){
    line(2*width/3 + i*4+2, doublefusee_tab4[i] + doublefusee_a, 2*width/3 + i*4+2, doublefusee_tab3[i] + doublefusee_a);
    }
  stroke(0);
  for(int i=0; i<(width/4)/3; i++){
    line(2*width/3 + i*4+2, -height , 2*width/3 + i*4+2, -height + doublefusee_tab3[i] + doublefusee_a);
  }

  doublefusee_a = doublefusee_a + doublefusee_vitesseLigne;
}


//////////////////////////////////////////
// Specific actions for the DiscoStar animation
//////////////////////////////////////////
 
public void draw_discostar() {
  background(0);
  
  fill(discostar_colorwheel % 255,255,255);
  discostar_colorwheel += discostar_colorinc;
  
  pushMatrix();
  translate(width/2, height/2);
  rotate(TWO_PI * frameCount/1200);  
  //fill(0, 0, 0);
  draw_halfDiscoStar(0);
  popMatrix();
   
  pushMatrix();
  translate(width/2, height/2);
  rotate(TWO_PI * frameCount/450);
  //fill(0, 0, 0);
  draw_halfDiscoStar(0.06f);
  popMatrix();
}
 
public void draw_halfDiscoStar(float fatten) {
  int numSpokes = 10;
  for (int i=0; i<numSpokes; i++) {
     float t0 = map(i, 0, numSpokes-1, 0, TWO_PI);
     float t1 = t0 + (TWO_PI/(2*numSpokes));
     arc(0, 0, 1000, 1000, t0, t1 + fatten);
  }
}


//////////////////////////////////////////
// Specific actions for the WormHole animation
//////////////////////////////////////////

public void draw_wormhole() {
  background(0);
  translate(width/2, height/2);
  for (wormhole_x = 0; wormhole_x < width; wormhole_x ++) {
    stroke(wormhole_x*3, wormhole_y*3, (wormhole_a + wormhole_b)*3);
    wormhole_y = wormhole_c*10;
    for (wormhole_a = 0; wormhole_a < width; wormhole_a ++) {
    wormhole_b = wormhole_x * tan(wormhole_c);
    }
    line(wormhole_x, wormhole_y, wormhole_a, wormhole_b);
    rotate(radians(30));
    }
    
  wormhole_c += 0.03f;
}

//////////////////////////////////////////
// Specific actions for the Atoms animation
//////////////////////////////////////////

public void atoms_setup(int number) {
  
  frameRate(50);
  stroke(0);
  strokeWeight(1);
  smooth();
  if (atoms_initialised == false) {
    atoms_electronlist = new ArrayList<Electron>(); 
  
    atoms_electronlist.add(new Electron(0, -PI/4.0f));
    atoms_electronlist.add(new Electron(3*PI/2.0f, -PI/4.0f));
    atoms_electronlist.add(new Electron(3*PI/4, -PI/4.0f));
  }
  atoms_initialised = true;
  atoms_beatprotosize = atoms_beatprotomaxsize;
  atoms_redprotocolor = !atoms_redprotocolor;
  atoms_numberofelectrons = number;

}

public void draw_atoms() {
  noStroke();
  //Blur the previous canvas
  fill(0, atoms_electrontail);
  rect(0,0,width,height);
  
  
  //Do not blur the central beat - draw a black circle around it
  fill(0);
  stroke(0);
  ellipse(width/2,height/2,atoms_beatprotosize+3,atoms_beatprotosize+3);
  noStroke();
  
  //Define the color for the central beat
  if (atoms_redprotocolor) {
    fill(255,0,0);
  }
  else {
    fill(255); 
  }
  
  ellipse(width/2,height/2,atoms_beatprotosize,atoms_beatprotosize);
  if (atoms_beatprotosize > atoms_beatprotominsize) {
    atoms_beatprotosize -= 4;
  }
  
  fill(255);
  if (atoms_numberofelectrons == 1) {
    atoms_electronlist.get(0).draw_electron();
  }
  else if (atoms_numberofelectrons == 2) {
    atoms_electronlist.get(0).draw_electron();
    atoms_electronlist.get(1).draw_electron();
  }
  else if (atoms_numberofelectrons == 3) {
    atoms_electronlist.get(0).draw_electron();
    atoms_electronlist.get(1).draw_electron();
    atoms_electronlist.get(2).draw_electron();

  }
  
  atoms_electronlist.get(0).move_electron();
  atoms_electronlist.get(1).move_electron();
  atoms_electronlist.get(2).move_electron();
  
}

class Electron {
  
  float teta;
  float electron_posx;
  float electron_posy;
  float ellipserate;
  float angle;
  
  Electron(float angle, float ellipserate) {
    this.teta = 0;
    this.angle = angle;
    this.ellipserate = ellipserate;
    this.electron_posx = width/2 + atoms_orbitsize*cos(teta);
    this.electron_posy = height/2 + atoms_orbitsize*sin(teta + this.ellipserate);
  }
  
  public void draw_electron() {
    //ellipse(this.electron_posx, this.electron_posy, atoms_electronsize, atoms_electronsize);
    pushMatrix();
    translate(width/2, height/2);
    rotate(this.angle);
    //translate(width/3,height/3);
    ellipse(this.electron_posx, this.electron_posy, atoms_electronsize, atoms_electronsize);
    popMatrix();
  }
  
  public void move_electron() {
    teta += 0.1f;
    electron_posx = atoms_orbitsize*cos(teta);
    electron_posy = atoms_orbitsize*sin(teta + this.ellipserate);
  }
  
}

//////////////////////////////////////////
// Specific actions for the Atoms animation
//////////////////////////////////////////

public void draw_perfectcircle() {
  //Blur the previous canvas
  fill(0, perfect_circleperfectcircletail);
  rect(0,0,width,height);
  
  
  //Do not blur the central beat - draw a black circle around it
  fill(0);
  ellipse(width/2,height/2,perfect_circlebeatprotosize+4,perfect_circlebeatprotosize+4);
  
  //Define the color for the central beat
  if (perfect_circleredprotocolor) {
    fill(255,0,0);
  }
  else {
    fill(255); 
  }
  
  ellipse(width/2,height/2,perfect_circlebeatprotosize,perfect_circlebeatprotosize);
  if (perfect_circlebeatprotosize > perfect_circlebeatprotominsize) {
    perfect_circlebeatprotosize -= 4;
  }
  
  fill(255);
  
  perfect_circleperfectcirclelist.get(0).draw_perfectcircle();
  perfect_circleperfectcirclelist.get(1).draw_perfectcircle();
  perfect_circleperfectcirclelist.get(2).draw_perfectcircle();
  
  perfect_circleperfectcirclelist.get(0).move_perfectcircle();
  perfect_circleperfectcirclelist.get(1).move_perfectcircle();
  perfect_circleperfectcirclelist.get(2).move_perfectcircle();
}

class PerfectCircle {
  
  float teta;
  float perfectcircle_posx;
  float perfectcircle_posy;
  float ellipserate;
  float angle;
  
  PerfectCircle(float angle, float ellipserate) {
    this.teta = 0;
    this.angle = angle;
    this.ellipserate = ellipserate;
    this.perfectcircle_posx = width/2 + perfect_circleorbitsize*cos(teta);
    this.perfectcircle_posy = height/2 + perfect_circleorbitsize*sin(teta + this.ellipserate);
  }
  
  public void draw_perfectcircle() {
    //ellipse(this.perfectcircle_posx, this.perfectcircle_posy, perfect_circleperfectcirclesize, perfect_circleperfectcirclesize);
    pushMatrix();
    translate(width/2, height/2);
    rotate(this.angle);
    //translate(width/3,height/3);
    ellipse(this.perfectcircle_posx, this.perfectcircle_posy, perfect_circleperfectcirclesize, perfect_circleperfectcirclesize);
    popMatrix();
  }
  
  public void move_perfectcircle() {
    teta += 0.1f;
    perfectcircle_posx = perfect_circleorbitsize*cos(teta);
    perfectcircle_posy = perfect_circleorbitsize*sin(teta + this.ellipserate);
  }
  
}


//////////////////////////////////////////
// Specific actions for the HyperSpeed animation
//////////////////////////////////////////

public void draw_hyperspeed() {
  fill(0, hyperspeed_blur);
  noStroke();
  rect(0,0,width,height);
  
  stroke(255);
  for (int i = 0;i < hyperspeed_nagarelist.size();i++) {
    try {
      hyperspeed_nagarelist.get(i).drawpoint();
      hyperspeed_nagarelist.get(i).move();
    }
    catch (Exception e) {
      outputLog.println("Hyperspeed animation caused an exception during draw thread : " + e);
    }
  }
  killoldstars();
}

public void killoldstars() {
  for (int i = 0;i < hyperspeed_nagarelist.size();i++) {
    if (hyperspeed_nagarelist.get(i).hoshi_x < -width/2 || hyperspeed_nagarelist.get(i).hoshi_x > 3*width/2 || hyperspeed_nagarelist.get(i).hoshi_y < -height/2 || hyperspeed_nagarelist.get(i).hoshi_y > 3*height/2) {
      hyperspeed_nagarelist.remove(i);
      hyperspeed_nagarelist.add(new NagareBoshi());
      break;
    }
  }
}

class NagareBoshi {

  float hoshi_x;
  float hoshi_y;
  float hoshi_previousx;
  float hoshi_previousy;
  float hoshi_angle;
  float hoshi_speed;
  float hoshi_strokeWeight;
  
  NagareBoshi() {
    hoshi_x = width/2;
    hoshi_y = height/2;
    hoshi_angle = random(0,TAU);
    hoshi_speed = random(hyperspeed_maxspeed/4,hyperspeed_maxspeed);
    hoshi_strokeWeight = random(1,4);
    
    //Do not make the star start right at the center of the screen
    hoshi_x += hoshi_speed * cos(hoshi_angle);
    hoshi_y += hoshi_speed * sin(hoshi_angle);
    hoshi_previousx = hoshi_x;
    hoshi_previousy = hoshi_y;

  }
  
  public void drawpoint() {
     strokeWeight(this.hoshi_strokeWeight);
     line(this.hoshi_previousx, this.hoshi_previousy, this.hoshi_x, this.hoshi_y);
  }
  
  public void move() {
    this.hoshi_previousx = this.hoshi_x;
    this.hoshi_previousy = this.hoshi_y;
    this.hoshi_x += this.hoshi_speed * cos(this.hoshi_angle);
    this.hoshi_y += this.hoshi_speed * sin(this.hoshi_angle);
  }
 
}


//////////////////////////////////////////
// Specific actions for the ColorWaves animation
//////////////////////////////////////////

public void draw_colorwaves() {  
  int k = 0;
  while (k < waves_list.size()) {
      ColorWave waves_w = (ColorWave) waves_list.get(k);
      if (waves_t - waves_w.it > 2) {
        waves_list.remove(k);  
      }   
      k ++;
  }
  randomSeed(131);
  clear();
  for (int i = 0; i < waves_numberofparticles; i++) {
      particle();
  }
   
  if (waves_ampwait) {
      waves_ampsize += 0.2f;
  }
  waves_t += waves_dt;
}
 
public void create_randomwave() {
  waves_ampsize = 2 + 3*noise(frameCount*0.1f);
  waves_list.add(new ColorWave(PApplet.parseInt(noise(frameCount*10)*width), PApplet.parseInt(noise(frameCount*20)*height), waves_ampsize, waves_t));
}

public void create_strongwave() {
  waves_list.add(new ColorWave(width/2, height/2, 10, waves_t));
}

public void particle() {
  float x = random(0, width);
  float y = random(0, height);
   
  float px = x;
  float py = y;
  float pz = .01f;
   
  for(int i = 0; i < waves_list.size(); i++) {
    ColorWave waves_w = (ColorWave) waves_list.get(i);
    float ph = waves_w.get(x, y);
    float a = waves_w.geta(x, y);
    px += ph * cos(a);
    py += ph * sin(a);
    pz += ph;
  }
   
  fill(map(x + y, 0, width + height, waves_mincolorhue, waves_maxcolorhue), 255, 200);
  noStroke();
  ellipse(px, py, pz, pz);
}
 
public void clear() {
  fill(0, 0, 0, waves_attenuation);
  rect(0, 0, width, height);
}


class ColorWave {
  float x, y;
  float amp;
  float it;
   
  ColorWave(float xx, float yy, float aa, float st) {
    x = xx;
    y = yy;
    amp = aa;
     
    it = st;
  }
   
  public float get(float px, float py) {
    float r = dist(x, y, px, py);
     
    float ph = 75 * (waves_t - it) - r / 8;
     
    return amp * sin(ph) / ph;
  }
   
  public float geta(float px, float py) {
    float a = atan2(px - x, py - y);
     
    return a;
  }
}

//////////////////////////////////////////
// Specific actions for the ContinuousTriangles animation
//////////////////////////////////////////

public void draw_continuoustriangles() {
  background(0); 
  if (continoustriangles_invert == false) {
    draw_lefttrangles();
    draw_centertrangles();
    draw_righttrangles();
  }
  else {
    draw_lefttranglesinvert();
    draw_centertranglesinvert();
    draw_righttranglesinvert();
  }
}

public void draw_lefttrangles() { 
 if (NUMBER_OF_PANELS == 3) {
   fill(continoustriangles_black);
   rect(0,0,width/NUMBER_OF_PANELS,height);
   draw_singletriangle(0, continoustriangles_leftposy - height, true, continoustriangles_white);
   draw_singletriangle(0, continoustriangles_leftposy - height/2, true, continoustriangles_white);
   draw_singletriangle(0, continoustriangles_leftposy, true, continoustriangles_white);
   draw_singletriangle(0, continoustriangles_leftposy + height/2, true, continoustriangles_white);
 }
 else if (NUMBER_OF_PANELS == 5) {
   pushMatrix();
   translate(width/NUMBER_OF_PANELS,0);
   fill(continoustriangles_black);
   rect(0,0,width/NUMBER_OF_PANELS,height);
   draw_singletriangle(0, continoustriangles_leftposy - height, true, continoustriangles_white);
   draw_singletriangle(0, continoustriangles_leftposy - height/2, true, continoustriangles_white);
   draw_singletriangle(0, continoustriangles_leftposy, true, continoustriangles_white);
   draw_singletriangle(0, continoustriangles_leftposy + height/2, true, continoustriangles_white);
   popMatrix();
  } 
 continoustriangles_leftposy = (continoustriangles_leftposy + continoustriangles_leftspeed) % height; 
}

public void draw_centertrangles() {
 
 if (NUMBER_OF_PANELS == 3) {
   fill(continoustriangles_white);
   rect(width/NUMBER_OF_PANELS,0,width/3,height);  
   draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy - height), false, continoustriangles_black);
   draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy - height/2), false, continoustriangles_black);
   draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy), false, continoustriangles_black);
   draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy + height/2), false, continoustriangles_black); 
   continoustriangles_centerposy = (continoustriangles_centerposy + continoustriangles_centerspeed) % height;
 } 
 else if (NUMBER_OF_PANELS == 5) {
   for (int i = 0; i<(NUMBER_OF_PANELS/2)+1; i++) {
     pushMatrix();
     translate((2*i*width/NUMBER_OF_PANELS),0);
     fill(continoustriangles_white);
     rect(0,0,width/NUMBER_OF_PANELS,height);  
     draw_singletriangle(0, height - (continoustriangles_centerposy - height), false, continoustriangles_black);
     draw_singletriangle(0, height - (continoustriangles_centerposy - height/2), false, continoustriangles_black);
     draw_singletriangle(0, height - (continoustriangles_centerposy), false, continoustriangles_black);
     draw_singletriangle(0, height - (continoustriangles_centerposy + height/2), false, continoustriangles_black); 
     continoustriangles_centerposy = (continoustriangles_centerposy + continoustriangles_centerspeed) % height;
     popMatrix();   
   }
 } 
}

public void draw_righttrangles() {
  if (NUMBER_OF_PANELS == 3) {
    fill(continoustriangles_black);
    pushMatrix();
    translate((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);
    rect(0,0,width/NUMBER_OF_PANELS,height);
    draw_singletriangle(0, continoustriangles_rightposy - height, true, continoustriangles_white);
    draw_singletriangle(0, continoustriangles_rightposy - height/2, true, continoustriangles_white);
    draw_singletriangle(0, continoustriangles_rightposy, true, continoustriangles_white);
    draw_singletriangle(0, continoustriangles_rightposy + height/2, true, continoustriangles_white);
    continoustriangles_rightposy = (continoustriangles_rightposy + continoustriangles_rightspeed) % height;
    popMatrix();
  }
  else if (NUMBER_OF_PANELS == 5) {
    fill(continoustriangles_black);
    pushMatrix();
    translate((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS,0);
    rect(0,0,width/NUMBER_OF_PANELS,height);
    draw_singletriangle(0, continoustriangles_rightposy - height, true, continoustriangles_white);
    draw_singletriangle(0, continoustriangles_rightposy - height/2, true, continoustriangles_white);
    draw_singletriangle(0, continoustriangles_rightposy, true, continoustriangles_white);
    draw_singletriangle(0, continoustriangles_rightposy + height/2, true, continoustriangles_white);
    continoustriangles_rightposy = (continoustriangles_rightposy + continoustriangles_rightspeed) % height;
    popMatrix();
  } 
}

public void draw_lefttranglesinvert() {
  if (NUMBER_OF_PANELS == 3) {  
    fill(continoustriangles_white);
    rect(0,0,width/NUMBER_OF_PANELS,height);
    draw_singletriangle(0, continoustriangles_leftposy + 2*height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_leftposy + 3*height/2, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_leftposy + height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_leftposy + height/2, false, continoustriangles_black);
    continoustriangles_leftposy = (continoustriangles_leftposy - continoustriangles_leftspeed) % height;
  }
  else if (NUMBER_OF_PANELS == 5) {
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,0);
    fill(continoustriangles_white);
    rect(0,0,width/NUMBER_OF_PANELS,height);
    draw_singletriangle(0, continoustriangles_leftposy + 2*height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_leftposy + 3*height/2, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_leftposy + height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_leftposy + height/2, false, continoustriangles_black);
    continoustriangles_leftposy = (continoustriangles_leftposy - continoustriangles_leftspeed) % height; 
    popMatrix();
  }
}

public void draw_centertranglesinvert() {
  if (NUMBER_OF_PANELS == 3) {  
    fill(continoustriangles_black);
    rect(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height);  
    draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy + 2*height), true, continoustriangles_white);
    draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy + 3*height/2), true, continoustriangles_white); 
    draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy + height), true, continoustriangles_white);
    draw_singletriangle(width/NUMBER_OF_PANELS, height - (continoustriangles_centerposy + height/2), true, continoustriangles_white);
    continoustriangles_centerposy = (continoustriangles_centerposy - continoustriangles_centerspeed) % height;
  }
  else if (NUMBER_OF_PANELS == 5) {
    for (int i = 0; i<(NUMBER_OF_PANELS/2)+1; i++) {
      pushMatrix();
      translate((2*i*width/NUMBER_OF_PANELS),0);
      fill(continoustriangles_black);
      rect(0,0,width/NUMBER_OF_PANELS,height);  
      draw_singletriangle(0, height - (continoustriangles_centerposy + 2*height), true, continoustriangles_white);
      draw_singletriangle(0, height - (continoustriangles_centerposy + 3*height/2), true, continoustriangles_white); 
      draw_singletriangle(0, height - (continoustriangles_centerposy + height), true, continoustriangles_white);
      draw_singletriangle(0, height - (continoustriangles_centerposy + height/2), true, continoustriangles_white);
      continoustriangles_centerposy = (continoustriangles_centerposy - continoustriangles_centerspeed) % height;
      popMatrix();
    }
  }   
}

public void draw_righttranglesinvert() {
  if (NUMBER_OF_PANELS == 3) {
    pushMatrix();
    translate((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS,0);
    fill(continoustriangles_white);
    rect(0,0,width/NUMBER_OF_PANELS,height);
    draw_singletriangle(0, continoustriangles_rightposy + 2*height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_rightposy + 3*height/2, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_rightposy + height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_rightposy + height/2, false, continoustriangles_black);
    continoustriangles_rightposy = (continoustriangles_rightposy - continoustriangles_rightspeed) % height;
    popMatrix();
  } 
  else if (NUMBER_OF_PANELS == 5) {
    pushMatrix();
    translate((NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS,0);
    fill(continoustriangles_white);
    rect(0,0,width/NUMBER_OF_PANELS,height);
    draw_singletriangle(0, continoustriangles_rightposy + 2*height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_rightposy + 3*height/2, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_rightposy + height, false, continoustriangles_black);
    draw_singletriangle(0, continoustriangles_rightposy + height/2, false, continoustriangles_black);
    continoustriangles_rightposy = (continoustriangles_rightposy - continoustriangles_rightspeed) % height;
    popMatrix();
  } 
}


public void draw_singletriangle(float posx, float posy, boolean direction, int col) {
 fill(col);
 beginShape();
 vertex(4+posx,posy);
 vertex(4+posx + 0.7f*width/NUMBER_OF_PANELS,posy);
 if (direction == true) {
   vertex(4+posx + 0.7f*width/(NUMBER_OF_PANELS*2), posy + 0.7f*height/2);
 }
 else {
   vertex(4+posx + 0.7f*width/(NUMBER_OF_PANELS*2), posy - 0.7f*height/2); 
 }
 endShape();  
}


public void continoustriangles_setup() {
  if (continoustriangles_drift == true) {
    continoustriangles_leftspeed = 1.2f;
    continoustriangles_centerspeed = 1.8f;
    continoustriangles_rightspeed = 2.4f;
  }
  else {
    continoustriangles_leftspeed = 1.2f;
    continoustriangles_centerspeed = 1.2f;
    continoustriangles_rightspeed = 1.2f;
  }
  if (continoustriangles_resync == true) {
    continoustriangles_leftposy = 0;
    continoustriangles_centerposy = 0;
    continoustriangles_rightposy = 0;
    continoustriangles_resync = false;
  }
  else {
  }
}


//////////////////////////////////////////
// Specific actions for the Mandala animation
//////////////////////////////////////////

public void draw_mandala(){
    
  background(0);
  stroke(255);
  fill(255);
  ellipse(width/2,height/2,mandala_figuresize*0.95f,mandala_figuresize*0.95f);
  fill(0);
  ellipse(width/2,height/2,mandala_figuresize*0.91f,mandala_figuresize*0.91f);
  fill(255);
  ellipse(width/2,height/2,mandala_figuresize*0.88f,mandala_figuresize*0.88f);
    

  //layer 2
  pushMatrix();
  translate(width/2,height/2);
  rotate(mandala_angle);
  for(int j=0;j<mandala_numstarlayers;j+=1){
    for(int i=0;i<mandala_numsquares;i+=1){
      rotate(2*PI/(mandala_numstars));
      noStroke();
      fill(mandala_color);
      mandala_quad(0,PApplet.parseInt((width/1000.0f)*(190+j*100)),PApplet.parseInt((width/1000.0f)*(50+j*8)));
    }
   }
  stroke(255-mandala_color);
  strokeWeight(8);
  line(-mandala_barsize/2,0,mandala_barsize/2,0);
  strokeWeight(1);  
  
  popMatrix();
  mandala_angle-=0.05f;
  
  
  pushMatrix();
  translate(width/2,height/2);
  rotate(mandala_angle2);
  
  fill(255,0,0);
  noStroke();
  ellipse(height*0.5f,0,mandala_ballsize,mandala_ballsize);
  ellipse(-height*0.5f,0,mandala_ballsize,mandala_ballsize);
  popMatrix();
  
  mandala_angle2 += 0.075f;
  if (mandala_ballsize > mandala_minballsize) {
    mandala_ballsize -= 3;
  }    
  
  if (mandala_switch) {
    if (mandala_color > 0) {
      mandala_color=max(mandala_color-10,0);
    }
  }
  else {
    if (mandala_color < 255) {
      mandala_color=min(mandala_color+10,255);
    }    
  }

}
  

 public void mandala_quad(int x,int y,int offset){
   quad(x,y,x+offset,y-offset,x,y-offset*2,x-offset, y-offset);
 }
 
 
//////////////////////////////////////////
// Specific actions for the Kaleido animation
//////////////////////////////////////////
 
public void draw_kaleido() {
  kaleido_posX += 3;
  
  if (kaleido_posX > 600) {
   kaleido_posX = 0; 
  }
  
  background(0);
  kaleido_t+= kaleido_posX;
  for (int i = 0; i < kaleido_rings; i++) {
     
    int kaleido_ntris = ceil(noise(kaleido_seed+i, kaleido_posX/500.0f)*10);
    kaleido_ntris = 10;
    float kaleido_rad = 8*noise(kaleido_seed+(kaleido_t/20000.0f)+500, kaleido_seed+i);
    float kaleido_width = kaleido_posX * noise(kaleido_seed+i, kaleido_t/10000.0f);
    float kaleido_height = kaleido_posX * noise(kaleido_seed+i+200, kaleido_t/10000.0f);
     
    if (i > kaleido_rings-5) {
      kaleido_width /= 5.0f;
      kaleido_height /= 5.0f;
      kaleido_rad /= 2.0f;
    }
     
    pushMatrix();
    translate(width/2,height/2);
     
    noStroke();
     
    float rcolor = 4 * noise(kaleido_seed+(kaleido_posX + 1000 + kaleido_t/100.0f)/500, kaleido_seed+i);
 
    if (rcolor > 1.6f) {
      if (i > kaleido_rings-2) {
        fill(0,160,255);
      }
      else {
        fill(250,0,70);
      }
    }
    else {
      fill(0);
    }
     
    //rotate(t/10000.0);
    rotate(i);
     
    for (int j = 0; j < kaleido_ntris; j++) {
      rotate(PI*2 / kaleido_ntris);
      triangle(-kaleido_width, kaleido_rad, kaleido_width, kaleido_rad, 0, kaleido_rad+kaleido_height);
    }
    popMatrix();
  }
}

public void draw_kaleidoinverse() {
  kaleido_posX += 3;
  
  if (kaleido_posX > 600) {
   kaleido_posX = 0; 
  }
  
  background(255);
  kaleido_t+= kaleido_posX;
  for (int i = 0; i < kaleido_rings; i++) {
     
    //int kaleido_ntris = ceil(noise(kaleido_seed+i, kaleido_posX/500.0)*10);
    int kaleido_ntris = 8;
    float kaleido_rad = 10*noise(kaleido_seed+(kaleido_t/20000.0f)+500, kaleido_seed+i);
    float kaleido_width = kaleido_posX * noise(kaleido_seed+i, kaleido_t/10000.0f);
    float kaleido_height = kaleido_posX * noise(kaleido_seed+i+200, kaleido_t/10000.0f);
     
    if (i > kaleido_rings-5) {
      kaleido_width /= 5.0f;
      kaleido_height /= 5.0f;
      kaleido_rad /= 2.0f;
    }
     
    pushMatrix();
    translate(width/2,height/2);
     
    noStroke();
     
    float rcolor = 4 * noise(kaleido_seed+(kaleido_posX + 1000 + kaleido_t/100.0f)/500, kaleido_seed+i);
 
    if (rcolor > 1.6f) {
      if (i > kaleido_rings-2) {
        fill(250,0,70);
      }
      else {
        fill(0,160,255);
      }
    }
    else {
      fill(255);
    }
     
    //rotate(t/10000.0);
    rotate(i);
     
    for (int j = 0; j < kaleido_ntris; j++) {
      rotate(PI*2 / kaleido_ntris);
      triangle(-kaleido_width, kaleido_rad, kaleido_width, kaleido_rad, 0, kaleido_rad+kaleido_height);
    }
    popMatrix();
  }
}


//////////////////////////////////////////
// Specific actions for the Flowers animation
//////////////////////////////////////////

public void draw_flower() {
  filter(BLUR);
  for(Iterator i=flowers_flowers.iterator(); i.hasNext();) {
    Flower flower = (Flower)i.next();
    flower.drawFlower();
  }
}
 

public void initFlowers() {
  
  flowers_flowers = new ArrayList();
  addConcentricFlowers(width/2, height/2, width/2, 10*(flowers_sequencenumber%25));  //random(TWO_PI)
  
}
 
public void addConcentricFlowers(float x, float y, float maxRadius, float colorHue) {
  int petalCount = (int)random(1, 8);
  int pointsPerPetal = (int)random(20, 200) / petalCount;
  for (int i=1; i<6; i++) {
    flowers_flowers.add(new Flower(x, y, maxRadius/8*(6-i), petalCount, pointsPerPetal, color(colorHue, 255, 255*((float)i)/5)));
  }
}
 
class RandomOscillator {
  float mean;
  float amplitude;
  float value;
  float angle;
  float multiplier;
   
  RandomOscillator(float mean, float amplitude, float startValue) {
    this.mean = mean;
    this.amplitude = amplitude;
    this.angle = random(TWO_PI);
    this.multiplier = mean !=0 ? startValue / mean : 1;
    next();
  }
   
  public float getValue() {
    return value;
  }
   
  public void next(){
    angle = (angle+random(PI/50)) % TWO_PI;
    value = multiplier*(mean + amplitude*sin(angle));
    multiplier += (1-multiplier) * 0.03f;
   }
}
 
class Flower {
  float x;
  float y;
  int petalCount;
  int pointsPerPetal;
  int clr;
  RandomOscillator radiusOscillators[];
  RandomOscillator angleOscillators[];
   
  Flower(float x, float y, float meanRadius, int petalCount, int pointsPerPetal, int clr) {
    this.x = x;
    this.y = y;
    this.petalCount = petalCount; 
    this.pointsPerPetal = pointsPerPetal;
    this.clr = clr;
    this.radiusOscillators =  new RandomOscillator[pointsPerPetal];
    this.angleOscillators = new RandomOscillator[pointsPerPetal];
    for (int i=0; i<pointsPerPetal; i++) {
      this.radiusOscillators[i] = new RandomOscillator(meanRadius, meanRadius*0.3f, 0);
      this.angleOscillators[i] = new RandomOscillator(0, TWO_PI/petalCount/pointsPerPetal*3, 0);     
    }
  }
   
  public void drawFlower() {
    stroke(clr);
    beginShape();
    float angle = TWO_PI / petalCount / pointsPerPetal;
    for (int i=0; i<petalCount*pointsPerPetal+3; i++) {
      float alfa = angle*i + angleOscillators[i%pointsPerPetal].getValue();
      float radius = radiusOscillators[i%pointsPerPetal].getValue();
      curveVertex(radius*sin(alfa)+x, radius*cos(alfa)+y);
    }
    endShape();
    for(int i=0; i<pointsPerPetal; i++) {
      radiusOscillators[i].next();
      angleOscillators[i].next();
    } 
  }
}


//////////////////////////////////////////
// Specific actions for the ElectricSpiral animation
//////////////////////////////////////////


public void draw_electricspiral()
{
  filter(BLUR);
  filter(ERODE);
  electricspiral_framecounter += electricspiral_animationspeed;
  //long electricspiral_cMillis = millis();
  long electricspiral_cMillis = electricspiral_framecounter;
  float electricspiral_timer = electricspiral_cMillis*.001f*electricspiral_speed;
 
  electricspiral_counter = PApplet.parseInt(electricspiral_timer / electricspiral_cycleLength);   
 
  for (int i = 0; i < electricspiral_nbrPoints; i++)
  {
      ElectricSpiralDot  electricspiral_dt = electricspiral_dots[i];
      float electricspiral_r = i/(float)electricspiral_nbrPoints;
      if ((electricspiral_counter & 1) != 0)
        electricspiral_r = 1-electricspiral_r;
 
      float electricspiral_a = electricspiral_timer * electricspiral_r;
      float electricspiral_len = i*electricspiral_crad/(float)electricspiral_nbrPoints;
       
      // len *= sin(a*timer*my*.25);
      int electricspiral_x = (int) (electricspiral_cx - sin(electricspiral_a)*electricspiral_len);
      int electricspiral_y = (int) (electricspiral_cy + cos(electricspiral_a)*electricspiral_len);
      float electricspiral_huev = 255*electricspiral_r+electricspiral_timer*.002f; //  + mouseY/(float)height;
      electricspiral_huev -= PApplet.parseInt(electricspiral_huev);
      //float electricspiral_satv = electricspiral_cMillis-electricspiral_dt.lastSound < 500? (electricspiral_cMillis-electricspiral_dt.lastSound)/4 : 127;

      //float electricspiral_minRad = 255*(2+i/6.0);
      //float electricspiral_radv = electricspiral_cMillis-electricspiral_dt.lastSound < 500? (electricspiral_minRad+6)-6*(electricspiral_cMillis-electricspiral_dt.lastSound)/2 : electricspiral_minRad;
     //  fill(color(huev,satv,1));
     // ellipse(x,y,radv,radv);
      electricspiral_dt.x = electricspiral_x;
      electricspiral_dt.y = electricspiral_y;
      electricspiral_dt.sIdx = -1;
      electricspiral_dt.tine = electricspiral_a;
  }
  strokeWeight(2);
  stroke((millis() % 1000) / 4);
  //stroke(1);
  for (int i = 0; i < electricspiral_nbrPoints; i++)
  {
     ElectricSpiralDot electricspiral_dt = electricspiral_dots[i];
     // if (dt.sIdx == -1) {
         // Find closest line
         int cIdx = 0, cIdx2 = 0;
         float mDst = pow(electricspiral_dots[cIdx].x - electricspiral_dt.x,2) + pow(electricspiral_dots[cIdx].y-electricspiral_dt.y,2);
         for (int j = 0; j < electricspiral_nbrPoints; ++j) {
           if (j == i)
             continue;
           float tDst = pow(electricspiral_dots[j].x - electricspiral_dt.x,2) + pow(electricspiral_dots[j].y-electricspiral_dt.y,2);
           if (tDst < mDst) {
               mDst = tDst;
               cIdx2 = cIdx;
               cIdx = j;
           }
         }
         electricspiral_dots[i].sIdx = cIdx;
         electricspiral_dots[cIdx].sIdx = i;
         float electricspiral_r1 = i/(float)electricspiral_nbrPoints;
         float electricspiral_r2 = cIdx/(float)electricspiral_nbrPoints;
         float electricspiral_r3 = (electricspiral_r1+electricspiral_r2)/2;
         float electricspiral_huev = 255*electricspiral_r3+electricspiral_timer*.002f; //  + mouseY/(float)height;
         electricspiral_huev -= PApplet.parseInt(electricspiral_huev);
         stroke(color((150*(electricspiral_huev/6)),255,200));
         line(electricspiral_dots[i].x,electricspiral_dots[i].y,electricspiral_dots[cIdx].x,electricspiral_dots[cIdx].y);
         line(electricspiral_dots[i].x,electricspiral_dots[i].y,electricspiral_dots[cIdx2].x,electricspiral_dots[cIdx2].y);
  }
 
  electricspiral_timer -= electricspiral_speed;
 
  electricspiral_frameCtr++;
}
 
public class ElectricSpiralDot {
    public float x;
    public float y;
    public int sIdx;
    float  tine;
    long  lastSound;
}; 

//////////////////////////////////////////
// Specific actions for the SmallSquares animations
//////////////////////////////////////////

public void draw_smallsquareleft() {
  background(0);
  noStroke();
  fill(255);
  if (frameCount % 6 != 0) {
    int bonus_size;
    if (random(1) > 0.85f) {
      if (random(1) > 0.5f) {
        bonus_size = 8;
      }
      else {
        bonus_size = -8;
      }
    }
    else {
      bonus_size = 0; 
    }
    rect(((NUMBER_OF_PANELS-1)/2 - 1)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size);
  }
}

public void draw_smallsquarecenter() {
  background(0);
  noStroke();
  fill(255);
  if (frameCount % 6 != 0) {
    int bonus_size;
    if (random(1) > 0.85f) {
      if (random(1) > 0.5f) {
        bonus_size = 8;
      }
      else {
        bonus_size = -8;
      }
    }
    else {
      bonus_size = 0; 
    }
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size);
  }
}


public void draw_smallsquareright() {
  background(0);
  noStroke();
  fill(255);
  if (frameCount % 6 != 0) {
    int bonus_size;
    if (random(1) > 0.85f) {
      if (random(1) > 0.5f) {
        bonus_size = 8;
      }
      else {
        bonus_size = -8;
      }
    }
    else {
      bonus_size = 0; 
    }
    rect(((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size);
  }
}

public void draw_smallsquares() {
  background(0);
  noStroke();
  fill(255);

  int bonus_size1, bonus_size2, bonus_size3;
  if (random(1) > 0.85f) {
    if (random(1) > 0.5f) {
      bonus_size1 = 8;
    }
    else {
      bonus_size1 = -8;
    }
  }
  else {
    bonus_size1 = 0; 
  }
  if (random(1) > 0.85f) {
    if (random(1) > 0.5f) {
      bonus_size2 = 8;
    }
    else {
      bonus_size2 = -8;
    }  }
  else {
    bonus_size2 = 0; 
  }
  if (random(1) > 0.85f) {
    if (random(1) > 0.5f) {
      bonus_size3 = 8;
    }
    else {
      bonus_size3 = -8;
    }  }
  else {
    bonus_size3 = 0; 
  }
  
  if (frameCount % 6 != 0) {
    rect(((NUMBER_OF_PANELS-1)/2 - 1)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size1, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size1, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size1, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size1);
  }
  
  if (frameCount % 5 != 0) {
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size2, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size2, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size2, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size2);
  }
  
  if (frameCount % 7 != 0) {
    rect(((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size3, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size3, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size3, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size3);

  }
  
  
  if (NUMBER_OF_PANELS == 5) {
  if (frameCount % 8 != 0) {
    rect(((NUMBER_OF_PANELS-1)/2 - 2)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size1, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size1, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size1, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size1);
  }

  if (frameCount % 9 != 0) {
    rect(((NUMBER_OF_PANELS-1)/2 + 2)*width/NUMBER_OF_PANELS + smallsquares_offset - bonus_size1, 
          height/2 - (width/(2*NUMBER_OF_PANELS)) + smallsquares_offset - bonus_size1, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size1, 
          width/NUMBER_OF_PANELS - 2*smallsquares_offset + 2*bonus_size1);
  }
    
  }

}


//////////////////////////////////////////
// Specific actions for the FastSpiral animations
//////////////////////////////////////////

public void fastspiral_init() {
  fastspiral_x = width/2;
  fastspiral_y = height/2;
  fastspiral_theta = 0; 
  fastspiral_r = 0;
  fastspiral_kill = false;
  fastspiral_c = color(255,0,0);
  
  background(0);
  frameRate(120);
  colorMode(RGB); 
}

public void draw_fastspiral() {
 
  float fastspiral_x = width/2 + fastspiral_r * cos(fastspiral_theta);
  float fastspiral_y = height/2 + fastspiral_r * sin(fastspiral_theta);
 
  // Draw an ellipse at x,y
  noStroke();

  
  if (fastspiral_kill == false) {
    fastspiral_c = PApplet.parseInt(0+(6*fastspiral_theta));
    fastspiral_transparency = 255;
  }
  else {
    fastspiral_c = 0;
    fastspiral_transparency = PApplet.parseInt(0+(8*fastspiral_theta));
  }

  fill(fastspiral_c,0,0,fastspiral_transparency);
  noStroke();
  // Adjust for center of window
  if (fastspiral_kill == false) {
    ellipse(fastspiral_x, fastspiral_y, 14, 14);
  }
  else {
    ellipse(fastspiral_x, fastspiral_y, 32, 32);
  }
  if (fastspiral_kill == false) {
    // Increment the angle
    fastspiral_theta += .5f;
    // Increment the radius
    fastspiral_r += 0.4f;
  }
  else {
    if (fastspiral_r > 0) {
      // Decrement the angle
      fastspiral_theta -= .35f;
      // Decrement the radius
      fastspiral_r -= 0.4f;
    }
  }
  if (fastspiral_kill == false) {
    if (fastspiral_r > width/2) {
      fastspiral_kill = !fastspiral_kill;
      fastspiral_r += 6;
      fastspiral_theta += 0.4f;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the ProgressiveRed animation
//////////////////////////////////////////

public void draw_progressivered() {
  progressivered_color += 1;
  fill(progressivered_color, 0, 0);
  rect(0,0,width,height);
  
}


//////////////////////////////////////////
// Specific actions for the WeirdSquare animation
//////////////////////////////////////////

public void draw_weirdsquare() {
  background(0);
  weirdsquare_redbackground+=1;
  
  fill(0,255,weirdsquare_redbackground);
  rect(0,0,width,height);
  
  pushMatrix();
  translate(width/2,height/2);  
  fill(weirdsquare_getColor(weirdsquare_step*3/2, weirdsquare_step*3/2));
  beginShape();
  
  int x0 = -weirdsquare_step/2;
  int y0 = -weirdsquare_step/2;
  int x1 = weirdsquare_step/2;
  int y1 = weirdsquare_step/2;

  vertex(x0, y0);
  weirdsquare_addBezierVertex(x0, y0, x1, y0);
  weirdsquare_addBezierVertex(x1, y0, x1, y1);
  weirdsquare_addBezierVertex(x1, y1, x0, y1);
  weirdsquare_addBezierVertex(x0, y1, x0, y0);
  endShape();
  weirdsquare_time += 0.05f;
  hueOffset += noise(weirdsquare_time)*weirdsquare_noiseSpeed;
  popMatrix();
}
 
public int weirdsquare_getColor(int x, int y) {
  return color((noise(weirdsquare_time, x*0.1f/weirdsquare_step, y*0.1f/weirdsquare_step)*0.5f+hueOffset)%1, noise(weirdsquare_time, x*0.1f/weirdsquare_step+1000, y*0.1f/weirdsquare_step+1000)*2*255, weirdsquare_redbackground);
}
 
public float weirdsquare_getRotation(int x, int y) {
  return (noise(weirdsquare_time, x*0.1f/weirdsquare_step-1000, y*0.1f/weirdsquare_step-1000)-0.5f)*PI;
}
 
public void weirdsquare_addBezierVertex(int x0, int y0, int x1, int y1) {
  float a = atan2(y1-y0, x1-x0);
  float a0 = a + weirdsquare_getRotation(x0, y0);
  float a1 = a + weirdsquare_getRotation(x1, y1);
     
  bezierVertex(x0+weirdsquare_bezierbase*cos(a0), y0+weirdsquare_bezierbase*sin(a0), x1-weirdsquare_bezierbase*cos(a1), y1-weirdsquare_bezierbase*sin(a1), x1, y1);
}
 

public void weirdsquare_initialize() {
  noiseSeed((int)random(10000));
  //hueOffset = random(1);
}


//////////////////////////////////////////
// Specific actions for the SpotsMultiColor animation
//////////////////////////////////////////


public void draw_spotsmulticolor() {
  if ((frameCount % PApplet.parseInt(random(3,4)) == 0))
  {
    background(0);
    int randomcol = (int) spotsmulticolor_colorselection[floor(random(spotsmulticolor_colorselection.length))];
    fill(randomcol);
    stroke(randomcol);
    
    int nombreSpotDroite = (int)random(0, 5);
    int nombreSpotGauche = (int)random(0, 2);
    for(int i=0;i<nombreSpotDroite;i++){
      float x1 = random(width/3, width);
      float x2 = random(-width/4, width);
      line(x1, 0, x2, height);
      line(x1, 0, x2+spots_tailleCone, height);
      line(x1, 0, x2-spots_tailleCone, height);
    }
    for(int i=0;i<nombreSpotGauche;i++){
      float x3 = random(-width/3, 0);
      float x4 = random(0, 2*width/3);    
      line(x3, 0, x4, height);
      line(x3, 0, x4+spots_tailleCone, height);
      line(x3, 0, x4-spots_tailleCone, height);
    }  
  }
}
  
//////////////////////////////////////////
// Specific actions for the StroboLineColor animation
//////////////////////////////////////////

public void draw_strobolinecolor() {
  int randomcol = (int) spotsmulticolor_colorselection[floor(random(spotsmulticolor_colorselection.length))];
  fill(randomcol);
  stroke(randomcol);

  if (frameCount % PApplet.parseInt(random(3,5)) == 0)
  {
    background(0);  
    int nombreRectangle = (int)random(0, 10);
    for(int i=0;i<nombreRectangle;i++){
      rect(random(0,width), 0, random(1, width/10), height);
      }
    }
}
  
//////////////////////////////////////////
// Specific actions for the StroboColor animation
//////////////////////////////////////////

public void draw_strobocolor() {
  if (frameCount % 2 == 0)
  {
    int randomcol = (int) spotsmulticolor_colorselection[floor(random(spotsmulticolor_colorselection.length))];
    fill(randomcol);
    noStroke();
    rect(0,0,width,height);
  }
  else
  {
    fill(0);
    rect(0,0,width,height);
  }
}


//////////////////////////////////////////
// Specific actions for the DoubleFlowers animation
//////////////////////////////////////////

public void draw_doubleflowers() {
  background(0);
  for(Iterator i=doubleflower_flowers.iterator(); i.hasNext();) {
    DoubleFlower doubleflower = (DoubleFlower)i.next();
    doubleflower.drawFlower();
  }
 
  for(Iterator i=doubleflower_flowers.iterator(); i.hasNext();) {
    DoubleFlower doubleflower = (DoubleFlower)i.next();
    doubleflower.next();
  }
 
  for(Iterator i=doubleflower_zOscillators.iterator(); i.hasNext();) {
    DoubleRandomOscillator doubleoscillator = (DoubleRandomOscillator)i.next();
    doubleoscillator.next();
  }
}
 

 
public void doubleflower_initFlowers() {
  doubleflower_flowers = new ArrayList();
  doubleflower_zOscillators = new ArrayList();
  float hueValue = random(TWO_PI);
  int colorSat = 255;
  doubleflower_addConcentricFlowers(0*width/12, height/2, 3*width/4, hueValue, colorSat);
  doubleflower_addConcentricFlowers(12*width/12, height/2, 3*width/4, hueValue, colorSat);

}
 
public void doubleflower_addConcentricFlowers(float x, float y, float maxRadius, float colorHue, int colorSat) {
  DoubleRandomOscillator doubleflower_zOscillator = new DoubleRandomOscillator(3.5f, 2.5f, 0);
  doubleflower_zOscillators.add(doubleflower_zOscillator);
  for (int i=1; i<6; i++) {
    doubleflower_flowers.add(new DoubleFlower(x, y, i, doubleflower_zOscillator, maxRadius/8*(6-i), (int)(3+random(3)), (int)(3+random(2)), color(colorHue, colorSat, 255*((float)i)/5)));
  }
}
 
class DoubleRandomOscillator {
  float mean;
  float amplitude;
  float value;
  float angle;
  float multiplier;
   
  DoubleRandomOscillator(float mean, float amplitude, float startValue) {
    this.mean = mean;
    this.amplitude = amplitude;
    this.angle = random(TWO_PI);
    this.multiplier = startValue / mean;
    next();
  }
   
  public float getValue() {
    return value;
  }
   
  public void next(){
    angle = (angle+random(PI/20)) % TWO_PI;
    value = multiplier*(mean + amplitude*sin(angle));
    multiplier += (1-multiplier) * 0.01f;
   }
}
 
class DoubleFlower {
  float x;
  float y;
  float zIndex;
  DoubleRandomOscillator zOscillator;
  int petalCount;
  int pointsPerPetal;
  int clr;
  DoubleRandomOscillator oscillators[];
   
  DoubleFlower(float x, float y, float zIndex, DoubleRandomOscillator zOscillator, float meanRadius, int petalCount, int pointsPerPetal, int clr) {
    this.x = x;
    this.y = y;
    this.zIndex = zIndex;
    this.zOscillator = zOscillator;
    this.petalCount = petalCount; 
    this.pointsPerPetal = pointsPerPetal;
    this.clr = clr;
    this.oscillators =  new DoubleRandomOscillator[pointsPerPetal];
    for (int i=0; i<pointsPerPetal; i++) {
      this.oscillators[i] = new DoubleRandomOscillator(meanRadius, meanRadius*0.3f, 0);
    }
  }
   
  public void drawFlower() {
    fill(clr);
    float delta = 200 - zOscillator.getValue()*zIndex;
    float radiusMultiplier = 200/delta;
    for (float x0=x%delta-delta; x0<width+delta-100; x0+=delta) {
      beginShape();
      float angle = TWO_PI / petalCount / pointsPerPetal;
      for (int i=0; i<petalCount*pointsPerPetal+3; i++) {
        float alfa = angle*i;
        float radius = oscillators[i%pointsPerPetal].getValue() * radiusMultiplier;
        curveVertex(radius*sin(alfa)+x0, radius*cos(alfa)+y);
      }
      endShape();
    }
  }
   
  public void next() {
    for(int i=0; i<pointsPerPetal; i++) {
      oscillators[i].next();
    } 
  }
   
}

//////////////////////////////////////////
// Specific actions for the 3D Animations 
//////////////////////////////////////////

public void draw_thirdDimension_bigasscube() {
  thirdDimension_drawNormal();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_cornercube() {
  thirdDimension_drawNormal();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_glitchcube() {
  thirdDimension_drawGlitch();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_noglitchcube() {
  thirdDimension_drawNormal();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_jerkycube() {
  thirdDimension_drawjerkyEdges();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_movingjerkycube() {
  thirdDimension_drawmovingjerkyEdges();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_doublecube() {
  thirdDimension_drawGlitch();
  thirdDimension_counter += 1;
}


public void draw_thirdDimension_singlepyramid() {
  thirdDimension_viewer3d.movewireframe();
  thirdDimension_viewer3d.display3D();
  thirdDimension_counter += 1;
}

public void draw_thirdDimension_multiplepyramids() {
  if (thirdDimension_counter % thirdDimension_pyramidfrequency == 0) {
    if (random(1) < 0.33f) {
      thirdDimension_viewer3d.create_pyramid(width/2, color(0,0,255), color(0,255,255), 3, 6, false, -width/4, -height/4, random(1, 3), random(0.5f, 2), random(1), random(0.01f, 0.04f), random(0.04f), random(-0.02f, 0.02f), true, true, false, true, false);
    }
    else {
      if (random(1) > 0.5f) {
        thirdDimension_viewer3d.create_pyramid(width/2, color(0,0,255), color(0,255,255), 3, 6, false, -width/4, 5*height/4, random(1, 3), -random(2), random(1), random(0.01f, 0.04f), random(0.04f), random(0.02f, 0.02f), true, true, false, true, false);
      }
      else {
        thirdDimension_viewer3d.create_pyramid(width/2, color(0,0,255), color(0,255,255), 3, 6, false, -width/4, height/2, random(1, 3), random(-0.5f, 0.5f), random(1), random(0.01f, 0.04f), random(0.04f), random(0.02f, 0.02f), true, true, false, true, false);
      }
    }
  }
  
  thirdDimension_drawNormal();
  thirdDimension_counter += 1;
  
  //Remove old pyramids
  thirdDimension_viewer3d.remove_old_pyramids();
}

public void thirdDimension_drawNormal() {
  thirdDimension_viewer3d.movewireframe();
  thirdDimension_viewer3d.display3D();
}

public void thirdDimension_drawGlitch() {
  thirdDimension_viewer3d.movewireframe();
  thirdDimension_viewer3d.displayGlitch3D();
}

public void thirdDimension_drawjerkyEdges() {
  thirdDimension_viewer3d.displayJerkyEdges();
}

public void thirdDimension_drawmovingjerkyEdges() {
  thirdDimension_viewer3d.movewireframe();
  thirdDimension_viewer3d.displayJerkyEdges();
}


class Node3D {
  
 float x,y,z;
 boolean isVisible;
  
  Node3D(float _x, float _y, float _z) {
    this.x=_x;
    this.y=_y;
    this.z=_z;
    this.isVisible = false;
  } 
  
}

class Edge3D {
  
 Node3D start;
 Node3D stop;
 boolean isVisible;
 
 Edge3D(Node3D _start, Node3D _stop) {
   this.start = _start;
   this.stop = _stop; 
   this.isVisible = false;
 } 
 
}

class Face3D {
  
  ArrayList<Node3D> nodes;
  float maxSurface;
  boolean isVisible;
  int faceColor;
  
  Face3D(Node3D node1, Node3D node2, Node3D node3, int faceCol) {
    this.nodes = new ArrayList<Node3D>();
    this.nodes.add(node1);
    this.nodes.add(node2);
    this.nodes.add(node3);
    this.maxSurface = this.calculateMaxSurface(node1, node2, node3);
    this.isVisible = false;
    this.faceColor = faceCol;
  }
  
  Face3D(Node3D node1, Node3D node2, Node3D node3, Node3D node4, int faceCol) {
    this.nodes = new ArrayList<Node3D>();
    this.nodes.add(node1);
    this.nodes.add(node2);
    this.nodes.add(node3);
    this.nodes.add(node4);
    this.maxSurface = this.calculateMaxSurface(node1, node2, node3, node4);
    this.isVisible = false;
    this.faceColor = faceCol;
  }

  Face3D(Node3D node1, Node3D node2, Node3D node3, Node3D node4, Node3D node5, int faceCol) {
    this.nodes = new ArrayList<Node3D>();
    this.nodes.add(node1);
    this.nodes.add(node2);
    this.nodes.add(node3);
    this.nodes.add(node4);
    this.nodes.add(node5);
    this.maxSurface = this.calculateMaxSurface(node1, node2, node3, node4, node5);
    this.isVisible = false;
    this.faceColor = faceCol;
  }
  
  public void displayFace(boolean glitch) {
    displayFace(glitch, 1); 
  }
  
  public void displayFace(boolean glitch, float probability) {
    noStroke();
    if (glitch == true) {      //Glitch : randomly change the face's color to white
      int newcol;
      if (random(1) > 0.1f) {
        newcol = color((hue(this.faceColor) + 255 + random(probability * 20)) % 255,255,255);
      }
      else {
        newcol = color((hue(this.faceColor) + 255 + random(probability * 20)) % 255,0,255);
      }
      fill(newcol);
      if (random(2) > probability) {
        beginShape();
        for (int i = 0; i<this.nodes.size(); i++) {
          vertex(this.nodes.get(i).x, this.nodes.get(i).y);
        }
        endShape();
      }
    }
    else {                    //Noglitch : Add some shading to the faces
      float brightnessratio;
      if (this.nodes.size() == 3) {
        brightnessratio = 255 * (this.visibleSurface(this.nodes.get(0), this.nodes.get(1), this.nodes.get(2))/this.maxSurface);
      }
      else {
        brightnessratio = 255 * (this.visibleSurface(this.nodes.get(0), this.nodes.get(1), this.nodes.get(2), this.nodes.get(3))/this.maxSurface);
      }
      int newCol = color(hue(this.faceColor), saturation(this.faceColor), map(brightnessratio, 0, 255, 60, 255));
      fill(newCol);
      beginShape();
      for (int i = 0; i<this.nodes.size(); i++) {
        vertex(this.nodes.get(i).x, this.nodes.get(i).y);
      }
      endShape();
    }
  }

  public float calculateMaxSurface(Node3D P1, Node3D P2, Node3D P3){
    //Triangle 
    float distanceA = sqrt(sq(P2.x - P1.x) + sq(P2.y - P1.y) + sq(P2.z - P1.z));
    float distanceB = sqrt(sq(P3.x - P1.x) + sq(P3.y - P1.y) + sq(P3.z - P1.z));
    return distanceA * distanceB / 2;
  }

  public float calculateMaxSurface(Node3D P1, Node3D P2, Node3D P3, Node3D P4){
    //Square, or rectangle => no need for the fourth node 
    float distanceA = sqrt(sq(P2.x - P1.x) + sq(P2.y - P1.y) + sq(P2.z - P1.z));
    float distanceB = sqrt(sq(P4.x - P1.x) + sq(P4.y - P1.y) + sq(P4.z - P1.z));
    //float distanceC = sqrt(sq(P3.x - P2.x) + sq(P3.y - P2.y) + sq(P3.z - P2.z));
    //float distanceD = sqrt(sq(P3.x - P1.x) + sq(P3.y - P1.y) + sq(P3.z - P1.z));
    return distanceA * distanceB;
  }

  public float calculateMaxSurface(Node3D P1, Node3D P2, Node3D P3, Node3D P4, Node3D P5){
    //Hexagon - to be done ! 
    outputLog.println("Hexagon surface computation - needs to be implemented !");
    return 0;
  }

  
  public float visibleSurface(Node3D P1, Node3D P2, Node3D P3){
    //No z : only x and y are visible !
    float distanceA = sqrt(sq(P2.x - P1.x) + sq(P2.y - P1.y));
    float distanceB = sqrt(sq(P3.x - P1.x) + sq(P3.y - P1.y));
    return distanceA * distanceB / 2;
  }

  
  public float visibleSurface(Node3D P1, Node3D P2, Node3D P3, Node3D P4){
    //No z : only x and y are visible !
    float distanceA = sqrt(sq(P2.x - P1.x) + sq(P2.y - P1.y));
    float distanceB = sqrt(sq(P4.x - P1.x) + sq(P4.y - P1.y));
    return distanceA * distanceB;
  }
  
  public float visibleSurface(Node3D P1, Node3D P2, Node3D P3, Node3D P4, Node3D P5){
    //Hexagon - to be done ! 
    outputLog.println("Hexagon surface computation - needs to be implemented !");
    return 0;
  }
    
}

class Wireframe3D {

  ArrayList<Node3D> nodes;
  ArrayList<Edge3D> edges;
  ArrayList<Face3D> faces;
  IntList glitchEdges;    //Contains a list of all the edges which will glitch (as int numbers)
  FloatList glitchEdgesProbability;
  IntList glitchFaces;
  FloatList glitchFacesProbability;
  int nodeColor;
  int edgeColor;
  float nodeRadius;
  float strokeWeight;
  
  float SpeedX;
  float SpeedY;
  float SpeedZ;
  float RotX;
  float RotY;
  float RotZ;
  
  boolean displayNodes;
  boolean displayEdges;
  boolean displayFaces;
  boolean glitchScale;
  boolean showHiddenPoints;
  
  Wireframe3D() {
    this.nodes = new ArrayList<Node3D>();
    this.edges = new ArrayList<Edge3D>();
    this.faces = new ArrayList<Face3D>();

    this.glitchEdges = new IntList();
    this.glitchEdgesProbability = new FloatList();
    this.glitchFaces = new IntList();
    this.glitchFacesProbability = new FloatList();
    
    this.nodeColor = color(255);
    this.edgeColor = color(255);
    this.strokeWeight = 1;
    this.nodeRadius = 1;
    
    this.SpeedX = 0;
    this.SpeedY = 0;
    this.SpeedZ = 0;
    this.RotX = 0;
    this.RotY = 0;
    this.RotZ = 0;

    this.displayNodes = true;
    this.displayEdges = true;
    this.displayFaces = true;
    this.glitchScale = false;
    this.showHiddenPoints = false;
  } 
  
  Wireframe3D(int nodeCol, int edgeCol) {
    this.nodes = new ArrayList<Node3D>();
    this.edges = new ArrayList<Edge3D>();
    this.faces = new ArrayList<Face3D>();

    this.glitchEdges = new IntList();
    this.glitchEdgesProbability = new FloatList();
    this.glitchFaces = new IntList();
    this.glitchFacesProbability = new FloatList();
    
    this.nodeColor = color(nodeCol);
    this.edgeColor = color(edgeCol);
    this.strokeWeight = 1;
    this.nodeRadius = 1;
    
    this.SpeedX = 0;
    this.SpeedY = 0;
    this.SpeedZ = 0;
    this.RotX = 0;
    this.RotY = 0;
    this.RotZ = 0;
    
    this.displayNodes = true;
    this.displayEdges = true;
    this.displayFaces = true;
    this.glitchScale = false;
    this.showHiddenPoints = false;
  }   
  
  Wireframe3D(int nodeCol, int edgeCol, int weight, int nodeRadius) {
    this.nodes = new ArrayList<Node3D>();
    this.edges = new ArrayList<Edge3D>();
    this.faces = new ArrayList<Face3D>();

    this.glitchEdges = new IntList();
    this.glitchEdgesProbability = new FloatList();
    this.glitchFaces = new IntList();
    this.glitchFacesProbability = new FloatList();
    
    this.nodeColor = color(nodeCol);
    this.edgeColor = color(edgeCol);
    this.strokeWeight = weight;
    this.nodeRadius = nodeRadius;
    
    this.SpeedX = 0;
    this.SpeedY = 0;
    this.SpeedZ = 0;
    this.RotX = 0;
    this.RotY = 0;
    this.RotZ = 0;
    
    this.displayNodes = true;
    this.displayEdges = true;
    this.displayFaces = true;
    this.glitchScale = false;
    this.showHiddenPoints = false;
  }  

  Wireframe3D(int nodeCol, int edgeCol, int weight, int nodeRadius, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean glitchscale, float speedx, float speedy, float speedz, float rotx, float roty, float rotz) {
    this.nodes = new ArrayList<Node3D>();
    this.edges = new ArrayList<Edge3D>();
    this.faces = new ArrayList<Face3D>();

    this.glitchEdges = new IntList();
    this.glitchEdgesProbability = new FloatList();
    this.glitchFaces = new IntList();
    this.glitchFacesProbability = new FloatList();
    
    this.nodeColor = color(nodeCol);
    this.edgeColor = color(edgeCol);
    this.strokeWeight = weight;
    this.nodeRadius = nodeRadius;
    
    this.SpeedX = speedx;
    this.SpeedY = speedy;
    this.SpeedZ = speedz;
    this.RotX = rotx;
    this.RotY = roty;
    this.RotZ = rotz;
    
    this.displayNodes = displaynodes;
    this.displayEdges = displayedges;
    this.displayFaces = displayfaces;
    this.glitchScale = glitchscale;
    this.showHiddenPoints = false;

  }     
  
  Wireframe3D(int nodeCol, int edgeCol, int weight, int nodeRadius, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean displayhiddenpoints, boolean glitchscale, float speedx, float speedy, float speedz, float rotx, float roty, float rotz) {
    this.nodes = new ArrayList<Node3D>();
    this.edges = new ArrayList<Edge3D>();
    this.faces = new ArrayList<Face3D>();

    this.glitchEdges = new IntList();
    this.glitchEdgesProbability = new FloatList();
    this.glitchFaces = new IntList();
    this.glitchFacesProbability = new FloatList();
    
    this.nodeColor = color(nodeCol);
    this.edgeColor = color(edgeCol);
    this.strokeWeight = weight;
    this.nodeRadius = nodeRadius;
    
    this.SpeedX = speedx;
    this.SpeedY = speedy;
    this.SpeedZ = speedz;
    this.RotX = rotx;
    this.RotY = roty;
    this.RotZ = rotz;
    
    this.displayNodes = displaynodes;
    this.displayEdges = displayedges;
    this.displayFaces = displayfaces;
    this.showHiddenPoints = displayhiddenpoints;
    this.glitchScale = glitchscale;

  }     

  public void defineVisibleNodes() {
    int temp_invisibleNode = 0;
    float temp_z = 10000;
    for (int i = 0; i<nodes.size(); i++) {
      if (nodes.get(i).z < temp_z) {
        temp_z = nodes.get(i).z;
        temp_invisibleNode = i;
      }
    }
    for (int i = 0; i<nodes.size(); i++) {
      if (i == temp_invisibleNode) {
        this.nodes.get(i).isVisible = false;
      }
      else {
        this.nodes.get(i).isVisible = true;
      }
    } 
  }
  
  public void defineVisibleEdges() {
    for (Edge3D edge: this.edges) {
      if (edge.start.isVisible == false || edge.stop.isVisible == false) {
        edge.isVisible = false;
      }
      else {
        edge.isVisible = true;
      }
    } 
  }
  
  public void translate3D(String axis, float distance) {
    if (axis.equals("x")) {
      for (int i=0; i<this.nodes.size(); i++) {
        this.nodes.get(i).x += distance;
      } 
    }
    if (axis.equals("y")) {
      for (int i=0; i<this.nodes.size(); i++) {
        this.nodes.get(i).y += distance;
      } 
    }
    if (axis.equals("z")) {
      for (int i=0; i<this.nodes.size(); i++) {
        this.nodes.get(i).z += distance;
      }
    }
  }
  
  public void scale3D(float centerX, float centerY, float scale) {
    for (Node3D node: this.nodes) {
      node.x = centerX + scale * (node.x - centerX);
      node.y = centerY + scale * (node.y - centerY);
      node.z *= scale;
    }
    this.strokeWeight *= scale;
    this.nodeRadius *= scale;
  }
  
  public void rotate3DX(float[] centerPoint, float angle_rad) {
    //Note: centerPoint : {x,y,z}
    for (Node3D node: this.nodes) {
      float y = node.y - centerPoint[1];
      float z = node.z - centerPoint[2];
      float distance = sqrt(y*y + z*z);
      float theta = atan2(y,z) + angle_rad;
      node.z = centerPoint[2] + distance * cos(theta);
      node.y = centerPoint[1] + distance * sin(theta);
    }
  }
  
  public void rotate3DY(float[] centerPoint, float angle_rad) {
    //Note: centerPoint : {x,y,z}
    for (Node3D node: this.nodes) {
      float x = node.x - centerPoint[0];
      float z = node.z - centerPoint[2];
      float distance = sqrt(x*x + z*z);
      float theta = atan2(x,z) + angle_rad;
      node.z = centerPoint[2] + distance * cos(theta);
      node.x = centerPoint[0] + distance * sin(theta);
    }
  }

  public void rotate3DZ(float[] centerPoint, float angle_rad) {
    //Note: centerPoint : {x,y,z}
    for (Node3D node: this.nodes) {
      float x = node.x - centerPoint[0];
      float y = node.y - centerPoint[1];
      float distance = sqrt(x*x + y*y);
      float theta = atan2(y,x) + angle_rad;
      node.x = centerPoint[0] + distance * cos(theta);
      node.y = centerPoint[1] + distance * sin(theta);
    }
  }

  
  public float[] findCenter() {
    int num_nodes = this.nodes.size();
    float meanX = 0; 
    float meanY = 0;
    float meanZ = 0;
    for (int i=0; i<num_nodes;i++) {
      meanX += this.nodes.get(i).x;
      meanY += this.nodes.get(i).y;
      meanZ += this.nodes.get(i).z;
    }
    float[] centerPoint = {meanX/num_nodes, meanY/num_nodes, meanZ/num_nodes};
    return centerPoint;
  }
  
  public void setAllGlitch() {
    this.glitchEdges = new IntList();
    this.glitchEdgesProbability = new FloatList();
    
    this.glitchFaces = new IntList();
    this.glitchFacesProbability = new FloatList();
    
    for (int i = 0; i<this.edges.size(); i++) {
      this.glitchEdges.append(i);
      this.glitchEdgesProbability.append(random(1));
    }
    for (int i = 0; i<this.faces.size(); i++) {
      this.glitchFaces.append(i);
      this.glitchFacesProbability.append(random(1));
    }
  }
  
  public void addGlitchEdges(int i, float probability) {
    boolean iIsAGlitchEdge = false;
    for (int index = 0; index < this.glitchEdges.size(); index++) {
      if (this.glitchEdges.get(index) == i) {
        iIsAGlitchEdge = true;
      } 
    }

    if (iIsAGlitchEdge == false) {
      this.glitchEdges.append(i);
      this.glitchEdgesProbability.append(probability);
    }
  }
  
  public void removeGlitchEdges(int i) {
    for (int j = 0; j<this.glitchEdges.size(); j++) {
      if (this.glitchEdges.get(j) == i) {
        this.glitchEdges.remove(j);
        this.glitchEdgesProbability.remove(j);
        break;
      }
    }
  }
  
  public void addGlitchFaces(int i, float probability) {
    boolean iIsAGlitchFace = false;
    for (int index = 0; index < this.glitchFaces.size(); index++) {
      if (this.glitchFaces.get(index) == i) {
        iIsAGlitchFace = true;
      } 
    }

    if (iIsAGlitchFace == false) {
      this.glitchFaces.append(i);
      this.glitchFacesProbability.append(probability);
    }
  }
  
  public void removeGlitchFaces(int i) {
    for (int j = 0; j<this.glitchFaces.size(); j++) {
      if (this.glitchFaces.get(j) == i) {
        this.glitchFaces.remove(j);
        this.glitchFacesProbability.remove(j);
        break;
      }
    }
  }  
   
  public void outputNodes() {
    outputLog.println("Nodes registered in the cube :");
    for (int i=0; i<nodes.size();i++) {
      outputLog.println("node " + i + " : x=" + nodes.get(i).x + " y=" + nodes.get(i).y + " z=" +nodes.get(i).z); 
    } 
  }
  
  
  public void outputEdges() {
    outputLog.println("Edges registered in the cube :");
    for (int i=0; i<edges.size();i++) {
      outputLog.println("edge " + i + " : x1=" + edges.get(i).start.x + " y1=" + edges.get(i).start.y + " z1=" +edges.get(i).start.z + " : x2=" + edges.get(i).stop.x + " y2=" + edges.get(i).stop.y + " z2=" +edges.get(i).stop.z); 
    } 
  }
  
}

class ProjectionViewer {

  ArrayList<Wireframe3D> wireframes;
  
  ProjectionViewer() {
    wireframes = new ArrayList<Wireframe3D>();
  }
  
  public void create_cube(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch) {
    create_cube(size, nodecolor, edgecolor, strokeweight, nodeRadius, glitch, 0, 0, 0, 0, 0, 0, 0, 0, true, true, true, false, glitch);
  }
  
  public void create_cube(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch, boolean displaynodes, boolean displayedges, boolean displayfaces) {
    create_cube(size, nodecolor, edgecolor, strokeweight, nodeRadius, glitch, 0, 0, 0, 0, 0, 0, 0, 0, displaynodes, displayedges, displayfaces, false, glitch);
  }
  
  public void create_cube(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch, float posx, float posy, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean showhiddenpoints, boolean glitchscale) {
    float translate_x = 0;
    float translate_y = 0;
    float translate_z = 0;
    float rotate_x = 0.02f;
    float rotate_y = 0.025f;
    float rotate_z = 0.03f;
    create_cube(size, nodecolor, edgecolor, strokeweight, nodeRadius, glitch, posx, posy, translate_x, translate_y, translate_z, rotate_x, rotate_y, rotate_z, displaynodes, displayedges, displayfaces, showhiddenpoints, glitchscale);
    
  }
  
  public void create_cube(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch, float posx, float posy, float translate_x, float translate_y, float translate_z, float rot_anglex, float rot_angley, float rot_anglez, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean showhiddenpoints, boolean glitchscale) {
    create_cube(size, nodecolor, edgecolor, strokeweight, nodeRadius, glitch, posx, posy, translate_x, translate_y, translate_z, rot_anglex, rot_angley, rot_anglez, displaynodes, displayedges, displayfaces, showhiddenpoints, glitchscale, true);
  }
  
  public void create_cube(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch, float posx, float posy, float translate_x, float translate_y, float translate_z, float rot_anglex, float rot_angley, float rot_anglez, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean showhiddenpoints, boolean glitchscale, boolean initRotate) {
    Wireframe3D cube = new Wireframe3D(nodecolor, edgecolor, strokeweight, nodeRadius);
    ArrayList<Node3D> cube_nodes = new ArrayList<Node3D>();
    for (int x=0; x<=1; x++) {
      for (int y=0; y<=1; y++) {
        for (int z=0; z<=1; z++) {
          cube_nodes.add(new Node3D(x*size,y*size,z*size));        
        }
      }
    }
    cube.nodes = cube_nodes;
    int[] nodelist1 = {0,1,2,3};
    for (int i: nodelist1) {
      cube.edges.add(new Edge3D(cube_nodes.get(i), cube_nodes.get(i+4))); 
    }
    int[] nodelist2 = {0,1,4,5};
    for (int i: nodelist2) {
      cube.edges.add(new Edge3D(cube_nodes.get(i), cube_nodes.get(i+2))); 
    }
    int[] nodelist3 = {0,2,4,6};
    for (int i: nodelist3) {
      cube.edges.add(new Edge3D(cube_nodes.get(i), cube_nodes.get(i+1))); 
    }
    
    cube.faces.add(new Face3D(cube_nodes.get(2), cube_nodes.get(0), cube_nodes.get(4), cube_nodes.get(6), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    cube.faces.add(new Face3D(cube_nodes.get(0), cube_nodes.get(1), cube_nodes.get(5), cube_nodes.get(4), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    cube.faces.add(new Face3D(cube_nodes.get(3), cube_nodes.get(1), cube_nodes.get(0), cube_nodes.get(2), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    cube.faces.add(new Face3D(cube_nodes.get(6), cube_nodes.get(4), cube_nodes.get(5), cube_nodes.get(7), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    cube.faces.add(new Face3D(cube_nodes.get(3), cube_nodes.get(2), cube_nodes.get(6), cube_nodes.get(7), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    cube.faces.add(new Face3D(cube_nodes.get(7), cube_nodes.get(5), cube_nodes.get(1), cube_nodes.get(3), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    
    if (glitch == true) {
      cube.setAllGlitch();
    }
    
    //Useful for debug
    //cube.outputNodes();
    //cube.outputEdges();
    
    cube.translate3D("x", posx);
    cube.translate3D("y", posy);
    
    cube.SpeedX = translate_x;
    cube.SpeedY = translate_y;
    cube.SpeedZ = translate_z;
    cube.RotX = rot_anglex;
    cube.RotY = rot_angley;
    cube.RotZ = rot_anglez;
    
    if (initRotate == true) {
      cube.rotate3DX(cube.findCenter(),rot_anglex * 100);
      cube.rotate3DY(cube.findCenter(),rot_angley * 100);
      cube.rotate3DZ(cube.findCenter(),rot_anglez * 100);
    }
    
    cube.displayNodes = displaynodes;
    cube.displayEdges = displayedges;
    cube.displayFaces = displayfaces;
    cube.glitchScale = glitchscale;
    cube.showHiddenPoints = showhiddenpoints;
    
    wireframes.add(cube);
  }
  
  public void create_pyramid(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch, float posx, float posy, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean showhiddenpoints, boolean glitchscale) {
    float translate_x = 0;
    float translate_y = 0;
    float translate_z = 0;
    float rot_anglex = 0.1f;
    float rot_angley = 0.1f;
    float rot_anglez = 0.1f;
    create_pyramid(size, nodecolor, edgecolor, strokeweight, nodeRadius, glitch, posx, posy, translate_x, translate_y, translate_z, rot_anglex, rot_angley, rot_anglez, displaynodes, displayedges, displayfaces, showhiddenpoints, glitchscale);
  }
  
  public void create_pyramid(float size, int nodecolor, int edgecolor, int strokeweight, int nodeRadius, boolean glitch, float posx, float posy, float translate_x, float translate_y, float translate_z, float rot_anglex, float rot_angley, float rot_anglez, boolean displaynodes, boolean displayedges, boolean displayfaces, boolean showhiddenpoints, boolean glitchscale) {
    Wireframe3D pyramid = new Wireframe3D(nodecolor, edgecolor, strokeweight, nodeRadius);
    ArrayList<Node3D> pyramid_nodes = new ArrayList<Node3D>();
    pyramid_nodes.add(new Node3D(0*size,0*size,(sqrt(2.0f/3.0f) - (0.5f/sqrt(6)))*size));
    pyramid_nodes.add(new Node3D((-0.5f/sqrt(3))*size,-0.5f*size,(-0.5f/sqrt(6))*size));
    pyramid_nodes.add(new Node3D((-0.5f/sqrt(3))*size,0.5f*size,(-0.5f/sqrt(6))*size));
    pyramid_nodes.add(new Node3D((1.0f/sqrt(3))*size,0*size,(-0.5f/sqrt(6))*size));

    pyramid.nodes  = pyramid_nodes;
    pyramid.edges.add(new Edge3D(pyramid_nodes.get(0), pyramid_nodes.get(1)));
    pyramid.edges.add(new Edge3D(pyramid_nodes.get(0), pyramid_nodes.get(2)));
    pyramid.edges.add(new Edge3D(pyramid_nodes.get(0), pyramid_nodes.get(3)));
    pyramid.edges.add(new Edge3D(pyramid_nodes.get(1), pyramid_nodes.get(2)));
    pyramid.edges.add(new Edge3D(pyramid_nodes.get(1), pyramid_nodes.get(3)));
    pyramid.edges.add(new Edge3D(pyramid_nodes.get(2), pyramid_nodes.get(3)));
    
    pyramid.faces.add(new Face3D(pyramid_nodes.get(0), pyramid_nodes.get(1), pyramid_nodes.get(2), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    pyramid.faces.add(new Face3D(pyramid_nodes.get(0), pyramid_nodes.get(1), pyramid_nodes.get(3), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    pyramid.faces.add(new Face3D(pyramid_nodes.get(3), pyramid_nodes.get(1), pyramid_nodes.get(2), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));
    pyramid.faces.add(new Face3D(pyramid_nodes.get(0), pyramid_nodes.get(2), pyramid_nodes.get(3), thirdDimension_colorlist3d[floor(random(thirdDimension_colorlist3d.length))]));

    
    if (glitch == true) {
      pyramid.setAllGlitch();
    }
    
    //Useful for debug
    //pyramid.outputNodes();
    //pyramid.outputEdges();
    
    pyramid.translate3D("x", posx);
    pyramid.translate3D("y", posy);
    pyramid.rotate3DX(pyramid.findCenter(),rot_anglex * 100);
    pyramid.rotate3DY(pyramid.findCenter(),rot_angley * 100);
    pyramid.rotate3DZ(pyramid.findCenter(),rot_anglez * 100);
    
    pyramid.SpeedX = translate_x;
    pyramid.SpeedY = translate_y;
    pyramid.SpeedZ = translate_z;
    pyramid.RotX = rot_anglex;
    pyramid.RotY = rot_angley;
    pyramid.RotZ = rot_anglez;
    
    pyramid.displayNodes = displaynodes;
    pyramid.displayEdges = displayedges;
    pyramid.displayFaces = displayfaces;
    pyramid.glitchScale = glitchscale;
    pyramid.showHiddenPoints = showhiddenpoints;
    
    wireframes.add(pyramid);
  }

  
  public void checkIfVisible(Face3D face) {
    //Check if the specified face is visible using a cross product :
    //If the resulting vector points towards the viewer, the face is visible. If it points outwards, it is masked by other faces
    //Put the result directly as an attribute inside the face
    //   0 _____ 3
    //    |     |    //The faces are defined by their nodes as follows, always counter-clockwise
    //    |     |    // (1->2) ^ (1->0) = pseudo-vector normal to the face
    //   1|_____|2
    
    float[] vector12 = {face.nodes.get(2).x - face.nodes.get(1).x, face.nodes.get(2).y - face.nodes.get(1).y, face.nodes.get(2).z - face.nodes.get(1).z};
    float[] vector10 = {face.nodes.get(0).x - face.nodes.get(1).x, face.nodes.get(0).y - face.nodes.get(1).y, face.nodes.get(0).z - face.nodes.get(1).z};
    
    //Only the z component is needed, not calculating x and y allows for a small performance gain 
    //float normalx = vector10[1]*vector12[2] - vector10[2]*vector12[1];
    //float normaly = vector10[2]*vector12[0] - vector10[0]*vector12[2];
    float normalz = vector10[0]*vector12[1] - vector10[1]*vector12[0];
    if (normalz >= 0) {
      face.isVisible = true;
    }
    else {
      face.isVisible = false;
    }
  }
  
  //Draw the wireframes on the Processing canvas
  public void display3D() {
    background(0);
    for (Wireframe3D wireframe: wireframes) {
      
      //Check which nodes and which edges are visible
      wireframe.defineVisibleNodes();
      wireframe.defineVisibleEdges();
      
      //Display faces, then edges, then nodes
      if (wireframe.displayFaces == true) {
        for (Face3D face: wireframe.faces) {
          //This check is more expensive, it is best done only if necessary
          checkIfVisible(face);
          
          if (face.isVisible == true) {
            face.displayFace(false);
          }
        } 
      }
      
      if (wireframe.displayEdges == true) {
        for (Edge3D edge: wireframe.edges) {
          if (edge.isVisible == true || wireframe.showHiddenPoints == true) {
            strokeWeight(wireframe.strokeWeight);
            stroke(wireframe.edgeColor);
            line(edge.start.x, edge.start.y, edge.stop.x, edge.stop.y);
          }
        }
      }
      
      if (wireframe.displayNodes == true) {
        for (Node3D node: wireframe.nodes) {
          if (node.isVisible == true || wireframe.showHiddenPoints == true) {
            strokeWeight(wireframe.nodeRadius);
            stroke(wireframe.nodeColor);
            point(node.x, node.y);
          }
        }
      }

    }
  }
  
  public void displayGlitch3D() {
    background(0);
    for (Wireframe3D wireframe: wireframes) {
      
      //Check which nodes and which edges are visible
      wireframe.defineVisibleNodes();
      wireframe.defineVisibleEdges();
      
      //Display faces, then edges, then nodes
      if (wireframe.displayFaces == true) {
        for (int i = 0; i< wireframe.faces.size(); i++) {
          Face3D face = wireframe.faces.get(i);
          checkIfVisible(face);
          if (face.isVisible == true) {
            
            boolean iIsAGlitchFace = false;
            for (int index = 0; index < wireframe.glitchFaces.size(); index++) {
              if (wireframe.glitchFaces.get(index) == i) {
                iIsAGlitchFace = true;
              } 
            }
            
            if (iIsAGlitchFace == true) {
              //Get the glitch probability for this particular face
              float probability = 1;
              for (int j = 0; j < wireframe.glitchFaces.size(); j++) {
                if (wireframe.glitchFaces.get(j) == i) {
                  probability = wireframe.glitchFacesProbability.get(j);
                }
              } 
              face.displayFace(true, probability);
            }
            else {
              face.displayFace(false);
            }
          }
        } 
      }  
      
      if (wireframe.displayEdges == true) {
        for (int i = 0; i < wireframe.edges.size(); i++) {
          Edge3D edge = wireframe.edges.get(i);
          
          if (edge.isVisible == true || wireframe.showHiddenPoints == true) {
            boolean iIsAGlitchEdge = false;
            for (int index = 0; index < wireframe.glitchEdges.size(); index++) {
              if (wireframe.glitchEdges.get(index) == i) {
                iIsAGlitchEdge = true;
              } 
            }
  
            
            if (iIsAGlitchEdge == true) {
              //Get the glitch probability for this particular edge
              float probability = 1;
              for (int j = 0; j < wireframe.glitchEdges.size(); j++) {
                if (wireframe.glitchEdges.get(j) == i) {
                  probability = wireframe.glitchEdgesProbability.get(j);
                }
              }
              
              if (probability < 0.1f) {
                if (random(1) > probability) {
                  strokeWeight(wireframe.strokeWeight);
                  stroke(wireframe.edgeColor);
                  line(edge.start.x, edge.start.y, edge.stop.x, edge.stop.y); 
                }
              }
              else {
                int newcol = color((hue(wireframe.edgeColor) + 255 + random(probability * 100)) % 255,255,255);
                if (random(1) > probability) {
                  strokeWeight(wireframe.strokeWeight);
                  stroke(newcol);
                  line(edge.start.x, edge.start.y, edge.stop.x, edge.stop.y); 
                }
              }                         
            }
            else {
              strokeWeight(wireframe.strokeWeight);
              stroke(wireframe.edgeColor);
              line(edge.start.x, edge.start.y, edge.stop.x, edge.stop.y);
            }
          }
        }
      }
      if (wireframe.displayNodes == true) {
        for (Node3D node: wireframe.nodes) {
          if (node.isVisible == true || wireframe.showHiddenPoints == true) {
            strokeWeight(wireframe.nodeRadius);
            stroke(wireframe.nodeColor);
            point(node.x, node.y);
          }
        }
      }
    
    }
  }
  
  public void displayJerkyEdges() {
    background(0);
    
    if (thirdDimension_counter % thirdDimension_jerkyEdgeFrequency == 0) {
      thirdDimension_nodeSelector += 1;
    } 
    
    for (Wireframe3D wireframe: wireframes) {      
      //Display edges, then nodes
      if (wireframe.displayEdges == true) {
        for (int i=0; i< wireframe.edges.size(); i++) {
          Edge3D edge = wireframe.edges.get(i);
          
          boolean displayEdge = false;
          if (edge.start.x == wireframe.nodes.get(thirdDimension_nodeSelector % wireframe.nodes.size()).x && edge.start.y == wireframe.nodes.get(thirdDimension_nodeSelector % wireframe.nodes.size()).y) {
            displayEdge = true;
          }
          if (edge.stop.x == wireframe.nodes.get(thirdDimension_nodeSelector % wireframe.nodes.size()).x && edge.stop.y == wireframe.nodes.get(thirdDimension_nodeSelector % wireframe.nodes.size()).y) {
            displayEdge = true;
          }

          
          if (displayEdge == true) {
            strokeWeight(wireframe.strokeWeight);
            stroke(wireframe.edgeColor);
            line(edge.start.x, edge.start.y, edge.stop.x, edge.stop.y);

            //Draw the associated nodes - only for this particular edge
            if (wireframe.displayNodes == true) {
              strokeWeight(wireframe.nodeRadius);
              stroke(wireframe.nodeColor);
              point(edge.start.x, edge.start.y);
              point(edge.stop.x, edge.stop.y);

            }
          }
        }
      }
    }
  }
  
  public void translateAll3D(String axis, float distance) {
    for (Wireframe3D wireframe: this.wireframes) {
      wireframe.translate3D(axis, distance);
    } 
  }
  
  public void scaleAll3D(float centerX, float centerY, float scale) {
    for (Wireframe3D wireframe: this.wireframes) {
      wireframe.scale3D(centerX, centerY, scale);
    } 
  }

  
  public void movewireframe() {
    for (Wireframe3D wireframe: this.wireframes) {
      //wireframe.translate3D("x", 1); 
      
      if (wireframe.glitchScale == true) {
        wireframe.scale3D(width/2,height/2,random(0.97f,1.03f));
      }

      wireframe.translate3D("x", wireframe.SpeedX);
      wireframe.translate3D("y", wireframe.SpeedY);
      wireframe.translate3D("z", wireframe.SpeedZ);
      wireframe.rotate3DX(wireframe.findCenter(), wireframe.RotX);
      wireframe.rotate3DY(wireframe.findCenter(), wireframe.RotY);
      wireframe.rotate3DZ(wireframe.findCenter(), wireframe.RotZ);
    }
  }
  
  public void remove_old_pyramids() {
    for (Wireframe3D wireframe: this.wireframes) {
      //Performance gain : check only the first node
      if (wireframe.nodes.get(0).x > 250 || wireframe.nodes.get(0).x < -150 || wireframe.nodes.get(0).y > 150 || wireframe.nodes.get(0).y < -100) {
        this.wireframes.remove(wireframe);
        break;    //Quit for loop to avoid concurrent access exceptions 
      }
    }
  }
}


//////////////////////////////////////////
// Specific actions for the BloodSki animation
//////////////////////////////////////////

public void draw_bloodski ()
{
  bloodSki_particleManager.update();
  bloodSki_particleManager.display();
  copy (bloodSki_Xc, bloodSki_Yc, bloodSki_Wc, bloodSki_Hc, 0, 0, width, height);
}

 
class BloodSkiParticleManager {
   
  int [] palette = {0x007e0000, 0x00be0000, 0x00e1d5c1, 0x00f5ecd7, 0x00fdfdfd};
  
  PVector O;
  int bloodSki_minRad, bloodSki_maxRad, sqbloodSki_maxRad;
  
  BloodSkiParticle [] particles; 
   
  PVector [] trigLUT;
   
  final int
    auraColor = 0xffffff0,
    trigRes = 360;
  final float
    trigStep = TWO_PI / trigRes, 
    rF = .05f,
    gF = 0.00005f, 
    c_rad = .3f;
  
   

   
  BloodSkiParticleManager (int n, int bloodSki_minRad, int bloodSki_maxRad, int x, int y, int z) {
    O = new PVector (x,y,z);
    this.bloodSki_minRad= bloodSki_minRad;
    this.bloodSki_maxRad= bloodSki_maxRad;
    trigLUT = new PVector [trigRes];
    for (int i=0; i<trigRes; i++) {
      float angle = i * trigStep;
      trigLUT[i] = new PVector (cos(angle), sin(angle));
      trigLUT[i].mult (bloodSki_minRad);
    }   
    particles = new BloodSkiParticle [n];
    for (int i=0; i<n; i++){
      particles[i] = new BloodSkiParticle();
      resetParticle (particles[i]);
      setParticleColor (particles[i]);
    }
  }
   

   
  public void resetParticle (BloodSkiParticle p){
    int alfa = (int) random(trigRes);
    float zF = random (-1,1);
    p.l = new PVector ( O.x + trigLUT[alfa].x, O.y + trigLUT[alfa].y, O.z + bloodSki_minRad*zF);
    p.s = new PVector(random(-1,1),random(-1,1),random(-1,1));
    p.a = new PVector(0,0,0);
    p.setDiameters ( c_rad, 1.25f );
  }
   
  public void setParticleColor (BloodSkiParticle p){
    int k = (int) (norm (PVector.dist (p.l, O), bloodSki_maxRad, 0) * 100);
    int i = (int) random (palette.length);
    p.h   = (palette[i] | k<<24);
  }
   
  public void display (){
    fill (auraColor);
    for (int i=0; i<particles.length; i++) particles[i].displayAura();
    for (int i=0; i<particles.length; i++) particles[i].display();    
  }
 
  public void update (){
    PVector totalRotation = new PVector(), gravity = new PVector();    
    for (int i=0; i<particles.length; i++) {
      for (int j=0; j<particles.length; j++) {
        totalRotation.add ( particles[i].s.cross (PVector.sub (particles[j].l, particles[i].l)) );
      }
      totalRotation.normalize ();
      totalRotation.mult (rF);
      gravity = PVector.sub (O, particles[i].l);
      gravity.normalize();
      gravity.mult (gF);
      particles[i].update (PVector.add (gravity,totalRotation));
      particles[i].setDiameters ( c_rad, 1.25f );
      if (PVector.dist (particles[i].l,O)>=bloodSki_maxRad) resetParticle (particles[i]);
    }
  }   
}   


class BloodSkiParticle {
 
  float  d1, d2;     
  PVector l, s, a;   
  int h;
 
  BloodSkiParticle () {
    l = new PVector ();
    s = new PVector ();
    a = new PVector ();
  }
 
  public void setDiameters (float diamCoef, float auraSize) {
    d1 = l.z * diamCoef;
    d2 = d1  * auraSize;
  }
 
  public void displayAura () {
    ellipse (l.x, l.y, d2, d2);
  }
 
  public void display () {
    fill (h);
    ellipse (l.x, l.y, d1, d1);
  }
 
  public void update (PVector newAcceleration) {
    a.add  (newAcceleration);
    s.add  (a);
    l.add  (s);
    a.mult (0);
  }
}

//////////////////////////////////////////
// Specific actions for the Gloubiboulga animation
//////////////////////////////////////////


public void draw_gloubiboulga() {
  
  background(0);

  for (int i=0; i<gloubiboulga_swarm.size(); i++) { 
    GloubiboulgaDots myGloubiboulgaDots = (GloubiboulgaDots) gloubiboulga_swarm.get(i); 
    myGloubiboulgaDots.render(); 
    myGloubiboulgaDots.move();
    myGloubiboulgaDots.cohere();
    myGloubiboulgaDots.align();
    myGloubiboulgaDots.avoid();
    myGloubiboulgaDots.bounce();
  }
}
 
 
public void makeGloubiboulgaDotss( int numdots ) { 
  for (int i=0; i<numdots; i++) {
    PVector newpos = new PVector(random(width), random(height));
    GloubiboulgaDots myGloubiboulgaDots = new GloubiboulgaDots( newpos, 1 ); 
    gloubiboulga_swarm.add(myGloubiboulgaDots); 
  }
}
 
class GloubiboulgaDots { 
  float diam;
  PVector pos;
  PVector vel;
  PVector acc;
  int col;
 
 
  GloubiboulgaDots( PVector _pos, float _diam ) { 
    pos = _pos; 
    diam = _diam;
    vel = new PVector(random(-1, 1), random(-1, 1)); 
    col =  color(255, 110);
    acc = new PVector(0, 0);
  }
 
 
  public void render() {
 
    beginShape(TRIANGLE_FAN);
    noStroke();
    fill(col);
    vertex(pos.x, pos.y);
 
 
    for (int i=0; i<gloubiboulga_swarm.size(); i++) { 
      GloubiboulgaDots neighbour = (GloubiboulgaDots) gloubiboulga_swarm.get(i);
 
      float distance = pos.dist( neighbour.pos );
      if (distance < gloubiboulga_thresh) {
        vertex(neighbour.pos.x, neighbour.pos.y);
      }
    }
    vertex(pos.x, pos.y);
    endShape(TRIANGLE_FAN);
  }
 
 
  public void move() { 
 
    vel.add(acc);
    vel.limit(gloubiboulga_maxvel);
    pos.add(vel);
    acc.mult(0);
  }
 
  public void bounce() {
    if (pos.x < 0) {
      vel.x = vel.x * -1;
    }
 
    if (pos.x > width) {
      vel.x = vel.x * -1;
    }
 
    if (pos.y < 0) {
      vel.y=vel.y * -1;
    }
 
    if (pos.y > height) {
      vel.y = vel.y * -1;
    }
  }
 
 
  public void avoid() { 
    for (int i=0; i<gloubiboulga_swarm.size(); i++) { 
      GloubiboulgaDots neighbour = (GloubiboulgaDots) gloubiboulga_swarm.get(i);
      float distance = pos.dist( neighbour.pos );
      if (distance < gloubiboulga_avoid_distance) {
        PVector push = PVector.sub(pos, neighbour.pos);
        push.normalize();
        push.mult(gloubiboulga_avoid_strength);
        acc.add(push);
      }
    }
  }
 
  public void cohere() {
    PVector mid_pos = new PVector();
    int neighbour_count = 0;
 
    for (int i=0; i<gloubiboulga_swarm.size(); i++) {
      GloubiboulgaDots neighbour = (GloubiboulgaDots) gloubiboulga_swarm.get(i);
      float distance = pos.dist( neighbour.pos );
      if (distance < gloubiboulga_cohere_distance) {
        mid_pos.add(neighbour.pos);
        neighbour_count++;
      }
    }
    mid_pos.div( neighbour_count );
    PVector pull = PVector.sub(mid_pos, pos);
    pull.normalize();
    pull.mult(gloubiboulga_cohere_strength);
    acc.add(pull);
  }
 
  public void align() { 
    PVector ave_vel = new PVector();
    int neighbour_count = 0;
 
      for (int i=0; i<gloubiboulga_swarm.size(); i++) {
      GloubiboulgaDots neighbour = (GloubiboulgaDots) gloubiboulga_swarm.get(i);
      float distance = pos.dist( neighbour.pos );
      if (distance < gloubiboulga_align_distance) {
        ave_vel.add(neighbour.vel);
        neighbour_count++;
      }
    }
    ave_vel.div( neighbour_count );
    ave_vel.normalize();
    ave_vel.mult(gloubiboulga_align_strength);
    acc.add(ave_vel);
  }
}


//////////////////////////////////////////
// Specific actions for the RevolutionLines animation
//////////////////////////////////////////

public void draw_revolutionlines(){
  noStroke();
  fill(0,0,0,10);
  rect(0,0,width,height);
  for(int a=0;a<revolutionline_lines.length;a++){
    revolutionline_lines[a].drawline();
  }
  revolutionlines_defineCenter();
}
 
class RevolutionLine{
  float x;
  float y;
  float objx;
  float objy;
  float an;
  float r;
  float v;
  float ac;
  float acv;
  RevolutionLine otherline;
  int c;
   
  
  RevolutionLine(int _x, int _y, float _v){
    ac=random(TWO_PI);
    //acv=random(-PI*0.01, PI*0.01);
    acv = PI*0.005f;
    x=_x; y=_y;
    objx=x;objy=y;
    if(revolutionline_lines.length>0){
      otherline = revolutionlines_searchClosest(x,y);
       
      r = dist(otherline.x, otherline.y, x,y);
      an = atan2(y-otherline.y, x-otherline.x);
      //v=random(0.001,0.05);
      v = _v;
      
      if(random(10)<5){v=-v;}
    }
    revolutionline_lines = (RevolutionLine[]) append (revolutionline_lines, this);
  }
  
  public void drawline(){
    stroke(sin(ac)*127+127,255,255);  
    ac+=acv;
    if(otherline!=null){
      x = otherline.x+cos(an)*r;
      y = otherline.y+sin(an)*r;
      an+=v;
    }
    float d = dist(x,y,objx,objy);
    if(d>2){
      float nx=x+((objx-x)/d)*2;
      float ny=y+((objy-y)/d)*2;
      x=nx;
      y=ny;
      if(otherline!=null){
        line(x,y,otherline.x, otherline.y);
      }
    }
  }
}
 
public void revolutionlines_defineCenter(){
  float x=0,y=0;
  for(int a=0;a<revolutionline_lines.length;a++){
    x+=revolutionline_lines[a].x;y+=revolutionline_lines[a].y;
  }
  x/=revolutionline_lines.length;y/=revolutionline_lines.length;
  float difx=width/2-x;float dify=height/2-y;
  for(int a=0;a<revolutionline_lines.length;a++){
    revolutionline_lines[a].objx=revolutionline_lines[a].x+difx;
     revolutionline_lines[a].objy=revolutionline_lines[a].y+dify;
  }
}
 
 
public RevolutionLine revolutionlines_searchClosest(float x, float y){
  RevolutionLine otherline = revolutionline_lines[floor(random(revolutionline_lines.length))];
  float t=100000;
  for(int a=0;a<revolutionline_lines.length;a++){
    float d=dist(x,y,revolutionline_lines[a].x, revolutionline_lines[a].y);
    if(d<t){
      t=d;
      otherline=revolutionline_lines[a];
    }
  }
  return otherline;
}



//////////////////////////////////////////
// Specific actions for the RedNoise + Shape animation
//////////////////////////////////////////

public void draw_rednoiseshape1() {
  draw_rednoise(); 
}

public void draw_rednoiseshape2() {
  draw_rednoise(); 
  draw_rednoise_blackcross();
}

public void draw_rednoiseshape3() {
  draw_rednoise(); 
  draw_rednoise_glitchcross();
}

public void draw_rednoiseshape4() {
  draw_rednoise();
  draw_rednoise_glitchtriangle();
}

public void draw_rednoiseshape5() {
  draw_rednoise();
  draw_rednoise_circle();
}

public void draw_rednoiseshape6() {
  draw_rednoise();
  draw_rednoise_trianglestrobo(); 
}

public void draw_rednoise() {
  noStroke();
  for (int i = 0; i<width/4;i++) {
    for (int j = 0; j<height/4;j++) {
      fill(random(60,255),0,0);
      rect(i*4,j*4,i*4+4,j*4+4);
    }
  }
}

public void draw_rednoise_blackcross() {
  strokeWeight(16);
  stroke(0);
  line(0,-width/(2*NUMBER_OF_PANELS),(2*NUMBER_OF_PANELS)*width/(2*NUMBER_OF_PANELS),width/(2*NUMBER_OF_PANELS) + height); 
  line((2*NUMBER_OF_PANELS)*width/(2*NUMBER_OF_PANELS),-width/(2*NUMBER_OF_PANELS),0,width/(2*NUMBER_OF_PANELS) + height);
}

public void draw_rednoise_glitchcross() {
  strokeWeight(16);
  stroke(255);
  float randomcol = random(1);
  float offsetx = random(-8,8);
  float offsety = random(-8,8);

  if (randomcol > 0.66f) {
    stroke(0);
  }
  else if (randomcol > 0.33f) {
    stroke(255);
  }
  else {
    stroke(255,0,0); 
  }
  line(0 + offsetx,-width/(2*NUMBER_OF_PANELS) + offsety,(2*NUMBER_OF_PANELS)*width/(2*NUMBER_OF_PANELS) + offsetx,width/(2*NUMBER_OF_PANELS) + height + offsety);
  line((2*NUMBER_OF_PANELS)*width/(2*NUMBER_OF_PANELS) + offsetx,-width/6 + offsety,0 + offsetx,width/(2*NUMBER_OF_PANELS) + height + offsety);
}

public void draw_rednoise_glitchtriangle() {
  noFill();
  float offsetx = random(-8,8);
  float offsety = random(-8,8);
  float randomcol = random(1);
  if (randomcol > 0.66f) {
    strokeWeight(16);
    stroke(0);
  }
  else if (randomcol > 0.33f) {
    strokeWeight(16);
    stroke(255);
  }
  else {
    strokeWeight(16);
    stroke(255,0,0);
  }
  beginShape();
  vertex(width/6 + offsetx,5*height/6 + offsety);
  vertex(5*width/6 + offsetx,5*height/6 + offsety);
  vertex(width/2 + offsetx,height/6 + offsety);
  endShape(CLOSE);
}

public void draw_rednoise_circle() {
  strokeWeight(24);
  stroke(255);
  noFill();
  ellipse(width/2,height/2, rednoise_circlerad, rednoise_circlerad);
  rednoise_circlerad += 8;
}

public void draw_rednoise_trianglestrobo() {
  strokeWeight(8);
  stroke(255);
  if(frameCount%8 == 0 || (frameCount+1)%8 == 0){
    line(0, height/4, width, height/4);
    line(0, height/2, width, height/2);
    line(0, 3*height/4, width, 3*height/4);
  }
  if((frameCount+4)%8 == 0 || (frameCount+5)%8 == 0 || (frameCount+6)%8 == 0){
    line(0, height, width/2, 0);
    line(width, height, width/2, 0);
  }  
  if((frameCount+7)%8 == 0){
    line(width/6, height, 0, 2*height/3);
    line(width/3, height, 0, height/3);
    line(2*width/3, height, width, height/3);
    line(5*width/6, height, width, 2*height/3);
  }  
 
}


//////////////////////////////////////////
// Specific actions for the TurningSingleLines animation
//////////////////////////////////////////

public void draw_turningsinglelines() {
  background(0);
  for (SingleTurningLine line: turningsinglelines_lines) {
    line.drawSingleTurningLine();
  }
  for (SingleTurningLine line: turningsinglelines_lines) {
    if (line.isDead()) {
      turningsinglelines_lines.remove(line);
      break;
    }
  }

}

class SingleTurningLine {
  float position;
  float angle;
  
  SingleTurningLine(float _angle) {
    angle = _angle;
    position = turningsinglelines_init - (((PI - abs(angle%(2*PI)-(3*PI/2)))/PI) * turningsinglelines_init);
  }
  
  public void drawSingleTurningLine() {
    pushMatrix();
    rotate(angle);
    line(-2*width,position,3*width,position);
    popMatrix();
    position += turningsinglelines_increment;
  }
  
  public boolean isDead() {
    if (position > 3*height) {
      return true;
    }
    else {
      return false;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the RandomAppearingLines animation
//////////////////////////////////////////

public void draw_randomappearinglines() {
  randomappearinglines_framecount += 1;
  
  if (randomappearinglines_framecount > randomappearinglines_framechange) {
    randomappearinglines_framecount = 0;
    randomappearinglines_currentangle += 0.3f*PI;
    randomappearinglines_currentx = randomappearinglines_initx; 
    randomappearinglines_currenty = randomappearinglines_inity;
    randomappearinglines_previousx = randomappearinglines_initx;
    randomappearinglines_previousy = randomappearinglines_inity;
  }
  
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  pushMatrix();
  translate(width/2,height/2);
  rotate(randomappearinglines_currentangle);
  stroke(255);
  strokeWeight(8);
  line(randomappearinglines_previousx, randomappearinglines_previousy, randomappearinglines_currentx, randomappearinglines_currenty);
  popMatrix();
  
  randomappearinglines_previousx = randomappearinglines_currentx;
  randomappearinglines_previousy = randomappearinglines_currenty;
  randomappearinglines_currentx += randomappearinglines_speedx;
  randomappearinglines_currenty += randomappearinglines_speedy;
}


//////////////////////////////////////////
// Specific actions for the ImpulseRectangles animation
//////////////////////////////////////////

public void draw_horizontal_impulsewhiterectangle() {
  fill(0,15);
  rect(0,0,width,height);
  fill(255);
  noStroke();
  rect(0, height/8, impulserectangles_posx, height/4);
  rect(width, 5*height/8, width - impulserectangles_posx, height/4);
  fill(0);
  rect(0, height/8, impulserectangles_posx - impulserectangles_rectanglesize, height/4);
  rect(width, 5*height/8, width - impulserectangles_posx + impulserectangles_rectanglesize, height/4);

  impulserectangles_posx += impulserectangles_incrementx;
}

public void draw_vertical_impulsewhiterectangle() {
  fill(0,15);
  rect(0,0,width,height);
  fill(255);
  noStroke();
  rect(((NUMBER_OF_PANELS/2)-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, impulserectangles_posy);
  rect(((NUMBER_OF_PANELS/2)+1)*width/NUMBER_OF_PANELS, height, width/NUMBER_OF_PANELS, height - impulserectangles_posy);
  fill(0);
  rect(((NUMBER_OF_PANELS/2)-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, impulserectangles_posy - impulserectangles_rectanglesize);
  rect(((NUMBER_OF_PANELS/2)+1)*width/NUMBER_OF_PANELS, height, width/NUMBER_OF_PANELS, height - impulserectangles_posy + impulserectangles_rectanglesize);
  
  impulserectangles_posy += impulserectangles_incrementy;
}

public void draw_horizontal_impulseredrectangle() {
  fill(0,15);
  rect(0,0,width,height);
  fill(255,0,0);
  noStroke();
  rect(0, height/8, impulserectangles_posx, height/4);
  rect(width, 5*height/8, width - impulserectangles_posx, height/4);
  fill(0);
  rect(0, height/8, impulserectangles_posx - impulserectangles_rectanglesize, height/4);
  rect(width, 5*height/8, width - impulserectangles_posx + impulserectangles_rectanglesize, height/4);

  impulserectangles_posx += impulserectangles_incrementx;
}

public void draw_vertical_impulseredrectangle() {
  fill(0,15);
  rect(0,0,width,height);
  fill(255,0,0);
  noStroke();
  rect(((NUMBER_OF_PANELS/2)-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, impulserectangles_posy);
  rect(((NUMBER_OF_PANELS/2)+1)*width/NUMBER_OF_PANELS, height, width/NUMBER_OF_PANELS, height - impulserectangles_posy);
  fill(0);
  rect(((NUMBER_OF_PANELS/2)-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, impulserectangles_posy - impulserectangles_rectanglesize);
  rect(((NUMBER_OF_PANELS/2)+1)*width/NUMBER_OF_PANELS, height, width/NUMBER_OF_PANELS, height - impulserectangles_posy + impulserectangles_rectanglesize);
  
  impulserectangles_posy += impulserectangles_incrementy;
}

//////////////////////////////////////////
// Specific actions for the Crescent animation
//////////////////////////////////////////

public void draw_crescent() {
  noStroke();
  fill(0);
  rect(0,0,width,height);
  pushMatrix();
  translate(width/2,5*height/6);
  rotate(PI);
  stroke(0,255,255);
  
  for (int i = 0; i<crescent_number; i++) {
    crescent_fatfactor = 1/(1+abs((crescent_emphasis%10 - 2.5f) - i));
    float hue = (max(crescent_minstrokeweight, (crescent_fatfactor*crescent_maxbonussize)) - crescent_minstrokeweight) * crescent_colorfactor;
    strokeWeight(max(crescent_minstrokeweight, (crescent_fatfactor*crescent_maxbonussize)));
    stroke(hue,255,255);
    line(crescent_distext * cos(i * PI / (crescent_number - 1)), crescent_distext * sin(i * PI / (crescent_number - 1)), 
          crescent_distint * cos(i * PI / (crescent_number - 1)), crescent_distint * sin(i * PI / (crescent_number - 1)));
  }  
  popMatrix();
  crescent_emphasis += crescent_speed;

}

//////////////////////////////////////////
// Specific actions for the Clock animation
//////////////////////////////////////////

public void draw_clock() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  pushMatrix();
  translate(width/2,height/2);
  rotate(clock_mainangle);
  
  stroke(255);
  strokeWeight(8);
  for (int i = 0; i < clock_numberofbranches; i++) {
    line(width/5, 0, width/2, 0);
    rotate(TWO_PI / clock_numberofbranches);
  }
  popMatrix();
  
  pushMatrix();
  translate(width/2,height/2);
  rotate(clock_subangle);
  
  if (clock_rotate == true) {
    clock_subangle += clock_subspeed;
    if (clock_subangle % (TWO_PI / clock_numberofbranches) < clock_subspeed) {
      clock_rotate = false;
    }
  }
  else {
    clock_subangle = 0;
  }
  
  stroke(255,0,0);
  strokeWeight(8);
  for (int i = 0; i < clock_numberofbranches; i++) {
    line(width/6, 0, width/2, 0);
    rotate(TWO_PI / clock_numberofbranches);
  }
  popMatrix();
  clock_mainangle += clock_speed;
}


//////////////////////////////////////////
// Specific actions for the ColorBeat animation
//////////////////////////////////////////

public void draw_colorbeat() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  fill(0,255,255);
  rect(0,0,width,height/16);
  fill(15,255,255);
  rect(0,height/8,width,height/16);
  fill(60,255,255);
  rect(0,height/4,width,height/16);
  fill(80,255,255);
  rect(0,3*height/8,width,height/16);    
  fill(155,255,255);
  rect(0,4*height/8,width,height/16);
  fill(160,255,255);
  rect(0,5*height/8,width,height/16);    
  fill(165,255,255);
  rect(0,6*height/8,width,height/16);  
  fill(170,255,255);
  rect(0,7*height/8,width,height/16);    
  
  fill(0);
  noStroke();
  beginShape();
  vertex(width/6, height);
  vertex(5*width/6, height);
  vertex(width/2,-height/6);
  endShape();
  
  
  rect(0, 0, width, colorbeat_value - colorbeat_maxval);
  if (colorbeat_value < 5*height/3) {
    colorbeat_value += 4;
  }
}

public void draw_colorbeatstroboline() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  if (frameCount % 2 == 0) {
    fill(0,255,255);
    rect(0,0,width,height/16);
    fill(15,255,255);
    rect(0,height/8,width,height/16);
    fill(60,205,255);
    rect(0,height/4,width,height/16);
    fill(90,205,255);
    rect(0,3*height/8,width,height/16);    
    fill(155,255,255);
    rect(0,4*height/8,width,height/16);
    fill(160,255,255);
    rect(0,5*height/8,width,height/16);    
    fill(165,255,255);
    rect(0,6*height/8,width,height/16);  
    fill(170,255,255);
    rect(0,7*height/8,width,height/16);    
  }  
  
  fill(0);
  noStroke();
  beginShape();
  vertex(width/6, height);
  vertex(5*width/6, height);
  vertex(width/2,-height/6);
  endShape();
  
}

public void draw_colorbeatwhitestrobotriangle() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  if (frameCount % 2 == 0) {
    fill(255);
    noStroke();
    beginShape();
    vertex(width/6, height);
    vertex(5*width/6, height);
    vertex(width/2,-height/6);
    endShape();
  }      
}

public void draw_colorbeattransition() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  fill(0,255,255);
  rect(0,0,width,height/16);
  fill(15,255,255);
  rect(0,height/8,width,height/16);
  fill(60,205,255);
  rect(0,height/4,width,height/16);
  fill(90,205,255);
  rect(0,3*height/8,width,height/16);    
  fill(155,255,255);
  rect(0,4*height/8,width,height/16);
  fill(160,255,255);
  rect(0,5*height/8,width,height/16);    
  fill(165,255,255);
  rect(0,6*height/8,width,height/16);  
  fill(170,255,255);
  rect(0,7*height/8,width,height/16);    
    
  fill(0);
  noStroke();
  beginShape();
  vertex(width/6, height);
  vertex(5*width/6, height);
  vertex(width/2,-height/6);
  endShape();
  
  rect(width/2, 0, colorbeat_transitionpos, height);
  rect(width/2, 0, -colorbeat_transitionpos, height);  
  
  colorbeat_transitionpos += 4;
  
}

//////////////////////////////////////////
// Specific actions for the InvertExplode animation
//////////////////////////////////////////

public void draw_invertexplode() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  strokeWeight(16);
  //stroke(invertexplode_circlehue, 255, 255);
  stroke(0, 255, 255);
  if (invertexplode_circlewidth > 0) {
    ellipse(width/2, height/2, invertexplode_circlewidth, invertexplode_circlewidth);
  }
  invertexplode_circlewidth -= invertexplode_circlespeed;
  invertexplode_circlehue = max(invertexplode_circlehue - invertexplode_huespeed, 0);
  
  pushMatrix();
  translate(width/2, height/2);
  rotate(invertexplode_angle);
  for (int i = 0; i < invertexplode_numberoflines; i++) {
    rotate(TWO_PI / invertexplode_numberoflines);
    strokeWeight(8);
    if (invertexplode_pos*6 < 255) {
      stroke(0, 255 - invertexplode_pos*6, 255);
    }
    else {
      stroke(0, 0, 255);

    }
    line(invertexplode_pos, 0, invertexplode_pos + invertexplode_linelength, 0);
  }
  popMatrix();
  
  invertexplode_pos += 2 * invertexplode_circlespeed / 3;
}


//////////////////////////////////////////
// Specific actions for the DarkSnakes animation
//////////////////////////////////////////

public void draw_darksnakes() {
  for(int i = 0; i < darksnakes_snakes.length; i++) {
    if(!darksnakes_snakes[i].done())
    darksnakes_snakes[i].go();
  }

  darksnakes_snakes = (DarkSnake[]) append(darksnakes_snakes, new DarkSnake(width, 0, 15, random(100), 1));

}

class DarkSnake {
  float X;
  float Y;
  float rot;
  float V;
  float tm;
  int fm;
  DarkSnake(int tX, int tY, float tfm, float trot, float tV) {
    X = tX;
    Y = tY;
    rot = trot;
    tm = tfm;
    V = tV;
  }
  public void go() {
    V += random(-0.03f, 0.03f);
    tm /= 1.01f;
    strokeWeight(tm);
    rot += random(-0.2f, 0.2f);
    line(X, Y, X + V*sin(rot), Y + V*cos(rot));
    line(X, Y, X + V*sin(rot), Y + V*cos(rot));
    X += V*sin(rot);
    Y += V*cos(rot);
    fm++;
    if(random(400) > 398.5f-(fm/20)) {
      darksnakes_snakes = (DarkSnake[]) append(darksnakes_snakes, new DarkSnake(PApplet.parseInt(X), PApplet.parseInt(Y), tm, rot + random(-0.2f, 0.2f), V));
    }
  }
  public boolean done() {
    if(tm < 1.01f) {
      return true;
    } else {
      return false;
    }
  }
}


//////////////////////////////////////////
// Specific actions for the BrightSnakes animation
//////////////////////////////////////////

public void draw_brightsnakes() {
  for(int i = 0; i < brightsnakes_snakes.length; i++) {
    if(!brightsnakes_snakes[i].done())
    brightsnakes_snakes[i].go();
  }

  brightsnakes_snakes = (BrightSnake[]) append(brightsnakes_snakes, new BrightSnake(0, 0, 15, random(100), 1));

}

class BrightSnake {
  float X;
  float Y;
  float rot;
  float V;
  float tm;
  int fm;
  BrightSnake(int tX, int tY, float tfm, float trot, float tV) {
    X = tX;
    Y = tY;
    rot = trot;
    tm = tfm;
    V = tV;
  }
  public void go() {
    V += random(-0.03f, 0.03f);
    tm /= 1.01f;
    strokeWeight(tm);
    rot += random(-0.2f, 0.2f);
    line(X, Y, X + V*sin(rot), Y + V*cos(rot));
    line(X, Y, X + V*sin(rot), Y + V*cos(rot));
    X += V*sin(rot);
    Y += V*cos(rot);
    fm++;
    if(random(400) > 398.5f-(fm/20)) {
      brightsnakes_snakes = (BrightSnake[]) append(brightsnakes_snakes, new BrightSnake(PApplet.parseInt(X), PApplet.parseInt(Y), tm, rot + random(-0.2f, 0.2f), V));
    }
  }
  public boolean done() {
    if(tm < 1.01f) {
      return true;
    } else {
      return false;
    }
  }
}


//////////////////////////////////////////
// Specific actions for the LightPainting animation
//////////////////////////////////////////

//When the mouse is dragged, create a new spark at the mouse position with a velocity based on the drag speed and direction.
//TODO : adapt the code so it can be controlled through a tablet
public void mouseDragged() {
  if (lightpainting_initok == true) {
    if (lightpainting_skipCount >= lightpainting_emissionPeriod) {
  
      //Reset the skip count.
      lightpainting_skipCount = 0;
   
      //Convert the prior and current mouse screen coordinates to model coordinates.   
      LightPaintingPoint3D prior = lightpainting_canvas.toModelCoordinates(pmouseX, pmouseY);
      LightPaintingPoint3D current = lightpainting_canvas.toModelCoordinates(mouseX, mouseY);
   
      //The spark's initial velocity is the difference between the current and prior points, randomized a bit to create a "spray" effect and scaled by the elapsed time
      LightPaintingVector3D velocity = current.diff(prior);
      velocity.shift(new LightPaintingVector3D(random(-lightpainting_spraySpread, lightpainting_spraySpread), 0, random(-lightpainting_spraySpread, lightpainting_spraySpread) * velocity.x));
      velocity.scale(1.0f / averageElapsedMillis);
   
      //Set the spark's intital motion and queue up the next particle.
      lightpainting_sparks[lightpainting_nextSpark].initializeMotion(current, velocity);
      lightpainting_nextSpark = (lightpainting_nextSpark + 1) % lightpainting_particleCount;
    }
    else {
      //Increase the skip count.
      lightpainting_skipCount++;
    }
  }
}

public void lightpainting_addRandomLine() {
  for (int i = 0; i < lightpainting_numberofimpulses; i++) {
    float light_x1, light_y1, light_x2, light_y2;
    light_x1 = random(width/3,2*width/3);
    light_x2 = light_x1 + random(-8,8);
    light_y1 = random(0,2*height/3);
    light_y2 = light_y1 + random(-8,8);
  
    LightPaintingPoint3D prior = lightpainting_canvas.toModelCoordinates(light_x1, light_y1);
    LightPaintingPoint3D current = lightpainting_canvas.toModelCoordinates(light_x2, light_y2);
  
    LightPaintingVector3D velocity = current.diff(prior);
    velocity.shift(new LightPaintingVector3D(random(-lightpainting_spraySpread, lightpainting_spraySpread), 0, random(-lightpainting_spraySpread, lightpainting_spraySpread) * velocity.x));
    velocity.scale(1.0f / averageElapsedMillis);
   
    //Set the spark's intital motion and queue up the next particle.
    lightpainting_sparks[lightpainting_nextSpark].initializeMotion(current, velocity);
    lightpainting_nextSpark = (lightpainting_nextSpark + 1) % lightpainting_particleCount;
  }
}
 

 
public void draw_lightpainting() {
  //Determine how long it has been since we last drew a frame.
  long now = millis();
  long elapsedMillis = now - lastFrameDrawn;
  lastFrameDrawn = now;
  averageElapsedMillis = .90f * averageElapsedMillis + .10f * elapsedMillis;
  //Fade the screen's current contents a bit more toward black.
  noStroke();
  fill(0, 0, 0, constrain(3 * elapsedMillis, 0, 255));
  rect(0, 0, width, height);
 
  for (LightPaintingParticle spark : lightpainting_sparks) {
    if (spark.isActive()) {
      spark.paint(elapsedMillis);
      spark.evolve(elapsedMillis);
    }
  }
}
 

public static class LightPaintingPoint2D {
  public final float x;
  public final float y;
 
  public LightPaintingPoint2D(float x, float y) {
    this.x = x;
    this.y = y;
  }
}
 

public static class LightPaintingVector3D {
  public float x;
  public float y;
  public float z;
 
  public LightPaintingVector3D(float x, float y, float z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
 
  public void shift(LightPaintingVector3D v) {
    x += v.x;
    y += v.y;
    z += v.z;
  }
 
  public LightPaintingVector3D add(LightPaintingVector3D v) {
    return new LightPaintingVector3D(x + v.x, y + v.y, z + v.z);
  }
 
  public void scale(float c) {
    x *= c;
    y *= c;
    z *= c;
  }
 
  public LightPaintingVector3D mul(float c) {
    return new LightPaintingVector3D(c * x, c * y, c * z);
  }
}
 

public static class LightPaintingPoint3D {
  public float x;
  public float y;
  public float z;
 
  public LightPaintingPoint3D(float x, float y, float z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
 
  public void shift(LightPaintingVector3D v) {
    x += v.x;
    y += v.y;
    z += v.z;
  }
 
  public LightPaintingPoint3D add(LightPaintingVector3D v) {
    return new LightPaintingPoint3D(x + v.x, y + v.y, z + v.z);
  }
 
  public LightPaintingVector3D diff(LightPaintingPoint3D p) {
    return new LightPaintingVector3D(x - p.x, y - p.y, z - p.z);
  }
}
 
//A LightPaintingCanvas3D allows drawing graphics primitives in a 3D coordinate system.
public class LightPaintingCanvas3D {
  private final float focalLength;
 
  private final float interactionPlane;
 
  public LightPaintingCanvas3D(float focalLength, float interactionPlane) {
    this.focalLength = focalLength;
    this.interactionPlane = interactionPlane;
  }
 
  //Convert a point in the 3D model to a point on the 2D screen. 
  public LightPaintingPoint2D toScreenCoordinates(LightPaintingPoint3D p) {
    float scale = focalLength / p.z;
 
    return new LightPaintingPoint2D(p.x * scale + width / 2, p.y * scale + height / 2);
  }
 
  //Convert a point on the 2D screen to a point in the 3D model, projected on the interaction plane.
  public LightPaintingPoint3D toModelCoordinates(float x, float y) {
    float scale = interactionPlane / focalLength;
 
    return new LightPaintingPoint3D((x - width / 2) * scale, (y - height / 2) * scale, interactionPlane);
  }
 

  //Scale the diameter of a sphere whose center is at a particular Z distance to its diameter on the screen.
  public float scaleToScreen(float diameter, float distance) {
    return diameter * focalLength / distance;
  }
 
  private void drawLine(LightPaintingPoint2D from, LightPaintingPoint2D to) {
    line(from.x, from.y, to.x, to.y);
  }
 
  private void drawPoint(LightPaintingPoint2D p) {
    point(p.x, p.y);
  }
 
  //Draw a line between 3D points.
  public void drawLine(LightPaintingPoint3D from, LightPaintingPoint3D to, float weight) {
    strokeWeight(max(0,scaleToScreen(weight, to.z)));
    drawLine(toScreenCoordinates(from), toScreenCoordinates(to));
  }
 
  //Draw a point in 3D.
  public void drawPoint(LightPaintingPoint3D p, float weight) {
    strokeWeight(max(0,scaleToScreen(weight, p.z)));
    drawPoint(toScreenCoordinates(p));
  }
 

  //Draw a circle with vertical normal vector.
  public void drawHorizontalCircle(LightPaintingPoint3D center, float radius) {
    float screenRadius = lightpainting_canvas.scaleToScreen(radius, center.z);
    LightPaintingPoint2D p = toScreenCoordinates(center);
    ellipse(p.x, p.y, screenRadius, screenRadius * .3f);
  }
}
 
//Increase the intensity of a color value.
public float amplify(float n) {
  return constrain(4 * n, 0, 255);
}
 

public class LightPaintingParticle {

  private LightPaintingPoint3D location;  //The coordinates of the particle's current location.
  private LightPaintingVector3D velocity;  //The particle's velocity.
 
  private float red;    //The particle's color.
  private float green;
  private float blue;
  
  //Was the particle drawn off the left of the screen?
  private boolean pastLeftWall;
 
  //Was the particle drawn off the right of the screen?
  private boolean pastRightWall;
 
  //Create a LightPaintingParticle with a specified color.
  public LightPaintingParticle(float red, float green, float blue) {
    this.red = red;
    this.green = green;
    this.blue = blue;
  }
 
  //Initialize or reset all variables describing the motion of the particle to the specified values.
  public void initializeMotion(LightPaintingPoint3D location, LightPaintingVector3D velocity) {
    this.location = location;
    this.velocity = velocity;
  }
 

  //Returns true if the LightPaintingParticle should still be actively evolving in time.
  public boolean isActive() {
    return location != null && location.z >= lightpainting_focalLength;
  }
 
  //Draw a motion-blurred trajectory of a particular stroke weight and opacity. The stroke weight will be scaled based on the LightPaintingParticle's distance from the viewer.
  private void drawMotion(LightPaintingPoint3D from, LightPaintingPoint3D to, float weight, float opacity) {
    stroke(red, green, blue, opacity);
    lightpainting_canvas.drawLine(from, to, weight);
  }
 

  //Draw the LightPaintingParticle on the screen.
  public void paint(float elapsedMillis) {
    LightPaintingPoint3D from = location;
    LightPaintingPoint3D to = location.add(velocity.mul(elapsedMillis));
 
    //Draw three motion blurs, successively narrower and brighter.    
    drawMotion(from, to, 64, 8);
    drawMotion(from, to, 32, 32);
    drawMotion(from, to, 8, 255);

    //Draw a splash if it has struck the ground
    if (isUnderground(elapsedMillis)) {
      splash(to);
    }
    //Remember if we drew off of the left or right of the screen.
    LightPaintingPoint2D p = lightpainting_canvas.toScreenCoordinates(to);
    pastLeftWall = p.x < 0;
    pastRightWall = p.x >= width;
  }
 
  //Draw the splash when the LightPaintingParticle strikes the ground.
  private void splash(LightPaintingPoint3D to) {
    //The splash is a circle on the ground with dim illumination in its interior and a bright ring on its circumference.
    stroke(red, green, blue, 128);
    fill(red, green, blue, 64);
    lightpainting_canvas.drawHorizontalCircle(to, 64);

    //At the point where the LightPaintingParticle touched the ground, draw a small but bright flash of light.
    stroke(amplify(red), amplify(green), amplify(blue), 255);
    lightpainting_canvas.drawPoint(to, 8);
  }
 
 
  //Is the LightPaintingParticle's next position beneath the surface of the ground?
  private boolean isUnderground(float elapsedMillis) {
    return location.y + velocity.y * elapsedMillis > height;
  }
 
  //Various functions to determine the direction of the LightPaintingParticle's motion.
  private boolean isMovingLeft() {
    return velocity.x <= -lightpainting_tolerance;
  }
 
  private boolean isMovingRight() {
    return velocity.x >= lightpainting_tolerance;
  }
 
  private boolean isMovingUp() {
    return velocity.y <= -lightpainting_tolerance;
  }
 
  private boolean isMovingDown() {
    return velocity.y >= lightpainting_tolerance;
  }
 
  private boolean isMovingVertically() {
    return isMovingUp() || isMovingDown();
  }
 
  //Reverse the horizontal motion of the LightPaintingParticle.
  private void bounceHorizontal() {
    velocity.x = -velocity.x;
  }
 

  //Reverse the vertical motion of the LightPaintingParticle.
  private void bounceVertical() {
    //The LightPaintingParticle's kinetic energy will be scaled down randomly.  It will lose energy with every bounce.
    velocity.y = -velocity.y * random(lightpainting_lowBounce, lightpainting_highBounce);
  }
 
  //Give the particle an inactive status, indicating it no longer needs to be evolved in time.
  private void deactivate() {
    location.z = 0;
  }
 
  //Evolve the LightPaintingParticle's motion over the specified amount of time in millis.
  public void evolve(float elapsedMillis) {
    //Bounce off of the left or right borders of the screen if the LightPaintingParticle has gone off.
    if ((pastLeftWall && isMovingLeft()) || (pastRightWall && isMovingRight())) {
      bounceHorizontal();
    }
 
    //If the LightPaintingParticle has struck the ground, bounce vertically.  Deactivate the particle if it has lost so much energy it is no longer really bouncing.
    if (isUnderground(elapsedMillis) && isMovingDown()) {
      bounceVertical();
      if (!isMovingVertically()) {
        deactivate();
      }
    }
 
    //Add the LightPaintingParticle's velocity times elapsed time to its current location.
    location.shift(velocity.mul(elapsedMillis));
 

    //Apply the accleration due to gravity.
    velocity.y += lightpainting_gravity;
  }
}
 
 
//////////////////////////////////////////
// Specific actions for the ShiftPixels animations
//////////////////////////////////////////


public void draw_shiftpixelsup() {
  loadPixels();
  int[] temppixels = pixels;
  for (int i = 0; i < temppixels.length; i++) {
    pixels[i] = temppixels[(i+width*shiftpixels_speed) % (width*height)];
  }
  updatePixels();
}

public void draw_shiftpixelsdown() {
  loadPixels();
  //Due to a strange bug in Processing, it is impossible to use a simple int[] to store the pixels, it ends up being modified along with pixels
  IntList temppixels = new IntList();
  for (int i = 0; i < pixels.length; i++) {
    temppixels.append(pixels[i]);
  }
  for (int i = 0; i < pixels.length; i++) {
    int newindex = (((i - width*shiftpixels_speed)  % (width*height)) + (width*height)) % (width*height);
    pixels[i] = temppixels.get(newindex);
  }
  updatePixels();
  
}

public void draw_shiftpixelsleft() {
 loadPixels();
  IntList temppixels = new IntList();
  for (int i = 0; i < pixels.length; i++) {
    temppixels.append(pixels[i]);
  }
  for (int i = 0; i < pixels.length; i++) {
    int newindex = ((PApplet.parseInt((i - (i % width))/width))*width + ((i + shiftpixels_speed) % width));
    pixels[i] = temppixels.get(newindex);
  }
  updatePixels();

}

public void draw_shiftpixelsright() {
 loadPixels();
  IntList temppixels = new IntList();
  for (int i = 0; i < pixels.length; i++) {
    temppixels.append(pixels[i]);
  }
  for (int i = 0; i < pixels.length; i++) {
    int newindex = ((PApplet.parseInt((i - (i % width))/width))*width + ((i + shiftpixels_speed) % width));
    pixels[newindex] = temppixels.get(i);
  }
  updatePixels();
}

public void draw_shredpixelsvertical() {
  loadPixels();
  //Due to a strange bug in Processing, it is impossible to use a simple int[] to store the pixels, it ends up being modified along with pixels
  IntList temppixels = new IntList();
  for (int i = 0; i < pixels.length; i++) {
    temppixels.append(pixels[i]);
  }
  for (int i = 0; i < pixels.length; i++) {
    int newindex = (((i - width*shiftpixels_speed)  % (width*height)) + (width*height)) % (width*height);
    if ((i % width) - width/3 < 0 || (i % width) - 2*width/3 > 0) { 
      pixels[i] = temppixels.get(newindex);
    }
    else {
      pixels[newindex] = temppixels.get(i);
    }
  }
  updatePixels();
}

public void draw_shredpixelshorizontal() {
  loadPixels();
  //Due to a strange bug in Processing, it is impossible to use a simple int[] to store the pixels, it ends up being modified along with pixels
  IntList temppixels = new IntList();
  for (int i = 0; i < pixels.length; i++) {
    temppixels.append(pixels[i]);
  }
  for (int i = 0; i < pixels.length; i++) {
    int newindex = ((PApplet.parseInt((i - (i % width))/width))*width + ((i + shiftpixels_speed) % width));
    if (i - (width*height)/2 > 0) { 
      pixels[i] = temppixels.get(newindex);
    }
    else {
      pixels[newindex] = temppixels.get(i);
    }
  }
  updatePixels();
}


//////////////////////////////////////////
// Specific actions for the LightFusion animation
//////////////////////////////////////////

public void draw_lightfusion() {
  lightfusion_time += lightfusion_timeincrement;
  lightfusion_updateposition();
  lightfusion_drawFrame(lightfusion_time);
}

public void lightfusion_drawFrame(float lightfusion_time) {
    loadPixels();
    //for(int v=0; v<height; v++) {
    
    if (lightfusion_column == false) {
      for(int v=0; v<height; v++) {
        float y = map(v, 0, height, lightfusion_ymin, lightfusion_ymax);
        for(int u=0; u<width; u++) {
          float x = map(u, 0, width, lightfusion_xmin, lightfusion_xmax);
          pixels[u+v*width] = lightfusion_RGB(x, y, lightfusion_time, u, v);
        }
      }
    }
    else {
      for(int v=0; v<height; v++) {
        float y = map(v, 0, height, lightfusion_ymin, lightfusion_ymax);
        for(int u=0; u<width; u++) {
          float x = map(u, 0, width, lightfusion_xmin, lightfusion_xmax);
          pixels[u+v*width] = lightfusion_RGB(x, y, lightfusion_time, u, 0);
        }
      }
    }
    updatePixels();
}


public void lightfusion_updateposition() {
  if (lightfusion_moveUp) {
    lightfusion_Y -= lightfusion_speedY;
  }
  else {
    lightfusion_Y += lightfusion_speedY;
  }
  
  if (lightfusion_moveRight) {
    lightfusion_X += lightfusion_speedX;
  }
  else {
    lightfusion_X -= lightfusion_speedX;
  }
  
  if (lightfusion_Y > height) {
    lightfusion_moveUp = true;
  }
  if (lightfusion_Y < - height/12) {
    lightfusion_moveUp = false;
  }  

  if (lightfusion_X > 5*width/6) {
    lightfusion_moveRight = false;
  }
  if (lightfusion_X < width/6) {
    lightfusion_moveRight = true;
  }    
}

public int lightfusion_RGB (float x, float y, float lightfusion_time, int u, int v) {
  float d1 = dist(u, v, width/6, height/6) / width * 8.5f;               // top-left star
  float d1_bis = dist(u, v, 5*width/6, height/6) / width * 8.5f;     // top-right star  
  float d2 = dist(u, v, lightfusion_X, lightfusion_Y) / width * 8.5f;       // mouse-following star
  float d3 = dist(width/6, height/6, lightfusion_X, lightfusion_Y) / width;           // stars fusion
  float d3_bis = dist(5*width/6, height/6, lightfusion_X, lightfusion_Y) / width;           // stars fusion
  float pattern = pow(cos(x-lightfusion_time/6) * sin(y+lightfusion_time/2) +1, -1/d2);
  float luma = (pattern) * 127;
  float d = d1*d2*d3;
  float d_bis = d1_bis*d2*d3_bis;
  if (d < d_bis) {
    return color(luma/d, luma/d - lightfusion_Y, luma/d - lightfusion_Y);
  }
  else {
    return color(luma/d_bis, luma/d_bis - lightfusion_Y, luma/d_bis - lightfusion_Y); 
  }
}

public int lightfusion_R(int x, int y) { return ((x*255*3)/lightfusion_xspan) % 256; }
public int lightfusion_G(int x, int y) { return ((y*255*3)/lightfusion_yspan) % 256; }
public int lightfusion_B(int x, int y) { return 256*(y*lightfusion_xspan+x)/(lightfusion_xspan*lightfusion_yspan); }


//////////////////////////////////////////
// Specific actions for the RandomPaint animation
//////////////////////////////////////////



public void draw_randompaint() {
  fill(0,15);
  noStroke();
  rect(0,0,width,height);

  randompaint_t = 0;
  float blue = randompaint_startX/5+round(random(randompaint_startX/width)*75);
  float red =200-(randompaint_startX/width)*80-round(random(randompaint_startX/width)*100);
  float green = random(50);
  int saturation = 200;
  while (randompaint_t <= 30) {
    if (randompaint_startX < -0.3f*width - 5 || randompaint_startX > 1.3f*width || randompaint_startY < -0.3f*height - 5 || randompaint_startY > 1.3f*height) {
      saturation=0;
    }
    if (randompaint_startX >= -0.3f*width - 5 && randompaint_startX <= 2*width && randompaint_startY >= -0.3f*height - 5 && randompaint_startY <= 1.3f*height) {
      randompaint_ang+=random(-1,1)*5;
      stroke(red, green, blue, saturation);
      randompaint_lastX = randompaint_startX + cos(radians(randompaint_ang))*randompaint_len*(width/height);
      randompaint_lastY = randompaint_startY + sin(radians(randompaint_ang))*randompaint_len;
      line(randompaint_startX, randompaint_startY,randompaint_lastX*2 ,randompaint_lastY*2) ;
      randompaint_startX = randompaint_lastX;
      randompaint_startY = randompaint_lastY;
    }
    else if (randompaint_startX < -0.3f*width - 5) {
      randompaint_startX = width - random(randompaint_len);
    }
    else if (randompaint_startX > 1.3f*width) {
      randompaint_startX = -5 + random(randompaint_len);
    }
    else if (randompaint_startY < -0.3f*height - 5) {
      randompaint_startY = height - random(randompaint_len);
    }
    else if (randompaint_startY > 1.3f*height) {
      randompaint_startY = -5 + random(randompaint_len);
    }
    randompaint_t++;
  }

}


//////////////////////////////////////////
// Specific actions for the RedWave animation
//////////////////////////////////////////


public float redwave_wave(int x, int y, float fx, float fy, float a, float vx, float vy) {
  return sin((x+2*sin(y*fx*3))*fx + redwave_t*vx) * sin(y*fy + redwave_t*vy) * a;
}

public int redwave_RGB(int x, int y, float t) {
  float value = 0;
  //                  fx    fy    a     vx    vy
  value += redwave_wave(x, y, 0.20f, 0.10f, 0.4f, redwave_dx, redwave_dy );
  value += redwave_wave(x, y, 0.31f, 0.31f, 0.4f, 0.2f, 0.2f);
  value += redwave_wave(x, y, 0.09f, 0.07f, 0.4f, 0.2f, 0.2f);

  value = sin(value*7);
  value = pow(value*value, .1f);
  float normed = value*255;
  return color(255-normed/2, 24, 0);
}


public void redwave_drawFrame(float t)
{
  redwave_dx = pow(sin(t/20), 2)/3;
  redwave_dy = pow(cos(t/20), 2)/3;

  loadPixels();
  for (int v=0; v<height; v++) {
    int y = (int) map(v, 0, width, redwave_ymax, redwave_ymin);

    for (int u=0; u<width; u++) {
      int x = (int) map(u, 0, width, redwave_xmin, redwave_xmax);
      pixels[u+v*width] = redwave_RGB(x, y, t);
    }
  }
  updatePixels();
}

public void draw_redwave()
{
  redwave_t = (redwave_t + redwave_timeIncrement) % 154;
  redwave_drawFrame(redwave_t);
}

//////////////////////////////////////////
// Specific actions for the DiagonalColor animation
//////////////////////////////////////////

public void draw_diagonalcolor() {
  background(0);
 
  pushMatrix();
  translate(width/2, 0);
  rotate(radians(45));
  for (int i = 0; i < diagonalcolors.length;i++) {
    diagonalcolors[i].move();
    diagonalcolors[i].display();
  }
  popMatrix();
}
 
class DiagonalColor {
  float w = 20;
  float h = random(150, 200);
  float x = random(-width/2, width);
  float y = random(-height/2, height);
  float spd = random(1, 3);
 
  float hue;
 
  DiagonalColor(float tmpHue) {
    hue = tmpHue;
  }
 
  public void move() {
    y += spd;
 
    if (y > height + h) {
      y = -h*2;
      x = random(-width/2, width);
    }
  }
 
  public void display() {
    noStroke();
    fill(hue, 255, 0.8f*255);
    rect(x, y, w, h);
    
    hue += 0.1f;
    
    if (hue > 360) {
      hue = 0;
    }
    
    if (hue > 20 && hue < 160) {
      //Shitty colors : go faster
      hue += 2;
    }

    if (hue > 250 && hue < 320) {
      //Shitty colors : go faster
      hue += 1;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the HypnoSpiralRed animation
//////////////////////////////////////////


public void draw_hypnospiralred()
{
  float tempdX = hypnospiralred_noiseMove * (noise(frameCount * hypnospiralred_noiseScale)- 0.5f);
  float tempdY = hypnospiralred_noiseMove * (noise(100 + frameCount * hypnospiralred_noiseScale) - 0.5f);
  if (dist(width/2,height/2, hypnospiralred_X + tempdX, height/2) > dist(width/2,height/2, hypnospiralred_X, height/2)) {
    hypnospiralred_X += 0.3f* tempdX;
  }
  else {
    hypnospiralred_X += tempdX;
  }
  if (dist(width/2,height/2, width/2, hypnospiralred_Y + tempdY) > dist(width/2,height/2, width/2, hypnospiralred_Y)) {
    hypnospiralred_Y += 0.2f* tempdY;
  }
  else {
    hypnospiralred_Y += tempdY;
  }
  hypnospiralred_timeIncrement += hypnospiralred_timeIncrementFactor * (0.5f - noise(hypnospiralred_noiseScale2 * frameCount));
  hypnospiralred_t += hypnospiralred_timeIncrement;
  
  hypnospiralred_drawFrame(hypnospiralred_t);
}

public void hypnospiralred_drawFrame(float t)
{
  loadPixels();
  for(int v=0; v<height; v++) {
  //Mapping along width is not a mistake here !
  float y =(map(v, 0, width, hypnospiralred_ymax, hypnospiralred_ymin));
  for(int u=0; u<width; u++) {
    float x =(map(u, 0, width, hypnospiralred_xmin, hypnospiralred_xmax));
    pixels[u+v*width] = hypnospiralred_RGB(x, y, t);
    }
  }   
  updatePixels();
}

public int hypnospiralred_RGB(float x, float y, float t) {
  x -= (hypnospiralred_X - width/2) / width * hypnospiralred_xspan;
  y += (hypnospiralred_Y - height/2) / height * hypnospiralred_yspan;

  float radius = dist(x, y, 0, 0);    // cartesian to polar
  float angle = atan2(x, y) + t;      // cartesian to polar; turns with time
  float value = cos(angle*2 - log(radius)*5); // the spiral
  value = pow(value, 8); 

  hypnospiralred_timeIncrement = 0.1f+hypnospiralred_X/1500;
  float luma = (value) * 255;
  return color(luma,0,0);
}

//////////////////////////////////////////
// Specific actions for the NightRoad animation
//////////////////////////////////////////


public void nightroad_drawFrame(float nightroad_t)
{
    loadPixels();
    for(int v=0; v<height; v++) {
      float y = map(v, 0, height, nightroad_ymax, nightroad_ymin);
      for(int u=0; u<width; u++) {
        float x = map(u, 0, width, nightroad_xmin, nightroad_xmax);
        pixels[u+v*width] = nightroad_RGB(x, y, nightroad_t);
      }
    }
    updatePixels();
}

public void draw_nightroad()
{
  nightroad_frameCounter += 1;
  nightroad_brightness = min(nightroad_frameCounter*3, 255)/255.0f;
  nightroad_t += nightroad_timeIncrement;
  nightroad_direction = ((mouseX - width/2) / width) * TWO_PI;
  nightroad_drawFrame(nightroad_t);
  nightroad_Y = min(height, nightroad_Y + nightroad_beatspeed);
}

public int nightroad_RGB(float x, float y, float nightroad_t) {
  float val = cos(1/y+nightroad_t) * cos(x/y - nightroad_direction); // perspective spots raster
  val = 1 - pow(val,4);                          // increase contrast
  float band =  sq(1.2f*1/(x/y - nightroad_direction));         // V mask for central band
  float color_shift = nightroad_Y / (float)height;
  color_shift = map(color_shift, 0, 1, 0.2f, 0.65f);
  // pack all into HSV
  float h = 1+sin(val/2) + color_shift;
  float s = 3 ;
  float v = band * nightroad_brightness;
  return color(h * 255/3, s * 255/3, v * 255/3);
}


//////////////////////////////////////////
// Specific actions for the HypnoFlashTriangle animation
//////////////////////////////////////////
 
 public void draw_hypnoflashtriangle() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  for (HypnoTriangle triangle: hypnotriangle_list) {
    triangle.draw_hypnotriangle();
    triangle.move_hypnotriangle();
  }
  for (HypnoTriangle triangle: hypnotriangle_list) {
    if (triangle.isDead() == true) {;
      hypnotriangle_list.remove(triangle);
      break;
    }
  }
}


class HypnoTriangle {
  
  float size;
  float position;
  float growthRate = 1.13f;
  int instance;
  
  HypnoTriangle(int instancecounter) {
    size = 4;
    position = 2;
    instance = instancecounter;
  }
  
  public void draw_hypnotriangle() {
    
    if (instance % 2 == 0) {
      if (frameCount % 4 == 0 || frameCount % 4 == 1)  {
        fill(255,0,0);
      }
      else {
        fill(0);
      }
    }
    else {
      fill(0);
    }
    //stroke(255,0,0);
    noStroke();
    pushMatrix();
    translate(width/2, height/2);
    beginShape();
    vertex(-position/2,-position/3);
    vertex(position/2,-position/3);
    vertex(0,2*position/3);
    endShape(CLOSE);
    
    popMatrix();
  
  }
  
  public void move_hypnotriangle() {
    size *= growthRate;
    position *= growthRate;
  }
  
  public boolean isDead() {
    if (position > width * 20 && hypnotriangle_list.size() > 2) {
      return true;
    } 
    else {
      return false;
    }
  }

}

//////////////////////////////////////////
// Specific actions for the RotatingCut animation
//////////////////////////////////////////

public void draw_rotatingcut_black() {
  noStroke();
  fill(0);
  rect(0,0,width,height);
  pushMatrix();
  translate(width/2,height/2);
  rotate(rotatingcut_angle);
  fill(255);
  rect(-100,0,200,100);
  popMatrix();

  rotatingcut_angle += rotatingcut_speed;
  rotatingcut_speed = 0.4f*(noise(frameCount * 0.01f) - 0.5f);
}

public void draw_rotatingcut_black_fast() {
  noStroke();
  fill(0);
  rect(0,0,width,height);
  pushMatrix();
  translate(width/2,height/2);
  rotate(rotatingcut_angle);
  fill(255);
  rect(-100,0,200,100);
  popMatrix();

  rotatingcut_angle += rotatingcut_speed;
  rotatingcut_speed = (noise(frameCount * 0.01f) - 0.5f);
}

public void draw_rotatingcut_blue() {
  noStroke();
  fill(0);
  rect(0,0,width,height);
  pushMatrix();
  translate(width/2,height/2);
  rotate(rotatingcut_angle);
  fill(150+10*sin(rotatingcut_angle), 200, 255);
  rect(-100,0,200,100);
  popMatrix();
  
  if (rotatingcut_speed < 0.1f) {
    rotatingcut_angle += min(rotatingcut_speed,-0.1f);
  }
  else {
    rotatingcut_angle += max(rotatingcut_speed,0.2f);
  }
  rotatingcut_speed = 0.4f*(noise(frameCount * 0.02f) - 0.5f);
}

//////////////////////////////////////////
// Specific actions for the ArcRot animation
//////////////////////////////////////////


public void draw_greenArcRot() {
  background(0);
  float fc = frameCount*0.001f;
  for(int r=44; r<width; r+=24) {
    float miniR = r*0.01f;
    float a = arcRot_maxiPi*noise(2*miniR, fc);
    float b = arcRot_maxiPi*noise(2*fc * 2, miniR);
    if(abs(a-b) > PI) {
      stroke(color((20 + r) % 255, 255, 255));
    } else {
      stroke(100);
    }
    arc(width/2, height/2, r, r, min(a,b), max(a,b));   
  }
  
  fill(60, 255, 255);
  noStroke();
  ellipse(width/2, height/2, arcRot_pulseSize, arcRot_pulseSize);
  noFill();
  if (arcRot_pulseSize > 8) {
    arcRot_pulseSize -= arcRot_pulseSpeed;
  }
  
}

public void draw_redArcRot() {
  background(0);
  float fc = frameCount*0.001f;
  for(int r=44; r<width; r+=24) {
    float miniR = r*0.01f;
    float a = arcRot_maxiPi*noise(2*miniR, fc);
    float b = arcRot_maxiPi*noise(2*fc * 2, miniR);
    if(abs(a-b) > PI) {
      stroke(color((220 + 0.6f*r) % 255, 255, 255));
    } else {
      stroke(100);
    }
    arc(width/2, height/2, r, r, min(a,b), max(a,b));   
  }
  
  fill(0, 255, 255);
  noStroke();
  ellipse(width/2, height/2, arcRot_pulseSize, arcRot_pulseSize);
  noFill();
  if (arcRot_pulseSize > 8) {
    arcRot_pulseSize -= arcRot_pulseSpeed;
  }
  
}


//////////////////////////////////////////
// Specific actions for the EnergyGrid animation
//////////////////////////////////////////

public void draw_energyGrid() {
  noStroke();
  float energytriangles_brightness = map(energytriangles_energy, 1, 500, -20, 280);
  fill(0, 0, energytriangles_brightness, 160);
  rect(0, 0, width, height);

  for (EnergyTriangle triangle: EnergyTriangles) {
    triangle.drawEnergyTriangle();
  }
  //energytriangles_counter+=0.01;
  if (energytriangles_energy > 15) {
    energytriangles_energy -= energytriangles_energy / 90;
  }
}

class EnergyTriangle {
  float xPos;
  float yPos;
  float no;
  float h;
  float br;
  float x;
  float y;          
  float nx;
  float ny;
  float nd;
  float diameter = width / energytriangles_density * 1.5f;
  float angle;
  float angleSpeed;
  
  EnergyTriangle(float ixPos, float iyPos, float ino) {
    xPos = ixPos;
    yPos = iyPos;
    no = ino;
    angle = random(0, TWO_PI);
    angleSpeed = random(-0.2f, 0.2f);
  }

  public void drawEnergyTriangle() {
    noFill();
    h = map(energytriangles_energy, 15, 1000, 140, 255);//hue
    br = map(energytriangles_energy, 15, 1000, 100, 800);//brightness
    x = noise(1, no, frameCount * 0.01f);
    y = noise(2, no + 1, frameCount * 0.01f);            
    nx = map(x * energytriangles_energy, 0, energytriangles_energy, -energytriangles_energy, energytriangles_energy);
    ny = map(y * energytriangles_energy, 0, energytriangles_energy, -energytriangles_energy, energytriangles_energy);
    nd = map(x * energytriangles_energy, 0, energytriangles_energy, 0.2f * diameter, 2.0f * diameter);
    
    stroke(0, 255, max(255,2*br));
    pushMatrix();
    translate(xPos + nx, yPos + ny);
    rotate(angle);
    triangle(- diameter/2, - 0.33f * diameter*sqrt(3/2), diameter/2,  - 0.33f * diameter*sqrt(3/2), 0,  0.66f * diameter*sqrt(3/2));
    popMatrix();
    angle += angleSpeed;
  }
}

//////////////////////////////////////////
// Specific actions for the Patchwork animation
//////////////////////////////////////////

public void draw_patchwork() {
  int hue;
  if (random(1) > 0.5f) {
    hue = (int) random(0,45);
  }
  else {
    hue = (int) random(75,200);
  }
  fill(hue, 255, 255);
  pushMatrix();
  int rectWidth = (int)random(4, width);
  int rectHeight = (int)random(0, height);
  float rectAngle = random(0,TWO_PI);
  int rectOffCenter = (int)random(0, width/3);
  translate(width/2, height/2);
  rotate(rectAngle);
  rect(-rectWidth/2, rectOffCenter, rectWidth/2, rectHeight);
  popMatrix();
}


//////////////////////////////////////////
// Specific actions for the ReverseTriangle animation
//////////////////////////////////////////

public void draw_reverseTriangles() {
  reverseTriangles_red.beginDraw();
  reverseTriangles_red.fill(0);
  reverseTriangles_red.noStroke();
  reverseTriangles_red.rect(0,0,width,height);
  reverseTriangles_red.stroke(255,0,0);
  reverseTriangles_red.strokeWeight(min(8 * reverseTriangles_size, 16));
  reverseTriangles_red.noFill();  
  reverseTriangles_red.beginShape();
  reverseTriangles_red.vertex(width/2 + reverseTriangles_size*width/(2*NUMBER_OF_PANELS),height/2 + reverseTriangles_size*height/6);
  reverseTriangles_red.vertex(width/2,height/2 - reverseTriangles_size*height/6);
  reverseTriangles_red.vertex(width/2 - reverseTriangles_size*width/(2*NUMBER_OF_PANELS),height/2 + reverseTriangles_size*height/6);
  reverseTriangles_red.endShape(CLOSE);
  reverseTriangles_red.endDraw();
  
  reverseTriangles_green.beginDraw();
  reverseTriangles_green.fill(0);
  reverseTriangles_green.noStroke();
  reverseTriangles_green.rect(0,0,width,height);
  reverseTriangles_green.noFill();
  reverseTriangles_green.stroke(255,255,255);
  reverseTriangles_green.strokeWeight(min(8 * reverseTriangles_size, 16));
  reverseTriangles_green.beginShape();
  reverseTriangles_green.vertex(width/(NUMBER_OF_PANELS*2) + reverseTriangles_size*width/(NUMBER_OF_PANELS*4),height /2 - reverseTriangles_size*height/12);
  reverseTriangles_green.vertex(width/(NUMBER_OF_PANELS*2),height /2 + reverseTriangles_size*height/12);
  reverseTriangles_green.vertex(width/(NUMBER_OF_PANELS*2) - reverseTriangles_size*width/(NUMBER_OF_PANELS*4),height /2 - reverseTriangles_size*height/12);
  reverseTriangles_green.endShape(CLOSE);
  reverseTriangles_green.endDraw();
  
  reverseTriangles_size *= reverseTriangles_speed;
  
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  image(reverseTriangles_red, 0, 0);
  image(reverseTriangles_green, ((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, 0);
}



//////////////////////////////////////////
// Specific actions for the TrigoShapes animation
//////////////////////////////////////////

public PImage createArrowImage() {
    PGraphics buffer = createGraphics(14, 14);
    buffer.beginDraw();
    buffer.background(0xff000000, 0);
    buffer.noStroke();
    buffer.fill(0);
    buffer.beginShape();
    buffer.vertex(5, 0);
    buffer.vertex(9, 0);
    buffer.vertex(9, 6);
    buffer.vertex(14, 6);
    buffer.vertex(8, 14);
    buffer.vertex(0, 6);
    buffer.vertex(5, 6);
    buffer.endShape();
    buffer.endDraw();
    return buffer.get();
}
 
 
public void draw_trigoShapes() {
  trigoshapes_hue += trigoshapes_hueIncrement;

  float midX;
  float midY;
  float a;
  background(0); // Fill background
  trigoshapes_particleFormation = trigoshapes_particleFormation < 1 ? trigoshapes_particleFormation+0.005f : 1;
  trigoshapes_particleAngle += 0.02f;
  switch(trigoshapes_chosenFunction) { // Choose sin/cos-function & calculate position
    case 1:
      midX = width/2;
      midY = height/2 - (polyCos(0, 3) + polyCos(PI, 3)) * trigoshapes_radius * 0.5f;
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = midX + polySin(a, 3) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = midY + polyCos(a, 3) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = midX + polySin(a, 3) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = midY + polyCos(a, 3) * trigoshapes_smallradius;
      }
    break;
    case 2:
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = width/2 + polySin(a, 4) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = height/2 + polyCos(a, 4) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = width/2 + polySin(a, 4) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = height/2 + polyCos(a, 4) * trigoshapes_smallradius;
      }
    break;
    case 3:
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = width/2 + polySin(a, 5) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = height/2 + polyCos(a, 5) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = width/2 + polySin(a, 5) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = height/2 + polyCos(a, 5) * trigoshapes_smallradius;
      }
    break;
    case 4:
      midX = width/2;
      midY = height/2 - (polyCos(0, 3) + polyCos(PI, 3)) * trigoshapes_radius * 0.5f;
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = midX + polySin(a, 4) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = midY + polyCos(a, 3) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = midX + polySin(a, 4) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = midY + polyCos(a, 3) * trigoshapes_smallradius;
      }
    break;
    case 5:
      midX = width/2;
      midY = height/2 - (polyCos(0, 3) + polyCos(PI, 3)) * trigoshapes_radius * 0.5f;
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = midX + sin(a) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = midY + polyCos(a, 3) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = midX + sin(a) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = midY + polyCos(a, 3) * trigoshapes_smallradius;
      }
    break;
    case 6:
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = width/2 + infSin(a) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = height/2 + infCos(a) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = width/2 + infSin(a) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = height/2 + infCos(a) * trigoshapes_smallradius;
      }
    break;
    case 7:
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = width/2 + infSin(a) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = height/2 + polyCos(a, 4) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = width/2 + infSin(a) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = height/2 + polyCos(a, 4) * trigoshapes_smallradius;
      }
    break;
    case 8:
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = width/2 + sin(a) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = height/2 + infCos(a) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = width/2 + sin(a) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = height/2 + infCos(a) * trigoshapes_smallradius;
      }
    break;
    default:
      for(int n = 0; n < trigoshapes_particles.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles.length * n;
        trigoshapes_particles[n].targetX = width/2 + sin(a) * trigoshapes_radius;
        trigoshapes_particles[n].targetY = height/2 + cos(a) * trigoshapes_radius;
      }
      for(int n = 0; n < trigoshapes_particles2.length; n++) {
        a = trigoshapes_particleAngle + PI*2 / trigoshapes_particles2.length * n;
        trigoshapes_particles2[n].targetX = width/2 + sin(a) * trigoshapes_smallradius;
        trigoshapes_particles2[n].targetY = height/2 + cos(a) * trigoshapes_smallradius;
      }
    break;
  }
  fill(0,255,255);
  trigoshapes_particles[0].updateAndRender();
  fill(255);
  for(int n = 1; n < trigoshapes_particles.length; n++) {
    trigoshapes_particles[n].updateAndRender();
  }
  
  //fill((trigoshapes_hue % 360),255,255);
  fill(0,0,255);    //Make it red !
  for(int n = 0; n < trigoshapes_particles2.length; n++) {
    trigoshapes_particles2[n].updateAndRender();
  }
    
}
 
 
public float infSin(float angle) {
  return angle % TWO_PI < PI ? sin(angle*2 + HALF_PI)*0.5f - 0.5f : sin(HALF_PI - (angle-HALF_PI)*2)*0.5f + 0.5f;
}
 
 
public float infCos(float angle) {
  return angle % TWO_PI < PI ? cos(angle*2 + HALF_PI)*0.5f : cos(HALF_PI - (angle-HALF_PI)*2)*0.5f;
}
 
 
public float polySin(float angle, int edges) {
  float arc = TWO_PI / edges;
  int index = floor(angle / arc);
  float factor = (angle - index*arc) / arc;
  return sin(index*arc) * (1-factor) + sin((index+1)*arc) * factor;
}
 
 
public float polyCos(float angle, int edges) {
  float arc = TWO_PI / edges;
  int index = floor(angle / arc);
  float factor = (angle - index*arc) / arc;
  return cos(index*arc) * (1-factor) + cos((index+1)*arc) * factor;
}
 
 
class TrigoShapeParticle {
     
  float targetX;
  float targetY;
  PVector[] blur;
   
   
  TrigoShapeParticle(float x, float y) {
    targetX = x;
    targetY = y;
    blur = new PVector[15];
    for(int n = 0; n < blur.length; n++)
        blur[n] = new PVector(x, y, 0);
  }
   
   
  public void updateAndRender() {
    for(int n = blur.length-1; n > 0; n--) {
      blur[n].x = blur[n-1].x;
      blur[n].y = blur[n-1].y;
      ellipse(blur[n].x, blur[n].y, width/12, width/12);
    }
    float movementAngle = atan2(targetX-blur[0].x, targetY-blur[0].y);
    blur[0].x = blur[0].x*(1-trigoshapes_particleFormation) + targetX*trigoshapes_particleFormation;
    blur[0].y = blur[0].y*(1-trigoshapes_particleFormation) + targetY*trigoshapes_particleFormation;
    ellipse(blur[0].x, blur[0].y, width/12, width/12);
    pushMatrix();
    translate(blur[0].x, blur[0].y);
    rotate(-movementAngle);
    //image(trigoshapes_arrowImage, -trigoshapes_arrowImage.width/2, -trigoshapes_arrowImage.height/2);
    popMatrix();
  }
     
     
}


//////////////////////////////////////////
// Specific actions for the nonotak animations
//////////////////////////////////////////

public void draw_nonotak_1() {
  if (nonotak_1_color == 255) {
    stroke(255);
    noFill();
    strokeWeight(4);
    for (int i = 0; i<width/4; i++) {
      line((i*4*4 + nonotak_1_x) % width, 0, (i*4*4 + nonotak_1_x) % width, height);
    } 
    
  }
  else {
    fill(0);
    noStroke();
    rect(0,0,width,height);
  }
}

public void draw_nonotak_2() {
  noStroke();
  fill(0);
  rect(0,0,width,height);
  fill(255);
  rect(width/2 - (nonotak_2_x*(width/(float)height))/2, height/2 - nonotak_2_x/2, nonotak_2_x*(width/(float)height), nonotak_2_x);
  nonotak_2_x += 4;
}

public void draw_nonotak_3() {
  noStroke();
  fill(255);
  rect(0,0,width,height);
  fill(0);
  rect(width/2 - (nonotak_3_x*(width/(float)height))/2, height/2 - nonotak_3_x/2, nonotak_3_x*(width/(float)height), nonotak_3_x);
  nonotak_3_x += 4;
}

public void draw_nonotak_4() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  stroke(255);
  line(0, (nonotak_4_y % height), width/3, (nonotak_4_y % height));
  line(2*width/3, (nonotak_4_y % height), width, (nonotak_4_y % height));
  line(0, ((nonotak_4_y + height/2) % height), width/3, ((nonotak_4_y + height/2) % height));
  line(2*width/3, ((nonotak_4_y + height/2) % height), width, ((nonotak_4_y + height/2) % height));

  if (frameCount % 4 == 0 || frameCount % 4 == 1) {
    line(width/2, 0, width/2, height);
  }
  nonotak_4_y += 4;
}

public void draw_nonotak_5() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  stroke(255);
  line(0, nonotak_5_y, ((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, nonotak_5_y);
  line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, nonotak_5_y, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS, height - nonotak_5_y);
  line(((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS, height - nonotak_5_y, width, height - nonotak_5_y);
  

  if (nonotak_5_y >= height) { 
    nonotak_5_up = true;
  }
  if (nonotak_5_y <= 0) { 
    nonotak_5_up = false;
  }  
  if (nonotak_5_up == true) {
    nonotak_5_y -= 4;
  }
  else {
    nonotak_5_y += 4;
  }
}


//////////////////////////////////////////
// Specific actions for the Nonotak panel fill animations
//////////////////////////////////////////

class NonotakPanelFill {
 
  int type;
  float progress;
  float progress2;
  
  NonotakPanelFill(int _type) {
    type = _type;
    progress = 0;
    progress2 = 0;
  }
  
  public void panelfill_draw() {
    if (this.isReadyToFade() == false) {
      noStroke();
      fill(255);
      rect(type*width/NUMBER_OF_PANELS + width/(2*NUMBER_OF_PANELS) - progress, height/2 - progress*2, progress*2, progress*4); 
      progress += 2;
    }
    else {
      noStroke();
      fill(0);
      rect(type*width/NUMBER_OF_PANELS + width/(2*NUMBER_OF_PANELS) - progress2, height/2 - progress2*2, progress2*2, progress2*4); 
      progress2 += 2;
    }
  }
  
  public boolean isReadyToFade() {
    if (progress > width/(2*NUMBER_OF_PANELS)) {
      return true;
    }
    else {
      return false;
    }
  }
 
  public boolean isReadyToDie() {
    if (progress2 > width/(2*NUMBER_OF_PANELS)) {
      return true;
    }
    else {
      return false;
    }
  } 
}

public void draw_nonotakPanelFill() {
  for (NonotakPanelFill panel: nonotakPanelFill_list) {
    panel.panelfill_draw();
  }
  boolean panelToKill = false;
  int panelToKill_number = 0;
  for (int i = 0; i<nonotakPanelFill_list.size(); i++) {
    NonotakPanelFill panel = nonotakPanelFill_list.get(i);
    if (panel.isReadyToDie() == true) {
      panelToKill = true;
      panelToKill_number = i;
      break;
    }
  }
  if (panelToKill == true) {
    nonotakPanelFill_list.remove(nonotakPanelFill_list.get(panelToKill_number));
  }
}

//////////////////////////////////////////
// Specific actions for the RandomWhiteLineFlash animation
//////////////////////////////////////////

public void draw_randomWhiteLineFlash() {
  background(0);
  fill(255);
  noStroke();
  float lineHeight = random(0,height);
  float lineWidth = random(0,height);
  rect(0, lineHeight, width, lineWidth);
  
}

//////////////////////////////////////////
// Specific actions for the NonotakWoosh animations
//////////////////////////////////////////

public void draw_nonotakWoosh() {
  fill(0);
  noStroke();
  rect(0,0,width,height);

  for (NonotakWoosh woosh: nonotakWoosh_list) {
    woosh.drawWoosh();
  }
  boolean wooshToKill = false;
  int wooshToKill_number = 0;
  for (int i = 0; i<nonotakWoosh_list.size(); i++) {
    NonotakWoosh woosh = nonotakWoosh_list.get(i);
    if (woosh.readyToKill == true) {
      wooshToKill = true;
      wooshToKill_number = i;
      break;
    }
  }
  if (wooshToKill == true) {
    nonotakWoosh_list.remove(nonotakWoosh_list.get(wooshToKill_number));
  }
}


class NonotakWoosh {

  int type;
  int step;
  float progress1;
  float progress2;
  float progress3;
  boolean readyToKill = false;
  float nonotakWooshSpeed = 8 + 2*(NUMBER_OF_PANELS-3);
  
  NonotakWoosh(int _type) {
    type = _type;
    step = 0;
    switch (type) {
      case 0: progress1 = 0; progress2 = height/2; progress3 = width/NUMBER_OF_PANELS; break;
      case 1: progress1 = 0; progress2 = height/2; progress3 = width/NUMBER_OF_PANELS; break;
      case 2: progress1 = 0; progress2 = width/NUMBER_OF_PANELS; progress3 = height/2; break;
      case 3: progress1 = 0; progress2 = width/NUMBER_OF_PANELS; progress3 = height/2; break;
    }
  }
  
  public void drawWoosh() {
    switch (type) {
      case 0: draw_nonotakWoosh_0();break;
      case 1: draw_nonotakWoosh_1();break;
      case 2: draw_nonotakWoosh_2();break;
      case 3: draw_nonotakWoosh_3();break; 
    }
  }
  
  public void draw_nonotakWoosh_0() {
    fill(255);
    switch (this.step) {
      case 0: rect(width - this.progress1, 0, this.progress1, height/2); this.progress1 += nonotakWooshSpeed; if (this.progress1 >= width) { this.step = 1;} break;
      case 1: rect(0, 0, this.progress1, height/2); this.progress1 -= nonotakWooshSpeed; if (this.progress1 <= width/NUMBER_OF_PANELS) { this.step = 2;} break;
      case 2: rect(0, 0, width/NUMBER_OF_PANELS, this.progress2); this.progress2 += nonotakWooshSpeed; if (this.progress2 >= height) { this.step = 3;} break;
      case 3: rect(0, height - this.progress2, width/NUMBER_OF_PANELS, this.progress2); this.progress2 -= nonotakWooshSpeed; if (this.progress2 <= height/2) { this.step = 4;} break;
      case 4: rect(0, height/2, this.progress3, height/2); this.progress3 += nonotakWooshSpeed; if (this.progress3 >= width) { this.step = 5;} break;
      case 5: rect(width - this.progress3, height/2, this.progress3, height/2); this.progress3 -= nonotakWooshSpeed; if (this.progress3 <= 0) { this.step = 6;} break;
      case 6: this.readyToKill = true;
    }
  }
  
  public void draw_nonotakWoosh_1() {
    fill(255);
    switch (this.step) {
      case 0: rect(0, height/2, this.progress1, height/2); this.progress1 += nonotakWooshSpeed; if (this.progress1 >= width) { this.step = 1;} break;
      case 1: rect(width - this.progress1, height/2, this.progress1, height/2); this.progress1 -= nonotakWooshSpeed; if (this.progress1 <= width/NUMBER_OF_PANELS) { this.step = 2;} break;
      case 2: rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, height - this.progress2, width/NUMBER_OF_PANELS, this.progress2); this.progress2 += nonotakWooshSpeed; if (this.progress2 >= height) { this.step = 3;} break;
      case 3: rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/3, this.progress2); this.progress2 -= nonotakWooshSpeed; if (this.progress2 <= height/2) { this.step = 4;} break;
      case 4: rect(width - this.progress3, 0, this.progress3, height/2); this.progress3 += nonotakWooshSpeed; if (this.progress3 >= width) { this.step = 5;} break;
      case 5: rect(0, 0, this.progress3, height/2); this.progress3 -= nonotakWooshSpeed; if (this.progress3 <= 0) { this.step = 6;} break;
      case 6: this.readyToKill = true;
    }
  }

  public void draw_nonotakWoosh_2() {
    fill(255);
    switch (this.step) {
      case 0: rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, height - this.progress1, width/NUMBER_OF_PANELS, this.progress1); this.progress1 += nonotakWooshSpeed; if (this.progress1 >= height) { this.step = 1;} break;
      case 1: rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, this.progress1); this.progress1 -= nonotakWooshSpeed; if (this.progress1 <= height/2) { this.step = 2;} break;
      case 2: rect(width - this.progress2, 0, this.progress2, height/2); this.progress2 += nonotakWooshSpeed; if (this.progress2 >= width) { this.step = 3;} break;
      case 3: rect(0, 0, this.progress2, height/2); this.progress2 -= nonotakWooshSpeed; if (this.progress2 <= width/NUMBER_OF_PANELS) { this.step = 4;} break;
      case 4: rect(0, 0, width/NUMBER_OF_PANELS, this.progress3); this.progress3 += nonotakWooshSpeed; if (this.progress3 >= height) { this.step = 5;} break;
      case 5: rect(0, height - this.progress3, width/NUMBER_OF_PANELS, height); this.progress3 -= nonotakWooshSpeed; if (this.progress3 <= 0) { this.step = 6;} break;
      case 6: this.readyToKill = true;
    }
  }
  
  public void draw_nonotakWoosh_3() {
    fill(255);
    switch (this.step) {
      case 0: rect(0, 0, width/NUMBER_OF_PANELS, this.progress1); this.progress1 += nonotakWooshSpeed; if (this.progress1 >= height) { this.step = 1;} break;
      case 1: rect(0, height - this.progress1, width/NUMBER_OF_PANELS, this.progress1); this.progress1 -= nonotakWooshSpeed; if (this.progress1 <= height/2) { this.step = 2;} break;
      case 2: rect(0, height/2, this.progress2, height/2); this.progress2 += nonotakWooshSpeed; if (this.progress2 >= width) { this.step = 3;} break;
      case 3: rect(width - this.progress2, height/2, this.progress2, height/2); this.progress2 -= nonotakWooshSpeed; if (this.progress2 <= width/NUMBER_OF_PANELS) { this.step = 4;} break;
      case 4: rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, height - this.progress3, width/NUMBER_OF_PANELS, this.progress3); this.progress3 += nonotakWooshSpeed; if (this.progress3 >= height) { this.step = 5;} break;
      case 5: rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, 0, width/NUMBER_OF_PANELS, this.progress3); this.progress3 -= nonotakWooshSpeed; if (this.progress3 <= 0) { this.step = 6;} break;
      case 6: this.readyToKill = true;
    }
  }
}


//////////////////////////////////////////
// Specific actions for the Patatap animations
//////////////////////////////////////////

public void draw_patatapWithAudioInput() {
  //Reset old flags according to the current system time
  invalidateOutdatedImpulseFlags();
  
  patatap_checkImpulseFlags();
  draw_patatap();
  
  //Reset all the impulse flags, as they have been processed
  impulseMessageProcessed = true;
}

public void draw_patatap() {  
  noStroke();
  fill(patatap_colorsetBackground[patatap_currentColorset]);
  rect(0,0,width,height);
  
  for (PatatapObject patatap:  patatapObjectList) {
    patatap.draw_patatap();
  }
  
  for (PatatapObject patatap:  patatapObjectList) {
    if (patatap.isDead() == true) {
      patatapObjectList.remove(patatap);
      break;
    }
  }
}

public void patatap_checkImpulseFlags() {
  if (impulse_Kick == true)     patatapObjectList.add(new PatatapObject(1));
  if (impulse_Snare == true)    patatapObjectList.add(new PatatapObject(9));
  if (impulse_Cymbals == true)  patatapObjectList.add(new PatatapObject(10));
  if (impulse_Bass == true)     patatapObjectList.add(new PatatapObject(0));
  if (impulse_Keys == true)     patatapObjectList.add(new PatatapObject(0));
  if (impulse_Guitar == true)   patatapObjectList.add(new PatatapObject(0));
}

class PatatapObject {

  int type;
  int progress;
  int maxprogress;
  boolean switcher;
  float angle;

  PatatapObject(int t) {
    type = t;
    progress = 0;
    maxprogress = patatap_maxProgressTable[t];
    switcher = patatap_switcher[t];
    patatap_switcher[t] = !patatap_switcher[t];
    angle = random(0,TWO_PI);
  }

  public void draw_patatap() {
    
    switch(this.type) {
      case 0:  draw_type0();break;
      case 1:  draw_type1();break;
      case 2:  draw_type2();break;
      case 3:  draw_type3();break;
      case 4:  draw_type4();break;
      case 5:  draw_type5();break;
      case 6:  draw_type6();break;
      case 7:  draw_type7();break;
      case 8:  draw_type8();break;
      case 9:  draw_type9();break;
      case 10: draw_type10();break;
      case 11: draw_type11();break;
      case 12: draw_type12();break;
      case 13: draw_type13();break;
      case 14: draw_type14();break;
      case 15: patatap_currentColorset = (patatap_currentColorset+1)%patatap_colorsetBackground.length;break;
      default: break;
    }
    progress += 1;
  } 

  public void draw_type0() {
    noStroke();
    fill(patatap_colorsetElement1[patatap_currentColorset]);
    if (switcher == false) {
      rect(0, height - progress*16, width/NUMBER_OF_PANELS, height);
    }
    else {
      rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, height - progress*16, width/NUMBER_OF_PANELS, height);
    }
  }
  
  public void draw_type1() {
    strokeWeight(20);
    stroke(patatap_colorsetElement2[patatap_currentColorset]);
    noFill();
    ellipse(width/2,height/2, progress*16, progress*16);
  }
  
  public void draw_type2() {
    noStroke();
    fill(patatap_colorsetElement4[patatap_currentColorset]);
    if (switcher == false) {
      rect(-width + progress*16, height/6, width, height/6);
      rect(-width + progress*16, 3*height/6, width, height/6);
      rect(-width + progress*16, 5*height/6, width, height/6);
    }
    else {
      rect(width - progress*16, height/6, width, height/6);
      rect(width - progress*16, 3*height/6, width, height/6);
      rect(width - progress*16, 5*height/6, width, height/6);
    }
  }
  
  public void draw_type3() {
    noStroke();
    fill(patatap_colorsetElement4[patatap_currentColorset]);
    if (switcher == false) {
      if (progress < 8) {
        ellipse(width/2, 1.5f*height - progress*8, width/NUMBER_OF_PANELS, width/NUMBER_OF_PANELS);
      }
      else if (progress < 10) {
        ellipse(width/2, height/2, width/NUMBER_OF_PANELS, width/NUMBER_OF_PANELS);
      }
      else if (progress <= 15) {
        ellipse(width/2, height/2, width/(2*NUMBER_OF_PANELS) - (progress-14)*4, width/(2*NUMBER_OF_PANELS) - (progress-14)*4);
      }
    }
    else {
      if (progress < 8) {
        ellipse(width/2, -0.5f*height + progress*8, width/NUMBER_OF_PANELS, width/NUMBER_OF_PANELS);
      }
      else if (progress < 10) {
        ellipse(width/2, height/2, width/NUMBER_OF_PANELS, width/NUMBER_OF_PANELS);
      }
      else if (progress <= 15) {
        ellipse(width/2, height/2, width/(2*NUMBER_OF_PANELS) - (progress-14)*4, width/(2*NUMBER_OF_PANELS) - (progress-14)*4);
      }      
    }
      
  }

  public void draw_type4() {
    noStroke();
    fill(patatap_colorsetFlash[patatap_currentColorset], max(0, 255-progress*8));  
    rect(0,0,width,height);
  }  
  
  public void draw_type5() {
    noStroke();
    if (frameCount % 4 == 0 || frameCount % 4 == 1) { 
      fill(patatap_colorsetFlash[patatap_currentColorset]);
    }
    else {
      fill(patatap_colorsetBackground[patatap_currentColorset]);
    }
    rect(0,0,width,height);
  }
  
  public void draw_type6() {
    noStroke();
    fill(patatap_colorsetElement2[patatap_currentColorset]);
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, height - progress*8, width/NUMBER_OF_PANELS, height/2);
    fill(patatap_colorsetElement4[patatap_currentColorset]);
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, -height/2 + progress*8, width/NUMBER_OF_PANELS, height/2); 
  }
  
  public void draw_type7() {
    noFill();
    strokeWeight(16);
    stroke(patatap_colorsetElement2[patatap_currentColorset]);
    float startAngle;
    if (switcher == false) {
      startAngle = PI/4;
    }
    else {
      startAngle = 5*PI/4;
    }
    
    if (progress <= patatap_maxProgressTable[7]/2) {
      arc(width/2, height/2, width/2, width/2, startAngle, startAngle + 2*progress*TWO_PI/patatap_maxProgressTable[7]);
    }
    else {
      arc(width/2, height/2, width/2, width/2, startAngle + (2*(progress-patatap_maxProgressTable[7]/2)*TWO_PI/patatap_maxProgressTable[7]) , startAngle + TWO_PI);
    }
  }
  
  public void draw_type8() {
    stroke(patatap_colorsetElement1[patatap_currentColorset]);
    strokeWeight(16);
    noFill();
    if (progress <= patatap_maxProgressTable[8]/2) {
      line(width/2,height/2,width/2 - progress*4,height/2);
      line(width/2,height/2,width/2 + progress*4,height/2);
      line(width/2,height/2,width/2,height/2 - progress*4);
      line(width/2,height/2,width/2,height/2 + progress*4);
    }
    else {
      line(width/2 - (progress-patatap_maxProgressTable[8]/2)*4,height/2,width/2 - progress*4,height/2);
      line(width/2 + (progress-patatap_maxProgressTable[8]/2)*4,height/2,width/2 + progress*4,height/2);
      line(width/2,height/2 - (progress-patatap_maxProgressTable[8]/2)*4,width/2,height/2 - progress*4);
      line(width/2,height/2 + (progress-patatap_maxProgressTable[8]/2)*4,width/2,height/2 + progress*4);      
    }
  }
  
  public void draw_type9() {
    noStroke();
    fill(patatap_colorsetElement1[patatap_currentColorset]);
    pushMatrix();
    translate(width/(NUMBER_OF_PANELS*2) + (patatap_maxProgressTable[8]- progress*2)/2 , height/2 + (patatap_maxProgressTable[8] - progress*2)/2);
    rect(-(patatap_maxProgressTable[8] - progress*2),-(patatap_maxProgressTable[8] - progress*2), patatap_maxProgressTable[8] - progress*2,patatap_maxProgressTable[8] - progress*2);
    popMatrix();

    pushMatrix();
    translate(width - width/(NUMBER_OF_PANELS*2) + (patatap_maxProgressTable[8] - progress*2)/2 , height/2 + (patatap_maxProgressTable[8] - progress*2)/2);
    rect(-(patatap_maxProgressTable[8] - progress*2),-(patatap_maxProgressTable[8] - progress*2), patatap_maxProgressTable[8] - progress*2,patatap_maxProgressTable[8] - progress*2);
    popMatrix();
    
  }
  
  public void draw_type10() {
    pushMatrix();   
    translate(width/2,height/2);
    rotate(this.angle);
    stroke(patatap_colorsetElement4[patatap_currentColorset]);
    strokeWeight(8);
    noFill();
    line(-width*1.5f+progress*12,0,-width*0.5f + progress*12,0);
    popMatrix();
  }
  
  public void draw_type11() {
    noStroke();
    fill(patatap_colorsetElement3[patatap_currentColorset]);
    if (switcher == false) {
      rect(0, -height + progress*12, width, height);
    }
    else {
      rect(0, height - progress*12, width, height);
    }
  }
  
  public void draw_type12() {
    noStroke();
    fill(patatap_colorsetElement1[patatap_currentColorset]);
    if (switcher == true) {
      ellipse(width/(NUMBER_OF_PANELS*2), height - 0.5f*(progress-patatap_maxProgressTable[12]/2)*(progress-patatap_maxProgressTable[12]/2), 20,20);      
    }
    else {
      ellipse(width - width/(NUMBER_OF_PANELS*2), 0.5f*(progress-patatap_maxProgressTable[12]/2)*(progress-patatap_maxProgressTable[12]/2), 20,20);
    }
  }
  
  public void draw_type13() {
    stroke(patatap_colorsetElement3[patatap_currentColorset]);
    strokeWeight(8);
    noFill();
    if (switcher == true) {
      if (progress <= patatap_maxProgressTable[13]/4) {
        line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS - (width/NUMBER_OF_PANELS)*progress/(patatap_maxProgressTable[13]/4), (height/2)*progress/(patatap_maxProgressTable[13]/4));
      }
      else if (progress < patatap_maxProgressTable[13]/2) {
        line(width/NUMBER_OF_PANELS,0,0,height/2);
        line(0,height/2,(width/NUMBER_OF_PANELS)*(progress - patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4), height/2 + (height/2)*(progress - patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4));
      }
      else if (progress < 3*patatap_maxProgressTable[13]/4) {
        line((width/NUMBER_OF_PANELS) - (width/NUMBER_OF_PANELS)*(progress - patatap_maxProgressTable[13]/2)/(patatap_maxProgressTable[13]/4),(height/2)*(progress - patatap_maxProgressTable[13]/2)/(patatap_maxProgressTable[13]/4),0,height/2);
        line(0,height/2,width/NUMBER_OF_PANELS,height);
      }
      else {
        line((width/NUMBER_OF_PANELS)*(progress - 3*patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4),height/2 + (height/2)*(progress - 3*patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4),width/NUMBER_OF_PANELS,height);
      }
    }
    else {
      if (progress <= patatap_maxProgressTable[13]/4) {
        line(width - width/NUMBER_OF_PANELS,0,width - width/NUMBER_OF_PANELS + (width/NUMBER_OF_PANELS)*progress/(patatap_maxProgressTable[13]/4), (height/2)*progress/(patatap_maxProgressTable[13]/4));
      }
      else if (progress < patatap_maxProgressTable[13]/2) {
        line(width - width/NUMBER_OF_PANELS,0,width,height/2);
        line(width,height/2, width - (width/NUMBER_OF_PANELS)*(progress - patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4), height/2 + (height/2)*(progress - patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4));
      }
      else if (progress < 3*patatap_maxProgressTable[13]/4) {
        line(width - width/NUMBER_OF_PANELS + (width/NUMBER_OF_PANELS)*(progress - patatap_maxProgressTable[13]/2)/(patatap_maxProgressTable[13]/4),(height/2)*(progress - patatap_maxProgressTable[13]/2)/(patatap_maxProgressTable[13]/4),width,height/2);
        line(width,height/2,width - (width/NUMBER_OF_PANELS),height);
      }
      else {
        line(width - (width/NUMBER_OF_PANELS)*(progress - 3*patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4),height/2 + (height/2)*(progress - 3*patatap_maxProgressTable[13]/4)/(patatap_maxProgressTable[13]/4),width - width/NUMBER_OF_PANELS,height);
      }   
    }
  }
  
  public void draw_type14() {
    noStroke();
    fill(patatap_colorsetElement1[patatap_currentColorset], max(0, 255-progress*8));  
    if (switcher == true) {
      rect(0,0,width/2,height);
    }
    else {
      rect(width/2,0,width/2,height);
    }
  }
  
  
  public boolean isDead() {
    if (progress >= maxprogress) {
      return true;
    }
    else {
      return false;
    }
  }

}

//////////////////////////////////////////
// Specific actions for the ParallelWorlds animation
//////////////////////////////////////////

public void draw_parallelworlds() {
    
  fill(0,100);
  noStroke();
  rect(0,0,width,height);
  
  crecy_setColor();
  
  if (crecy_init == true) {
    for (Crecy crecy: crecy_list) {
      crecy.draw_crecy();
    }
    for (Crecy crecy: crecy_list) {
      if (crecy.isDead() == true) {
        crecy_list.remove(crecy);
        break;
      }
    }
  }
    
  for (ParallelWorldLine line: parallelworlds_list) {
    line.drawline();
  }
  for (ParallelWorldLine line: parallelworlds_list) {
    if (line.isDead() == true) {
      parallelworlds_list.remove(line);
      break;
    }
  }
    
  if (parallelworlds_flashpower > 0) {
    parallelworlds_flashpower -= parallelworlds_colorDecreaseSpeed;
  }
  
}

class ParallelWorldLine {
  float y;
  float linewidth = width/(2*NUMBER_OF_PANELS);
  boolean normalOrder;
  
  ParallelWorldLine (boolean _normalOrder) {
    normalOrder = _normalOrder;
    if (normalOrder == true) {
      y = - linewidth;
    }
    else {
      y = height + linewidth;
    }
  }
  
  public void drawline() {
    //For this animation, the fact that width/3 is used instead of width/NUMBER_OF_PANELS is intentional !
    noStroke();
    colorMode(RGB);
    //fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower),255);
    fill(crecy_red, crecy_green, crecy_blue);
    beginShape();
    vertex(0,map(y,-2*height/4,6*height/4,-6*height/4,10*height/4));
    vertex(width/3, y);
    vertex(width/3, y + linewidth);
    vertex(0,map(y + linewidth,-2*height/4,6*height/4,-6*height/4,10*height/4));
    endShape(CLOSE);
    
    beginShape();
    vertex(width/3, y);
    vertex(2*width/3, y);
    vertex(2*width/3, y + linewidth);
    vertex(width/3, y + linewidth);
    endShape(CLOSE);
    
    beginShape();
    vertex(2*width/3, y);
    vertex(width,map(y,-2*height/4,6*height/4,-6*height/4,10*height/4));
    vertex(width,map(y + linewidth,-2*height/4,6*height/4,-6*height/4,10*height/4));
    vertex(2*width/3, y + linewidth);
    endShape(CLOSE);
    
    if (parallelworlds_reverse == false) {
      y += parallelworlds_speed;
    }
    else {
      y -= parallelworlds_speed;
    }
  }
  
  public boolean isDead() {
    if (y > height*4/3 || y < -height/3) {
      return true;
    }
    else {
      return false;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the Fireflies animation
//////////////////////////////////////////


public void draw_fireflies() {
  background(0);
  for (Firefly firefly: fireflies_list) {
    firefly.run();
  }
 
}
 
 
public void fireflies_init() {
  fireflies_list.clear();
  for (int i=0; i<fireflies_number; i++) {
    PVector fireflies_org = new PVector(random(fireflies_edge, width-fireflies_edge), random(fireflies_edge, height-fireflies_edge));
    float fireflies_radius = random(width/20, 3*width/20);
    PVector fireflies_loc = new PVector(fireflies_org.x+fireflies_radius, fireflies_org.y);
    float fireflies_offSet = random(TWO_PI);
    int fireflies_dir = 1;
    float fireflies_r = random(1);
    if (fireflies_r>.5f) fireflies_dir =-1;
    Firefly myFirefly = new Firefly(fireflies_org, fireflies_loc, fireflies_radius, fireflies_dir, fireflies_offSet);
    fireflies_list.add(myFirefly);
  }
}
 
class Firefly {
 
  PVector fireflies_org, fireflies_loc;
  float fireflies_theta, fireflies_radius, fireflies_offSet, fireflies_distance;
  float fireflies_s, fireflies_dir, fireflies_d = width/10;
 
  Firefly(PVector _fireflies_org, PVector _fireflies_loc, float _fireflies_radius, int _fireflies_dir, float _fireflies_offSet) {
    fireflies_org = _fireflies_org;
    fireflies_loc = _fireflies_loc;
    fireflies_radius = _fireflies_radius;
    fireflies_dir = _fireflies_dir;
    fireflies_offSet = _fireflies_offSet;
  }
 
  public void run() {
    move();
    lineBetween();
  }
 
  public void move() {
    fireflies_loc.x = fireflies_org.x + sin(fireflies_theta+fireflies_offSet)*fireflies_radius;
    fireflies_loc.y = fireflies_org.y + cos(fireflies_theta+fireflies_offSet)*fireflies_radius;
    fireflies_theta += (0.0523f/2*fireflies_dir);
  }
 
  public void lineBetween() {
    for (int i=0; i<fireflies_list.size(); i++) {
      Firefly fireflies_other = (Firefly) fireflies_list.get(i);
      fireflies_distance = fireflies_loc.dist(fireflies_other.fireflies_loc);
      if (fireflies_distance >0 && fireflies_distance < fireflies_d) {
        fill(0xffFF0900,50);
        stroke(255, 200);
        noStroke();
        ellipse(fireflies_loc.x, fireflies_loc.y, fireflies_d+width/5-fireflies_distance*4, fireflies_d+width/5-fireflies_distance*4);
      }
    }
  }
}


//////////////////////////////////////////
// Specific actions for the MultiCrecy animation
//////////////////////////////////////////

public void crecy_setColor() {
//if (crecy_internalCounter == 0) {
////    crecy_red   = 255;
////    crecy_green = 255;
////    crecy_blue  = 255;
//    crecy_red   = 160;
//    crecy_green = 220;
//    crecy_blue  = 255;
//  }
//  else if (crecy_internalCounter == 1) {
////    crecy_red   = 0;
////    crecy_green = 0;
////    crecy_blue  = 255;
//    crecy_red   = 160;
//    crecy_green = 220;
//    crecy_blue  = 255;
//  }
//  else if (crecy_internalCounter == 2) {
////    crecy_red   = 0;
////    crecy_green = 150;
////    crecy_blue  = 255;
//    crecy_red   = 160;
//    crecy_green = 220;
//    crecy_blue  = 255;
//  }
//  else if (crecy_internalCounter == 3) {
//    crecy_red   = 160;
//    crecy_green = 220;
//    crecy_blue  = 255;
//  }
//  else {
//    //crecy_colorcounter += 1;
//    crecy_red   = 160;
//    crecy_green = 220;
//    crecy_blue  = 255;
//  }  
    crecy_red   = 120;
    crecy_green = 140;
    crecy_blue  = 255;
}

public void draw_multicrecy() {
  
  fill(0,100);
  noStroke();
  rect(0,0,width,height);
  
  crecy_setColor();
  
  for (Crecy crecy: crecy_list) {
    crecy.draw_crecy();
  }
  for (Crecy crecy: crecy_list) {
    if (crecy.isDead() == true) {
      crecy_list.remove(crecy);
      break;
    }
  }
    
  //For better integration, draw ParallelWorlds as well
  for (ParallelWorldLine line: parallelworlds_list) {
    try {
      line.drawline();
    }
    catch(Exception e) {
      outputLog.println("Caught an exception while trying to execute drawline from the MultiCrecy animation : " + e);
    }
  }
  for (ParallelWorldLine line: parallelworlds_list) {
    if (line.isDead() == true) {
      try {
        parallelworlds_list.remove(line);
      }
      catch(Exception e) {
        outputLog.println("Caught an exception while trying to remove line from the MultiCrecy animation : " + e);
      }
      break;
    }
  }
  
  if (parallelworlds_flashpower > 0) {
    parallelworlds_flashpower -= parallelworlds_colorDecreaseSpeed;
  }

}

class Crecy {
  int type;
  int direction;
  int progress;
  int progressTurningPoint;
  int maxProgress;
  
  Crecy(int family) {
    if (NUMBER_OF_PANELS == 3) {
      switch(family) {
        case 1: type = 0  + PApplet.parseInt(random(6)); break;
        case 2: type = 10 + PApplet.parseInt(random(6)); break;
        case 3: type = 20 + PApplet.parseInt(random(3)); break;
        case 4: type = 23 + PApplet.parseInt(random(6)); break;
        case 5: type = 33 + PApplet.parseInt(random(6));break;
        case 6: type = 39 + crecy_chooseNewDouble();break;
        default: break;
      }
    }
    else {
      switch(family) {
        case 1: type = 0  + PApplet.parseInt(random(10)); break;
        case 2: type = 10 + PApplet.parseInt(random(10)); break;
        case 3: type = 20 + PApplet.parseInt(random(3)); break;
        case 4: type = 23 + PApplet.parseInt(random(10)); break;
        case 5: type = 33 + PApplet.parseInt(random(6));break;
        case 6: type = 39 + crecy_chooseNewDouble();break;
        default: break;
      }      
    }
    direction = PApplet.parseInt(random(4));
    maxProgress = crecy_maxProgressList[type];
  }
  
  public int crecy_chooseNewDouble() {
    if (NUMBER_OF_PANELS >= 5) {
      if (crecy_previousDouble == 0) {
        if (random(1) > 0.5f) { crecy_previousDouble = 1; return crecy_previousDouble; }
        else                 { crecy_previousDouble = 2; return crecy_previousDouble; }
      }
      else if (crecy_previousDouble == 1) {
        if (random(1) > 0.5f) { crecy_previousDouble = 0; return crecy_previousDouble; }
        else                 { crecy_previousDouble = 2; return crecy_previousDouble; } 
      }
      else {
        if (random(1) > 0.5f) { crecy_previousDouble = 0; return crecy_previousDouble; }
        else                 { crecy_previousDouble = 1; return crecy_previousDouble; } 
      }
    }
    else {
      crecy_previousDouble = (crecy_previousDouble + 1)%2 ;
      return crecy_previousDouble;
    }
  }
  
  public void draw_crecy() {
    switch (type) {
      case 0: draw_type0();break;
      case 1: draw_type1();break;
      case 2: draw_type2();break;
      case 3: draw_type3();break;
      case 4: draw_type4();break;
      case 5: draw_type5();break;
      case 6: draw_type6();break;
      case 7: draw_type7();break;
      case 8: draw_type8();break;
      case 9: draw_type9();break;
      
      case 10: draw_type10();break;
      case 11: draw_type11();break;
      case 12: draw_type12();break;
      case 13: draw_type13();break;
      case 14: draw_type14();break;
      case 15: draw_type15();break;
      case 16: draw_type16();break;
      case 17: draw_type17();break;
      case 18: draw_type18();break;
      case 19: draw_type19();break;
      
      case 20: draw_type20();break;      
      case 21: draw_type21();break;
      case 22: draw_type22();break;
      
      case 23: draw_type23();break;
      case 24: draw_type24();break;
      case 25: draw_type25();break;
      case 26: draw_type26();break;      
      case 27: draw_type27();break;
      case 28: draw_type28();break;
      case 29: draw_type29();break;
      case 30: draw_type30();break;
      case 31: draw_type31();break;
      case 32: draw_type32();break;
      
      case 33: draw_type33();break;
      case 34: draw_type34();break;
      case 35: draw_type35();break;
      case 36: draw_type36();break;
      case 37: draw_type37();break;
      case 38: draw_type38();break;
      
      case 39: draw_type39();break;
      case 40: draw_type40();break;
      case 41: draw_type41();break;
    }
  }
  
  public void draw_type0() {
    noFill();
    //if (crecy_internalCounter == 4) {
    //  colorMode(HSB);
    //  stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    //}
    //else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    //}
    strokeWeight(4);
    pushMatrix();
    translate(0,0);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type1() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    //translate(width/NUMBER_OF_PANELS,0);
    translate(0,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type2() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type3() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type4() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(2*width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type5() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(3*width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type6() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(3*width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }

  public void draw_type7() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(4*width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }

  public void draw_type8() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(4*width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }

  public void draw_type9() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(2*width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS - 4) {
      switch(direction) {
        case 0:line(progress*4 + 2, 2, progress*4 + 2, height/2-2);break;
        case 1:line(width/NUMBER_OF_PANELS - progress*4 - 2, 2, width/NUMBER_OF_PANELS - progress*4 - 2, height/2-2);break;
        case 2:line(2, progress*4 + 2, width/NUMBER_OF_PANELS-2, progress*4 + 2);break;
        case 3:line(2, height/2 - progress*4 - 2, width/NUMBER_OF_PANELS-2, height/2 - progress*4 - 2);break;
      }
    }
    popMatrix();
    progress += 1;
  }  
  
  
  ////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////
  
  public void draw_type10() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,0);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type11() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type12() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type13() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type14() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(2*width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type15() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(2*width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  
  public void draw_type16() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(3*width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type17() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(3*width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }

  public void draw_type18() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(4*width/NUMBER_OF_PANELS,0);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }
  
  public void draw_type19() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(4*width/NUMBER_OF_PANELS,height/2);
    if (progress*4 < width/NUMBER_OF_PANELS) { 
      rect(width/(2*NUMBER_OF_PANELS) - progress*2,height/4 - progress*2, progress*4, progress*4);
    }
    else if (progress*4 <= 2*width/NUMBER_OF_PANELS) {
      line(0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS),0);
      line(width/NUMBER_OF_PANELS,0,(progress*4 - width/NUMBER_OF_PANELS),0);
      line(0,0,0,width/NUMBER_OF_PANELS-(progress*4 - width/NUMBER_OF_PANELS));
      line(0,height/2,0,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,height/2,(progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(0,height/2,width/NUMBER_OF_PANELS - (progress*4 - width/NUMBER_OF_PANELS),height/2);
      line(width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS,(progress*4 - width/NUMBER_OF_PANELS));
      line(width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height/2 - (progress*4 - width/NUMBER_OF_PANELS));
    }
    popMatrix();
    progress += 1; 
  }  
  
  ////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////
  
  public void draw_type20() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(8);
    if (height - progress*8 >= 0) {
      line(width/(NUMBER_OF_PANELS*2),height,width/(NUMBER_OF_PANELS*2),height - progress*8);
      line((NUMBER_OF_PANELS*2-1)*width/(NUMBER_OF_PANELS*2),0,(NUMBER_OF_PANELS*2-1)*width/(NUMBER_OF_PANELS*2), progress*8);
    }
    else {
      line(width/(NUMBER_OF_PANELS*2),-4,width/(NUMBER_OF_PANELS*2),2*height - progress*8);
      line((NUMBER_OF_PANELS*2-1)*width/(NUMBER_OF_PANELS*2),height+4,(NUMBER_OF_PANELS*2-1)*width/(NUMBER_OF_PANELS*2), progress*8 - height);
    }
    progress += 1;
  }
  
  public void draw_type21() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(8);
    if (width/NUMBER_OF_PANELS - progress*4 >= 0) {
      line(width/NUMBER_OF_PANELS-6, 0, width/NUMBER_OF_PANELS - progress*4 - 8, 0);
      line(width/NUMBER_OF_PANELS-6, height/2, width/NUMBER_OF_PANELS - progress*4 - 8, height/2);
      line(width/NUMBER_OF_PANELS-6, height, width/NUMBER_OF_PANELS - progress*4 - 8, height);
    }
    else if (2*width/NUMBER_OF_PANELS - progress*4 >= 0) {
      line(-6, 0, 2*width/NUMBER_OF_PANELS - progress*4, 0);
      line(-6, height/2, 2*width/NUMBER_OF_PANELS - progress*4, height/2);
      line(-6, height, 2*width/NUMBER_OF_PANELS - progress*4, height);
    }
    progress += 1;
  }
  
  public void draw_type22() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(8);
    if (width/3 - progress*4 >= 0) {
      line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS+6, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + progress*4 + 8, 0);
      line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS+6, height/2, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + progress*4 + 8, height/2);
      line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS+6, height, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + progress*4 + 8, height);
    }
    //This condition is not to be replaced by (NUMBER_OF_PANELS-1)*width ! 
    else if (2*width/NUMBER_OF_PANELS - progress*4 >= 0) {
      line(width+6, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*4, 0);
      line(width+6, height/2, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*4, height/2);
      line(width+6, height, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*4, height);
    }
    progress += 1;
  }
  

  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////

  
  
  public void draw_type23() {
    noStroke();
    pushMatrix();
    translate(0,0);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type24() {
    noStroke();
    pushMatrix();
    translate(0,height/2);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type25() {
    noStroke();
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,0);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }

  
  public void draw_type26() {
    noStroke();
    pushMatrix();
    translate(width/NUMBER_OF_PANELS,height/2);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }

  
  public void draw_type27() {
    noStroke();
    pushMatrix();
    translate(2*width/NUMBER_OF_PANELS,0);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type28() {
    noStroke();
    pushMatrix();
    translate(2*width/NUMBER_OF_PANELS,height/2);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }
  
  public void draw_type29() {
    noStroke();
    pushMatrix();
    translate(3*width/NUMBER_OF_PANELS,0);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }

  public void draw_type30() {
    noStroke();
    pushMatrix();
    translate(3*width/NUMBER_OF_PANELS,height/2);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }

  public void draw_type31() {
    noStroke();
    pushMatrix();
    translate(4*width/NUMBER_OF_PANELS,0);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }

  public void draw_type32() {
    noStroke();
    pushMatrix();
    translate(4*width/NUMBER_OF_PANELS,height/2);
    if (direction <= 2) {
      fill(crecy_red, crecy_green, crecy_blue, max(0,255-progress*20));
      rect(0,0,width/NUMBER_OF_PANELS,height/2);
    }
    else {
      if ((progress % 4 == 0 || progress % 4 == 1) && progress < 12) {
        if (crecy_internalCounter == 4) {
//          colorMode(HSB);
//          fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        else {
          colorMode(RGB);
          fill(crecy_red, crecy_green, crecy_blue);
        }
        rect(0,0,width/NUMBER_OF_PANELS,height/2);
      }
      else {
        fill(0);
        rect(0,0,width/NUMBER_OF_PANELS,height/2); 
      }
    }
    popMatrix();
    progress += 1;
  }  
  
  //////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////

  public void draw_type33() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,2);
    if (width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(width/NUMBER_OF_PANELS - 2, 0, width/NUMBER_OF_PANELS - 2 - progress*8, 0);
      }
      else {
        line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2 + progress*8, 0);
      }
    }
    else if (2*width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(0, 0, 2*width/NUMBER_OF_PANELS - progress*8 - 2, 0);
      }
      else {
        line(width, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*8 + 2, 0);
      }
    }
    popMatrix();
    
    if (NUMBER_OF_PANELS >=5) {
      line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + 2, height - progress*8, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS - 2, height - progress*8);
    }
    progress += 1;
  }
  
  public void draw_type34() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,2+height/5);
    if (width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(width/NUMBER_OF_PANELS - 2, 0, width/NUMBER_OF_PANELS - 2 - progress*8, 0);
      }
      else {
        line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2 + progress*8, 0);
      }
    }
    else if (2*width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(0, 0, 2*width/NUMBER_OF_PANELS - progress*8 - 2, 0);
      }
      else {
        line(width, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*8 + 2, 0);
      }
    }
    popMatrix();
    
    if (NUMBER_OF_PANELS >=5) {
      line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + 2, height - progress*8, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS - 2, height - progress*8);
    }
    progress += 1;
  }
  
  public void draw_type35() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,2+2*height/5);
    if (width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(width/NUMBER_OF_PANELS - 2, 0, width/NUMBER_OF_PANELS - 2 - progress*8, 0);
      }
      else {
        line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2 + progress*8, 0);
      }
    }
    else if (2*width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(0, 0, 2*width/NUMBER_OF_PANELS - progress*8 - 2, 0);
      }
      else {
        line(width, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*8 + 2, 0);
      }
    }
    popMatrix();
    
    if (NUMBER_OF_PANELS >=5) {
      line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + 2, height - progress*8, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS - 2, height - progress*8);
    }
    progress += 1;
  }

  public void draw_type36() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,2+3*height/5);
    if (width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(width/NUMBER_OF_PANELS - 2, 0, width/NUMBER_OF_PANELS - 2 - progress*8, 0);
      }
      else {
        line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2 + progress*8, 0);
      }
    }
    else if (2*width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(0, 0, 2*width/NUMBER_OF_PANELS - progress*8 - 2, 0);
      }
      else {
        line(width, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*8 + 2, 0);
      }
    }
    popMatrix();
    
    if (NUMBER_OF_PANELS >=5) {
      line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + 2, height - progress*8, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS - 2, height - progress*8);
    }
    progress += 1;
  }  
  
  
  public void draw_type37() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,2+4*height/5);
    if (width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(width/NUMBER_OF_PANELS - 2, 0, width/NUMBER_OF_PANELS - 2 - progress*8, 0);
      }
      else {
        line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2 + progress*8, 0);
      }
    }
    else if (2*width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(0, 0, 2*width/NUMBER_OF_PANELS - progress*8 - 2, 0);
      }
      else {
        line(width, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*8 + 2, 0);
      }
    }
    popMatrix();
    
    if (NUMBER_OF_PANELS >=5) {
      line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + 2, height - progress*8, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS - 2, height - progress*8);
    }
    progress += 1;
  }
  
  public void draw_type38() {
    noFill();
    if (crecy_internalCounter == 4) {
      colorMode(HSB);
      stroke(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    }
    else {
      colorMode(RGB);
      stroke(crecy_red, crecy_green, crecy_blue);
    }
    strokeWeight(4);
    pushMatrix();
    translate(0,-2+height);
    if (width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(width/NUMBER_OF_PANELS - 2, 0, width/NUMBER_OF_PANELS - 2 - progress*8, 0);
      }
      else {
        line((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2, 0, (NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS + 2 + progress*8, 0);
      }
    }
    else if (2*width/NUMBER_OF_PANELS - progress*8 >= 0) {
      if (direction == 0 || direction == 1) {
        line(0, 0, 2*width/NUMBER_OF_PANELS - progress*8 - 2, 0);
      }
      else {
        line(width, 0, (NUMBER_OF_PANELS-2)*width/NUMBER_OF_PANELS + progress*8 + 2, 0);
      }
    }
    popMatrix();
    
    if (NUMBER_OF_PANELS >=5) {
      line(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS + 2, height - progress*8, ((NUMBER_OF_PANELS-1)/2 + 1)*width/NUMBER_OF_PANELS - 2, height - progress*8);
    }
    progress += 1;
  }
  
  /////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////
  
  public void draw_type39() {
    //colorMode(HSB);
    //fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    fill(crecy_red, crecy_green, crecy_blue);
    noStroke();
    rect(0, height - progress*8, width/NUMBER_OF_PANELS, height);
    progress += 1;
  }
  
  public void draw_type40() {
    //colorMode(HSB);
    //fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    fill(crecy_red, crecy_green, crecy_blue);
    noStroke();
    rect((NUMBER_OF_PANELS-1)*width/NUMBER_OF_PANELS, height - progress*8, width/NUMBER_OF_PANELS, height);
    progress += 1;
  }
  
  public void draw_type41() {
    //colorMode(HSB);
    //fill(crecy_colorcounter % 255, min(255, 255 - parallelworlds_flashpower), 255);
    fill(crecy_red, crecy_green, crecy_blue);
    noStroke();
    rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS, height - progress*8, width/NUMBER_OF_PANELS, height);
    progress += 1;
  }
  
  public boolean isDead() {
    if (progress >= maxProgress) {
      return true;
    }
    else {
      return false;
    }
  }
}

//////////////////////////////////////////
// Specific actions for the Snake animation
//////////////////////////////////////////

public void draw_snake1() {
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  snake_instance1.drawSnake();
  snake_instance1.moveSnake();
  snake_instance2.moveSnake();
  snake_instance3.moveSnake();
  snake_instance4.moveSnake();
  snake_instance5.moveSnake();
  snake_instance6.moveSnake();
}

public void draw_snake2() {
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  snake_instance1.drawSnake();
  snake_instance1.moveSnake();
  snake_instance2.drawSnake();
  snake_instance2.moveSnake();
  snake_instance3.moveSnake();
  snake_instance4.moveSnake();
  snake_instance5.moveSnake();
  snake_instance6.moveSnake();
  
}

public void draw_snake3() {
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  snake_instance1.drawSnake();
  snake_instance1.moveSnake();
  snake_instance2.drawSnake();
  snake_instance2.moveSnake();
  snake_instance3.drawSnake();
  snake_instance3.moveSnake();
  snake_instance4.moveSnake();
  snake_instance5.moveSnake();
  snake_instance6.moveSnake();
  
}

public void draw_snake4() {
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  snake_instance1.drawSnake();
  snake_instance1.moveSnake();
  snake_instance2.drawSnake();
  snake_instance2.moveSnake();
  snake_instance3.drawSnake();
  snake_instance3.moveSnake();
  snake_instance4.drawSnake();
  snake_instance4.moveSnake();
  snake_instance5.moveSnake();
  snake_instance6.moveSnake();
  
}

public void draw_snake5() {
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  snake_instance1.drawSnake();
  snake_instance1.moveSnake();
  snake_instance2.drawSnake();
  snake_instance2.moveSnake();
  snake_instance3.drawSnake();
  snake_instance3.moveSnake();
  snake_instance4.drawSnake();
  snake_instance4.moveSnake();
  snake_instance5.drawSnake();
  snake_instance5.moveSnake();
  snake_instance6.moveSnake();
  
}

public void draw_snake6() {
  noStroke();
  fill(0,10);
  rect(0,0,width,height);
  snake_instance1.drawSnake();
  snake_instance1.moveSnake();
  snake_instance2.drawSnake();
  snake_instance2.moveSnake();
  snake_instance3.drawSnake();
  snake_instance3.moveSnake();
  snake_instance4.drawSnake();
  snake_instance4.moveSnake();
  snake_instance4.drawSnake();
  snake_instance5.moveSnake();
  snake_instance6.drawSnake();
  snake_instance6.moveSnake();
  
}


public ArrayList<SnakeObjective> snake_findObjectives(SnakeObjective currentLocation, SnakeObjective previousLocation) {
  ArrayList<SnakeObjective> candidates = new ArrayList<SnakeObjective>();
  for (SnakeObjective candidate: snake_objectives) {
    int deltaX = candidate.x - currentLocation.x;
    int deltaY = candidate.y - currentLocation.y;
    //Filter the objectives which are closest to the currentLocation, and yet different from the previous objective
    if ((deltaX != 0 && deltaY != 0) == false) {
      if ((deltaX == 0 && deltaY == 0) == false) {
        if ((candidate.x == previousLocation.x && candidate.y == previousLocation.y) == false) {
          if ((abs(deltaX) >= width/NUMBER_OF_PANELS || abs(deltaY) >= height/2) == false) { 
            candidates.add(candidate);
          }
        }
      }
    } 
  }
  
  return candidates;
}

class Snake {
 
  SnakeObjective nextObjective;
  SnakeObjective previousObjective;
  int x;
  int y;
  int prevX;
  int prevY;
  int speed;
  boolean red;
  
  Snake(int _speed, boolean _red) {
    nextObjective = snake_objectives.get(PApplet.parseInt(random(snake_objectives.size())));
    previousObjective = nextObjective;
    x = nextObjective.x;
    y = nextObjective.y;
    prevX = x;
    prevY = y; 
    speed = _speed;
    red = _red;
  }
  
  public void drawSnake() {
    pushStyle();
    strokeWeight(snake_weight);
    if (red == true) {
      stroke(255,255*noise(0.02f*frameCount),255*noise(0.02f*frameCount));
    }
    else {
      stroke(255*noise(0.02f*frameCount),255*noise(0.02f*frameCount),255);
    }
    line(this.prevX,this.prevY,this.x,this.y);
    popStyle();
  }
  
  public void moveSnake() {
    prevX = x;
    prevY = y;
    int deltaX = nextObjective.x - x;
    int deltaY = nextObjective.y - y;
    if (deltaX > 0) {this.x += this.speed;}
    if (deltaX < 0) {this.x -= this.speed;}
    if (deltaY > 0) {this.y += this.speed;}
    if (deltaY < 0) {this.y -= this.speed;}
    
    if (nextObjective.x == x && nextObjective.y == y) {
      ArrayList<SnakeObjective> candidates = snake_findObjectives(this.nextObjective, this.previousObjective);
      this.previousObjective = this.nextObjective;
      this.nextObjective = candidates.get(PApplet.parseInt(random(candidates.size())));
    }
  }   
} 

class SnakeObjective {
  
  int x;
  int y;
  
  SnakeObjective(int _x, int _y) {
    x = _x;
    y = _y;
  } 
}

public void snake_specialInit() {
  snake_objectives = new ArrayList<SnakeObjective>();
  int margin = snake_weight/2;
  snake_objectives.add(new SnakeObjective(margin,margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS - margin,margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS + margin,margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS - margin,margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS + margin,margin));
  snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS - margin,margin));
  snake_objectives.add(new SnakeObjective(margin, height/2 - margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS - margin, height/2 - margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS + margin, height/2 - margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS - margin, height/2 - margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS + margin, height/2 - margin));
  snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS - margin, height/2 - margin));
  snake_objectives.add(new SnakeObjective(margin, height/2 + margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS - margin, height/2 + margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS + margin, height/2 + margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS - margin, height/2 + margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS + margin, height/2 + margin));
  snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS - margin, height/2 + margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS - margin, height - margin));
  snake_objectives.add(new SnakeObjective(width/NUMBER_OF_PANELS + margin, height - margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS - margin, height - margin));
  snake_objectives.add(new SnakeObjective(2*width/NUMBER_OF_PANELS + margin, height - margin));
  snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS - margin, height - margin));
  
  if (NUMBER_OF_PANELS == 5) {
    snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS + margin, margin));
    snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS + margin, height/2 - margin));
    snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS + margin, height/2 + margin));
    snake_objectives.add(new SnakeObjective(3*width/NUMBER_OF_PANELS + margin, height - margin));
    
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS - margin, margin));
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS - margin, height/2 - margin));
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS - margin, height/2 + margin));
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS - margin, height - margin));

    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS + margin, margin));
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS + margin, height/2 - margin));
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS + margin, height/2 + margin));
    snake_objectives.add(new SnakeObjective(4*width/NUMBER_OF_PANELS + margin, height - margin));

    snake_objectives.add(new SnakeObjective(5*width/NUMBER_OF_PANELS - margin, margin));
    snake_objectives.add(new SnakeObjective(5*width/NUMBER_OF_PANELS - margin, height/2 - margin));
    snake_objectives.add(new SnakeObjective(5*width/NUMBER_OF_PANELS - margin, height/2 + margin));
    snake_objectives.add(new SnakeObjective(5*width/NUMBER_OF_PANELS - margin, height - margin));    
  }
}

//////////////////////////////////////////
// Specific actions for the SweepingBallsAndArrows animation
//////////////////////////////////////////

public void draw_sweepingBallsAndArrow() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
  
  for (SweeperBall ball: sweeperBalls_list) {
    ball.drawBall();
    ball.moveBall();
  }
  for (SweeperBall ball: sweeperBalls_list) {
    if (ball.isDead() == true) {
      sweeperBalls_list.remove(ball);
      break;
    }
  }
  fill(0);
  noStroke();
  rect(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS,height);
  
  for (DoubleArrow arrow: sweeperBalls_listarrow) {
    arrow.drawArrow();
  }
  for (DoubleArrow arrow: sweeperBalls_listarrow) {
    if (arrow.isDead() == true) {
      sweeperBalls_listarrow.remove(arrow);
      break;
    }
  }  
}

class SweeperBall {

  float x;
  float y;
  float dx;
  float dy;
  float size;
  float ballcolor;
  
  SweeperBall() {
    this.size = random(sweeperBalls_minBallSize, sweeperBalls_maxBallSize);
    if (random(1) > 0.5f) {
      this.x = random(width/3);
    }
    else {
      this.x = 2*width/3 + random(width/3);
    }
    this.y = random(height + this.size, height + this.size + height/2);
    this.dx = random(- sweeperBalls_initSpeedVar, sweeperBalls_initSpeedVar);
    this.dy = random(sweeperBalls_initSpeed - sweeperBalls_initSpeedVar, sweeperBalls_initSpeed + sweeperBalls_initSpeedVar);
    this.ballcolor = random(150,255);
  } 
  
  public void drawBall() {
    fill(this.ballcolor);
    ellipse(this.x, this.y, this.size, this.size);
    
  }
  
  public void moveBall() {
    x -= dx;
    y -= dy;
    dx -= sweeperBalls_randomAccel;
    dy -= sweeperBalls_randomAccel;
  }
  
  public boolean isDead() {
    if (this.y < -height) {
      return true;
    }
    else {
      return false;
    }
  }
}

class DoubleArrow {
  float progress;
  int arrowcolor;
  
  DoubleArrow() {
    progress = 0;
    if (sweeperBalls_arrowcolor) {
      arrowcolor = 255;
    }
    else {
      arrowcolor = 0;
    }
    sweeperBalls_arrowcolor = !sweeperBalls_arrowcolor;
  }
  
  public void drawArrow() {
    stroke(255,255-arrowcolor,255-arrowcolor);
    strokeWeight(8);
    beginShape();
    vertex(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS+4, progress + 4 - width/(2*NUMBER_OF_PANELS));
    vertex(width/2, progress);
    vertex(((NUMBER_OF_PANELS-1)/2+1)*width/NUMBER_OF_PANELS-4, progress + 4 - width/(2*NUMBER_OF_PANELS));
    endShape();
    
    beginShape();
    vertex(((NUMBER_OF_PANELS-1)/2)*width/NUMBER_OF_PANELS+4, height - (progress + 4 - width/(2*NUMBER_OF_PANELS)));
    vertex(width/2, height - (progress));
    vertex(((NUMBER_OF_PANELS-1)/2+1)*width/NUMBER_OF_PANELS-4, height - (progress + 4 - width/(2*NUMBER_OF_PANELS)));
    endShape();  
    progress += sweeperBalls_arrowSpeed;
  }
  
  public boolean isDead() {
    if (this.progress > 3*height/2) {
      return true;
    }
    else {
      return false;
    }
  }

}

//////////////////////////////////////////
// Specific actions for the RotatingHalfCircle animation
//////////////////////////////////////////

public void draw_rotatingHalfCircle() {
  fill(0);
  noStroke();
  rect(0,0,width,height);
 
  translate(width/2, height/2);
   
  for (int i=0; i<rotatingHalfCircle_num; i++) {
    rotatingHalfCircle_transparency = map(sin(rotatingHalfCircle_theta+(TWO_PI/rotatingHalfCircle_num)*i), -1, 1, 0, 110);
    rotatingHalfCircle_size = map(sin(rotatingHalfCircle_theta+(TWO_PI/rotatingHalfCircle_num)*i), -1, 1, width/10, width/5);
    rotatingHalfCircle_corner = map(sin(rotatingHalfCircle_theta+(TWO_PI/rotatingHalfCircle_num)*i), -1, 1, rotatingHalfCircle_size, 0);
    fill(0xffE80004, rotatingHalfCircle_transparency);
    pushMatrix();
    rotate(i*(TWO_PI/rotatingHalfCircle_num));
    rotatingHalfCircle_x = map(sin(rotatingHalfCircle_theta), -1, 1, 0, width/6);
    rect(rotatingHalfCircle_x, width/6, 1.8f*rotatingHalfCircle_size, rotatingHalfCircle_size, rotatingHalfCircle_corner);
    popMatrix();
  }
  rotatingHalfCircle_theta += 0.0523f;
 
}

//////////////////////////////////////////
// Specific actions for the PeriodicNoise animation
//////////////////////////////////////////

public void draw_periodicNoise() {
  noStroke();
  for (int i = 0; i<width; i+=4) {
    for (int j = 0; j<height; j+=4) {
      fill(255 - 192*noise((frameCount + i + j)*periodicNoise_noiseSpeed));
      rect(i,j,4,4);
    }
  }
}

//////////////////////////////////////////
// Specific actions for the Tumbler animation
//////////////////////////////////////////

public void draw_tumbler() {
  background(0);
  pushMatrix();
  pushStyle();
  rectMode(CENTER);
  fill(255);
  draw_tumblerLines(width/2, height/2,10);
  popStyle();
  popMatrix();
  tumbler_theta += 0.0523f;
}
 
public void draw_tumblerLines(int _x, int _y, int _n) {
  int num=_n;
  translate(_x, _y);
  pushMatrix();
  rotate(tumbler_r);
  for (int i=0; i<num; i++) {
    float w = map(sin(tumbler_theta+(TWO_PI/num*i)),-1,1,width*.1f,width*1.2f);
    float h = height/5;
    float x = 0;
    float y = -(num*h*1.5f/2)+i*h*1.5f;
    rect(x, y, w, h);
  }
  popMatrix();
  tumbler_r += 0.0523f/2;
}

//////////////////////////////////////////
// Specific actions for the DynamicAngleLines animation
//////////////////////////////////////////

public void draw_dynamicAngleLinesWhite() {
  draw_dynamicAngleLines(color(255));
}

public void draw_dynamicAngleLinesHalfRed() {
  draw_dynamicAngleLines(color(255), color(255,0,0));
}

public void draw_dynamicAngleLinesRed() {
  draw_dynamicAngleLines(color(255,0,0));
}

public void draw_dynamicAngleLines(int color1) {
  background(0);
  fill(color1);
  noStroke();
  pushMatrix();
  translate(width/2,height/2);
  rotate(dynamicAngleLines_angle);
  for (int i = 0; i < dynamicAngleLines_nbrLines; i++) {
    int x = PApplet.parseInt(random(-(width+height)/2, (width+height)/2));
    rect(x,-width-height, PApplet.parseInt(random(dynamicAngleLines_maxLineWidth)) , 2*(width+height));
  }
  popMatrix();
  
  if (dynamicAngleLines_positiveInc) {
    dynamicAngleLines_angle -= dynamicAngleLines_angleSpeed;
  }
  else {
    dynamicAngleLines_angle += dynamicAngleLines_angleSpeed;
  }
}

public void draw_dynamicAngleLines(int color1, int color2) {
  background(0);
  noStroke();
  pushMatrix();
  translate(width/2,height/2);
  rotate(dynamicAngleLines_angle);
  for (int i = 0; i < dynamicAngleLines_nbrLines; i++) {
    if (random(1) > 0.5f) {
      fill(color1);
    }
    else {
      fill(color2);
    }
    int x = PApplet.parseInt(random(-(width+height)/2, (width+height)/2));
    rect(x,-width-height, PApplet.parseInt(random(dynamicAngleLines_maxLineWidth)) , 2*(width+height));
  }
  popMatrix();
  
  if (dynamicAngleLines_positiveInc) {
    dynamicAngleLines_angle -= dynamicAngleLines_angleSpeed;
  }
  else {
    dynamicAngleLines_angle += dynamicAngleLines_angleSpeed;
  }
}

public void setup_dynamicAngleLines() {
  frameRate(25);
  colorMode(RGB);
  dynamicAngleLines_maxLineWidth = height/4;
  dynamicAngleLines_angle = dynamicAngleLines_angle + random(PI/3,2*PI/3);
  dynamicAngleLines_positiveInc = !dynamicAngleLines_positiveInc;
}


//////////////////////////////////////////
// Specific actions for the FauveRandomFlash animation
//////////////////////////////////////////


public void draw_fauveRandomFlash() {
  background(0);
  for (int i=0;i<NUMBER_OF_PANELS;i++) {
    fauveRandomFlash_drawBlurryEclipse(PApplet.parseInt(random(width)), PApplet.parseInt(random(-height/3,-height/8)), PApplet.parseInt(random(fauveRandomFlash_minEllipseSize,fauveRandomFlash_maxEllipseSize)),fauveRandomFlash_blueWhite);
  }
  for (int i=0;i<NUMBER_OF_PANELS;i++) {
    fauveRandomFlash_drawBlurryEclipse(PApplet.parseInt(random(width)), PApplet.parseInt(random(height,5*height/4)), PApplet.parseInt(random(fauveRandomFlash_minEllipseSize,fauveRandomFlash_maxEllipseSize)),fauveRandomFlash_red);
  }
  filter(BLUR,5);
}

public void fauveRandomFlash_drawBlurryEclipse(int x, int y, int size, int col) {
  fill(col);
  noStroke();
  ellipse(x,y,size,size);
}


//////////////////////////////////////////
// Specific actions for the BarWaves animation
//////////////////////////////////////////

public void draw_barWavesWhite() {
  barWaves_drawWaves(barWaves_colBlack,barWaves_colWhite);
}

public void draw_barWavesRed() {
  barWaves_drawWaves(barWaves_colRed1,barWaves_colRed2);
}

public void draw_barWavesBlue() {
  barWaves_drawWaves(barWaves_colBlue1,barWaves_colBlue2);
}

public void barWaves_initWaves() {     
  float barWaves_sc = 50;
  barWaves_time = random(1000);
  for (int i=0; i<barWaves_columns; i++) {
    barWaves_offSets[i]= noise(barWaves_sc*sin(barWaves_time), barWaves_sc*cos(barWaves_time))*height/2;
    barWaves_offTheta[i]= barWaves_ot;
    barWaves_ot += TWO_PI/barWaves_columns;
    barWaves_time += barWaves_speed;
  }
}
 
public void barWaves_drawWaves(int color1, int color2) {
 
  for (int i=0; i<barWaves_columns; i++) {
    barWaves_scal = map(sin(barWaves_theta+barWaves_offTheta[i]), -1, 1, 0.5f, 1.5f);
    float x=barWaves_stepX*(i+.5f);
    if (i%2==0) {
      float y = height/2 - barWaves_offSets[i]*barWaves_scal;
      stroke(color1);
      line(x, 0, x, y);
      stroke(color2);
      line(x, y, x, height);
    }
    else {
      float y = height/2 + barWaves_offSets[i]*barWaves_scal;
      stroke(color2);
      line(x, y, x, height);
      stroke(color1);
      line(x, 0, x, y);
    }
  }
  barWaves_theta -= barWaves_speed;
}

//////////////////////////////////////////
// Specific actions for the RedSun animation
//////////////////////////////////////////

public void draw_redSun() {
  pushStyle();
  strokeCap(SQUARE);
  randomSeed(redSun_rs);
  background(0);
  
  fill(255,0,0);
  noStroke();
  ellipse(width/2,height/2,redSun_internalCircleRadius,redSun_internalCircleRadius);
  redSun_internalCircleRadius += redSun_circleSpeed;
  if (redSun_internalCircleRadius > redSun_internalCircleLimitSize) {
    fill(0);
    ellipse(width/2,height/2,redSun_internalCircleRadius-redSun_internalCircleLimitSize,redSun_internalCircleRadius-redSun_internalCircleLimitSize);
  }
  
  noFill();
  stroke(0);
  strokeWeight(100);
  ellipse(width/2, height/2, redSun_szS*0.5f, redSun_szS*0.5f);
  strokeWeight(15);
  stroke(255);
  ellipse(width/2, height/2, width, width);
 
  redSun_angle=0;
  for (int i=0; i<redSun_num; i++) {
    redSun_szB = 1*width/2;
    float redSun_xo = width/2;
    float redSun_yo = height/2;
    float redSun_x = redSun_xo+sin(redSun_angle)*redSun_szB;
    float redSun_y = redSun_yo+cos(redSun_angle)*redSun_szB;
    strokeWeight(random(10, 15));
    stroke(255, 255, 255);
    point(redSun_x, redSun_y);
    PVector redSun_loc = new PVector(redSun_x, redSun_y);
    PVector redSun_center = new PVector(redSun_xo, redSun_yo);
    PVector redSun_dir = PVector.sub(redSun_center, redSun_loc);
    redSun_dir.normalize();
    float redSun_m = random(20, 30);
    float redSun_offSet = TWO_PI/redSun_num*i;
    float redSun_mu = map(sin(redSun_theta+redSun_offSet*3),-1,1,redSun_m,redSun_m/2);
    redSun_dir.mult(redSun_mu);
    line(redSun_loc.x, redSun_loc.y, redSun_loc.x+redSun_dir.x, redSun_loc.y+redSun_dir.y);
    strokeWeight(5);
    redSun_angle += (TWO_PI/redSun_num);
  }
  redSun_theta += 0.1f;
  popStyle();
}


//////////////////////////////////////////
// Specific actions for the SlicedWave animations
//////////////////////////////////////////

public void draw_slicedWaveWhite() {
  draw_slicedWave(slicedWave_white);
}

public void draw_slicedWaveRed() {
  draw_slicedWave(slicedWave_red);
}

public void draw_slicedWave(int sliceColor) {
  fill(0, 15);
  noStroke();
  rect(0,0,width, height);
  
  pushMatrix();
  translate(width/2,height/2);
  rotate(slicedWave_angle);
  
  stroke(sliceColor);
  noFill();
  slicedWave_c=0;
 
  for (int i=0; i<slicedWave_slices; i++) {
    slicedWave_sw = map(sin(slicedWave_theta+(TWO_PI/slicedWave_num)*slicedWave_c), -1, 1, height/40, height/5);
    for (int j=0; j<slicedWave_pieces; j++) {
      slicedWave_scal = map(sin(slicedWave_theta+(TWO_PI/slicedWave_num)*slicedWave_c), -1, 1, 1, 3);
 
      strokeWeight(slicedWave_sw);
      //arc(width/2, height/2, slicedWave_r[slicedWave_c]*slicedWave_scal, slicedWave_r[slicedWave_c]*slicedWave_scal, (TWO_PI/slicedWave_slices)*i, (TWO_PI/slicedWave_slices)*(i+.7));
      arc(0, 0, slicedWave_r[slicedWave_c]*slicedWave_scal, slicedWave_r[slicedWave_c]*slicedWave_scal, (TWO_PI/slicedWave_slices)*i, (TWO_PI/slicedWave_slices)*(i+.7f));
      slicedWave_c++;
    }
  }
  slicedWave_theta += 0.0523f;
  fill(sliceColor);
  noStroke();
  ellipse(0, 0, height/8, height/8);
  popMatrix();
  if(slicedWave_angleStock > 0) {
    slicedWave_angle += slicedWave_rotSpeed;
    slicedWave_angleStock -= 1;
  }
  
}



////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

public void draw_dirtyAudioProcessing() {
  
  //Reset old flags according to the current system time
  invalidateOutdatedImpulseFlags();
  
  background(0);
  stroke(255);
  strokeWeight(4);
  float signalLevelGain = 1000;
//  for (int i=1; i<=audioInputBuffer_Kick.size()/4; i++) {
//    float sample = audioInputBuffer_Kick.get(audioInputBuffer_Kick.size()-i);
//    line(i*4, height/2, i*4, height/2 + sample*signalLevelGain);
//    line(i*4, height/2, i*4, height/2 - sample*signalLevelGain);
//  }

  for (int i=1; i<=min(height/4,audioInputBuffer_Kick.size()); i++) {
    float sample = audioInputBuffer_Kick.get(audioInputBuffer_Kick.size()-i);
    line(width/(2*NUMBER_OF_PANELS), i*4, width/(2*NUMBER_OF_PANELS) + min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
    line(width/(2*NUMBER_OF_PANELS), i*4, width/(2*NUMBER_OF_PANELS) - min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
  }

  stroke(255,180,180);
  for (int i=1; i<=min(height/4,audioInputBuffer_Kick.size()); i++) {
    float sample = audioInputBuffer_Cymbals.get(audioInputBuffer_Cymbals.size()-i);
    line(3*width/(2*NUMBER_OF_PANELS), i*4, 3*width/(2*NUMBER_OF_PANELS) + min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
    line(3*width/(2*NUMBER_OF_PANELS), i*4, 3*width/(2*NUMBER_OF_PANELS) - min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
  }

  stroke(255,80,80);
  for (int i=1; i<=min(height/4,audioInputBuffer_Kick.size()); i++) {
    float sample = audioInputBuffer_Bass.get(audioInputBuffer_Bass.size()-i);
    line((2*NUMBER_OF_PANELS - 3)*width/(2*NUMBER_OF_PANELS), i*4, (2*NUMBER_OF_PANELS - 3)*width/(2*NUMBER_OF_PANELS) + min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
    line((2*NUMBER_OF_PANELS - 3)*width/(2*NUMBER_OF_PANELS), i*4, (2*NUMBER_OF_PANELS - 3)*width/(2*NUMBER_OF_PANELS) - min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
  }
  
  stroke(255,0,0);
  for (int i=1; i<=min(height/4,audioInputBuffer_Kick.size()); i++) {
    float sample = audioInputBuffer_Snare.get(audioInputBuffer_Snare.size()-i);
    line((2*NUMBER_OF_PANELS - 1)*width/(2*NUMBER_OF_PANELS), i*4, (2*NUMBER_OF_PANELS - 1)*width/(2*NUMBER_OF_PANELS) + min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
    line((2*NUMBER_OF_PANELS - 1)*width/(2*NUMBER_OF_PANELS), i*4, (2*NUMBER_OF_PANELS - 1)*width/(2*NUMBER_OF_PANELS) - min(sample*signalLevelGain, width/(2*NUMBER_OF_PANELS)), i*4);
  }
  
  if (impulse_Kick == true)    {uglyImpulseKickList.add(new UglyImpulseKick());}
  if (impulse_Snare == true)   {uglyImpulseSnareList.add(new UglyImpulseSnare());}
  if (impulse_Cymbals == true) {uglyImpulseCymbalList.add(new UglyImpulseCymbal());}
  if (impulse_Bass == true)    {uglyImpulseBassList.add(new UglyImpulseBass());}
  
  for (UglyImpulseKick uglyImpulseKick: uglyImpulseKickList) {
    uglyImpulseKick.drawLine();
  }
  
  for (UglyImpulseKick uglyImpulseKick: uglyImpulseKickList) {
    if (uglyImpulseKick.y > height) {
      uglyImpulseKickList.remove(uglyImpulseKick);
      break;
    }
  }
  
  for (UglyImpulseSnare uglyImpulseSnare: uglyImpulseSnareList) {
    uglyImpulseSnare.drawLine();
  }
  
  for (UglyImpulseSnare uglyImpulseSnare: uglyImpulseSnareList) {
    if (uglyImpulseSnare.y > height) {
      uglyImpulseSnareList.remove(uglyImpulseSnare);
      break;
    }
  }
  
  for (UglyImpulseCymbal uglyImpulseCymbal: uglyImpulseCymbalList) {
    uglyImpulseCymbal.drawLine();
  }
  
  for (UglyImpulseCymbal uglyImpulseCymbal: uglyImpulseCymbalList) {
    if (uglyImpulseCymbal.y > height) {
      uglyImpulseCymbalList.remove(uglyImpulseCymbal);
      break;
    }
  }
  
  for (UglyImpulseBass uglyImpulseBass: uglyImpulseBassList) {
    uglyImpulseBass.drawLine();
  }
  
  for (UglyImpulseBass uglyImpulseBass: uglyImpulseBassList) {
    if (uglyImpulseBass.y > height) {
      uglyImpulseBassList.remove(uglyImpulseBass);
      break;
    }
  }
  
  //Reset all the impulse flags, as they have been processed
  impulseMessageProcessed = true;
}

class UglyImpulseKick {
  int y;  
  UglyImpulseKick() {
    y = 0;
  }
  public void drawLine() {
    stroke(255);
    strokeWeight(4);
    line(2*width/NUMBER_OF_PANELS, y, (NUMBER_OF_PANELS - 2)*width/NUMBER_OF_PANELS, y);
    y += 8;
  }
}

class UglyImpulseSnare {
  int y;  
  UglyImpulseSnare() {
    y = 0;
  }
  public void drawLine() {
    stroke(255,180,180);
    fill(255,180,180);
    strokeWeight(4);
    ellipse(width/2,y,12,12);
    y += 8;
  }
}

class UglyImpulseCymbal {
  int y;  
  UglyImpulseCymbal() {
    y = 0;
  }
  public void drawLine() {
    stroke(255,80,80);
    fill(255,80,80);
    strokeWeight(4);
    ellipse(width/2 - 16,y,8,8);
    y += 8;
  }
}

class UglyImpulseBass {
  int y;  
  UglyImpulseBass() {
    y = 0;
  }
  public void drawLine() {
    stroke(255,0,0);
    fill(255,0,0);
    strokeWeight(4);
    ellipse(width/2 + 16,y,8,8);
    y += 8;
  }
}

//////////////////////////////////////////
// Specific actions for the HypnoAudio animation
//////////////////////////////////////////

public void draw_hypnoAudio() {
  
  //Reset old flags according to the current system time
  invalidateOutdatedImpulseFlags();
  
  if (hypnoAudio_listenToAudio == true) {
    if (impulse_Kick) {
      hypnoAudio_currentPoint = (hypnoAudio_currentPoint + 1)%hypnoAudio_coordinates.length;
    }
    if (impulse_Snare) {
      hypnoAudio_redImpact = 255;
    }
  }
  
  pushMatrix();
  background(0);
  translate(width/2, height/2);
  for (int i = 0; i < 360; i+=6) {
    for (int q = 0; q < 18*3; q+=18) {
      if (q == 18*2) {
        stroke(255, 255 - hypnoAudio_redImpact, 255 - hypnoAudio_redImpact);
      }
      else {
        stroke(255);
      }
      
      float x = map(sin(radians(q+i+frameCount))*i, -hypnoAudio_currentCoordinates[0]*width, hypnoAudio_currentCoordinates[1]*height, i, -i);
      float y = map(cos(radians(q+i+frameCount))*i, -hypnoAudio_currentCoordinates[0]*width, hypnoAudio_currentCoordinates[1]*height, -i, i);
      
      float x2 = map(sin(radians(q+i+6+frameCount))*(i+6), -hypnoAudio_currentCoordinates[0]*width, hypnoAudio_currentCoordinates[1]*height, i+6, -(i+6));
      float y2 = map(cos(radians(q+i+6+frameCount))*(i+6), -hypnoAudio_currentCoordinates[0]*width, hypnoAudio_currentCoordinates[1]*height, -(i+6), i+6);
      line(x, y, x2, y2);
      line(-x, -y, -x2, -y2);
      
      line(y, x, y2, x2);
      line(-y, -x, -y2, -x2);
      
      line(x, -y, x2, -y2);
      line(-x, y, -x2, y2);
      
      line(y, -x, y2, -x2);
      line(-y, x, -y2, x2);
    }
  }
  popMatrix();
  
  // Easing towards the target coordinate
  for (int j = 0; j < 2; j++) {
    hypnoAudio_currentCoordinates[j] += (hypnoAudio_coordinates[hypnoAudio_currentPoint][j] - hypnoAudio_currentCoordinates[j]) * hypnoAudio_moveSpeed;
  }
  
  // Ease back towards white
  if (hypnoAudio_redImpact > 0) {
    hypnoAudio_redImpact -= hypnoAudio_colorAttenuation;
  }
  
  //Reset all the impulse flags, as they have been processed
  impulseMessageProcessed = true;
}

//////////////////////////////////////////
// Specific actions for the DisplayFFT animation
//////////////////////////////////////////

public void draw_displayFFT_bass() {
  background(0);
  fill(255);
  rect((width/12)*0,height - map(signalFFT_Bass.band1,0,8000,0,height), (width/12), height);
  rect((width/12)*1,height - map(signalFFT_Bass.band2,0,8000,0,height), (width/12), height);
  rect((width/12)*2,height - map(signalFFT_Bass.band3,0,8000,0,height), (width/12), height);
  rect((width/12)*3,height - map(signalFFT_Bass.band4,0,8000,0,height), (width/12), height);
  rect((width/12)*4,height - map(signalFFT_Bass.band5,0,8000,0,height), (width/12), height);
  rect((width/12)*5,height - map(signalFFT_Bass.band6,0,8000,0,height), (width/12), height);
  rect((width/12)*6,height - map(signalFFT_Bass.band7,0,8000,0,height), (width/12), height);
  rect((width/12)*7,height - map(signalFFT_Bass.band8,0,8000,0,height), (width/12), height);
  rect((width/12)*8,height - map(signalFFT_Bass.band9,0,8000,0,height), (width/12), height);
  rect((width/12)*9,height - map(signalFFT_Bass.band10,0,8000,0,height), (width/12), height);
  rect((width/12)*10,height - map(signalFFT_Bass.band11,0,8000,0,height), (width/12), height);
  rect((width/12)*11,height - map(signalFFT_Bass.band12,0,8000,0,height), (width/12), height);
}


//////////////////////////////////////////
// Specific actions for the SpiderWeb animation
//////////////////////////////////////////

public void spiderweb_init() {
  spiderWebPoints = new ArrayList<SpiderWebPoint>();
  for (int i=0; i<spiderweb_nbPoints; i++) {
    spiderWebPoints.add(new SpiderWebPoint());
  }
  for (SpiderWebPoint point: spiderWebPoints) {
    point.findFriends();
  }
}

public void draw_spiderwebs() {
  
  background(0);
  strokeWeight(3);
  noFill();
  
  if (spiderweb_color == SPIDERWEB_WHITE) {
    stroke(255);
  }
  else if (spiderweb_color == SPIDERWEB_RED) {
    stroke(255,0,0);
  }
  
  if (spiderweb_audioReactive) {
    
    //Reset old flags according to the current system time
    invalidateOutdatedImpulseFlags();
  
    if (impulse_Kick) {
      //Create a new environment
      spiderweb_init();
    }
    
    //Reset all the impulse flags, as they have been processed
    impulseMessageProcessed = true;
  }
  
  for (SpiderWebPoint point: spiderWebPoints) {
    point.drawLines();
  }
  
  if (spiderweb_fade) {
    fill(0, min(255, spiderweb_fadecpt));
    noStroke();
    rect(0,0,width,height);
    spiderweb_fadecpt += spiderweb_fadespeed;
  }
}

class SpiderWebPoint {
  int x;
  int y;
  
  int[][] closeFriends;
  
  SpiderWebPoint() {
    x = (int) random(-width/3,4*width/3);
    y = (int) random(-height/3,4*height/3);
    closeFriends = new int[spiderweb_maxFriends][2];
    //Initialize the list with rubbish
    for (int[] row: closeFriends) {
      Arrays.fill(row, 1000000);
    }
  }
  
  public void findFriends() {
    for (int i = 0; i<spiderWebPoints.size(); i++) {
      SpiderWebPoint point = spiderWebPoints.get(i);
      float squareDist = (x-point.x)*(x-point.x) + (y-point.y)*(y-point.y);
      
      for (int j = 0; j<spiderweb_maxFriends; j++) {
        // If the new possible friend is closer than the j point, insert it in its place and shift it
        if (closeFriends[j][1] > squareDist) {
          // Shift the previous values
          for (int k = spiderweb_maxFriends - 1; k > j; k--) {
            closeFriends[k] = closeFriends[k-1]; 
          }
          int[] newFriend = {i,(int)squareDist};
          closeFriends[j] = newFriend;
          break;
        }
      }
    }
  }
  
  public void drawLines() {
    for (int[] pointNb: closeFriends) {
      line(x, y, spiderWebPoints.get(pointNb[0]).x, spiderWebPoints.get(pointNb[0]).y);
    }
  }
  
}

//////////////////////////////////////////
// Specific actions for the Woublines animation
//////////////////////////////////////////

public void draw_woublines() {
  noStroke();
  fill(0,30);
  rect(0,0,width,height);
  stroke(255);
  
  if (woublines_audio) {
    
    //Reset old flags according to the current system time
    invalidateOutdatedImpulseFlags();
  
    if (impulse_Kick) {
      //Add a new line
      woublines_list.add(new WoubLine((int)random(4)));
    }
    
    //Set all the impulse flags to be reset at the end of the cycle, as they have been processed
    impulseMessageProcessed = true;
  }
  
  for (WoubLine line: woublines_list) {
    line.drawLine();
  }
  
  for (WoubLine line: woublines_list) {
    if (line.isDead()) {
      woublines_list.remove(line);
      break;
    }
  }
}

class WoubLine {
  
  int progress;
  int type;
  
  float y;
  float x;
  
  WoubLine(int _type) {
    progress = 0;
    type = _type;
  }
  
  public void drawLine() {
    y = ((height-progress)*(height-progress))/height;
    switch (type) {
      case 0:  x = width - progress*1.2f; stroke(255);      break;
      case 1:  x = width - progress*2;   stroke(255);      break;
      case 2:  x = width - progress*1.2f; stroke(255,0,0);  break;
      case 3:  x = width - progress*2;   stroke(255,0,0);  break;
      default: x = width;                stroke(255);      break;
    }
    line(width/2 - x, y, width/2 + x, y); 
    
    progress += woublines_speed;
  }
  
  public boolean isDead() {
    if (progress >= 2.5f*height) {
      return true;
    }
    else {
      return false;
    }
  }
}


//////////////////////////////////////////
// Specific actions for the Signal Waveform animation
//////////////////////////////////////////

public void draw_signalWaveform_white_kick() {
  stroke(255);
  draw_signalWaveform(audioInputBuffer_instantVal_Kick);
}

public void draw_signalWaveform_red_kick() {
  stroke(255,0,0);
  draw_signalWaveform(audioInputBuffer_instantVal_Kick);
}

public void draw_signalWaveform_white_snare() {
  stroke(255);
  draw_signalWaveform(audioInputBuffer_instantVal_Snare);
}

public void draw_signalWaveform_red_snare() {
  stroke(255,0,0);
  draw_signalWaveform(audioInputBuffer_instantVal_Snare);
}

public void draw_signalWaveform_white_cymbals() {
  stroke(255);
  draw_signalWaveform(audioInputBuffer_instantVal_Cymbals);
}

public void draw_signalWaveform_red_cymbals() {
  stroke(255,0,0);
  draw_signalWaveform(audioInputBuffer_instantVal_Cymbals);
}

public void draw_signalWaveform_white_bass() {
  stroke(255);
  draw_signalWaveform(audioInputBuffer_instantVal_Bass);
}

public void draw_signalWaveform_red_bass() {
  stroke(255,0,0);
  draw_signalWaveform(audioInputBuffer_instantVal_Bass);
}

public void draw_signalWaveform_white_keys() {
  stroke(255);
  draw_signalWaveform(audioInputBuffer_instantVal_Keys);
}

public void draw_signalWaveform_red_keys() {
  stroke(255,0,0);
  draw_signalWaveform(audioInputBuffer_instantVal_Keys);
}

public void draw_signalWaveform_white_guitar() {
  stroke(255);
  draw_signalWaveform(audioInputBuffer_instantVal_Guitar);
}

public void draw_signalWaveform_red_guitar() {
  stroke(255,0,0);
  draw_signalWaveform(audioInputBuffer_instantVal_Guitar);
}


public void draw_signalWaveform(CircularArrayList<Float> audioBuffer) {
  background(0);
  beginShape();
  for (int i=1; i<=min(width/4,audioBuffer.size()); i++) {
    float sample = audioBuffer.get(audioBuffer.size()-i);
    vertex(i*4, signalWaveForm_offsetY + audioBuffer.get(audioBuffer.size()-i));
  }
  endShape();
}

public void setup_signalWaveform() {
  strokeWeight(DISPLAY_SCALING_FACTOR);
  smooth();
  noFill();
  frameRate(50);
}


//////////////////////////////////////////
// Specific actions for the Simple Spiral animations
//////////////////////////////////////////

public void draw_simplespiral(int r, int g, int b) {
  background(0);
  pushMatrix();
  translate(width/2, height/2);
  for (int i=0; i<simplespiral_num; i++) {
    rotate(simplespiral_theta);
    stroke(r, g, b);
    arc(0, 0, width*1.2f-i*10, width*1.2f-i*10, 0, PI);
  }
  popMatrix();
  simplespiral_theta += PI/90;
}

//////////////////////////////////////////
// Specific actions for the Cathodic TV Off animations
//////////////////////////////////////////

public void draw_tvpoweroff() {
  background(0);  
  pushMatrix();
  translate(width/2,height/2);
  ellipse(0,0,max(0, 1.2f*width - tvpoweroff_progress), max(0,(1.2f*height - tvpoweroff_progress) / 4));
  ellipse(0,0,max(0, 0.2f*width - tvpoweroff_progress), max(0,(2.2f*height - tvpoweroff_progress) / 4));
  popMatrix();
  tvpoweroff_progress += tvpoweroff_speed;
  filter(BLUR,6);
}


//////////////////////////////////////////
// Specific actions for the WhiteSpread animation
//////////////////////////////////////////

public void draw_whitespread_start() {
  background(0);
  noStroke();
  fill(255);
  rect(width/2, 0, whitespread_progress, height);
  rect(width/2 - whitespread_progress, 0, whitespread_progress, height);
  whitespread_progress += whitespread_speed;
}

public void draw_whitespread_end() {
  background(0);
  noStroke();
  fill(255);
  rect(0, 0, width/2 - whitespread_progress, height);
  rect(width/2 + whitespread_progress, 0, width/2 - whitespread_progress, height);
  whitespread_progress += whitespread_speed;
}

//////////////////////////////////////////
// Specific actions for the ScannerLine animations
//////////////////////////////////////////

public void draw_scannerLine1_fastWhite() {
  draw_scannerLine1(scannerLine_FastSpeed, 255, 255, 255);
}

public void draw_scannerLine2_fastWhite() {
  draw_scannerLine2(scannerLine_FastSpeed, 255, 255, 255);
}

public void draw_scannerLine1_fastRed() {
  draw_scannerLine1(scannerLine_FastSpeed, 255, 0, 0);
}

public void draw_scannerLine2_fastRed() {
  draw_scannerLine2(scannerLine_FastSpeed, 255, 0, 0);
}

public void draw_scannerLine1_slowWhite() {
  draw_scannerLine1(scannerLine_SlowSpeed, 255, 255, 255);
}

public void draw_scannerLine2_slowWhite() {
  draw_scannerLine2(scannerLine_SlowSpeed, 255, 255, 255);
}

public void draw_scannerLine1_slowRed() {
  draw_scannerLine1(scannerLine_SlowSpeed, 255, 0, 0);
}

public void draw_scannerLine2_slowRed() {
  draw_scannerLine2(scannerLine_SlowSpeed, 255, 0, 0);
}

public void draw_scannerLine1(float speed, int r, int g, int b) {
  background(0,40);
  noFill();
  pushMatrix();
  translate(width/2,0);
  
  strokeWeight(8);
  stroke(r,g,b,255);
  line(scannerLine_progress - width/2,0, scannerLine_progress - width/2,height);
  
  //Draw the trail
  for (float factor = 1.1f; factor < 1.6f; factor += 0.08f) {
    strokeWeight(6*factor);
    stroke(r,g,b,255 - PApplet.parseInt(factor*30));  
    line(PApplet.parseInt(factor*(scannerLine_progress - width/2)),0, PApplet.parseInt(factor*(scannerLine_progress - width/2)),height);
  }

  popMatrix();
  scannerLine_progress += speed + (width/2 - scannerLine_progress)*(width/2 - scannerLine_progress)*scannerLine_SpeedVar;
}

public void draw_scannerLine2(float speed, int r, int g, int b) {
  background(0,40);
  noFill();
  pushMatrix();
  translate(width/2,0);
  
  strokeWeight(8);
  stroke(r,g,b,255);
  line(width/2 - scannerLine_progress,0, width/2 - scannerLine_progress,height);
  
  //Draw the trail
  for (float factor = 1.1f; factor < 1.6f; factor += 0.08f) {
    strokeWeight(6*factor);
    stroke(r,g,b,255 - PApplet.parseInt(factor*30));  
    line(PApplet.parseInt(factor*(width/2 - scannerLine_progress)),0, PApplet.parseInt(factor*(width/2 - scannerLine_progress)),height);
  }

  popMatrix();
  scannerLine_progress += speed + (width/2 - scannerLine_progress)*(width/2 - scannerLine_progress)*scannerLine_SpeedVar;  
}

//////////////////////////////////////////////////////////////////
// Register attributes to the animations, for better management //
//////////////////////////////////////////////////////////////////


//Arraylist of Attribute objects, one for every animation 
ArrayList<Attribute> animationAttributes;
//Arraylist of strings, containing the different existing attributes
StringList registeredAttributes;

//Same goes for custom devices actions 
ArrayList<Attribute> customDevicesAttributes;
StringList registeredAttributes_customDevices;

//And again for the DMX animations 
ArrayList<Attribute> DMXStrobeAttributes;
ArrayList<Attribute> DMXMovingHead_MovementAttributes;
ArrayList<Attribute> DMXMovingHead_ColorAttributes;
ArrayList<Attribute> DMXMovingHead_RhythmAttributes;
ArrayList<Attribute> DMXMovingHead_LightStyleAttributes;
ArrayList<Attribute> DMXMovingHead_AnimationAttributes;
ArrayList<Attribute> DMXOtherFixturesAttributes;
//StringList registeredAttributes_DMX;

//Register attributes to an animation, given its number, its name, and a list of attributes
public ArrayList<Attribute> registerAttribute(ArrayList<Attribute> attributesArray, int animationNbr, String attributeName, String[] attributeList) {
  boolean alreadyRegistered = false;

  for (Attribute animationAttr : attributesArray) {
    if (animationAttr.animationNbr == animationNbr) {
      alreadyRegistered = true;
      attributesArray.remove(animationAttr);
      break;
    } 
  }
  if (alreadyRegistered == true) {
    outputLog.println("--- Attributes already registed to animation no " + animationNbr + " - overwriting attributes");
  }
  String printattributes = "";
  for (int i = 0; i < attributeList.length; i++) {
    printattributes += attributeList[i] + ", ";
  }
  
  //outputLog.println("Registering attributes for animation #" + animationNbr + " -- " + printattributes);
  attributesArray.add(new Attribute(animationNbr, attributeName, attributeList));
  
  return attributesArray;
}

//Return a list of animation numbers, corresponding to animations matching all the specified attributes given as argument
public ArrayList<Attribute> filterAnimationsByAttributes(ArrayList<Attribute> attributesArray, String[] attributeList) {
  return filterAnimationsByAttributes(attributesArray, attributeList, new String[] {});
}

public ArrayList<Attribute> filterAnimationsByAttributes(ArrayList<Attribute> attributesArray, String[] attributeList, String[] unwantedAttributeList) {
  ArrayList<ArrayList<Attribute>> listsPerAttribute = new ArrayList<ArrayList<Attribute>>();
  for (int i = 0; i < attributeList.length; i++) {
    listsPerAttribute.add(new ArrayList<Attribute>());
  }
  for (int i = 0; i < attributeList.length; i++) {
    for (Attribute animation: attributesArray) {
      //Do not consider animations whose length is set as -1 : unfit for automatic mode
      if (animation.attributes.contains(attributeList[i])) {
        listsPerAttribute.get(i).add(animation);
      }
    }
  }
  ArrayList<Attribute> temp = new ArrayList<Attribute>();
  //It is only useful to check the first list (corresponding to the first specified attribute)
  //Only animations present in all of the lists shall be added to the final filtered list
  for (int i = 0; i < listsPerAttribute.get(0).size(); i++) {
    boolean allListsContainAnimation = true;
    for (int j = 0; j < listsPerAttribute.size(); j++) {
      boolean thisListContainsTheAnimation = false;
      for (Attribute animation: listsPerAttribute.get(j)) {
        if (animation.animationNbr == listsPerAttribute.get(0).get(i).animationNbr) {
          thisListContainsTheAnimation = true;
          break;
        }
      }
      allListsContainAnimation = allListsContainAnimation && thisListContainsTheAnimation;
    }
    if (allListsContainAnimation == true) {
      temp.add(listsPerAttribute.get(0).get(i));
    }
  }
  

  ArrayList<Attribute> temp2 = new ArrayList<Attribute>();
  //Check if the animations' attributes contain the unwanted attributes, and remove them
  //This is useful to remove animations coming from a set, in order not to consider them as individual animations
  if (unwantedAttributeList.length > 0) {
    //Limitation for now : only one attribute can be inside the unwanted attribute list
    String unwantedAttribute = unwantedAttributeList[0];
    for (int i = 0; i < temp.size(); i++) {
      Attribute animationFromTempList = temp.get(i);
      boolean containsUnwantedAttr = false;
      for (String attribute : animationFromTempList.attributes) {
        if (attribute.contains(unwantedAttribute) == true) {
          containsUnwantedAttr = true;
          break;
        }
      }
      if (containsUnwantedAttr == false) {
        temp2.add(temp.get(i));
      }
    }
  }
  else {    //unwantedAttributeList length is 0 -> no unwanted attribute !
    temp2 = temp;
  }  

  return temp2;
}


/*
List of the attributes to use :
Red, Slow, Fast, Video, Noise, Very Dark, Very Bright
Simple, Complex, Atmospheric, Fade In/Out, Objects
Geometric, Rotating, Circles, Lines, Curves, Triangles, Spiral
Atmospheric, Evolving, Smooth, Violent, Rhythmic, Random, Game

*/
public void setAnimationAttributes() {
  //register attributes : animation number | animation name | attributes as a table of strings | indicative animation length (in number of beats)
  animationAttributes = registerAttribute(animationAttributes,   0, "Init"                                , new String[] {"Special"}                                                                            );
  animationAttributes = registerAttribute(animationAttributes,   1, "BlackOut"                            , new String[] {"Still", "Rhythmic", "B&W", "Very Dark"}                                              );
  animationAttributes = registerAttribute(animationAttributes,   2, "WhiteOut"                            , new String[] {"Still", "Rhythmic", "B&W", "Very Bright"}                                            );
  animationAttributes = registerAttribute(animationAttributes,   3, "WideFlash"                           , new String[] {"Fade In/Out", "Lines", "Slow", "Smooth", "B&W"}                                      );
  animationAttributes = registerAttribute(animationAttributes,   4, "Long Wide Flash "                    , new String[] {"Fade In/Out", "Slow", "B&W"}                                                         );
  animationAttributes = registerAttribute(animationAttributes,   5, "Flash Extreme Left"                  , new String[] {"Fade In/Out", "B&W", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,   6, "Flash Left"                          , new String[] {"Fade In/Out", "B&W", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,   7, "Flash Center"                        , new String[] {"Fade In/Out", "B&W", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,   8, "Flash Right"                         , new String[] {"Fade In/Out", "B&W", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,   9, "Flash Extreme Right"                 , new String[] {"Fade In/Out", "B&W", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,  10, "Wide Flash Red"                      , new String[] {"Fade In/Out", "Slow", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes,  11, "Flash Extreme Left Red"              , new String[] {"Fade In/Out", "Red", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,  12, "Flash Left Red"                      , new String[] {"Fade In/Out", "Red", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,  13, "Flash Center Red"                    , new String[] {"Fade In/Out", "Red", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,  14, "Flash Right Red"                     , new String[] {"Fade In/Out", "Red", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,  15, "Flash Extreme Right Red"             , new String[] {"Fade In/Out", "Red", "Smooth"}                                                       );
  animationAttributes = registerAttribute(animationAttributes,  16, "Fadeout ExtremeLeft"                 , new String[] {"Fade In/Out", "Very Dark"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  17, "Fadeout Left"                        , new String[] {"Fade In/Out", "Very Dark"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  18, "Fadeout Center"                      , new String[] {"Fade In/Out", "Very Dark"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  19, "Fadeout Right"                       , new String[] {"Fade In/Out", "Very Dark"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  20, "Fadeout ExtremeRight"                , new String[] {"Fade In/Out", "Very Dark"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  21, "Fadeout"                             , new String[] {"Fade In/Out", "Very Dark", "B&W"}                                                    );
  animationAttributes = registerAttribute(animationAttributes,  22, "Fadein"                              , new String[] {"Fade In/Out", "Very Bright"}                                                         );
  animationAttributes = registerAttribute(animationAttributes,  23, "ExtremeLowLeft"                      , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  24, "ExtremeHiLeft"                       , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  25, "LowLeft"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  26, "HiLeft"                              , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  27, "LowMid"                              , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  28, "HiMid"                               , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  29, "LowRight"                            , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  30, "HiRight"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  31, "ExtremeLowRight"                     , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  32, "ExtremeHiRight"                      , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  33, "PanelFill Left"                      , new String[] {"Geometric", "Rhythmic", "Fast", "Simple", "B&W"}                                     );
  animationAttributes = registerAttribute(animationAttributes,  34, "PanelFill Center"                    , new String[] {"Geometric", "Rhythmic", "Fast", "Simple", "B&W"}                                     );
  animationAttributes = registerAttribute(animationAttributes,  35, "PanelFill Right"                     , new String[] {"Geometric", "Rhythmic", "Fast", "Simple", "B&W"}                                     );
  animationAttributes = registerAttribute(animationAttributes,  36, "PanelFill Line"                      , new String[] {"Geometric", "Lines", "Red"}                                                          );
  animationAttributes = registerAttribute(animationAttributes,  37, "Opposite Lines No Background"        , new String[] {"Geometric", "Simple", "Lines", "Slow", "B&W"}                                        );
  animationAttributes = registerAttribute(animationAttributes,  38, "Opening Lines"                       , new String[] {"Geometric", "Simple", "Lines", "B&W"}                                                );
  animationAttributes = registerAttribute(animationAttributes,  39, "Opening Lines Reinit"                , new String[] {"Geometric", "Simple", "Lines", "B&W"}                                                );
  animationAttributes = registerAttribute(animationAttributes,  40, "Line Wide Flash "                    , new String[] {"Fade In/Out", "Simple", "Fast", "Rhythmic", "B&W"}                                   );
  animationAttributes = registerAttribute(animationAttributes,  41, "Line Left Flash "                    , new String[] {"Fade In/Out", "Simple", "Fast", "Rhythmic", "B&W"}                                   );
  animationAttributes = registerAttribute(animationAttributes,  42, "Line Center Flash "                  , new String[] {"Fade In/Out", "Simple", "Fast", "Rhythmic", "B&W"}                                   );
  animationAttributes = registerAttribute(animationAttributes,  43, "Line Right Flash "                   , new String[] {"Fade In/Out", "Simple", "Slow", "Rhythmic", "B&W"}                                   );
  animationAttributes = registerAttribute(animationAttributes,  44, "Upwards Line White Out"              , new String[] {"Geometric", "Lines", "Slow", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes,  45, "Upwards Line"                        , new String[] {"Geometric", "Lines", "Very Dark", "Simple", "B&W", "Rhythmic"}                       );
  animationAttributes = registerAttribute(animationAttributes,  46, "Lines 1"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  47, "Lines 2"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  48, "Lines 3"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  49, "Lines 4"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  50, "Lines 5"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  51, "Lines 6"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  52, "Lines 7"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  53, "Lines 8"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  54, "Lines 9"                             , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  55, "Lines 10"                            , new String[] {"Still", "Rhythmic", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes,  56, "Unfolding Lines"                     , new String[] {"Lines", "Slow", "B&W"}                                                               );
  animationAttributes = registerAttribute(animationAttributes,  57, "Mugen"                               , new String[] {"Simple", "Lines", "Geometric", "B&W"}                                                );
  animationAttributes = registerAttribute(animationAttributes,  58, "Turning Single Lines"                , new String[] {"Geometric", "Lines", "Simple", "B&W", "Slow", "Rotating"}                            );
  animationAttributes = registerAttribute(animationAttributes,  59, "Random Appearing Lines"              , new String[] {"Geometric", "Lines", "B&W", "Slow", "Rotating"}                                      );
  animationAttributes = registerAttribute(animationAttributes,  60, "Nonotak 1"                           , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  61, "Nonotak 2"                           , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  62, "Nonotak 3"                           , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  63, "Nonotak 4"                           , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  64, "Nonotak 5"                           , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  65, "Nonotak PanelFill Extreme Left"      , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  66, "Nonotak PanelFill Left"              , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  67, "Nonotak PanelFill Center"            , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  68, "Nonotak PanelFill Right"             , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  69, "Nonotak PanelFill Extreme Right"     , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  70, "Nonotak Woosh 1"                     , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  71, "Nonotak Woosh 2"                     , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  72, "Nonotak Woosh 3"                     , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  73, "Nonotak Woosh 4"                     , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  74, "Rotating Cut Black"                  , new String[] {"Atmospheric", "Fast", "B&W", "Rotating"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  75, "Rotating Cut Blue"                   , new String[] {"Atmospheric", "Fast", "Blue", "Rotating"}                                            );
  animationAttributes = registerAttribute(animationAttributes,  76, "Rotating Cut - Fast"                 , new String[] {"Atmospheric", "Fast", "B&W", "Rotating"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  77, "Red Diagonal Lines"                  , new String[] {"Still", "Lines", "Rhythmic", "Red"}                                                  );
  animationAttributes = registerAttribute(animationAttributes,  78, "Blue Diagonal Lines"                 , new String[] {"Still", "Lines", "Rhythmic", "Blue"}                                                 );
  animationAttributes = registerAttribute(animationAttributes,  79, "Blue Diagonal Lines2"                , new String[] {"Still", "Lines", "Rhythmic", "Blue"}                                                 );
  animationAttributes = registerAttribute(animationAttributes,  80, "Blue Diagonal Lines3"                , new String[] {"Still", "Lines", "Rhythmic", "Blue"}                                                 );
  animationAttributes = registerAttribute(animationAttributes,  81, "Red Diagonal Lines2"                 , new String[] {"Still", "Lines", "Rhythmic", "Red"}                                                  );
  animationAttributes = registerAttribute(animationAttributes,  82, "White Diagonal Lines"                , new String[] {"Still", "Lines", "Rhythmic", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes,  83, "White Diagonal Lines2"               , new String[] {"Still", "Lines", "Rhythmic", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes,  84, "White Straight Lines"                , new String[] {"Still", "Lines", "Rhythmic", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes,  85, "Star - 2 sides"                      , new String[] {"Geometric", "Lines", "Slow", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes,  86, "Star - 3 sides"                      , new String[] {"Geometric", "Lines", "Slow", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes,  87, "Star - 4 sides"                      , new String[] {"Geometric", "Lines", "Slow", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes,  88, "Star - 6 sides"                      , new String[] {"Geometric", "Lines", "Slow", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes,  89, "Star - 8 sides"                      , new String[] {"Geometric", "Lines", "Slow", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes,  90, "Rotating Circles"                    , new String[] {"Geometric", "Circles", "Simple", "Rotating", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes,  91, "Joint Circles"                       , new String[] {"Atmospheric", "Slow", "B&W", "Simple"}                                               );
  animationAttributes = registerAttribute(animationAttributes,  92, "Parallel Worlds - Regular"           , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  93, "Parallel Worlds - Slow"              , new String[] {"Geometric", "B&W", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  94, "Parallel Worlds - Red Flash"         , new String[] {"Geometric", "Red", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  95, "Parallel Worlds - Reverse"           , new String[] {"Geometric", "Red", "Simple", "Rhythmic"}                                             );
  animationAttributes = registerAttribute(animationAttributes,  96, "MultiCrecy - Very Low Intensity"     , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Very Dark"}                           );
  animationAttributes = registerAttribute(animationAttributes,  97, "MultiCrecy - Low Intensity"          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Violent"}                             );
  animationAttributes = registerAttribute(animationAttributes,  98, "MultiCrecy - Medium Intensity"       , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Violent"}                             );
  animationAttributes = registerAttribute(animationAttributes,  99, "MultiCrecy - High Intensity"         , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Violent"}                             );
  animationAttributes = registerAttribute(animationAttributes, 100, "MultiCrecy - Hardcore Intensity"     , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Violent"}                             );
  animationAttributes = registerAttribute(animationAttributes, 101, "MultiCrecy - Double Intensity"       , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Violent"}                             );
  animationAttributes = registerAttribute(animationAttributes, 102, "MultiCrecy - Refrain"                , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "Violent"}                             );
  animationAttributes = registerAttribute(animationAttributes, 103, "Snake - Single"                      , new String[] {"Geometric", "Red", "Simple"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 104, "Snake - Double"                      , new String[] {"Geometric", "Red", "Simple"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 105, "Snake - Triple"                      , new String[] {"Geometric", "Red", "Simple"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 106, "Snake - Four"                        , new String[] {"Geometric", "Red", "Simple"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 107, "Snake - Five"                        , new String[] {"Geometric", "Red", "Simple"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 108, "Snake - Six"                         , new String[] {"Geometric", "Red", "Simple"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 109, "Moving Sine"                         , new String[] {"Geometric", "B&W", "Fast", "Simple"}                                                 );
  animationAttributes = registerAttribute(animationAttributes, 110, "Carglass"                            , new String[] {"Geometric", "Slow", "B&W"}                                                           );
  animationAttributes = registerAttribute(animationAttributes, 111, "Va-et-vient 1"                       , new String[] {"Geometric", "Fast", "B&W", "Rhythmic"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 112, "Va-et-vient 2"                       , new String[] {"Geometric", "Fast", "B&W", "Rhythmic"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 113, "Impulse White Rectangle - Horizontal", new String[] {"Geometric", "Squares", "B&W", "Fast", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 114, "Impulse White Rectangle - Vertical"  , new String[] {"Geometric", "Squares", "B&W", "Fast", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 115, "Impulse Red Rectangle - Horizontal"  , new String[] {"Geometric", "Squares", "Red", "Fast", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 116, "Impulse Red Rectangle - Vertical"    , new String[] {"Geometric", "Squares", "Red", "Fast", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 117, "Mixed Lines 1"                       , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 118, "Mixed Lines 2"                       , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 119, "Mixed Lines 3"                       , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 120, "Mixed Lines 4"                       , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 121, "Mixed Lines 5"                       , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 122, "Mixed Lines 6"                       , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 123, "Mixed Lines 7"                       , new String[] {"Geometric", "Lines", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                 );
  animationAttributes = registerAttribute(animationAttributes, 124, "Mixed Lines 8"                       , new String[] {"Geometric", "Lines", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                 );
  animationAttributes = registerAttribute(animationAttributes, 125, "Mixed Lines 9"                       , new String[] {"Geometric", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                          );
  animationAttributes = registerAttribute(animationAttributes, 126, "Mixed Lines 10"                      , new String[] {"Geometric", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                          );
  animationAttributes = registerAttribute(animationAttributes, 127, "Mixed Lines 11"                      , new String[] {"Geometric", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                          );
  animationAttributes = registerAttribute(animationAttributes, 128, "Mixed Lines 12"                      , new String[] {"Geometric", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                          );
  animationAttributes = registerAttribute(animationAttributes, 129, "Mixed Lines 13"                      , new String[] {"Geometric", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                          );
  animationAttributes = registerAttribute(animationAttributes, 130, "Mixed Lines 14"                      , new String[] {"Geometric", "Circles", "Fast", "Simple", "B&W", "Rhythmic"}                          );
  animationAttributes = registerAttribute(animationAttributes, 131, "Upwards Glitch Lines"                , new String[] {"Geometric", "Lines", "Slow", "Simple", "Red", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 132, "Diagonal Glitch Lines"               , new String[] {"Geometric", "Lines", "Fast", "Simple", "Red", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 133, "Compressed Lines"                    , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 134, "UpwardsGlitchMixedLines"             , new String[] {"Geometric", "Lines", "Fast", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes, 135, "UpwardsGlitchMixedLines2"            , new String[] {"Geometric", "Lines", "Fast", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes, 136, "Growing Triangles"                   , new String[] {"Geometric", "Triangles", "Rhythmic", "Slow", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 137, "Small Square Left"                   , new String[] {"Geometric", "Squares", "Violent", "Fast", "B&W", "Rhythmic"}                         );
  animationAttributes = registerAttribute(animationAttributes, 138, "Small Square Center"                 , new String[] {"Geometric", "Squares", "Violent", "Fast", "B&W", "Rhythmic"}                         );
  animationAttributes = registerAttribute(animationAttributes, 139, "Small Square Right"                  , new String[] {"Geometric", "Squares", "Violent", "Fast", "B&W", "Rhythmic"}                         );
  animationAttributes = registerAttribute(animationAttributes, 140, "Small Squares"                       , new String[] {"Geometric", "Squares", "Violent", "Fast", "B&W", "Rhythmic"}                         );
  animationAttributes = registerAttribute(animationAttributes, 141, "Moving Lines"                        , new String[] {"Geometric", "Lines", "Fast", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 142, "Moving Squares"                      , new String[] {"Objects", "Squares", "Slow", "Simple", "B&W", "Rhythmic"}                            );
  animationAttributes = registerAttribute(animationAttributes, 143, "Orbiting Particles"                  , new String[] {"Objects", "Circles", "Fast", "B&W", "Rhythmic"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 144, "Arrow Style"                         , new String[] {"Geometric", "Lines", "Fast", "B&W"}                                                  );
  animationAttributes = registerAttribute(animationAttributes, 145, "Single Arrow - Up-Down White"        , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "B&W"}                           );
  animationAttributes = registerAttribute(animationAttributes, 146, "Single Arrow - Left-Right White"     , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "B&W"}                           );
  animationAttributes = registerAttribute(animationAttributes, 147, "Single Arrow - Right-Left White"     , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "B&W"}                           );
  animationAttributes = registerAttribute(animationAttributes, 148, "Single Arrow - Down-Up White"        , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "B&W"}                           );
  animationAttributes = registerAttribute(animationAttributes, 149, "Single Arrow - Up-Down Red"          , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "Red"}                           );
  animationAttributes = registerAttribute(animationAttributes, 150, "Single Arrow - Left-Right Red"       , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "Red"}                           );
  animationAttributes = registerAttribute(animationAttributes, 151, "Single Arrow - Right-Left Red"       , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "Red"}                           );
  animationAttributes = registerAttribute(animationAttributes, 152, "Single Arrow - Down-Up Red"          , new String[] {"Geometric", "Objects", "Rhythmic", "Lines", "Fast", "Red"}                           );
  animationAttributes = registerAttribute(animationAttributes, 153, "Sweeping Balls And Arrows"           , new String[] {"Geometric", "B&W", "Complex", "Rhythmic"}                                            );
  animationAttributes = registerAttribute(animationAttributes, 154, "Columns White"                       , new String[] {"Geometric", "Lines", "Slow", "Rhythmic", "B&W"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 155, "Columns Black"                       , new String[] {"Geometric", "Lines", "Slow", "Rhythmic", "B&W"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 156, "Columns White Red"                   , new String[] {"Geometric", "Slow", "Red", "Rhythmic"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 157, "Columns Black Red"                   , new String[] {"Geometric", "Slow", "Red", "Rhythmic"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 158, "Continuous Triangles Resync "        , new String[] {"Geometric", "Triangles", "Slow", "Rhythmic", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 159, "Continuous Triangles Resync Invert"  , new String[] {"Geometric", "Triangles", "Slow", "Rhythmic", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 160, "Continuous Triangles Drift"          , new String[] {"Geometric", "Triangles", "Slow", "Rhythmic", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 161, "Continuous Triangles Drift Invert"   , new String[] {"Geometric", "Triangles", "Slow", "Rhythmic", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 162, "Beat Circle"                         , new String[] {"Geometric", "Fast", "Circles", "Simple", "Rhythmic", "Red"}                          );
  animationAttributes = registerAttribute(animationAttributes, 163, "Beat Circle Lines Reinit"            , new String[] {"Geometric", "Fast", "Circles", "Lines", "Simple", "Rhythmic", "Red"}                 );
  animationAttributes = registerAttribute(animationAttributes, 164, "Beat Circle Lines"                   , new String[] {"Geometric", "Fast", "Circles", "Lines", "Simple", "Rhythmic", "Red"}                 );
  animationAttributes = registerAttribute(animationAttributes, 165, "Beat Circle Color Lines 1"           , new String[] {"Geometric", "Fast", "Circles", "Lines", "Simple", "Rhythmic", "Red"}                 );
  animationAttributes = registerAttribute(animationAttributes, 166, "Beat Circle Color Lines 2"           , new String[] {"Geometric", "Fast", "Circles", "Lines", "Simple", "Rhythmic", "Colorful"}            );
  animationAttributes = registerAttribute(animationAttributes, 167, "Atoms - One Electron"                , new String[] {"Geometric", "Circles", "Fast", "Rhythmic", "Red"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 168, "Atoms - Two Electrons"               , new String[] {"Geometric", "Circles", "Fast", "Rhythmic", "Red"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 169, "Atoms - Three Electrons"             , new String[] {"Geometric", "Circles", "Fast", "Rhythmic", "Red"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 170, "Perfect Circle"                      , new String[] {"Geometric", "Circles", "Fast", "Rhythmic", "Red"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 171, "Tunnel White"                        , new String[] {"Atmospheric", "Fast", "B&W", "Violent", "Rhythmic"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 172, "Tunnel Red "                         , new String[] {"Atmospheric", "Fast", "Red", "Violent", "Rhythmic"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 173, "Exploding Circle"                    , new String[] {"Geometric", "Simple", "Circles", "Fast", "Rhythmic", "B&W"}                          );
  animationAttributes = registerAttribute(animationAttributes, 174, "Exploding Circle Left"               , new String[] {"Geometric", "Circles", "Fast", "B&W", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 175, "Exploding Circle Right"              , new String[] {"Geometric", "Circles", "Fast", "Red", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 176, "Color Waves - Regular"               , new String[] {"Atmospheric", "Circles", "Fast", "Red", "Rhythmic"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 177, "Color Waves - Strong"                , new String[] {"Atmospheric", "Circles", "Fast", "Red", "Rhythmic"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 178, "Glitch Triangle"                     , new String[] {"Geometric", "Triangles", "B&W", "Violent"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 179, "Glitch Line"                         , new String[] {"Geometric", "Lines", "B&W", "Violent"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 180, "Bar Waves - White"                   , new String[] {"Geometric", "B&W", "Lines"}                                                          );
  animationAttributes = registerAttribute(animationAttributes, 181, "Bar Waves - Red"                     , new String[] {"Geometric", "Red", "Lines"}                                                          );
  animationAttributes = registerAttribute(animationAttributes, 182, "Bar Waves - Blue"                    , new String[] {"Geometric", "Blue", "Lines"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 183, "Fucked Up Sine - 1"                  , new String[] {"Curves", "B&W", "Complex", "Fast", "Evolving"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 184, "Fucked Up Sine - 2"                  , new String[] {"Curves", "B&W", "Complex", "Fast", "Evolving"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 185, "Fucked Up Sine - 2 - No Reinit"      , new String[] {"Curves", "B&W", "Complex", "Fast", "Evolving"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 186, "Fucked Up Sine - 3"                  , new String[] {"Curves", "B&W", "Complex", "Fast", "Evolving"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 187, "Rotating Square"                     , new String[] {"Geometric", "Squares", "Rotating", "Complex", "Curves"}                              );
  animationAttributes = registerAttribute(animationAttributes, 188, "Mandala"                             , new String[] {"Geometric", "Circles", "Fast", "Rhythmic", "Red", "Complex"}                         );
  animationAttributes = registerAttribute(animationAttributes, 189, "Mandala - change shape"              , new String[] {"Geometric", "Circles", "Fast", "Rhythmic", "Red", "Complex"}                         );
  animationAttributes = registerAttribute(animationAttributes, 190, "Clock"                               , new String[] {"Geometric", "Lines", "Red", "Rhythmic"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 191, "Invert Explode"                      , new String[] {"Geometric", "Circles", "Rotating", "Lines", "Colorful", "Fast", "Rhythmic"}          );
  animationAttributes = registerAttribute(animationAttributes, 192, "Crescent"                            , new String[] {"Atmospheric", "Lines", "Red", "Slow", "Colorful"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 193, "Trigo Shapes"                        , new String[] {"Geometric", "Smooth", "Red", "Rhythmic", "Rotating"}                                 );
  animationAttributes = registerAttribute(animationAttributes, 194, "Newton Pendulum"                     , new String[] {"Geometric", "Evolving", "Simple", "Circles", "Lines", "Fast", "B&W"}                 );
  animationAttributes = registerAttribute(animationAttributes, 195, "Circle Pusher Rotate"                , new String[] {"Geometric", "Evolving", "Circles", "Rotating", "B&W", "Rhythmic"}                    );
  animationAttributes = registerAttribute(animationAttributes, 196, "Circle Pusher Straight"              , new String[] {"Geometric", "Evolving", "Circles", "B&W", "Rhythmic"}                                );
  animationAttributes = registerAttribute(animationAttributes, 197, "Patatap 1"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 198, "Patatap 2"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 199, "Patatap 3"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 200, "Patatap 4"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 201, "Patatap 5"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 202, "Patatap 6"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 203, "Patatap 7"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 204, "Patatap 8"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 205, "Patatap 9"                           , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 206, "Patatap 10"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 207, "Patatap 11"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 208, "Patatap 12"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 209, "Patatap 13"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 210, "Patatap 14"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 211, "Patatap 15"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 212, "Patatap 16"                          , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 213, "Patatap with audio"                  , new String[] {"Geometric", "Colorful", "Simple", "Rhythmic", "AudioInput"}                          );
  animationAttributes = registerAttribute(animationAttributes, 214, "Shadows"                             , new String[] {"Rotating", "Fast", "B&W"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 215, "SpiralTriangle"                      , new String[] {"Geometric", "Spiral", "B&W", "Slow"}                                                 );
  animationAttributes = registerAttribute(animationAttributes, 216, "Pulse Star"                          , new String[] {"Geometric", "Circles", "B&W", "Slow"}                                                );
  animationAttributes = registerAttribute(animationAttributes, 217, "Arrow Shape"                         , new String[] {"Geometric", "Triangles", "Slow", "B&W"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 218, "Moire"                               , new String[] {"Atmospheric", "Complex", "Slow", "B&W"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 219, "Tumbler"                             , new String[] {"Geometric", "B&W", "Simple", "Lines", "Rotating"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 220, "Super formula"                       , new String[] {"Complex", "Evolving", "Atmospheric", "Rhythmic", "B&W"}                              );
  animationAttributes = registerAttribute(animationAttributes, 221, "HypnoAudio"                          , new String[] {"Geometric", "Red", "Evolving", "Rhythmic", "AudioInput"}                             );
  animationAttributes = registerAttribute(animationAttributes, 222, "HypnoAudio - without audio (manual)" , new String[] {"Geometric", "Red", "Evolving", "Rhythmic"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 223, "Snow"                                , new String[] {"Atmospheric", "Noise", "B&W", "Very Dark"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 224, "Noise : InitFlasher"                 , new String[] {"Video", "Noise", "B&W"}                                                              );
  animationAttributes = registerAttribute(animationAttributes, 225, "Rain"                                , new String[] {"Atmospheric", "Noise", "B&W", "Very Dark"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 226, "White Noise"                         , new String[] {"Noise", "B&W"}                                                                       );
  animationAttributes = registerAttribute(animationAttributes, 227, "White Noise Crescendo"               , new String[] {"Noise", "B&W"}                                                                       );
  animationAttributes = registerAttribute(animationAttributes, 228, "Hyper Speed"                         , new String[] {"Atmospheric", "Lines", "Fast", "B&W"}                                                );
  animationAttributes = registerAttribute(animationAttributes, 229, "Random BW Flow"                      , new String[] {"Noise", "Complex", "B&W"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 230, "Random Smoke Particles"              , new String[] {"Noise", "Evolving", "Atmospheric", "B&W"}                                            );
  animationAttributes = registerAttribute(animationAttributes, 231, "Periodic Noise"                      , new String[] {"Atmospheric", "B&W", "Noise"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 232, "DoubleGradient transition"           , new String[] {"Fade In/Out", "Atmospheric", "B&W", "Smooth", "Slow"}                                );
  animationAttributes = registerAttribute(animationAttributes, 233, "Sonar"                               , new String[] {"Fade In/Out", "Slow", "Smooth", "B&W"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 234, "SonarAllWhite"                       , new String[] {"Fade In/Out", "Slow", "Smooth", "B&W"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 235, "Thunder Lines Init"                  , new String[] {"Atmospheric", "Lines", "Fast", "B&W", "Smooth"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 236, "Thunder Lines - More Lines"          , new String[] {"Atmospheric", "Lines", "Fast", "B&W", "Smooth"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 237, "Opening Whiteout"                    , new String[] {"Fade In/Out", "Simple", "Slow", "B&W", "Smooth"}                                     );
  animationAttributes = registerAttribute(animationAttributes, 238, "Dark Snakes"                         , new String[] {"Fade In/Out", "Slow", "Smooth"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 239, "Bright Snakes"                       , new String[] {"Fade In/Out", "Slow", "Smooth"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 240, "Milktank"                            , new String[] {"Atmospheric", "Objects", "Fast", "B&W", "Evolving"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 241, "Flashing Dots Border"                , new String[] {"Atmospheric", "Circles", "Slow", "B&W"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 242, "Light Fusion"                        , new String[] {"Atmospheric", "Fast", "B&W", "Violent"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 243, "BW Triangles"                        , new String[] {"Geometric", "Evolving", "B&W"}                                                       );
  animationAttributes = registerAttribute(animationAttributes, 244, "Color Vertex"                        , new String[] {"Atmospheric", "Fast", "Rhythmic", "Colorful", "Complex", "Evolving"}                 );
  animationAttributes = registerAttribute(animationAttributes, 245, "Gloubiboulga"                        , new String[] {"Geometric", "Atmospheric", "Complex", "Colorful", "Fast"}                            );
  animationAttributes = registerAttribute(animationAttributes, 246, "CarreMarshall"                       , new String[] {"Geometric", "Squares", "B&W", "Smooth", "Slow"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 247, "MarshallStrobo"                      , new String[] {"Violent", "Geometric", "Squares", "B&W", "Smooth", "Slow", "B&W"}                    );
  animationAttributes = registerAttribute(animationAttributes, 248, "Strobo normal"                       , new String[] {"Violent", "B&W", "Fast"}                                                             );
  animationAttributes = registerAttribute(animationAttributes, 249, "StroboX"                             , new String[] {"Fade In/Out", "Violent", "Lines", "Fast", "B&W"}                                     );
  animationAttributes = registerAttribute(animationAttributes, 250, "Dynamic Angle Lines - White"         , new String[] {"Geometric", "B&W", "Simple", "Lines", "Rotating", "Rhythmic"}                        );
  animationAttributes = registerAttribute(animationAttributes, 251, "Dynamic Angle Lines - Half Red"      , new String[] {"Geometric", "Red", "Simple", "Lines", "Rotating", "Rhythmic"}                        );
  animationAttributes = registerAttribute(animationAttributes, 252, "Dynamic Angle Lines - Red"           , new String[] {"Geometric", "Red", "Simple", "Lines", "Rotating", "Rhythmic"}                        );
  animationAttributes = registerAttribute(animationAttributes, 253, "Spots"                               , new String[] {"Violent", "Geometric", "Lines", "Fast", "B&W"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 254, "StroboLine"                          , new String[] {"Violent", "Geometric", "Lines", "Fast", "B&W"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 255, "Random White Line Flash"             , new String[] {"Geometric", "B&W", "Simple", "Rhythmic", "Violent"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 256, "StroboRed"                           , new String[] {"Violent", "Fast", "Red"}                                                             );
  animationAttributes = registerAttribute(animationAttributes, 257, "Spots Multi Color"                   , new String[] {"Geometric", "Lines", "Blue", "Colorful", "Violent"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 258, "Strobo Line Color"                   , new String[] {"Geometric", "Lines", "Blue", "Colorful", "Violent"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 259, "Strobo Color"                        , new String[] {"Geometric", "Simple", "Blue", "Violent"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 260, "Triangle Strobo"                     , new String[] {"Geometric", "Lines", "Violent", "Fast", "B&W"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 261, "Triangle Strobo 2"                   , new String[] {"Geometric", "Triangles", "Fast", "Red", "Blue", "Violent"}                           );
  animationAttributes = registerAttribute(animationAttributes, 262, "Hypno Flash Triangle"                , new String[] {"Geometric", "Triangles", "Rhythmic", "Red", "Violent"}                               );
  animationAttributes = registerAttribute(animationAttributes, 263, "Fauve Random Flash"                  , new String[] {"Atmospheric", "Red", "Simple"}                                                       );
  animationAttributes = registerAttribute(animationAttributes, 264, "Red Noise Shape 1"                   , new String[] {"Noise", "Red", "Fast"}                                                               );
  animationAttributes = registerAttribute(animationAttributes, 265, "Red Noise Shape 2"                   , new String[] {"Geometric", "Lines", "Noise", "Red", "Fast"}                                         );
  animationAttributes = registerAttribute(animationAttributes, 266, "Red Noise Shape 3"                   , new String[] {"Geometric", "Lines", "Noise", "Red", "Fast", "Violent"}                              );
  animationAttributes = registerAttribute(animationAttributes, 267, "Red Noise Shape 4"                   , new String[] {"Geometric", "Triangles", "Noise", "Red", "Fast", "Violent"}                          );
  animationAttributes = registerAttribute(animationAttributes, 268, "Red Noise Shape 5"                   , new String[] {"Geometric", "Circles", "Noise", "Red", "Fast"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 269, "Red Noise Shape 6"                   , new String[] {"Geometric", "Lines", "Noise", "Red", "Fast", "Violent"}                              );
  animationAttributes = registerAttribute(animationAttributes, 270, "Fusee Up"                            , new String[] {"Fade In/Out", "B&W", "Fast"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 271, "Fusee Down"                          , new String[] {"Fade In/Out", "B&W", "Fast"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 272, "Fusee Left"                          , new String[] {"Fade In/Out", "B&W", "Fast"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 273, "Fusee Right"                         , new String[] {"Fade In/Out", "B&W", "Fast"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 274, "FuseeCenterHorizontal"               , new String[] {"Fade In/Out", "B&W", "Fast"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 275, "FuseeCenterVertical"                 , new String[] {"Fade In/Out", "B&W", "Fast"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 276, "Double Fusee"                        , new String[] {"Fade In/Out", "Fast", "B&W"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 277, "Fusee Up Red"                        , new String[] {"Fade In/Out", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 278, "Fusee Down Red"                      , new String[] {"Fade In/Out", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 279, "Fusee Left Red"                      , new String[] {"Fade In/Out", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 280, "Fusee Right Red"                     , new String[] {"Fade In/Out", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 281, "Fusee Center Horizontal Red"         , new String[] {"Fade In/Out", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 282, "Fusee Center Vertical Red"           , new String[] {"Fade In/Out", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 283, "Responsive Circles BW"               , new String[] {"Atmospheric", "Slow", "B&W"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 284, "Responsive Circles"                  , new String[] {"Atmospheric", "Slow", "Blue"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 285, "Manual Circle"                       , new String[] {"Fade In/Out", "Geometric", "Circles", "Simple", "Slow", "White"}                     );
  animationAttributes = registerAttribute(animationAttributes, 286, "Automatic Circle"                    , new String[] {"Geometric", "Circles", "Simple", "Slow", "White"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 287, "Waveform"                            , new String[] {"Atmospheric", "Colorful"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 288, "Worms"                               , new String[] {"Objects", "Circles", "Smooth", "Blue", "Slow"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 289, "Kaleido Triangle"                    , new String[] {"Geometric", "Blue", "Complex", "Evolving"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 290, "Rhombus"                             , new String[] {"Geometric", "Colorful", "Smooth", "Slow"}                                            );
  animationAttributes = registerAttribute(animationAttributes, 291, "Glitch Diagonal Lines"               , new String[] {"Atmospheric", "Lines", "Rhythmic", "Blue"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 292, "Particles Explode"                   , new String[] {"Fade In/Out", "Fast", "Rhythmic", "Blue"}                                            );
  animationAttributes = registerAttribute(animationAttributes, 293, "Symmetry"                            , new String[] {"Atmospheric", "Smooth", "Complex", "Colorful"}                                       );
  animationAttributes = registerAttribute(animationAttributes, 294, "PixelLines"                          , new String[] {"Atmospheric", "Colorful", "Smooth"}                                                  );
  animationAttributes = registerAttribute(animationAttributes, 295, "Circle Contour"                      , new String[] {"Atmospheric", "Circles", "Slow", "Very Dark", "Blue"}                                );
  animationAttributes = registerAttribute(animationAttributes, 296, "Color Explode"                       , new String[] {"Atmospheric", "Objects", "Slow", "Colorful"}                                         );
  animationAttributes = registerAttribute(animationAttributes, 297, "Color Rain"                          , new String[] {"Atmospheric", "Lines", "Fast", "Colorful"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 298, "Warp Speed"                          , new String[] {"Fade In/Out", "Fast", "Colorful"}                                                    );
  animationAttributes = registerAttribute(animationAttributes, 299, "Digital Hex Particles"               , new String[] {"Fade In/Out", "Colorful", "Very Dark", "Lines", "Slow"}                              );
  animationAttributes = registerAttribute(animationAttributes, 300, "Red Arc Transition"                  , new String[] {"Fade In/Out", "Red", "Circles", "Fast"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 301, "Blue Arc Transition"                 , new String[] {"Fade In/Out", "Blue", "Circles", "Fast"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 302, "Shutter"                             , new String[] {"Geometric", "Atmospheric", "Red", "Slow"}                                            );
  animationAttributes = registerAttribute(animationAttributes, 303, "Butterfly"                           , new String[] {"Atmospheric", "Evolving", "Slow", "Very Dark", "Blue"}                               );
  animationAttributes = registerAttribute(animationAttributes, 304, "Bezier Flowers"                      , new String[] {"Geometric", "Lines", "Complex", "Rhythmic", "Colorful"}                              );
  animationAttributes = registerAttribute(animationAttributes, 305, "Light Painting"                      , new String[] {"3D", "Fast", "Objects", "Colorful", "Rhythmic"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 306, "Particles Flow"                      , new String[] {"Atmospheric", "Slow", "Blue"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 307, "Particles Flow Red"                  , new String[] {"Atmospheric", "Slow", "Red", "Smooth"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 308, "Flower"                              , new String[] {"Atmospheric", "Circles", "Evolving", "Colorful", "Rhythmic"}                         );
  animationAttributes = registerAttribute(animationAttributes, 309, "Double Flowers"                      , new String[] {"Atmospheric", "Slow", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 310, "Fireflies"                           , new String[] {"Atmospheric", "Red", "Complex", "Slow"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 311, "Fire Noise Squares"                  , new String[] {"Atmospheric", "Noise", "Red", "Evolving", "Smooth"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 312, "Blood Ski"                           , new String[] {"Atmospheric", "Fast", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 313, "Mechanic Lines"                      , new String[] {"Geometric", "Lines", "Red", "Slow"}                                                  );
  animationAttributes = registerAttribute(animationAttributes, 314, "Red Glowing Balls 1"                 , new String[] {"Geometric", "Red", "Slow"}                                                           );
  animationAttributes = registerAttribute(animationAttributes, 315, "Red Glowing Balls 2"                 , new String[] {"Geometric", "Red", "Slow"}                                                           );
  animationAttributes = registerAttribute(animationAttributes, 316, "Red vs Black vs White"               , new String[] {"Fade In/Out", "Circles", "Red", "Slow"}                                              );
  animationAttributes = registerAttribute(animationAttributes, 317, "Perlin Color "                       , new String[] {"Geometric", "Circles", "Red", "Random", "Slow"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 318, "Wind particles"                      , new String[] {"Atmospheric", "Smooth", "Red", "Evolving"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 319, "Rorschach 1"                         , new String[] {"Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 320, "Rorschach 2"                         , new String[] {"Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 321, "Rorschach 3"                         , new String[] {"Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 322, "Rorschach 4"                         , new String[] {"Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 323, "Rorschach 5"                         , new String[] {"Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 324, "RorschachSetColor"                   , new String[] {"Special", "Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                       );
  animationAttributes = registerAttribute(animationAttributes, 325, "RorschachSetBlack&White"             , new String[] {"Special", "Random", "Complex", "Fast", "Smooth", "Red", "B&W"}                       );
  animationAttributes = registerAttribute(animationAttributes, 326, "Progressive Red"                     , new String[] {"Fade In/Out", "Atmospheric", "Slow", "Red"}                                          );
  animationAttributes = registerAttribute(animationAttributes, 327, "Weird Square"                        , new String[] {"Atmospheric", "Slow", "Red"}                                                         );
  animationAttributes = registerAttribute(animationAttributes, 328, "Light Blobs"                         , new String[] {"Objects", "Circles", "Atmospheric", "Red"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 329, "Red Meta Balls"                      , new String[] {"Objects", "Circles", "Atmospheric", "Red"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 330, "Reverse Triangles"                   , new String[] {"Geometric", "Fast", "Red", "Rhythmic", "Violent"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 331, "3D Big Ass Cube"                     , new String[] {"3D", "Slow", "Red", "Rhythmic"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 332, "3D Corner Cube"                      , new String[] {"3D", "Slow", "Red", "Rhythmic"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 333, "3D Glitch Cube"                      , new String[] {"3D", "Slow", "Red", "Rhythmic", "Violent"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 334, "3D No Glitch Cube"                   , new String[] {"3D", "Slow", "Red", "Rhythmic"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 335, "3D Jerky Cube"                       , new String[] {"3D", "Slow", "B&W", "Rhythmic", "Violent"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 336, "3D Moving Jerky Cube"                , new String[] {"3D", "Slow", "B&W", "Rhythmic", "Violent"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 337, "3D Double Cube"                      , new String[] {"3D", "Slow", "Red", "Rhythmic", "Violent"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 338, "3D Single Pyramid"                   , new String[] {"3D", "Slow", "B&W", "Rhythmic"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 339, "3D Multiple Pyramids"                , new String[] {"3D", "Slow", "Red", "Rhythmic"}                                                      );
  animationAttributes = registerAttribute(animationAttributes, 340, "Energy Grid"                         , new String[] {"Atmospheric", "Rhythmic", "Geometric", "Triangles", "Red", "Fast", "Rotating"}       );
  animationAttributes = registerAttribute(animationAttributes, 341, "Random Paint"                        , new String[] {"Atmospheric", "Smooth", "Random", "Red"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 342, "Red Wave"                            , new String[] {"Atmospheric", "Smooth", "Slow", "Red"}                                               );
  animationAttributes = registerAttribute(animationAttributes, 343, "Diagonal Color"                      , new String[] {"Atmospheric", "Geometric", "Smooth", "Slow", "Colorful"}                             );
  animationAttributes = registerAttribute(animationAttributes, 344, "Scope"                               , new String[] {"Geometric", "Circles", "Fast", "Rotating", "Evolving", "Red"}                        );
  animationAttributes = registerAttribute(animationAttributes, 345, "SquareWaveGenerator"                 , new String[] {"Lines", "Rhythmic", "Smooth", "Red"}                                                 );
  animationAttributes = registerAttribute(animationAttributes, 346, "Falling Circles"                     , new String[] {"Atmospheric", "Circles", "Slow", "Blue"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 347, "Set Exploding Particles"             , new String[] {"Geometric", "Circles", "Evolving", "Rhythmic", "Blue"}                               );
  animationAttributes = registerAttribute(animationAttributes, 348, "Release Exploding Particles"         , new String[] {"Geometric", "Circles", "Evolving", "Rhythmic", "Blue"}                               );
  animationAttributes = registerAttribute(animationAttributes, 349, "Tesselate"                           , new String[] {"Geometric", "Squares", "Red", "Blue"}                                                );
  animationAttributes = registerAttribute(animationAttributes, 350, "Patchwork"                           , new String[] {"Atmospheric", "Fast", "Rectangles", "Colorful", "Fast"}                              );
  animationAttributes = registerAttribute(animationAttributes, 351, "Vines"                               , new String[] {"Objects", "Lines", "Fast", "Red", "Evolving"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 352, "Night Road"                          , new String[] {"Geometric", "Lines", "Rhythmic", "Blue"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 353, "Slasher"                             , new String[] {"Geometric", "Lines", "Objects", "Fast", "Colorful", "Rhythmic"}                      );
  animationAttributes = registerAttribute(animationAttributes, 354, "Color Beat"                          , new String[] {"Geometric", "Lines", "Colorful", "Fast", "Rhythmic"}                                 );
  animationAttributes = registerAttribute(animationAttributes, 355, "Color Beat Stroboline"               , new String[] {"Geometric", "Lines", "Colorful", "Fast", "Violent"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 356, "Color Beat White Strobo Triangle"    , new String[] {"Geometric", "Triangles", "B&W", "Fast", "Violent"}                                   );
  animationAttributes = registerAttribute(animationAttributes, 357, "Color Beat Transition"               , new String[] {"Fade In/Out", "Lines", "Colorful", "Fast"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 358, "Neko Jiru"                           , new String[] {"Special", "Video", "Simple", "Colorful"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 359, "Letter Explode"                      , new String[] {"Special", "Objects", "Fast", "B&W", "Red"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 360, "Rotozoom White"                      , new String[] {"Atmospheric", "Complex", "Fast", "Rotating", "B&W"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 361, "Rotozoom 1"                          , new String[] {"Atmospheric", "Rotating", "Complex", "Red"}                                          );
  animationAttributes = registerAttribute(animationAttributes, 362, "Rotozoom 2"                          , new String[] {"Atmospheric", "Rotating", "Complex", "Red"}                                          );
  animationAttributes = registerAttribute(animationAttributes, 363, "Rotozoom 3"                          , new String[] {"Atmospheric", "Rotating", "Complex", "Red"}                                          );
  animationAttributes = registerAttribute(animationAttributes, 364, "Spiraluality"                        , new String[] {"Rotating", "Smooth", "Slow", "Red", "Spiral", "Evolving"}                            );
  animationAttributes = registerAttribute(animationAttributes, 365, "Rotating Half Circle"                , new String[] {"Atmospheric", "Red", "Complex", "Slow", "Smooth", "Rotating"}                        );
  animationAttributes = registerAttribute(animationAttributes, 366, "Sliced Wave - White"                 , new String[] {"Atmospheric", "White", "Circles", "Rhythmic"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 367, "Sliced Wave - Red"                   , new String[] {"Atmospheric", "Red", "Circles", "Rhythmic"}                                          );
  animationAttributes = registerAttribute(animationAttributes, 368, "Arc Wave"                            , new String[] {"Objects", "Circles", "Geometric", "B&W"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 369, "Red Sun"                             , new String[] {"Atmospheric", "Red", "Circles", "Rhythmic"}                                          );
  animationAttributes = registerAttribute(animationAttributes, 370, "Arc Rot Green"                       , new String[] {"Atmospheric", "Rhythmic", "Geometric", "Circles", "Slow", "Colorful", "Rotating"}    );
  animationAttributes = registerAttribute(animationAttributes, 371, "Arc Rot Red"                         , new String[] {"Atmospheric", "Rhythmic", "Geometric", "Circles", "Slow", "Red", "Rotating"}         );
  animationAttributes = registerAttribute(animationAttributes, 372, "Hypno Pendulum"                      , new String[] {"Spiral", "Red", "Lines", "Geometric"}                                                );
  animationAttributes = registerAttribute(animationAttributes, 373, "LargeWheel Pendulum"                 , new String[] {"Spiral", "Red", "Lines", "Geometric"}                                                );
  animationAttributes = registerAttribute(animationAttributes, 374, "Single Square Spiral"                , new String[] {"Geometric", "Spiral", "Rotating", "Red"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 375, "Dual Square Spiral"                  , new String[] {"Geometric", "Spiral", "Rotating", "Red"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 376, "Complex Spiral Reinit"               , new String[] {"Atmospheric", "Spiral", "Rotating", "Complex", "Red"}                                );
  animationAttributes = registerAttribute(animationAttributes, 377, "Complex Spiral"                      , new String[] {"Atmospheric", "Spiral", "Rotating", "Complex", "Red"}                                );
  animationAttributes = registerAttribute(animationAttributes, 378, "Outward Spiral White"                , new String[] {"Fade In/Out", "Spiral", "Slow", "Evolving", "B&W"}                                   );
  animationAttributes = registerAttribute(animationAttributes, 379, "Outward Spiral Blue"                 , new String[] {"Fade In/Out", "Spiral", "Slow", "Evolving", "Blue"}                                  );
  animationAttributes = registerAttribute(animationAttributes, 380, "Outward Spiral Red"                  , new String[] {"Fade In/Out", "Spiral", "Slow", "Evolving", "Red"}                                   );
  animationAttributes = registerAttribute(animationAttributes, 381, "Fast Outward Spiral Red"             , new String[] {"Spiral", "Circles", "Slow", "Red"}                                                   );
  animationAttributes = registerAttribute(animationAttributes, 382, "Inwards Spiral"                      , new String[] {"Spiral", "Blue", "Lines", "Red", "Geometric"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 383, "Inwards Spiral Reverse"              , new String[] {"Spiral", "Blue", "Lines", "Red", "Geometric"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 384, "Hypno Spiral Red"                    , new String[] {"Spiral", "Fast", "Red"}                                                              );
  animationAttributes = registerAttribute(animationAttributes, 385, "Electric Spiral"                     , new String[] {"Geometric", "Spiral", "Evolving", "Red"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 386, "Cosmo Curve "                        , new String[] {"Geometric", "Spiral", "Red", "Evolving"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 387, "Cosmo Curve Reinit"                  , new String[] {"Spiral", "Red", "Lines", "Complex", "Evolving"}                                      );
  animationAttributes = registerAttribute(animationAttributes, 388, "Kaleido"                             , new String[] {"Geometric", "Circles", "Evolving", "Random", "Red", "Blue", "Complex"}               );
  animationAttributes = registerAttribute(animationAttributes, 389, "Kaleido Inverse"                     , new String[] {"Geometric", "Circles", "Evolving", "Random", "Red", "Blue", "Complex"}               );
  animationAttributes = registerAttribute(animationAttributes, 390, "Revolution Lines"                    , new String[] {"Geometric", "Atmospheric", "Circles", "Colorful", "Fast"}                            );
  animationAttributes = registerAttribute(animationAttributes, 391, "Disco Star"                          , new String[] {"Atmospheric", "Rotating", "Slow", "Colorful"}                                        );
  animationAttributes = registerAttribute(animationAttributes, 392, "Worm Hole"                           , new String[] {"Atmospheric", "Rotating", "Circles", "Lines", "Slow", "Blue", "Evolving", "Rhythmic"});
  animationAttributes = registerAttribute(animationAttributes, 393, "Tetris - 1 player game"              , new String[] {"Game"}                                                                               );
  animationAttributes = registerAttribute(animationAttributes, 394, "Pong - 2 player game"                , new String[] {"Game"}                                                                               );
  animationAttributes = registerAttribute(animationAttributes, 395, "Shift Pixels Up / Slow"              , new String[] {"Special", "Slow", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 396, "Shift Pixels Down / Slow"            , new String[] {"Special", "Slow", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 397, "Shift Pixels Left / Slow"            , new String[] {"Special", "Slow", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 398, "Shift Pixels Right / Slow"           , new String[] {"Special", "Slow", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 399, "Shift Pixels Up / Fast"              , new String[] {"Special", "Fast", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 400, "Shift Pixels Down / Fast"            , new String[] {"Special", "Fast", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 401, "Shift Pixels Left / Fast"            , new String[] {"Special", "Fast", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 402, "Shift Pixels Right / Fast"           , new String[] {"Special", "Fast", "Rhythmic"}                                                        );
  animationAttributes = registerAttribute(animationAttributes, 403, "Shred Pixels Vertical / Slow"        , new String[] {"Special", "Slow", "Rhythmic", "Violent"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 404, "Shred Pixels Horizontal / Slow"      , new String[] {"Special", "Slow", "Rhythmic", "Violent"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 405, "Shred Pixels Vertical / Slow"        , new String[] {"Special", "Fast", "Rhythmic", "Violent"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 406, "Shred Pixels Horizontal / Slow"      , new String[] {"Special", "Fast", "Rhythmic", "Violent"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 407, "Spider Web - White - Manual"         , new String[] {"Geometric", "Simple", "Lines", "B&W", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 408, "Spider Web - Red - Manual"           , new String[] {"Geometric", "Simple", "Lines", "Red", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 409, "Spider Web - White Fade - Manual"    , new String[] {"Geometric", "Simple", "Lines", "B&W", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 410, "Spider Web - Red Fade - Manual"      , new String[] {"Geometric", "Simple", "Lines", "Red", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 411, "Spider Web - White - Audio"          , new String[] {"Geometric", "Simple", "Lines", "B&W", "Rhythmic", "AudioInput"}                      );
  animationAttributes = registerAttribute(animationAttributes, 412, "Woublines - White Inwards"           , new String[] {"Geometric", "Simple", "Lines", "B&W", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 413, "Woublines - White Outwards"          , new String[] {"Geometric", "Simple", "Lines", "B&W", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 414, "Woublines - Red Inwards"             , new String[] {"Geometric", "Simple", "Lines", "Red", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 415, "Woublines - Red Outwards"            , new String[] {"Geometric", "Simple", "Lines", "Red", "Rhythmic"}                                    );
  animationAttributes = registerAttribute(animationAttributes, 416, "Woublines - Audio"                   , new String[] {"Geometric", "Simple", "Lines", "B&W", "Red", "AudioInput"}                           );
  animationAttributes = registerAttribute(animationAttributes, 417, "Audio instant signal - Kick - White" , new String[] {"B&W", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 418, "Audio instant signal - Kick - Red"   , new String[] {"Red", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 419, "Audio instant signal - Snare - White", new String[] {"B&W", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 420, "Audio instant signal - Snare - Red"  , new String[] {"Red", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 421, "Audio instant signal - Cymbals - White",new String[]{"B&W", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 422, "Audio instant signal - Cymbals - Red", new String[] {"Red", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 423, "Audio instant signal - Bass - White" , new String[] {"B&W", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 424, "Audio instant signal - Bass - Red"   , new String[] {"Red", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 425, "Audio instant signal - Keys - White" , new String[] {"B&W", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 426, "Audio instant signal - Keys - Red"   , new String[] {"Red", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 427, "Audio instant signal - Guitar - White",new String[] {"B&W", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 428, "Audio instant signal - Guitar - Red" , new String[] {"Red", "AudioInput"}                                                                  );
  animationAttributes = registerAttribute(animationAttributes, 429, "Simple Spiral - White"               , new String[] {"Circles", "Spiral", "B&W", "Fast"}                                                   );
  animationAttributes = registerAttribute(animationAttributes, 430, "Simple Spiral - Red"                 , new String[] {"Circles", "Spiral", "Red", "Fast"}                                                   );
  animationAttributes = registerAttribute(animationAttributes, 431, "Single Square Spiral - White"        , new String[] {"Geometric", "Spiral", "Rotating", "White"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 432, "Dual Square Spiral - White"          , new String[] {"Geometric", "Spiral", "Rotating", "White"}                                           );
  animationAttributes = registerAttribute(animationAttributes, 433, "TV Power Off"                        , new String[] {"Simple", "Fade In/Out", "White"}                                                     );
  animationAttributes = registerAttribute(animationAttributes, 434, "White Spread - Start"                , new String[] {"Simple", "Fade In/Out", "White", "Fast"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 435, "White Spread - End"                  , new String[] {"Simple", "Fade In/Out", "White", "Fast"}                                             );
  animationAttributes = registerAttribute(animationAttributes, 436, "ScannerLine 1 - Fast White"          , new String[] {"Simple", "Fast", "White"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 437, "ScannerLine 2 - Fast White"          , new String[] {"Simple", "Fast", "White"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 438, "ScannerLine 1 - Fast Red"            , new String[] {"Simple", "Fast", "Red"}                                                              );
  animationAttributes = registerAttribute(animationAttributes, 439, "ScannerLine 2 - Fast Red"            , new String[] {"Simple", "Fast", "Red"}                                                              );  
  animationAttributes = registerAttribute(animationAttributes, 440, "ScannerLine 1 - Slow White"          , new String[] {"Simple", "Slow", "White"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 441, "ScannerLine 2 - Slow White"          , new String[] {"Simple", "Slow", "White"}                                                            );
  animationAttributes = registerAttribute(animationAttributes, 442, "ScannerLine 1 - Slow Red"            , new String[] {"Simple", "Slow", "Red"}                                                              );
  animationAttributes = registerAttribute(animationAttributes, 443, "ScannerLine 2 - Slow Red"            , new String[] {"Simple", "Slow", "Red"}                                                              );
  animationAttributes = registerAttribute(animationAttributes, 509, "Audio Monitoring"                    , new String[] {"Atmospheric", "Red", "Circles", "Rhythmic", "AudioInput"}                            );
  animationAttributes = registerAttribute(animationAttributes, 510, "Display FFT - Bass"                  , new String[] {"Geometric", "Simple", "AudioInput"}                                                  );  
}


public void setCustomDevicesActionsAttributes() {
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 1,   "All Devices - Blackout"                             , new String[] { "All Devices", "Black", "Plain"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 2,   "Rack Lights - Blackout"                             , new String[] { "Rack Lights", "Black", "Plain"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 3,   "LED Tubes   - Blackout"                             , new String[] { "LED Tubes",   "Black", "Plain"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 4,   "All Devices - Whiteout"                             , new String[] { "All Devices", "White", "Plain"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 5,   "Rack Lights - Whiteout"                             , new String[] { "Rack Lights", "White", "Plain"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 6,   "LED Tubes   - Whiteout"                             , new String[] { "LED Tubes",   "White", "Plain"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 7,   "All Devices - Redout"                               , new String[] { "All Devices", "Red", "Plain"                            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 8,   "Rack Lights - Redout"                               , new String[] { "Rack Lights", "Red", "Plain"                            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 9,   "LED Tubes   - Redout"                               , new String[] { "LED Tubes",   "Red", "Plain"                            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 10,  "All Devices - Blueout"                              , new String[] { "All Devices", "Blue", "Plain"                           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 11,  "Rack Lights - Blueout"                              , new String[] { "Rack Lights", "Blue", "Plain"                           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 12,  "LED Tubes   - Blueout"                              , new String[] { "LED Tubes",   "Blue", "Plain"                           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 13,  "All Devices - Rainbowout"                           , new String[] { "All Devices", "Rainbow", "Plain"                        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 14,  "Rack Lights - Rainbowout"                           , new String[] { "Rack Lights", "Rainbow", "Plain"                        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 15,  "LED Tubes   - Rainbowout"                           , new String[] { "LED Tubes",   "Rainbow", "Plain"                        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 16,  "All Devices - Single WhiteOut"                      , new String[] { "All Devices", "Random", "White", "Plain"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 17,  "LED Tubes   - Single WhiteOut"                      , new String[] { "LED Tubes",   "Random", "White", "Plain"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 18,  "All Devices - Single RedOut"                        , new String[] { "All Devices", "Random", "Red", "Plain"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 19,  "LED Tubes   - Single RedOut"                        , new String[] { "LED Tubes",   "Random", "Red", "Plain"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 20,  "All Devices - Single BlueOut"                       , new String[] { "All Devices", "Random", "Blue", "Plain"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 21,  "LED Tubes   - Single BlueOut"                       , new String[] { "LED Tubes",   "Random", "Blue", "Plain"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 22,  "All Devices - Single RainbowOut"                    , new String[] { "All Devices", "Random", "Rainbow", "Plain"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 23,  "LED Tubes   - Single RainbowOut"                    , new String[] { "LED Tubes",   "Random", "Rainbow", "Plain"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 24,  "All Devices - Fast White Flash"                     , new String[] { "All Devices", "Fast", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 25,  "LED Tubes   - Fast White Flash"                     , new String[] { "LED Tubes",   "Fast", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 26,  "Rack Lights - Fast White Flash"                     , new String[] { "Rack Lights", "Fast", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 27,  "All Devices - Fast Red Flash"                       , new String[] { "All Devices", "Fast", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 28,  "LED Tubes   - Fast Red Flash"                       , new String[] { "LED Tubes",   "Fast", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 29,  "Rack Lights - Fast Red Flash"                       , new String[] { "Rack Lights", "Fast", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 30,  "All Devices - Fast Blue Flash"                      , new String[] { "All Devices", "Fast", "Blue", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 31,  "LED Tubes   - Fast Blue Flash"                      , new String[] { "LED Tubes",   "Fast", "Blue", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 32,  "Rack Lights - Fast Blue Flash"                      , new String[] { "Rack Lights", "Fast", "Blue", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 33,  "All Devices - Fast Rainbow Flash"                   , new String[] { "All Devices", "Fast", "Rainbow", "Flash"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 34,  "LED Tubes   - Fast Rainbow Flash"                   , new String[] { "LED Tubes",   "Fast", "Rainbow", "Flash"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 35,  "Rack Lights - Fast Rainbow Flash"                   , new String[] { "Rack Lights", "Fast", "Rainbow", "Flash"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 36,  "All Devices - Single Fast White Flash"              , new String[] { "All Devices", "Random", "Fast", "White", "Flash"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 37,  "LED Tubes   - Single Fast White Flash"              , new String[] { "LED Tubes",   "Random", "Fast", "White", "Flash"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 38,  "All Devices - Single Fast Red Flash"                , new String[] { "All Devices", "Random", "Fast", "Red", "Flash"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 39,  "LED Tubes   - Single Fast Red Flash"                , new String[] { "LED Tubes",   "Random", "Fast", "Red", "Flash"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 40,  "All Devices - Single Fast Blue Flash"               , new String[] { "All Devices", "Random", "Fast", "Blue", "Flash"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 41,  "LED Tubes   - Single Fast Blue Flash"               , new String[] { "LED Tubes",   "Random", "Fast", "Blue", "Flash"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 42,  "All Devices - Single Fast Rainbow Flash"            , new String[] { "All Devices", "Random", "Fast", "Rainbow", "Flash"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 43,  "LED Tubes   - Single Fast Rainbow Flash"            , new String[] { "LED Tubes",   "Random", "Fast", "Rainbow", "Flash"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 44,  "All Devices - Slow White Flash"                     , new String[] { "All Devices", "Slow", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 45,  "LED Tubes   - Slow White Flash"                     , new String[] { "LED Tubes",   "Slow", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 46,  "Rack Lights - Slow White Flash"                     , new String[] { "Rack Lights", "Slow", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 47,  "All Devices - Slow Red Flash"                       , new String[] { "All Devices", "Slow", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 48,  "LED Tubes   - Slow Red Flash"                       , new String[] { "LED Tubes",   "Slow", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 49,  "Rack Lights - Slow Red Flash"                       , new String[] { "Rack Lights", "Slow", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 50,  "All Devices - Slow Blue Flash"                      , new String[] { "All Devices", "Slow", "Blue", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 51,  "LED Tubes   - Slow Blue Flash"                      , new String[] { "LED Tubes",   "Slow", "Blue", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 52,  "Rack Lights - Slow Blue Flash"                      , new String[] { "Rack Lights", "Slow", "Blue", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 53,  "All Devices - Slow Rainbow Flash"                   , new String[] { "All Devices", "Slow", "Rainbow", "Flash"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 54,  "LED Tubes   - Slow Rainbow Flash"                   , new String[] { "LED Tubes",   "Slow", "Rainbow", "Flash"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 55,  "Rack Lights - Slow Rainbow Flash"                   , new String[] { "Rack Lights", "Slow", "Rainbow", "Flash"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 56,  "All Devices - Single Slow White Flash"              , new String[] { "All Devices", "Random", "Slow", "White", "Flash"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 57,  "LED Tubes   - Single Slow White Flash"              , new String[] { "LED Tubes",   "Random", "Slow", "White", "Flash"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 58,  "All Devices - Single Slow Red Flash"                , new String[] { "All Devices", "Random", "Slow", "Red", "Flash"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 59,  "LED Tubes   - Single Slow Red Flash"                , new String[] { "LED Tubes",   "Random", "Slow", "Red", "Flash"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 60,  "All Devices - Single Slow Blue Flash"               , new String[] { "All Devices", "Random", "Slow", "Blue", "Flash"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 61,  "LED Tubes   - Single Slow Blue Flash"               , new String[] { "LED Tubes",   "Random", "Slow", "Blue", "Flash"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 62,  "All Devices - Single Slow Rainbow Flash"            , new String[] { "All Devices", "Random", "Slow", "Rainbow", "Flash"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 63,  "LED Tubes   - Single Slow Rainbow Flash"            , new String[] { "LED Tubes",   "Random", "Slow", "Rainbow", "Flash"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 64,  "All Devices - Slow White Smooth Sine"               , new String[] { "All Devices", "Slow", "White", "Smooth Sine"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 65,  "Rack Lights - Slow White Smooth Sine"               , new String[] { "Rack Lights", "Slow", "White", "Smooth Sine"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 66,  "LED Tubes   - Slow White Smooth Sine"               , new String[] { "LED Tubes",   "Slow", "White", "Smooth Sine"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 67,  "All Devices - Slow Red Smooth Sine"                 , new String[] { "All Devices", "Slow", "Red", "Smooth Sine"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 68,  "Rack Lights - Slow Red Smooth Sine"                 , new String[] { "Rack Lights", "Slow", "Red", "Smooth Sine"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 69,  "LED Tubes   - Slow Red Smooth Sine"                 , new String[] { "LED Tubes",   "Slow", "Red", "Smooth Sine"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 70,  "All Devices - Slow Blue Smooth Sine"                , new String[] { "All Devices", "Slow", "Blue", "Smooth Sine"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 71,  "Rack Lights - Slow Blue Smooth Sine"                , new String[] { "Rack Lights", "Slow", "Blue", "Smooth Sine"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 72,  "LED Tubes   - Slow Blue Smooth Sine"                , new String[] { "LED Tubes",   "Slow", "Blue", "Smooth Sine"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 73,  "All Devices - Slow Rainbow Smooth Sine"             , new String[] { "All Devices", "Slow", "Rainbow", "Smooth Sine"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 74,  "Rack Lights - Slow Rainbow Smooth Sine"             , new String[] { "Rack Lights", "Slow", "Rainbow", "Smooth Sine"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 75,  "LED Tubes   - Slow Rainbow Smooth Sine"             , new String[] { "LED Tubes",   "Slow", "Rainbow", "Smooth Sine"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 76,  "All Devices - Single Slow White Smooth Sine"        , new String[] { "All Devices", "Random", "Slow", "White", "Smooth Sine"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 77,  "LED Tubes   - Single Slow White Smooth Sine"        , new String[] { "LED Tubes",   "Random", "Slow", "White", "Smooth Sine"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 78,  "All Devices - Single Slow Red Smooth Sine"          , new String[] { "All Devices", "Random", "Slow", "Red", "Smooth Sine"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 79,  "LED Tubes   - Single Slow Red Smooth Sine"          , new String[] { "LED Tubes",   "Random", "Slow", "Red", "Smooth Sine"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 80,  "All Devices - Single Slow Blue Smooth Sine"         , new String[] { "All Devices", "Random", "Slow", "Blue", "Smooth Sine"   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 81,  "LED Tubes   - Single Slow Blue Smooth Sine"         , new String[] { "LED Tubes",   "Random", "Slow", "Blue", "Smooth Sine"   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 82,  "All Devices - Single Slow Rainbow Smooth Sine"      , new String[] { "All Devices", "Random", "Slow", "Rainbow", "Smooth Sine"} );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 83,  "LED Tubes   - Single Slow Rainbow Smooth Sine"      , new String[] { "LED Tubes",   "Random", "Slow", "Rainbow", "Smooth Sine"} );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 84,  "All Devices - Fast White Smooth Sine"               , new String[] { "All Devices", "Fast", "White", "Smooth Sine"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 85,  "Rack Lights - Fast White Smooth Sine"               , new String[] { "Rack Lights", "Fast", "White", "Smooth Sine"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 86,  "LED Tubes   - Fast White Smooth Sine"               , new String[] { "LED Tubes",   "Fast", "White", "Smooth Sine"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 87,  "All Devices - Fast Red Smooth Sine"                 , new String[] { "All Devices", "Fast", "Red", "Smooth Sine"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 88,  "Rack Lights - Fast Red Smooth Sine"                 , new String[] { "Rack Lights", "Fast", "Red", "Smooth Sine"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 89,  "LED Tubes   - Fast Red Smooth Sine"                 , new String[] { "LED Tubes",   "Fast", "Red", "Smooth Sine"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 90,  "All Devices - Fast Blue Smooth Sine"                , new String[] { "All Devices", "Fast", "Blue", "Smooth Sine"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 91,  "Rack Lights - Fast Blue Smooth Sine"                , new String[] { "Rack Lights", "Fast", "Blue", "Smooth Sine"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 92,  "LED Tubes   - Fast Blue Smooth Sine"                , new String[] { "LED Tubes",   "Fast", "Blue", "Smooth Sine"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 93,  "All Devices - Fast Rainbow Smooth Sine"             , new String[] { "All Devices", "Fast", "Rainbow", "Smooth Sine"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 94,  "Rack Lights - Fast Rainbow Smooth Sine"             , new String[] { "Rack Lights", "Fast", "Rainbow", "Smooth Sine"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 95,  "LED Tubes   - Fast Rainbow Smooth Sine"             , new String[] { "LED Tubes",   "Fast", "Rainbow", "Smooth Sine"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 96,  "All Devices - Single Fast White Smooth Sine"        , new String[] { "All Devices", "Random", "Fast", "White", "Smooth Sine"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 97,  "LED Tubes   - Single Fast White Smooth Sine"        , new String[] { "LED Tubes",   "Random", "Fast", "White", "Smooth Sine"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 98,  "All Devices - Single Fast Red Smooth Sine"          , new String[] { "All Devices", "Random", "Fast", "Red", "Smooth Sine"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 99,  "LED Tubes   - Single Fast Red Smooth Sine"          , new String[] { "LED Tubes",   "Random", "Fast", "Red", "Smooth Sine"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 100, "All Devices - Single Fast Blue Smooth Sine"         , new String[] { "All Devices", "Random", "Fast", "Blue", "Smooth Sine"   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 101, "LED Tubes   - Single Fast Blue Smooth Sine"         , new String[] { "LED Tubes",   "Random", "Fast", "Blue", "Smooth Sine"   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 102, "All Devices - Single Fast Rainbow Smooth Sine"      , new String[] { "All Devices", "Random", "Fast", "Rainbow", "Smooth Sine"} );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 103, "LED Tubes   - Single Fast Rainbow Smooth Sine"      , new String[] { "LED Tubes",   "Random", "Fast", "Rainbow", "Smooth Sine"} );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 104, "All Devices - Fast White Stroboscope"               , new String[] { "All Devices", "Fast", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 105, "LED Tubes   - Fast White Stroboscope"               , new String[] { "LED Tubes",   "Fast", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 106, "Rack Lights - Fast White Stroboscope"               , new String[] { "Rack Lights", "Fast", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 107, "All Devices - Fast Red Stroboscope"                 , new String[] { "All Devices", "Fast", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 108, "LED Tubes   - Fast Red Stroboscope"                 , new String[] { "LED Tubes",   "Fast", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 109, "Rack Lights - Fast Red Stroboscope"                 , new String[] { "Rack Lights", "Fast", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 110, "All Devices - Fast Blue Stroboscope"                , new String[] { "All Devices", "Fast", "Blue", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 111, "LED Tubes   - Fast Blue Stroboscope"                , new String[] { "LED Tubes",   "Fast", "Blue", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 112, "Rack Lights - Fast Blue Stroboscope"                , new String[] { "Rack Lights", "Fast", "Blue", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 113, "All Devices - Fast Random Color Stroboscope"        , new String[] { "All Devices", "Fast", "Rainbow", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 114, "LED Tubes   - Fast Random Color Stroboscope"        , new String[] { "LED Tubes",   "Fast", "Rainbow", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 115, "Rack Lights - Fast Random Color Stroboscope"        , new String[] { "Rack Lights", "Fast", "Rainbow", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 116, "All Devices - Medium White Stroboscope"             , new String[] { "All Devices", "Medium", "White", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 117, "LED Tubes   - Medium White Stroboscope"             , new String[] { "LED Tubes",   "Medium", "White", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 118, "Rack Lights - Medium White Stroboscope"             , new String[] { "Rack Lights", "Medium", "White", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 119, "All Devices - Medium Red Stroboscope"               , new String[] { "All Devices", "Medium", "Red", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 120, "LED Tubes   - Medium Red Stroboscope"               , new String[] { "LED Tubes",   "Medium", "Red", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 121, "Rack Lights - Medium Red Stroboscope"               , new String[] { "Rack Lights", "Medium", "Red", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 122, "All Devices - Medium Blue Stroboscope"              , new String[] { "All Devices", "Medium", "Blue", "Stroboscope"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 123, "LED Tubes   - Medium Blue Stroboscope"              , new String[] { "LED Tubes",   "Medium", "Blue", "Stroboscope"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 124, "Rack Lights - Medium Blue Stroboscope"              , new String[] { "Rack Lights", "Medium", "Blue", "Stroboscope"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 125, "All Devices - Medium Random Color Stroboscope"      , new String[] { "All Devices", "Medium", "Rainbow", "Stroboscope"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 126, "LED Tubes   - Medium Random Color Stroboscope"      , new String[] { "LED Tubes",   "Medium", "Rainbow", "Stroboscope"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 127, "Rack Lights - Medium Random Color Stroboscope"      , new String[] { "Rack Lights", "Medium", "Rainbow", "Stroboscope"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 128, "All Devices - Slow White Stroboscope"               , new String[] { "All Devices", "Slow", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 129, "LED Tubes   - Slow White Stroboscope"               , new String[] { "LED Tubes",   "Slow", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 130, "Rack Lights - Slow White Stroboscope"               , new String[] { "Rack Lights", "Slow", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 131, "All Devices - Slow Red Stroboscope"                 , new String[] { "All Devices", "Slow", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 132, "LED Tubes   - Slow Red Stroboscope"                 , new String[] { "LED Tubes",   "Slow", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 133, "Rack Lights - Slow Red Stroboscope"                 , new String[] { "Rack Lights", "Slow", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 134, "All Devices - Slow Blue Stroboscope"                , new String[] { "All Devices", "Slow", "Blue", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 135, "LED Tubes   - Slow Blue Stroboscope"                , new String[] { "LED Tubes",   "Slow", "Blue", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 136, "Rack Lights - Slow Blue Stroboscope"                , new String[] { "Rack Lights", "Slow", "Blue", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 137, "All Devices - Slow Random Color Stroboscope"        , new String[] { "All Devices", "Slow", "Rainbow", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 138, "LED Tubes   - Slow Random Color Stroboscope"        , new String[] { "LED Tubes",   "Slow", "Rainbow", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 139, "Rack Lights - Slow Random Color Stroboscope"        , new String[] { "Rack Lights", "Slow", "Rainbow", "Stroboscope"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 140, "All Devices - Very Slow White Stroboscope"          , new String[] { "All Devices", "Very Slow", "White", "Stroboscope"       } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 141, "LED Tubes   - Very Slow White Stroboscope"          , new String[] { "LED Tubes",   "Very Slow", "White", "Stroboscope"       } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 142, "Rack Lights - Very Slow White Stroboscope"          , new String[] { "Rack Lights", "Very Slow", "White", "Stroboscope"       } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 143, "All Devices - Very Slow Red Stroboscope"            , new String[] { "All Devices", "Very Slow", "Red", "Stroboscope"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 144, "LED Tubes   - Very Slow Red Stroboscope"            , new String[] { "LED Tubes",   "Very Slow", "Red", "Stroboscope"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 145, "Rack Lights - Very Slow Red Stroboscope"            , new String[] { "Rack Lights", "Very Slow", "Red", "Stroboscope"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 146, "All Devices - Very Slow Blue Stroboscope"           , new String[] { "All Devices", "Very Slow", "Blue", "Stroboscope"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 147, "LED Tubes   - Very Slow Blue Stroboscope"           , new String[] { "LED Tubes",   "Very Slow", "Blue", "Stroboscope"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 148, "Rack Lights - Very Slow Blue Stroboscope"           , new String[] { "Rack Lights", "Very Slow", "Blue", "Stroboscope"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 149, "All Devices - Very Slow Random Color Stroboscope"   , new String[] { "All Devices", "Very Slow", "Rainbow", "Stroboscope"     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 150, "LED Tubes   - Very Slow Random Color Stroboscope"   , new String[] { "LED Tubes",   "Very Slow", "Rainbow", "Stroboscope"     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 151, "Rack Lights - Very Slow Random Color Stroboscope"   , new String[] { "Rack Lights", "Very Slow", "Rainbow", "Stroboscope"     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 152, "All Devices - Fast White Growing Stroboscope"       , new String[] { "All Devices", "Fast", "White", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 153, "LED Tubes   - Fast White Growing Stroboscope"       , new String[] { "LED Tubes",   "Fast", "White", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 154, "Rack Lights - Fast White Growing Stroboscope"       , new String[] { "Rack Lights", "Fast", "White", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 155, "All Devices - Fast Red Growing Stroboscope"         , new String[] { "All Devices", "Fast", "Red", "Growing Strobe"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 156, "LED Tubes   - Fast Red Growing Stroboscope"         , new String[] { "LED Tubes",   "Fast", "Red", "Growing Strobe"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 157, "Rack Lights - Fast Red Growing Stroboscope"         , new String[] { "Rack Lights", "Fast", "Red", "Growing Strobe"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 158, "All Devices - Medium White Growing Stroboscope"     , new String[] { "All Devices", "Medium", "White", "Growing Strobe"       } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 159, "LED Tubes   - Medium White Growing Stroboscope"     , new String[] { "LED Tubes",   "Medium", "White", "Growing Strobe"       } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 160, "Rack Lights - Medium White Growing Stroboscope"     , new String[] { "Rack Lights", "Medium", "White", "Growing Strobe"       } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 161, "All Devices - Medium Red Growing Stroboscope"       , new String[] { "All Devices", "Medium", "Red", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 162, "LED Tubes   - Medium Red Growing Stroboscope"       , new String[] { "LED Tubes",   "Medium", "Red", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 163, "Rack Lights - Medium Red Growing Stroboscope"       , new String[] { "Rack Lights", "Medium", "Red", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 164, "All Devices - Slow White Growing Stroboscope"       , new String[] { "All Devices", "Slow", "White", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 165, "LED Tubes   - Slow White Growing Stroboscope"       , new String[] { "LED Tubes",   "Slow", "White", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 166, "Rack Lights - Slow White Growing Stroboscope"       , new String[] { "Rack Lights", "Slow", "White", "Growing Strobe"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 167, "All Devices - Slow Red Growing Stroboscope"         , new String[] { "All Devices", "Slow", "Red", "Growing Strobe"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 168, "LED Tubes   - Slow Red Growing Stroboscope"         , new String[] { "LED Tubes",   "Slow", "Red", "Growing Strobe"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 169, "Rack Lights - Slow Red Growing Stroboscope"         , new String[] { "Rack Lights", "Slow", "Red", "Growing Strobe"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 170, "All Devices - Very Slow White Growing Stroboscope"  , new String[] { "All Devices", "Very Slow", "White", "Growing Strobe"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 171, "LED Tubes   - Very Slow White Growing Stroboscope"  , new String[] { "LED Tubes",   "Very Slow", "White", "Growing Strobe"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 172, "Rack Lights - Very Slow White Growing Stroboscope"  , new String[] { "Rack Lights", "Very Slow", "White", "Growing Strobe"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 173, "All Devices - Very Slow Red Growing Stroboscope"    , new String[] { "All Devices", "Very Slow", "Red", "Growing Strobe"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 174, "LED Tubes   - Very Slow Red Growing Stroboscope"    , new String[] { "LED Tubes",   "Very Slow", "Red", "Growing Strobe"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 175, "Rack Lights - Very Slow Red Growing Stroboscope"    , new String[] { "Rack Lights", "Very Slow", "Red", "Growing Strobe"      } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 176, "All Devices - Long White Upward Single Wave"        , new String[] { "All Devices", "Long", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 177, "LED Tubes   - Long White Upward Single Wave"        , new String[] { "LED Tubes",   "Long", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 178, "Rack Lights - Long White Upward Single Wave"        , new String[] { "Rack Lights", "Long", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 179, "All Devices - Long Red Upward Single Wave"          , new String[] { "All Devices", "Long", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 180, "LED Tubes   - Long Red Upward Single Wave"          , new String[] { "LED Tubes",   "Long", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 181, "Rack Lights - Long Red Upward Single Wave"          , new String[] { "Rack Lights", "Long", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 182, "All Devices - Long Blue Upward Single Wave"         , new String[] { "All Devices", "Long", "Blue", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 183, "LED Tubes   - Long Blue Upward Single Wave"         , new String[] { "LED Tubes",   "Long", "Blue", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 184, "Rack Lights - Long Blue Upward Single Wave"         , new String[] { "Rack Lights", "Long", "Blue", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 185, "All Devices - Short White Upward Single Wave"       , new String[] { "All Devices", "Short", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 186, "LED Tubes   - Short White Upward Single Wave"       , new String[] { "LED Tubes",   "Short", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 187, "Rack Lights - Short White Upward Single Wave"       , new String[] { "Rack Lights", "Short", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 188, "All Devices - Short Red Upward Single Wave"         , new String[] { "All Devices", "Short", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 189, "LED Tubes   - Short Red Upward Single Wave"         , new String[] { "LED Tubes",   "Short", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 190, "Rack Lights - Short Red Upward Single Wave"         , new String[] { "Rack Lights", "Short", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 191, "All Devices - Short Blue Upward Single Wave"        , new String[] { "All Devices", "Short", "Blue", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 192, "LED Tubes   - Short Blue Upward Single Wave"        , new String[] { "LED Tubes",   "Short", "Blue", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 193, "Rack Lights - Short Blue Upward Single Wave"        , new String[] { "Rack Lights", "Short", "Blue", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 194, "All Devices - Long White Downward Single Wave"      , new String[] { "All Devices", "Long", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 195, "LED Tubes   - Long White Downward Single Wave"      , new String[] { "LED Tubes",   "Long", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 196, "Rack Lights - Long White Downward Single Wave"      , new String[] { "Rack Lights", "Long", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 197, "All Devices - Long Red Downward Single Wave"        , new String[] { "All Devices", "Long", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 198, "LED Tubes   - Long Red Downward Single Wave"        , new String[] { "LED Tubes",   "Long", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 199, "Rack Lights - Long Red Downward Single Wave"        , new String[] { "Rack Lights", "Long", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 200, "All Devices - Long Blue Downward Single Wave"       , new String[] { "All Devices", "Long", "Blue", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 201, "LED Tubes   - Long Blue Downward Single Wave"       , new String[] { "LED Tubes",   "Long", "Blue", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 202, "Rack Lights - Long Blue Downward Single Wave"       , new String[] { "Rack Lights", "Long", "Blue", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 203, "All Devices - Short White Downward Single Wave"     , new String[] { "All Devices", "Short", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 204, "LED Tubes   - Short White Downward Single Wave"     , new String[] { "LED Tubes",   "Short", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 205, "Rack Lights - Short White Downward Single Wave"     , new String[] { "Rack Lights", "Short", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 206, "All Devices - Short Red Downward Single Wave"       , new String[] { "All Devices", "Short", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 207, "LED Tubes   - Short Red Downward Single Wave"       , new String[] { "LED Tubes",   "Short", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 208, "Rack Lights - Short Red Downward Single Wave"       , new String[] { "Rack Lights", "Short", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 209, "All Devices - Short Blue Downward Single Wave"      , new String[] { "All Devices", "Short", "Blue", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 210, "LED Tubes   - Short Blue Downward Single Wave"      , new String[] { "LED Tubes",   "Short", "Blue", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 211, "Rack Lights - Short Blue Downward Single Wave"      , new String[] { "Rack Lights", "Short", "Blue", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 212, "All Devices - Fast White BuildUp"                   , new String[] { "All Devices", "Fast", "White", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 213, "LED Tubes   - Fast White BuildUp"                   , new String[] { "LED Tubes",   "Fast", "White", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 214, "Rack Lights - Fast White BuildUp"                   , new String[] { "Rack Lights", "Fast", "White", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 215, "All Devices - Fast Red BuildUp"                     , new String[] { "All Devices", "Fast", "Red", "BuildUp"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 216, "LED Tubes   - Fast Red BuildUp"                     , new String[] { "LED Tubes",   "Fast", "Red", "BuildUp"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 217, "Rack Lights - Fast Red BuildUp"                     , new String[] { "Rack Lights", "Fast", "Red", "BuildUp"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 218, "All Devices - Fast Blue BuildUp"                    , new String[] { "All Devices", "Fast", "Blue", "BuildUp"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 219, "LED Tubes   - Fast Blue BuildUp"                    , new String[] { "LED Tubes",   "Fast", "Blue", "BuildUp"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 220, "Rack Lights - Fast Blue BuildUp"                    , new String[] { "Rack Lights", "Fast", "Blue", "BuildUp"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 221, "All Devices - Fast Rainbow BuildUp"                 , new String[] { "All Devices", "Fast", "Rainbow", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 222, "LED Tubes   - Fast Rainbow BuildUp"                 , new String[] { "LED Tubes",   "Fast", "Rainbow", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 223, "Rack Lights - Fast Rainbow BuildUp"                 , new String[] { "Rack Lights", "Fast", "Rainbow", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 224, "All Devices - Medium White BuildUp"                 , new String[] { "All Devices", "Medium", "White", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 225, "LED Tubes   - Medium White BuildUp"                 , new String[] { "LED Tubes",   "Medium", "White", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 226, "Rack Lights - Medium White BuildUp"                 , new String[] { "Rack Lights", "Medium", "White", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 227, "All Devices - Medium Red BuildUp"                   , new String[] { "All Devices", "Medium", "Red", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 228, "LED Tubes   - Medium Red BuildUp"                   , new String[] { "LED Tubes",   "Medium", "Red", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 229, "Rack Lights - Medium Red BuildUp"                   , new String[] { "Rack Lights", "Medium", "Red", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 230, "All Devices - Medium Blue BuildUp"                  , new String[] { "All Devices", "Medium", "Blue", "BuildUp"               } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 231, "LED Tubes   - Medium Blue BuildUp"                  , new String[] { "LED Tubes",   "Medium", "Blue", "BuildUp"               } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 232, "Rack Lights - Medium Blue BuildUp"                  , new String[] { "Rack Lights", "Medium", "Blue", "BuildUp"               } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 233, "All Devices - Medium Rainbow BuildUp"               , new String[] { "All Devices", "Medium", "Rainbow", "BuildUp"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 234, "LED Tubes   - Medium Rainbow BuildUp"               , new String[] { "LED Tubes",   "Medium", "Rainbow", "BuildUp"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 235, "Rack Lights - Medium Rainbow BuildUp"               , new String[] { "Rack Lights", "Medium", "Rainbow", "BuildUp"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 236, "All Devices - Slow White BuildUp"                   , new String[] { "All Devices", "Slow", "White", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 237, "LED Tubes   - Slow White BuildUp"                   , new String[] { "LED Tubes",   "Slow", "White", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 238, "Rack Lights - Slow White BuildUp"                   , new String[] { "Rack Lights", "Slow", "White", "BuildUp"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 239, "All Devices - Slow Red BuildUp"                     , new String[] { "All Devices", "Slow", "Red", "BuildUp"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 240, "LED Tubes   - Slow Red BuildUp"                     , new String[] { "LED Tubes",   "Slow", "Red", "BuildUp"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 241, "Rack Lights - Slow Red BuildUp"                     , new String[] { "Rack Lights", "Slow", "Red", "BuildUp"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 242, "All Devices - Slow Blue BuildUp"                    , new String[] { "All Devices", "Slow", "Blue", "BuildUp"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 243, "LED Tubes   - Slow Blue BuildUp"                    , new String[] { "LED Tubes",   "Slow", "Blue", "BuildUp"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 244, "Rack Lights - Slow Blue BuildUp"                    , new String[] { "Rack Lights", "Slow", "Blue", "BuildUp"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 245, "All Devices - Slow Rainbow BuildUp"                 , new String[] { "All Devices", "Slow", "Rainbow", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 246, "LED Tubes   - Slow Rainbow BuildUp"                 , new String[] { "LED Tubes",   "Slow", "Rainbow", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 247, "Rack Lights - Slow Rainbow BuildUp"                 , new String[] { "Rack Lights", "Slow", "Rainbow", "BuildUp"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 248, "All Devices - Very Slow White BuildUp"              , new String[] { "All Devices", "Very Slow", "White", "BuildUp"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 249, "LED Tubes   - Very Slow White BuildUp"              , new String[] { "LED Tubes",   "Very Slow", "White", "BuildUp"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 250, "Rack Lights - Very Slow White BuildUp"              , new String[] { "Rack Lights", "Very Slow", "White", "BuildUp"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 251, "All Devices - Very Slow Red BuildUp"                , new String[] { "All Devices", "Very Slow", "Red", "BuildUp"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 252, "LED Tubes   - Very Slow Red BuildUp"                , new String[] { "LED Tubes",   "Very Slow", "Red", "BuildUp"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 253, "Rack Lights - Very Slow Red BuildUp"                , new String[] { "Rack Lights", "Very Slow", "Red", "BuildUp"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 254, "All Devices - Very Slow Blue BuildUp"               , new String[] { "All Devices", "Very Slow", "Blue", "BuildUp"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 255, "LED Tubes   - Very Slow Blue BuildUp"               , new String[] { "LED Tubes",   "Very Slow", "Blue", "BuildUp"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 256, "Rack Lights - Very Slow Blue BuildUp"               , new String[] { "Rack Lights", "Very Slow", "Blue", "BuildUp"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 257, "All Devices - Very Slow Rainbow BuildUp"            , new String[] { "All Devices", "Very Slow", "Rainbow", "BuildUp"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 258, "LED Tubes   - Very Slow Rainbow BuildUp"            , new String[] { "LED Tubes",   "Very Slow", "Rainbow", "BuildUp"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 259, "Rack Lights - Very Slow Rainbow BuildUp"            , new String[] { "Rack Lights", "Very Slow", "Rainbow", "BuildUp"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 260, "All Devices - White Noise"                          , new String[] { "All Devices", "White", "Noise"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 261, "Rack Lights - White Noise"                          , new String[] { "Rack Lights", "White", "Noise"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 262, "LED Tubes   - White Noise"                          , new String[] { "LED Tubes",   "White", "Noise"                          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 263, "All Devices - Red Noise"                            , new String[] { "All Devices", "Red", "Noise"                            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 264, "Rack Lights - Red Noise"                            , new String[] { "Rack Lights", "Red", "Noise"                            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 265, "LED Tubes   - Red Noise"                            , new String[] { "LED Tubes",   "Red", "Noise"                            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 266, "All Devices - Blue Noise"                           , new String[] { "All Devices", "Blue", "Noise"                           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 267, "Rack Lights - Blue Noise"                           , new String[] { "Rack Lights", "Blue", "Noise"                           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 268, "LED Tubes   - Blue Noise"                           , new String[] { "LED Tubes",   "Blue", "Noise"                           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 269, "All Devices - Rainbow Noise"                        , new String[] { "All Devices", "Rainbow", "Noise"                        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 270, "Rack Lights - Rainbow Noise"                        , new String[] { "Rack Lights", "Rainbow", "Noise"                        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 271, "LED Tubes   - Rainbow Noise"                        , new String[] { "LED Tubes",   "Rainbow", "Noise"                        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 272, "All Devices - Fast White Smooth Noise"              , new String[] { "All Devices", "Fast", "White", "Smooth Noise"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 273, "Rack Lights - Fast White Smooth Noise"              , new String[] { "Rack Lights", "Fast", "White", "Smooth Noise"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 274, "LED Tubes   - Fast White Smooth Noise"              , new String[] { "LED Tubes",   "Fast", "White", "Smooth Noise"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 275, "All Devices - Fast Red Smooth Noise"                , new String[] { "All Devices", "Fast", "Red", "Smooth Noise"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 276, "Rack Lights - Fast Red Smooth Noise"                , new String[] { "Rack Lights", "Fast", "Red", "Smooth Noise"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 277, "LED Tubes   - Fast Red Smooth Noise"                , new String[] { "LED Tubes",   "Fast", "Red", "Smooth Noise"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 278, "All Devices - Fast Blue Smooth Noise"               , new String[] { "All Devices", "Fast", "Blue", "Smooth Noise"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 279, "Rack Lights - Fast Blue Smooth Noise"               , new String[] { "Rack Lights", "Fast", "Blue", "Smooth Noise"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 280, "LED Tubes   - Fast Blue Smooth Noise"               , new String[] { "LED Tubes",   "Fast", "Blue", "Smooth Noise"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 281, "All Devices - Fast Rainbow Smooth Noise"            , new String[] { "All Devices", "Fast", "Rainbow", "Smooth Noise"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 282, "Rack Lights - Fast Rainbow Smooth Noise"            , new String[] { "Rack Lights", "Fast", "Rainbow", "Smooth Noise"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 283, "LED Tubes   - Fast Rainbow Smooth Noise"            , new String[] { "LED Tubes",   "Fast", "Rainbow", "Smooth Noise"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 284, "All Devices - Slow White Smooth Noise"              , new String[] { "All Devices", "Slow", "White", "Smooth Noise"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 285, "Rack Lights - Slow White Smooth Noise"              , new String[] { "Rack Lights", "Slow", "White", "Smooth Noise"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 286, "LED Tubes   - Slow White Smooth Noise"              , new String[] { "LED Tubes",   "Slow", "White", "Smooth Noise"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 287, "All Devices - Slow Red Smooth Noise"                , new String[] { "All Devices", "Slow", "Red", "Smooth Noise"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 288, "Rack Lights - Slow Red Smooth Noise"                , new String[] { "Rack Lights", "Slow", "Red", "Smooth Noise"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 289, "LED Tubes   - Slow Red Smooth Noise"                , new String[] { "LED Tubes",   "Slow", "Red", "Smooth Noise"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 290, "All Devices - Slow Blue Smooth Noise"               , new String[] { "All Devices", "Slow", "Blue", "Smooth Noise"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 291, "Rack Lights - Slow Blue Smooth Noise"               , new String[] { "Rack Lights", "Slow", "Blue", "Smooth Noise"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 292, "LED Tubes   - Slow Blue Smooth Noise"               , new String[] { "LED Tubes",   "Slow", "Blue", "Smooth Noise"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 293, "All Devices - Slow Rainbow Smooth Noise"            , new String[] { "All Devices", "Slow", "Rainbow", "Smooth Noise"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 294, "Rack Lights - Slow Rainbow Smooth Noise"            , new String[] { "Rack Lights", "Slow", "Rainbow", "Smooth Noise"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 295, "LED Tubes   - Slow Rainbow Smooth Noise"            , new String[] { "LED Tubes",   "Slow", "Rainbow", "Smooth Noise"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 296, "LED Tubes   - Random Whiteout"                      , new String[] { "LED Tubes",   "Random", "White", "Plain"                } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 297, "LED Tubes   - Random Redout"                        , new String[] { "LED Tubes",   "Random", "Red", "Plain"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 298, "LED Tubes   - Random Blueout"                       , new String[] { "LED Tubes",   "Random", "Blue", "Plain"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 299, "LED Tubes   - Random Rainbowout"                    , new String[] { "LED Tubes",   "Random", "Rainbow", "Plain"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 300, "LED Tubes   - Random Fast White Stroboscope"        , new String[] { "LED Tubes",   "Random", "White", "Fast", "Stroboscope"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 301, "LED Tubes   - Random Fast Red Stroboscope"          , new String[] { "LED Tubes",   "Random", "Red", "Fast", "Stroboscope"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 302, "LED Tubes   - Random Fast Blue Stroboscope"         , new String[] { "LED Tubes",   "Random", "Blue", "Fast", "Stroboscope"   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 303, "LED Tubes   - Random Medium White Stroboscope"      , new String[] { "LED Tubes",   "Random", "White", "Medium", "Stroboscope"} );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 304, "LED Tubes   - Random Medium Red Stroboscope"        , new String[] { "LED Tubes",   "Random", "Red", "Medium", "Stroboscope"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 305, "LED Tubes   - Random Medium Blue Stroboscope"       , new String[] { "LED Tubes",   "Random", "Blue", "Medium", "Stroboscope" } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 306, "LED Tubes   - Random Slow White Stroboscope"        , new String[] { "LED Tubes",   "Random", "White", "Slow", "Stroboscope"  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 307, "LED Tubes   - Random Slow Red Stroboscope"          , new String[] { "LED Tubes",   "Random", "Red", "Slow", "Stroboscope"    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 308, "LED Tubes   - Random Slow Blue Stroboscope"         , new String[] { "LED Tubes",   "Random", "Blue", "Slow", "Stroboscope"   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 309, "LED Tubes   - Random Slow White Flash"              , new String[] { "LED Tubes",   "Random", "White", "Slow", "Flash"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 310, "LED Tubes   - Random Slow Red Flash"                , new String[] { "LED Tubes",   "Random", "Red", "Slow", "Flash"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 311, "LED Tubes   - Random Slow Blue Flash"               , new String[] { "LED Tubes",   "Random", "Blue", "Slow", "Flash"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 312, "LED Tubes   - Random Fast White Flash"              , new String[] { "LED Tubes",   "Random", "White", "Fast", "Flash"        } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 313, "LED Tubes   - Random Fast Red Flash"                , new String[] { "LED Tubes",   "Random", "Red", "Fast", "Flash"          } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 314, "LED Tubes   - Random Fast Blue Flash"               , new String[] { "LED Tubes",   "Random", "Blue", "Fast", "Flash"         } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 315, "LED Tubes   - Left Side Whiteout"                   , new String[] { "LED Tubes",   "Left", "White", "Plain"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 316, "LED Tubes   - Left Side Redout"                     , new String[] { "LED Tubes",   "Left", "Red", "Plain"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 317, "LED Tubes   - Left Side White Flash"                , new String[] { "LED Tubes",   "Left", "White", "Flash"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 318, "LED Tubes   - Left Side Red Flash"                  , new String[] { "LED Tubes",   "Left", "Red", "Flash"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 319, "LED Tubes   - Left Side White Stroboscope"          , new String[] { "LED Tubes",   "Left", "White", "Stroboscope"            } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 320, "LED Tubes   - Left Side Red Stroboscope"            , new String[] { "LED Tubes",   "Left", "Red", "Stroboscope"              } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 321, "LED Tubes   - Left Side White Upwards Short Wave"   , new String[] { "LED Tubes",   "Left", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 322, "LED Tubes   - Left Side Red Upwards Short Wave"     , new String[] { "LED Tubes",   "Left", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 323, "LED Tubes   - Left Side White Downwards Short Wave" , new String[] { "LED Tubes",   "Left", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 324, "LED Tubes   - Left Side Red Downwards Short Wave"   , new String[] { "LED Tubes",   "Left", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 325, "LED Tubes   - Left Side White Upwards Long Wave"    , new String[] { "LED Tubes",   "Left", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 326, "LED Tubes   - Left Side Red Upwards Long Wave"      , new String[] { "LED Tubes",   "Left", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 327, "LED Tubes   - Left Side White Downwards Long Wave"  , new String[] { "LED Tubes",   "Left", "White", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 328, "LED Tubes   - Left Side Red Downwards Long Wave"    , new String[] { "LED Tubes",   "Left", "Red", "Wave"                     } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 329, "LED Tubes   - Right Side Whiteout"                  , new String[] { "LED Tubes",   "Right", "White", "Plain"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 330, "LED Tubes   - Right Side Redout"                    , new String[] { "LED Tubes",   "Right", "Red", "Plain"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 331, "LED Tubes   - Right Side White Flash"               , new String[] { "LED Tubes",   "Right", "White", "Flash"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 332, "LED Tubes   - Right Side Red Flash"                 , new String[] { "LED Tubes",   "Right", "Red", "Flash"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 333, "LED Tubes   - Right Side White Stroboscope"         , new String[] { "LED Tubes",   "Right", "White", "Stroboscope"           } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 334, "LED Tubes   - Right Side Red Stroboscope"           , new String[] { "LED Tubes",   "Right", "Red", "Stroboscope"             } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 335, "LED Tubes   - Right Side White Upwards Short Wave"  , new String[] { "LED Tubes",   "Right", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 336, "LED Tubes   - Right Side Red Upwards Short Wave"    , new String[] { "LED Tubes",   "Right", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 337, "LED Tubes   - Right Side White Downwards Short Wave", new String[] { "LED Tubes",   "Right", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 338, "LED Tubes   - Right Side Red Downwards Short Wave"  , new String[] { "LED Tubes",   "Right", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 339, "LED Tubes   - Right Side White Upwards Long Wave"   , new String[] { "LED Tubes",   "Right", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 340, "LED Tubes   - Right Side Red Upwards Long Wave"     , new String[] { "LED Tubes",   "Right", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 341, "LED Tubes   - Right Side White Downwards Long Wave" , new String[] { "LED Tubes",   "Right", "White", "Wave"                  } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 342, "LED Tubes   - Right Side Red Downwards Long Wave"   , new String[] { "LED Tubes",   "Right", "Red", "Wave"                    } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 343, "LED Tubes   - Random White Upwards Short Wave"      , new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 344, "LED Tubes   - Random Red Upwards Short Wave"        , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 345, "LED Tubes   - Random White Upwards Long Wave"       , new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 346, "LED Tubes   - Random Red Upwards Long Wave"         , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 347, "LED Tubes   - Random White Downwards Short Wave"    , new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 348, "LED Tubes   - Random Red Downwards Short Wave"      , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 349, "LED Tubes   - Random White Downwards Long Wave"     , new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 350, "LED Tubes   - Random Red Downwards Long Wave"       , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 351, "LED Tubes   - Random White Upwards Short Wave"      , new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 352, "LED Tubes   - Single Tube Red Upwards Short Wave"   , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 353, "LED Tubes   - Single Tube White Upwards Long Wave"  , new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 354, "LED Tubes   - Single Tube Red Upwards Long Wave"    , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 355, "LED Tubes   - Single Tube White Downwards Short Wave",new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 356, "LED Tubes   - Single Tube Red Downwards Short Wave" , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 357, "LED Tubes   - Single Tube White Downwards Long Wave", new String[] { "LED Tubes",   "Random", "White", "Wave"                 } );
  customDevicesAttributes = registerAttribute(customDevicesAttributes, 358, "LED Tubes   - Single Tube Red Downwards Long Wave"  , new String[] { "LED Tubes",   "Random", "Red", "Wave"                   } );
}

public void setDMXAnimationsAttributes() {
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 1,   "All Devices - Blackout"                              , new String[] { "Strobe", "PAR", "All"                                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 2,   "Full Strobe - Very Slow"                             , new String[] { "Strobe", "All", "Very Slow"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 3,   "Full Strobe - Slow"                                  , new String[] { "Strobe", "All", "Slow"                                                     } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 4,   "Full Strobe - Medium"                                , new String[] { "Strobe", "All", "Medium"                                                   } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 5,   "Full Strobe - Fast"                                  , new String[] { "Strobe", "All", "Fast"                                                     } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 6,   "Full Strobe - Very Fast"                             , new String[] { "Strobe", "All", "Very Fast"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 7,   "Left Strobe - Very Slow"                             , new String[] { "Strobe", "Left", "Very Slow"                                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 8,   "Left Strobe - Slow"                                  , new String[] { "Strobe", "Left", "Slow"                                                    } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 9,   "Left Strobe - Medium"                                , new String[] { "Strobe", "Left", "Medium"                                                  } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 10,  "Left Strobe - Fast"                                  , new String[] { "Strobe", "Left", "Fast"                                                    } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 11,  "Left Strobe - Very Fast"                             , new String[] { "Strobe", "Left", "Very Fast"                                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 12,  "Right Strobe - Very Slow"                            , new String[] { "Strobe", "Right", "Very Slow"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 13,  "Right Strobe - Slow"                                 , new String[] { "Strobe", "Right", "Slow"                                                   } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 14,  "Right Strobe - Medium"                               , new String[] { "Strobe", "Right", "Medium"                                                 } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 15,  "Right Strobe - Fast"                                 , new String[] { "Strobe", "Right", "Fast"                                                   } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 16,  "Right Strobe - Very Fast"                            , new String[] { "Strobe", "Right", "Very Fast"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 17,  "Center Strobe - Very Slow"                           , new String[] { "Strobe", "Center", "Very Slow"                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 18,  "Center Strobe - Slow"                                , new String[] { "Strobe", "Center", "Slow"                                                  } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 19,  "Center Strobe - Medium"                              , new String[] { "Strobe", "Center", "Medium"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 20,  "Center Strobe - Fast"                                , new String[] { "Strobe", "Center", "Fast"                                                  } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 21,  "Center Strobe - Very Fast"                           , new String[] { "Strobe", "Center", "Very Fast"                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 22,  "Left/Right Strobe - Very Slow"                       , new String[] { "Strobe", "Left", "Right", "Very Slow"                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 23,  "Left/Right Strobe - Slow"                            , new String[] { "Strobe", "Left", "Right", "Slow"                                           } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 24,  "Left/Right Strobe - Medium"                          , new String[] { "Strobe", "Left", "Right", "Medium"                                         } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 25,  "Left/Right Strobe - Fast"                            , new String[] { "Strobe", "Left", "Right", "Fast"                                           } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 26,  "Left/Right Strobe - Very Fast"                       , new String[] { "Strobe", "Left", "Right", "Very Fast"                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 27,  "Alternate Strobe - 2/4"                              , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Slow"                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 28,  "Alternate Strobe - 1/4"                              , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Medium"                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 29,  "Alternate Strobe - 1/8"                              , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Fast"                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 30,  "Alternate Strobe - 1/16"                             , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Very Fast"                          } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 31,  "Rotating Strobe - 2/4"                               , new String[] { "Strobe", "All", "Rhythmic", "Slow"                                         } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 32,  "Rotating Strobe - 1/4"                               , new String[] { "Strobe", "All", "Rhythmic", "Medium"                                       } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 33,  "Rotating Strobe - 1/8"                               , new String[] { "Strobe", "All", "Rhythmic", "Fast"                                         } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 34,  "Rotating Strobe - 1/16"                              , new String[] { "Strobe", "All", "Rhythmic", "Very Fast"                                    } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 35,  "Growing Strobe - Full"                               , new String[] { "Strobe", "All"                                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 36,  "Growing Strobe - Left"                               , new String[] { "Strobe", "Left"                                                            } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 37,  "Growing Strobe - Right"                              , new String[] { "Strobe", "Right"                                                           } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 38,  "Growing Strobe - Center"                             , new String[] { "Strobe", "Center"                                                          } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 39,  "Growing Strobe - Left/Right"                         , new String[] { "Strobe", "Left", "Right"                                                   } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 40,  "Growing Strobe - Alternate Left/Right - 2/4"         , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Slow"                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 41,  "Growing Strobe - Alternate Left/Right - 1/4"         , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Medium"                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 42,  "Growing Strobe - Alternate Left/Right - 1/8"         , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Fast"                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 43,  "Growing Strobe - Alternate Left/Right - 1/16"        , new String[] { "Strobe", "Left", "Right", "Rhythmic", "Very Fast"                          } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 44,  "Growing Strobe - Rotating Left/Center/Right - 2/4"   , new String[] { "Strobe", "All", "Rhythmic", "Slow"                                         } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 45,  "Growing Strobe - Rotating Left/Center/Right - 1/4"   , new String[] { "Strobe", "All", "Rhythmic", "Medium"                                       } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 46,  "Growing Strobe - Rotating Left/Center/Right - 1/8"   , new String[] { "Strobe", "All", "Rhythmic", "Fast"                                         } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 47,  "Growing Strobe - Rotating Left/Center/Right - 1/16"  , new String[] { "Strobe", "All", "Rhythmic", "Very Fast"                                    } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 48,  "Martin Atomic - Short Single Flash"                  , new String[] { "Strobe", "Center", "Rhythmic"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 49,  "Martin Atomic - Long Single Flash"                   , new String[] { "Strobe", "Center", "Rhythmic"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 50,  "Impulse Flasher - Kick"                              , new String[] { "Strobe", "Center", "Rhythmic", "AudioInput"                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 51,  "Impulse Flasher - Snare"                             , new String[] { "Strobe", "Center", "Rhythmic", "AudioInput"                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 52,  "Impulse Flasher - Cymbals"                           , new String[] { "Strobe", "Center", "Rhythmic", "AudioInput"                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 53,  "Impulse Flasher - Bass"                              , new String[] { "Strobe", "Center", "Rhythmic", "AudioInput"                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 54,  "Impulse Flasher - Keys"                              , new String[] { "Strobe", "Center", "Rhythmic", "AudioInput"                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 55,  "Impulse Flasher - Guitar"                            , new String[] { "Strobe", "Center", "Rhythmic", "AudioInput"                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 56,  "Atomic FX - Ramp up - Slow Flash"                    , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 57,  "Atomic FX - Ramp up - Medium Flash"                  , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 58,  "Atomic FX - Ramp up - Fast Flash"                    , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 59,  "Atomic FX - Ramp up - Slow Continuous"               , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 60,  "Atomic FX - Ramp up - Medium Continuous"             , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 61,  "Atomic FX - Ramp up - Fast Continuous"               , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 62,  "Atomic FX - Ramp down - Slow Flash"                  , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 63,  "Atomic FX - Ramp down - Medium Flash"                , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 64,  "Atomic FX - Ramp down - Fast Flash"                  , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 65,  "Atomic FX - Ramp down - Slow Continuous"             , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 66,  "Atomic FX - Ramp down - Medium Continuous"           , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 67,  "Atomic FX - Ramp down - Fast Continuous"             , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 68,  "Atomic FX - Ramp up/down - Slow Flash"               , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 69,  "Atomic FX - Ramp up/down - Medium Flash"             , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 70,  "Atomic FX - Ramp up/down - Fast Flash"               , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 71,  "Atomic FX - Ramp up/down - Slow Continuous"          , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 72,  "Atomic FX - Ramp up/down - Medium Continuous"        , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 73,  "Atomic FX - Ramp up/down - Fast Continuous"          , new String[] { "Strobe", "Center", "Atomic"                                                } );  
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 74,  "Atomic FX - Random"                                  , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 75,  "Atomic FX - Lightning"                               , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 76,  "Atomic FX - Slow Spikes"                             , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 77,  "Atomic FX - Medium Spikes"                           , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 78,  "Atomic FX - Fast Spikes"                             , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 79,  "Atomic 3000 SpecialFX - Blinder - Very Weak"         , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 80,  "Atomic 3000 SpecialFX - Blinder - Weak"              , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 81,  "Atomic 3000 SpecialFX - Blinder - Medium"            , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 82,  "Atomic 3000 SpecialFX - Blinder - Strong"            , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 83,  "Atomic 3000 SpecialFX - Blinder - Very Strong"       , new String[] { "Strobe", "Center", "Atomic"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 84,  "Left Strobe - Very Weak / Full speed"                , new String[] { "Strobe", "Left", "Very Fast"                                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 85,  "Right Strobe - Very Weak / Full speed"               , new String[] { "Strobe", "Right", "Very Fast"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 86,  "Center Strobe - Very Weak / Full speed"              , new String[] { "Strobe", "Center", "Very Fast"                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 87,  "Left/Right Strobe - Very Weak / Full speed"          , new String[] { "Strobe", "Left", "Right", "Very Fast"                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 88,  "Full Strobe - Very Weak / Full speed"                , new String[] { "Strobe", "All", "Very Fast"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 89,  "Left Strobe - Weak / Full speed"                     , new String[] { "Strobe", "Left", "Very Fast"                                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 90,  "Right Strobe - Weak / Full speed"                    , new String[] { "Strobe", "Right", "Very Fast"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 91,  "Center Strobe - Weak / Full speed"                   , new String[] { "Strobe", "Center", "Very Fast"                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 92,  "Left/Right Strobe - Weak / Full speed"               , new String[] { "Strobe", "Left", "Right", "Very Fast"                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 93,  "Full Strobe - Weak / Full speed"                     , new String[] { "Strobe", "All", "Very Fast"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 94,  "Left Strobe - Moderate / Full speed"                 , new String[] { "Strobe", "Left", "Very Fast"                                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 95,  "Right Strobe - Moderate / Full speed"                , new String[] { "Strobe", "Right", "Very Fast"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 96,  "Center Strobe - Moderate / Full speed"               , new String[] { "Strobe", "Center", "Very Fast"                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 97,  "Left/Right Strobe - Moderate / Full speed"           , new String[] { "Strobe", "Left", "Right", "Very Fast"                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 98,  "Full Strobe - Moderate / Full speed"                 , new String[] { "Strobe", "All", "Very Fast"                                                } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 99,  "Left Strobe - Strong / Full speed"                   , new String[] { "Strobe", "Left", "Very Fast"                                               } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 100, "Right Strobe - Strong / Full speed"                  , new String[] { "Strobe", "Right", "Very Fast"                                              } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 101, "Center Strobe - Strong / Full speed"                 , new String[] { "Strobe", "Center", "Very Fast"                                             } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 102, "Left/Right Strobe - Strong / Full speed"             , new String[] { "Strobe", "Left", "Right", "Very Fast"                                      } );
  DMXStrobeAttributes = registerAttribute(DMXStrobeAttributes, 103, "Full Strobe - Strong / Full speed"                   , new String[] { "Strobe", "All", "Very Fast"                                                } );


  /////////////////////////////////////////////////////////////////////////



  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 1,   "Uniform - Center Pan / Low Tilt"                                 , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 2,   "Uniform - Left Pan / Low Tilt"                                   , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 3,   "Uniform - Right Pan / Low Tilt"                                  , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 4,   "Uniform - Center Pan / Front Tilt"                               , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 5,   "Uniform - Left Pan / Front Tilt"                                 , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 6,   "Uniform - Right Pan / Front Tilt"                                , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 7,   "Uniform - Center Pan / High Tilt"                                , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 8,   "Uniform - Left Pan / High Tilt"                                  , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 9,   "Uniform - Right Pan / High Tilt"                                 , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 10,  "Uniform - Center Pan / Upright Tilt"                             , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 11,  "Uniform - Left Pan / Upright Tilt"                               , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 12,  "Uniform - Right Pan / Upright Tilt"                              , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 13,  "Uniform - Center Pan / Back Tilt"                                , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 14,  "Uniform - Left Pan / Back Tilt"                                  , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 15,  "Uniform - Right Pan / Back Tilt"                                 , new String[] { "MovingHead-SetDirection-All", "MovingHead-Uniform"                                    } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 16,  "Divergent Pan - Wide Pan / Low Tilt"                             , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 17,  "Divergent Pan - Classic Pan / Low Tilt"                          , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 18,  "Divergent Pan - Narrow Pan / Low Tilt"                           , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 19,  "Divergent Pan - Wide Pan / Front Tilt"                           , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 20,  "Divergent Pan - Classic Pan / Front Tilt"                        , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 21,  "Divergent Pan - Narrow Pan / Front Tilt"                         , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 22,  "Divergent Pan - Wide Pan / High Tilt"                            , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 23,  "Divergent Pan - Classic Pan / High Tilt"                         , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 24,  "Divergent Pan - Narrow Pan / High Tilt"                          , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 25,  "Divergent Pan - Wide Pan / Upright Tilt"                         , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 26,  "Divergent Pan - Classic Pan / Upright Tilt"                      , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 27,  "Divergent Pan - Narrow Pan / Upright Tilt"                       , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 28,  "Convergent Pan - Wide Pan / Low Tilt"                            , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 29,  "Convergent Pan - Classic Pan / Low Tilt"                         , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 30,  "Convergent Pan - Narrow Pan / Low Tilt"                          , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 31,  "Convergent Pan - Wide Pan / Front Tilt"                          , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 32,  "Convergent Pan - Classic Pan / Front Tilt"                       , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 33,  "Convergent Pan - Narrow Pan / Front Tilt"                        , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 34,  "Convergent Pan - Wide Pan / High Tilt"                           , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 35,  "Convergent Pan - Classic Pan / High Tilt"                        , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 36,  "Convergent Pan - Narrow Pan / High Tilt"                         , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 37,  "Convergent Pan - Wide Pan / Upright Tilt"                        , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 38,  "Convergent Pan - Classic Pan / Upright Tilt"                     , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 39,  "Convergent Pan - Narrow Pan / Upright Tilt"                      , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent"                                 } );  
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 40,  "Symmetrical Tilt Pan - Extreme Tilt - Wide Outward Sun"          , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 41,  "Symmetrical Tilt Pan - Extreme Tilt - Narrow Outward Sun"        , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 42,  "Symmetrical Tilt Pan - Progressive Tilt - Wide Outward Sun"      , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 43,  "Symmetrical Tilt Pan - Progressive Tilt - Narrow Outward Sun"    , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 44,  "Symmetrical Tilt Pan - Extreme Tilt - Wide Inward Sun"           , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 45,  "Symmetrical Tilt Pan - Extreme Tilt - Narrow Inward Sun"         , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 46,  "Symmetrical Tilt Pan - Progressive Tilt - Wide Inward Sun"       , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 47,  "Symmetrical Tilt Pan - Progressive Tilt - Narrow Inward Sun"     , new String[] { "MovingHead-SetDirection-All", "MovingHead-Sun", "MovingHead-Symmetrical"              } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 48,  "Symmetrical Divergent Pan - Wide Pan - Low Opposite Tilt"        , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 49,  "Symmetrical Divergent Pan - Classic Pan - Low Opposite Tilt"     , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 50,  "Symmetrical Divergent Pan - Narrow Pan - Low Opposite Tilt"      , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 51,  "Symmetrical Divergent Pan - Wide Pan - Front Opposite Tilt"      , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 52,  "Symmetrical Divergent Pan - Classic Pan - Front Opposite Tilt"   , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 53,  "Symmetrical Divergent Pan - Narrow Pan - Front Opposite Tilt"    , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 54,  "Symmetrical Divergent Pan - Wide Pan - High Opposite Tilt"       , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 55,  "Symmetrical Divergent Pan - Classic Pan - High Opposite Tilt"    , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 56,  "Symmetrical Divergent Pan - Narrow Pan - High Opposite Tilt"     , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 57,  "Symmetrical Divergent Pan - Wide Pan - Upright Opposite Tilt"    , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 58,  "Symmetrical Divergent Pan - Classic Pan - Upright Opposite Tilt" , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 59,  "Symmetrical Divergent Pan - Narrow Pan - Upright Opposite Tilt"  , new String[] { "MovingHead-SetDirection-All", "MovingHead-Divergent", "MovingHead-Symmetrical"        } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 60,  "Symmetrical Convergent Pan - Wide Pan - Low Opposite Tilt"       , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 61,  "Symmetrical Convergent Pan - Classic Pan - Low Opposite Tilt"    , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 62,  "Symmetrical Convergent Pan - Narrow Pan - Low Opposite Tilt"     , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 63,  "Symmetrical Convergent Pan - Wide Pan - Front Opposite Tilt"     , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 64,  "Symmetrical Convergent Pan - Classic Pan - Front Opposite Tilt"  , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 65,  "Symmetrical Convergent Pan - Narrow Pan - Front Opposite Tilt"   , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 66,  "Symmetrical Convergent Pan - Wide Pan - High Opposite Tilt"      , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 67,  "Symmetrical Convergent Pan - Classic Pan - High Opposite Tilt"   , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 68,  "Symmetrical Convergent Pan - Narrow Pan - High Opposite Tilt"    , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 69,  "Symmetrical Convergent Pan - Wide Pan - Upright Opposite Tilt"   , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 70,  "Symmetrical Convergent Pan - Classic Pan - Upright Opposite Tilt", new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 71,  "Symmetrical Convergent Pan - Narrow Pan - Upright Opposite Tilt" , new String[] { "MovingHead-SetDirection-All", "MovingHead-Convergent", "MovingHead-Symmetrical"       } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 72,  "Center Fixtures - Center Pan / Front Tilt"                       , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 73,  "Center Fixtures - Left Pan / Front Tilt"                         , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 74,  "Center Fixtures - Right Pan / Front Tilt"                        , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 75,  "Center Fixtures - Center Pan / High Tilt"                        , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 76,  "Center Fixtures - Left Pan / High Tilt"                          , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 77,  "Center Fixtures - Right Pan / High Tilt"                         , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 78,  "Center Fixtures - Center Pan / Upright Tilt"                     , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 79,  "Center Fixtures - Left Pan / Upright Tilt"                       , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 80,  "Center Fixtures - Right Pan / Upright Tilt"                      , new String[] { "MovingHead-SetDirection-Center", "MovingHead-Uniform"                                 } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 81,  "Side Fixtures - Center Pan / Front Tilt"                         , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 82,  "Side Fixtures - Left Pan / Front Tilt"                           , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 83,  "Side Fixtures - Right Pan / Front Tilt"                          , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 84,  "Side Fixtures - Center Pan / High Tilt"                          , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 85,  "Side Fixtures - Left Pan / High Tilt"                            , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 86,  "Side Fixtures - Right Pan / High Tilt"                           , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 87,  "Side Fixtures - Center Pan / Upright Tilt"                       , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 88,  "Side Fixtures - Left Pan / Upright Tilt"                         , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 89,  "Side Fixtures - Right Pan / Upright Tilt"                        , new String[] { "MovingHead-SetDirection-Side", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 90,  "Left Fixtures - Center Pan / Front Tilt"                         , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 91,  "Left Fixtures - Left Pan / Front Tilt"                           , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 92,  "Left Fixtures - Right Pan / Front Tilt"                          , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 93,  "Left Fixtures - Center Pan / High Tilt"                          , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 94,  "Left Fixtures - Left Pan / High Tilt"                            , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 95,  "Left Fixtures - Right Pan / High Tilt"                           , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 96,  "Left Fixtures - Center Pan / Upright Tilt"                       , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 97,  "Left Fixtures - Left Pan / Upright Tilt"                         , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 98,  "Left Fixtures - Right Pan / Upright Tilt"                        , new String[] { "MovingHead-SetDirection-Left", "MovingHead-Uniform"                                   } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 99,  "Right Fixtures - Center Pan / Front Tilt"                        , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 100, "Right Fixtures - Left Pan / Front Tilt"                          , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 101, "Right Fixtures - Right Pan / Front Tilt"                         , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 102, "Right Fixtures - Center Pan / High Tilt"                         , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 103, "Right Fixtures - Left Pan / High Tilt"                           , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 104, "Right Fixtures - Right Pan / High Tilt"                          , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 105, "Right Fixtures - Center Pan / Upright Tilt"                      , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 106, "Right Fixtures - Left Pan / Upright Tilt"                        , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );
  DMXMovingHead_MovementAttributes = registerAttribute(DMXMovingHead_MovementAttributes, 107, "Right Fixtures - Right Pan / Upright Tilt"                       , new String[] { "MovingHead-SetDirection-Right", "MovingHead-Uniform"                                  } );


  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 1,  "All Fixtures - White"                                                   , new String[] { "MovingHead-SetColor-All", "MovingHead-White"                              } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 2,  "All Fixtures - Red"                                                     , new String[] { "MovingHead-SetColor-All", "MovingHead-Red"                                } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 3,  "All Fixtures - Deep Red"                                                , new String[] { "MovingHead-SetColor-All", "MovingHead-Deep Red"                           } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 4,  "All Fixtures - Blue"                                                    , new String[] { "MovingHead-SetColor-All", "MovingHead-Blue"                               } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 5,  "All Fixtures - Deep Blue"                                               , new String[] { "MovingHead-SetColor-All", "MovingHead-Deep Blue"                          } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 6,  "All Fixtures - Yellow"                                                  , new String[] { "MovingHead-SetColor-All", "MovingHead-Yellow"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 7,  "All Fixtures - Green"                                                   , new String[] { "MovingHead-SetColor-All", "MovingHead-Green"                              } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 8,  "All Fixtures - Ultraviolet"                                             , new String[] { "MovingHead-SetColor-All", "MovingHead-Ultraviolet"                        } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 9,  "All Fixtures - Orange"                                                  , new String[] { "MovingHead-SetColor-All", "MovingHead-Orange"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 10, "All Fixtures - CTO"                                                     , new String[] { "MovingHead-SetColor-All", "MovingHead-CTO"                                } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 11, "Center Fixtures - White"                                                , new String[] { "MovingHead-SetColor-Center", "MovingHead-White"                           } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 12, "Center Fixtures - Red"                                                  , new String[] { "MovingHead-SetColor-Center", "MovingHead-Red"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 13, "Center Fixtures - Deep Red"                                             , new String[] { "MovingHead-SetColor-Center", "MovingHead-Deep Red"                        } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 14, "Center Fixtures - Blue"                                                 , new String[] { "MovingHead-SetColor-Center", "MovingHead-Blue"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 15, "Center Fixtures - Deep Blue"                                            , new String[] { "MovingHead-SetColor-Center", "MovingHead-Deep Blue"                       } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 16, "Center Fixtures - Yellow"                                               , new String[] { "MovingHead-SetColor-Center", "MovingHead-Yellow"                          } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 17, "Center Fixtures - Green"                                                , new String[] { "MovingHead-SetColor-Center", "MovingHead-Green"                           } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 18, "Center Fixtures - Ultraviolet"                                          , new String[] { "MovingHead-SetColor-Center", "MovingHead-Ultraviolet"                     } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 19, "Center Fixtures - Orange"                                               , new String[] { "MovingHead-SetColor-Center", "MovingHead-Orange"                          } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 20, "Center Fixtures - CTO"                                                  , new String[] { "MovingHead-SetColor-Center", "MovingHead-CTO"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 21, "Side Fixtures - White"                                                  , new String[] { "MovingHead-SetColor-Side", "MovingHead-White"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 22, "Side Fixtures - Red"                                                    , new String[] { "MovingHead-SetColor-Side", "MovingHead-Red"                               } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 23, "Side Fixtures - Deep Red"                                               , new String[] { "MovingHead-SetColor-Side", "MovingHead-Deep Red"                          } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 24, "Side Fixtures - Blue"                                                   , new String[] { "MovingHead-SetColor-Side", "MovingHead-Blue"                              } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 25, "Side Fixtures - Deep Blue"                                              , new String[] { "MovingHead-SetColor-Side", "MovingHead-Deep Blue"                         } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 26, "Side Fixtures - Yellow"                                                 , new String[] { "MovingHead-SetColor-Side", "MovingHead-Yellow"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 27, "Side Fixtures - Green"                                                  , new String[] { "MovingHead-SetColor-Side", "MovingHead-Green"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 28, "Side Fixtures - Ultraviolet"                                            , new String[] { "MovingHead-SetColor-Side", "MovingHead-Ultraviolet"                       } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 29, "Side Fixtures - Orange"                                                 , new String[] { "MovingHead-SetColor-Side", "MovingHead-Orange"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 30, "Side Fixtures - CTO"                                                    , new String[] { "MovingHead-SetColor-Side", "MovingHead-CTO"                               } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 31, "Left Fixtures - White"                                                  , new String[] { "MovingHead-SetColor-Left", "MovingHead-White"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 32, "Left Fixtures - Red"                                                    , new String[] { "MovingHead-SetColor-Left", "MovingHead-Red"                               } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 33, "Left Fixtures - Deep Red"                                               , new String[] { "MovingHead-SetColor-Left", "MovingHead-Deep Red"                          } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 34, "Left Fixtures - Blue"                                                   , new String[] { "MovingHead-SetColor-Left", "MovingHead-Blue"                              } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 35, "Left Fixtures - Deep Blue"                                              , new String[] { "MovingHead-SetColor-Left", "MovingHead-Deep Blue"                         } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 36, "Left Fixtures - Yellow"                                                 , new String[] { "MovingHead-SetColor-Left", "MovingHead-Yellow"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 37, "Left Fixtures - Green"                                                  , new String[] { "MovingHead-SetColor-Left", "MovingHead-Green"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 38, "Left Fixtures - Ultraviolet"                                            , new String[] { "MovingHead-SetColor-Left", "MovingHead-Ultraviolet"                       } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 39, "Left Fixtures - Orange"                                                 , new String[] { "MovingHead-SetColor-Left", "MovingHead-Orange"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 40, "Left Fixtures - CTO"                                                    , new String[] { "MovingHead-SetColor-Left", "MovingHead-CTO"                               } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 41, "Right Fixtures - White"                                                 , new String[] { "MovingHead-SetColor-Right", "MovingHead-White"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 42, "Right Fixtures - Red"                                                   , new String[] { "MovingHead-SetColor-Right", "MovingHead-Red"                              } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 43, "Right Fixtures - Deep Red"                                              , new String[] { "MovingHead-SetColor-Right", "MovingHead-Deep Red"                         } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 44, "Right Fixtures - Blue"                                                  , new String[] { "MovingHead-SetColor-Right", "MovingHead-Blue"                             } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 45, "Right Fixtures - Deep Blue"                                             , new String[] { "MovingHead-SetColor-Right", "MovingHead-Deep Blue"                        } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 46, "Right Fixtures - Yellow"                                                , new String[] { "MovingHead-SetColor-Right", "MovingHead-Yellow"                           } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 47, "Right Fixtures - Green"                                                 , new String[] { "MovingHead-SetColor-Right", "MovingHead-Green"                            } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 48, "Right Fixtures - Ultraviolet"                                           , new String[] { "MovingHead-SetColor-Right", "MovingHead-Ultraviolet"                      } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 49, "Right Fixtures - Orange"                                                , new String[] { "MovingHead-SetColor-Right", "MovingHead-Orange"                           } );
  DMXMovingHead_ColorAttributes = registerAttribute(DMXMovingHead_ColorAttributes, 50, "Right Fixtures - CTO"                                                   , new String[] { "MovingHead-SetColor-Right", "MovingHead-CTO"                              } );
    
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 1,  "All Fixtures - No Sync"                                               , new String[] { "MovingHead-SetRhythm-All", "MovingHead-No Sync"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 2,  "Center Fixtures - No Sync"                                            , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-No Sync"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 3,  "Side Fixtures - No Sync"                                              , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-No Sync"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 4,  "Left Fixtures - No Sync"                                              , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-No Sync"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 5,  "Right Fixtures - No Sync"                                             , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-No Sync"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 6,  "All Fixtures - Together 32nd Sync"                                    , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Together", "MovingHead-32nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 7,  "All Fixtures - Together 16th Sync"                                    , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Together", "MovingHead-16th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 8,  "All Fixtures - Together 8th Sync"                                     , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Together", "MovingHead-8th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 9,  "All Fixtures - Together 4th Sync"                                     , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Together", "MovingHead-4th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 10, "All Fixtures - Together 2nd Sync"                                     , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Together", "MovingHead-2nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 11, "All Fixtures - Together Bar Sync"                                     , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Together", "MovingHead-Bar"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 12, "All Fixtures - Clockwise 32nd Sync"                                   , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Clockwise", "MovingHead-32nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 13, "All Fixtures - Clockwise 16th Sync"                                   , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Clockwise", "MovingHead-16th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 14, "All Fixtures - Clockwise 8th Sync"                                    , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Clockwise", "MovingHead-8th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 15, "All Fixtures - Clockwise 4th Sync"                                    , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Clockwise", "MovingHead-4th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 16, "All Fixtures - Clockwise 2nd Sync"                                    , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Clockwise", "MovingHead-2nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 17, "All Fixtures - Clockwise Bar Sync"                                    , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Clockwise", "MovingHead-Bar"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 18, "All Fixtures - AntiClockwise 32nd Sync"                               , new String[] { "MovingHead-SetRhythm-All", "MovingHead-AntiClockwise", "MovingHead-32nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 19, "All Fixtures - AntiClockwise 16th Sync"                               , new String[] { "MovingHead-SetRhythm-All", "MovingHead-AntiClockwise", "MovingHead-16th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 20, "All Fixtures - AntiClockwise 8th Sync"                                , new String[] { "MovingHead-SetRhythm-All", "MovingHead-AntiClockwise", "MovingHead-8th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 21, "All Fixtures - AntiClockwise 4th Sync"                                , new String[] { "MovingHead-SetRhythm-All", "MovingHead-AntiClockwise", "MovingHead-4th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 22, "All Fixtures - AntiClockwise 2nd Sync"                                , new String[] { "MovingHead-SetRhythm-All", "MovingHead-AntiClockwise", "MovingHead-2nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 23, "All Fixtures - AntiClockwise Bar Sync"                                , new String[] { "MovingHead-SetRhythm-All", "MovingHead-AntiClockwise", "MovingHead-Bar"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 24, "All Fixtures - Random 32nd Sync"                                      , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Random", "MovingHead-32nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 25, "All Fixtures - Random 16th Sync"                                      , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Random", "MovingHead-16th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 26, "All Fixtures - Random 8th Sync"                                       , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Random", "MovingHead-8th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 27, "All Fixtures - Random 4th Sync"                                       , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Random", "MovingHead-4th"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 28, "All Fixtures - Random 2nd Sync"                                       , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Random", "MovingHead-2nd"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 29, "All Fixtures - Random Bar Sync"                                       , new String[] { "MovingHead-SetRhythm-All", "MovingHead-Random", "MovingHead-Bar"                         } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 30, "Center Fixtures - Together 32nd Sync"                                 , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Together", "MovingHead-32nd"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 31, "Center Fixtures - Together 16th Sync"                                 , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Together", "MovingHead-16th"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 32, "Center Fixtures - Together 8th Sync"                                  , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Together", "MovingHead-8th"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 33, "Center Fixtures - Together 4th Sync"                                  , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Together", "MovingHead-4th"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 34, "Center Fixtures - Together 2nd Sync"                                  , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Together", "MovingHead-2nd"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 35, "Center Fixtures - Together Bar Sync"                                  , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Together", "MovingHead-Bar"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 36, "Center Fixtures - Random 32nd Sync"                                   , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Random", "MovingHead-32nd"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 37, "Center Fixtures - Random 16th Sync"                                   , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Random", "MovingHead-16th"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 38, "Center Fixtures - Random 8th Sync"                                    , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Random", "MovingHead-8th"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 39, "Center Fixtures - Random 4th Sync"                                    , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Random", "MovingHead-4th"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 40, "Center Fixtures - Random 2nd Sync"                                    , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Random", "MovingHead-2nd"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 41, "Center Fixtures - Random Bar Sync"                                    , new String[] { "MovingHead-SetRhythm-Center", "MovingHead-Random", "MovingHead-Bar"                      } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 42, "Side Fixtures - Together 32nd Sync"                                   , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Together", "MovingHead-32nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 43, "Side Fixtures - Together 16th Sync"                                   , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Together", "MovingHead-16th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 44, "Side Fixtures - Together 8th Sync"                                    , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Together", "MovingHead-8th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 45, "Side Fixtures - Together 4th Sync"                                    , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Together", "MovingHead-4th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 46, "Side Fixtures - Together 2nd Sync"                                    , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Together", "MovingHead-2nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 47, "Side Fixtures - Together Bar Sync"                                    , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Together", "MovingHead-Bar"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 48, "Side Fixtures - Random 32nd Sync"                                     , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Random", "MovingHead-32nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 49, "Side Fixtures - Random 16th Sync"                                     , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Random", "MovingHead-16th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 50, "Side Fixtures - Random 8th Sync"                                      , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Random", "MovingHead-8th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 51, "Side Fixtures - Random 4th Sync"                                      , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Random", "MovingHead-4th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 52, "Side Fixtures - Random 2nd Sync"                                      , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Random", "MovingHead-2nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 53, "Side Fixtures - Random Bar Sync"                                      , new String[] { "MovingHead-SetRhythm-Side", "MovingHead-Random", "MovingHead-Bar"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 54, "Left Fixtures - Together 32nd Sync"                                   , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Together", "MovingHead-32nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 55, "Left Fixtures - Together 16th Sync"                                   , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Together", "MovingHead-16th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 56, "Left Fixtures - Together 8th Sync"                                    , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Together", "MovingHead-8th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 57, "Left Fixtures - Together 4th Sync"                                    , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Together", "MovingHead-4th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 58, "Left Fixtures - Together 2nd Sync"                                    , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Together", "MovingHead-2nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 59, "Left Fixtures - Together Bar Sync"                                    , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Together", "MovingHead-Bar"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 60, "Left Fixtures - Random 32nd Sync"                                     , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Random", "MovingHead-32nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 61, "Left Fixtures - Random 16th Sync"                                     , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Random", "MovingHead-16th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 62, "Left Fixtures - Random 8th Sync"                                      , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Random", "MovingHead-8th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 63, "Left Fixtures - Random 4th Sync"                                      , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Random", "MovingHead-4th"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 64, "Left Fixtures - Random 2nd Sync"                                      , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Random", "MovingHead-2nd"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 65, "Left Fixtures - Random Bar Sync"                                      , new String[] { "MovingHead-SetRhythm-Left", "MovingHead-Random", "MovingHead-Bar"                        } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 66, "Right Fixtures - Together 32nd Sync"                                  , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Together", "MovingHead-32nd"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 67, "Right Fixtures - Together 16th Sync"                                  , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Together", "MovingHead-16th"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 68, "Right Fixtures - Together 8th Sync"                                   , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Together", "MovingHead-8th"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 69, "Right Fixtures - Together 4th Sync"                                   , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Together", "MovingHead-4th"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 70, "Right Fixtures - Together 2nd Sync"                                   , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Together", "MovingHead-2nd"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 71, "Right Fixtures - Together Bar Sync"                                   , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Together", "MovingHead-Bar"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 72, "Right Fixtures - Random 32nd Sync"                                    , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Random", "MovingHead-32nd"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 73, "Right Fixtures - Random 16th Sync"                                    , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Random", "MovingHead-16th"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 74, "Right Fixtures - Random 8th Sync"                                     , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Random", "MovingHead-8th"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 75, "Right Fixtures - Random 4th Sync"                                     , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Random", "MovingHead-4th"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 76, "Right Fixtures - Random 2nd Sync"                                     , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Random", "MovingHead-2nd"                       } );
  DMXMovingHead_RhythmAttributes = registerAttribute(DMXMovingHead_RhythmAttributes, 77, "Right Fixtures - Random Bar Sync"                                     , new String[] { "MovingHead-SetRhythm-Right", "MovingHead-Random", "MovingHead-Bar"                       } );
  
  
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 1,   "All Fixtures - Continuous Light"                             , new String[] {"MovingHead-SetLight-All", "MovingHead-Still"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 2,   "All Fixtures - Slow Crescendo Light"                         , new String[] {"MovingHead-SetLight-All", "MovingHead-Crescendo"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 3,   "All Fixtures - Fast Crescendo Light"                         , new String[] {"MovingHead-SetLight-All", "MovingHead-Crescendo"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 4,   "All Fixtures - Single Short Flash"                           , new String[] {"MovingHead-SetLight-All", "MovingHead-Flash"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 5,   "All Fixtures - Single Long Flash"                            , new String[] {"MovingHead-SetLight-All", "MovingHead-Flash"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 6,   "All Fixtures - Slow Strobe"                                  , new String[] {"MovingHead-SetLight-All", "MovingHead-Strobe"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 7,   "All Fixtures - Medium Strobe"                                , new String[] {"MovingHead-SetLight-All", "MovingHead-Strobe"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 8,   "All Fixtures - Fast Strobe"                                  , new String[] {"MovingHead-SetLight-All", "MovingHead-Strobe"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 9,   "All Fixtures - Slow Clockwise SineWave"                      , new String[] {"MovingHead-SetLight-All", "MovingHead-Sine"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 10,  "All Fixtures - Fast Clockwise SineWave"                      , new String[] {"MovingHead-SetLight-All", "MovingHead-Sine"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 11,  "All Fixtures - Slow Anti Clockwise SineWave"                 , new String[] {"MovingHead-SetLight-All", "MovingHead-Sine"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 12,  "All Fixtures - Fast Anti Clockwise SineWave"                 , new String[] {"MovingHead-SetLight-All", "MovingHead-Sine"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 13,  "All Fixtures - Random Glitch"                                , new String[] {"MovingHead-SetLight-All", "MovingHead-Glitch"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 14,  "All Fixtures - Minimal Aperture Beam"                        , new String[] {"MovingHead-SetLight-All", "MovingHead-Tight"                           } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 15,  "Center Fixtures - Continuous Light"                          , new String[] {"MovingHead-SetLight-Center", "MovingHead-Still"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 16,  "Center Fixtures - Slow Crescendo Light"                      , new String[] {"MovingHead-SetLight-Center", "MovingHead-Crescendo"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 17,  "Center Fixtures - Fast Crescendo Light"                      , new String[] {"MovingHead-SetLight-Center", "MovingHead-Crescendo"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 18,  "Center Fixtures - Single Short Flash"                        , new String[] {"MovingHead-SetLight-Center", "MovingHead-Flash"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 19,  "Center Fixtures - Single Long Flash"                         , new String[] {"MovingHead-SetLight-Center", "MovingHead-Flash"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 20,  "Center Fixtures - Slow Strobe"                               , new String[] {"MovingHead-SetLight-Center", "MovingHead-Strobe"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 21,  "Center Fixtures - Medium Strobe"                             , new String[] {"MovingHead-SetLight-Center", "MovingHead-Strobe"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 22,  "Center Fixtures - Fast Strobe"                               , new String[] {"MovingHead-SetLight-Center", "MovingHead-Strobe"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 23,  "Center Fixtures - Slow Clockwise SineWave"                   , new String[] {"MovingHead-SetLight-Center", "MovingHead-Sine"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 24,  "Center Fixtures - Fast Clockwise SineWave"                   , new String[] {"MovingHead-SetLight-Center", "MovingHead-Sine"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 25,  "Center Fixtures - Slow Anti Clockwise SineWave"              , new String[] {"MovingHead-SetLight-Center", "MovingHead-Sine"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 26,  "Center Fixtures - Fast Anti Clockwise SineWave"              , new String[] {"MovingHead-SetLight-Center", "MovingHead-Sine"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 27,  "Center Fixtures - Random Glitch"                             , new String[] {"MovingHead-SetLight-Center", "MovingHead-Glitch"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 28,  "Center Fixtures - Minimal Aperture Beam"                     , new String[] {"MovingHead-SetLight-Center", "MovingHead-Tight"                        } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 29,  "Side Fixtures - Continuous Light"                            , new String[] {"MovingHead-SetLight-Side", "MovingHead-Still"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 30,  "Side Fixtures - Slow Crescendo Light"                        , new String[] {"MovingHead-SetLight-Side", "MovingHead-Crescendo"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 31,  "Side Fixtures - Fast Crescendo Light"                        , new String[] {"MovingHead-SetLight-Side", "MovingHead-Crescendo"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 32,  "Side Fixtures - Single Short Flash"                          , new String[] {"MovingHead-SetLight-Side", "MovingHead-Flash"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 33,  "Side Fixtures - Single Long Flash"                           , new String[] {"MovingHead-SetLight-Side", "MovingHead-Flash"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 34,  "Side Fixtures - Slow Strobe"                                 , new String[] {"MovingHead-SetLight-Side", "MovingHead-Strobe"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 35,  "Side Fixtures - Medium Strobe"                               , new String[] {"MovingHead-SetLight-Side", "MovingHead-Strobe"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 36,  "Side Fixtures - Fast Strobe"                                 , new String[] {"MovingHead-SetLight-Side", "MovingHead-Strobe"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 37,  "Side Fixtures - Slow Clockwise SineWave"                     , new String[] {"MovingHead-SetLight-Side", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 38,  "Side Fixtures - Fast Clockwise SineWave"                     , new String[] {"MovingHead-SetLight-Side", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 39,  "Side Fixtures - Slow Anti Clockwise SineWave"                , new String[] {"MovingHead-SetLight-Side", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 40,  "Side Fixtures - Fast Anti Clockwise SineWave"                , new String[] {"MovingHead-SetLight-Side", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 41,  "Side Fixtures - Random Glitch"                               , new String[] {"MovingHead-SetLight-Side", "MovingHead-Glitch"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 42,  "Side Fixtures - Minimal Aperture Beam"                       , new String[] {"MovingHead-SetLight-Side", "MovingHead-Tight"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 43,  "Left Fixtures - Continuous Light"                            , new String[] {"MovingHead-SetLight-Left", "MovingHead-Still"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 44,  "Left Fixtures - Slow Crescendo Light"                        , new String[] {"MovingHead-SetLight-Left", "MovingHead-Crescendo"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 45,  "Left Fixtures - Fast Crescendo Light"                        , new String[] {"MovingHead-SetLight-Left", "MovingHead-Crescendo"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 46,  "Left Fixtures - Single Short Flash"                          , new String[] {"MovingHead-SetLight-Left", "MovingHead-Flash"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 47,  "Left Fixtures - Single Long Flash"                           , new String[] {"MovingHead-SetLight-Left", "MovingHead-Flash"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 48,  "Left Fixtures - Slow Strobe"                                 , new String[] {"MovingHead-SetLight-Left", "MovingHead-Strobe"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 49,  "Left Fixtures - Medium Strobe"                               , new String[] {"MovingHead-SetLight-Left", "MovingHead-Strobe"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 50,  "Left Fixtures - Fast Strobe"                                 , new String[] {"MovingHead-SetLight-Left", "MovingHead-Strobe"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 51,  "Left Fixtures - Slow Clockwise SineWave"                     , new String[] {"MovingHead-SetLight-Left", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 52,  "Left Fixtures - Fast Clockwise SineWave"                     , new String[] {"MovingHead-SetLight-Left", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 53,  "Left Fixtures - Slow Anti Clockwise SineWave"                , new String[] {"MovingHead-SetLight-Left", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 54,  "Left Fixtures - Fast Anti Clockwise SineWave"                , new String[] {"MovingHead-SetLight-Left", "MovingHead-Sine"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 55,  "Left Fixtures - Random Glitch"                               , new String[] {"MovingHead-SetLight-Left", "MovingHead-Glitch"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 56,  "Left Fixtures - Minimal Aperture Beam"                       , new String[] {"MovingHead-SetLight-Left", "MovingHead-Tight"                          } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 57,  "Right Fixtures - Continuous Light"                           , new String[] {"MovingHead-SetLight-Right", "MovingHead-Still"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 58,  "Right Fixtures - Slow Crescendo Light"                       , new String[] {"MovingHead-SetLight-Right", "MovingHead-Crescendo"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 59,  "Right Fixtures - Fast Crescendo Light"                       , new String[] {"MovingHead-SetLight-Right", "MovingHead-Crescendo"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 60,  "Right Fixtures - Single Short Flash"                         , new String[] {"MovingHead-SetLight-Right", "MovingHead-Flash"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 61,  "Right Fixtures - Single Long Flash"                          , new String[] {"MovingHead-SetLight-Right", "MovingHead-Flash"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 62,  "Right Fixtures - Slow Strobe"                                , new String[] {"MovingHead-SetLight-Right", "MovingHead-Strobe"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 63,  "Right Fixtures - Medium Strobe"                              , new String[] {"MovingHead-SetLight-Right", "MovingHead-Strobe"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 64,  "Right Fixtures - Fast Strobe"                                , new String[] {"MovingHead-SetLight-Right", "MovingHead-Strobe"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 65,  "Right Fixtures - Slow Clockwise SineWave"                    , new String[] {"MovingHead-SetLight-Right", "MovingHead-Sine"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 66,  "Right Fixtures - Fast Clockwise SineWave"                    , new String[] {"MovingHead-SetLight-Right", "MovingHead-Sine"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 67,  "Right Fixtures - Slow Anti Clockwise SineWave"               , new String[] {"MovingHead-SetLight-Right", "MovingHead-Sine"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 68,  "Right Fixtures - Fast Anti Clockwise SineWave"               , new String[] {"MovingHead-SetLight-Right", "MovingHead-Sine"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 69,  "Right Fixtures - Random Glitch"                              , new String[] {"MovingHead-SetLight-Right", "MovingHead-Glitch"                         } );
  DMXMovingHead_LightStyleAttributes = registerAttribute(DMXMovingHead_LightStyleAttributes, 70,  "Right Fixtures - Minimal Aperture Beam"                      , new String[] {"MovingHead-SetLight-Right", "MovingHead-Tight"                         } );
 

  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 1,   "No Movement - All Fixtures - Perform Current Light Style"                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Still"}        );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 2,   "No Movement - Center Fixtures - Perform Current Light Style"                        , new String[] {"MovingHead-Anim-Center", "MovingHead-Anim-Still"}        );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 3,   "No Movement - Side Fixtures - Perform Current Light Style"                          , new String[] {"MovingHead-Anim-Side", "MovingHead-Anim-Still"}        );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 4,   "No Movement - Left Fixtures - Perform Current Light Style"                          , new String[] {"MovingHead-Anim-Left", "MovingHead-Anim-Still"}        );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 5,   "No Movement - Right Fixtures - Perform Current Light Style"                         , new String[] {"MovingHead-Anim-Right", "MovingHead-Anim-Still"}        );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 6,   "Fast Move - All Fixtures - Center Pan - Low Tilt"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 7,   "Fast Move - All Fixtures - Left Pan - Low Tilt"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 8,   "Fast Move - All Fixtures - Right Pan - Low Tilt"                                    , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 9,   "Fast Move - All Fixtures - Center Pan - Front Tilt"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 10,  "Fast Move - All Fixtures - Left Pan - Front Tilt"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 11,  "Fast Move - All Fixtures - Right Pan - Front Tilt"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 12,  "Fast Move - All Fixtures - Center Pan - High Tilt"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 13,  "Fast Move - All Fixtures - Left Pan - High Tilt"                                    , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 14,  "Fast Move - All Fixtures - Right Pan - High Tilt"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 15,  "Fast Move - All Fixtures - Center Pan - Upright Tilt"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 16,  "Fast Move - All Fixtures - Left Pan - Upright Tilt"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 17,  "Fast Move - All Fixtures - Right Pan - Upright Tilt"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 18,  "Fast Move - All Fixtures - Center Pan - Back Tilt"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 19,  "Fast Move - All Fixtures - Left Pan - Back Tilt"                                    , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 20,  "Fast Move - All Fixtures - Right Pan - Back Tilt"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 21,  "Fast Move - All Fixtures - Wide Divergent Pan - Front Tilt"                         , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 22,  "Fast Move - All Fixtures - Classic Divergent Pan - Front Tilt"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 23,  "Fast Move - All Fixtures - Wide Divergent Pan - High Tilt"                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 24,  "Fast Move - All Fixtures - Classic Divergent Pan - High Tilt"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 25,  "Fast Move - All Fixtures - Wide Convergent Pan - Front Tilt"                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 26,  "Fast Move - All Fixtures - Classic Conergent Pan - Front Tilt"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 27,  "Fast Move - All Fixtures - Wide Convergent Pan - High Tilt"                         , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 28,  "Fast Move - All Fixtures - Classic Convergent Pan - High Tilt"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 29,  "Fast Move - All Fixtures - Extreme Divergent Pan - Wide Neg Tilt"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 30,  "Fast Move - All Fixtures - Extreme Divergent Pan - Narrow Neg Tilt"                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 31,  "Fast Move - All Fixtures - Extreme Divergent Pan - Wide Pos Tilt"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 32,  "Fast Move - All Fixtures - Extreme Divergent Pan - Narrow Pos Tilt"                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-FastMove"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 33,  "Continuous Sweep - Horizontal - Slow - Left To Right"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 34,  "Continuous Sweep - Horizontal - Regular - Left To Right"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 35,  "Continuous Sweep - Horizontal - Fast - Left To Right"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 36,  "Continuous Sweep - Horizontal - Slow - Right To Left"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 37,  "Continuous Sweep - Horizontal - Regular - Right To Left"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 38,  "Continuous Sweep - Horizontal - Fast - Right To Left"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 39,  "Single Sweep - Horizontal - Slow - Left To Right"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 40,  "Single Sweep - Horizontal - Regular - Left To Right"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 41,  "Single Sweep - Horizontal - Fast - Left To Right"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 42,  "Single Sweep - Horizontal - Slow - Right To Left"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 43,  "Single Sweep - Horizontal - Regular - Right To Left"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 44,  "Single Sweep - Horizontal - Fast - Right To Left"                                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 45,  "Continuous Sweep - Vertical - Slow - Left To Right"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 46,  "Continuous Sweep - Vertical - Regular - Left To Right"                              , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 47,  "Continuous Sweep - Vertical - Fast - Left To Right"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 48,  "Continuous Sweep - Vertical - Slow - Right To Left"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 49,  "Continuous Sweep - Vertical - Regular - Right To Left"                              , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 50,  "Continuous Sweep - Vertical - Fast - Right To Left"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 51,  "Single Sweep - Vertical - Slow - Left To Right"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 52,  "Single Sweep - Vertical - Regular - Left To Right"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 53,  "Single Sweep - Vertical - Fast - Left To Right"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 54,  "Single Sweep - Vertical - Slow - Right To Left"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 55,  "Single Sweep - Vertical - Regular - Right To Left"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 56,  "Single Sweep - Vertical - Fast - Right To Left"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Vertical", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 57,  "Continuous Sweep - Circular - Slow - Left To Right"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 58,  "Continuous Sweep - Circular - Regular - Left To Right"                              , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 59,  "Continuous Sweep - Circular - Fast - Left To Right"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 60,  "Continuous Sweep - Circular - Slow - Right To Left"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 61,  "Continuous Sweep - Circular - Regular - Right To Left"                              , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 62,  "Continuous Sweep - Circular - Fast - Right To Left"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 63,  "Single Sweep - Circular - Slow - Left To Right"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 64,  "Single Sweep - Circular - Regular - Left To Right"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 65,  "Single Sweep - Circular - Fast - Left To Right"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 66,  "Single Sweep - Circular - Slow - Right To Left"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 67,  "Single Sweep - Circular - Regular - Right To Left"                                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 68,  "Single Sweep - Circular - Fast - Right To Left"                                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Circular", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 69,  "Continuous Sweep - Horizontal - Slow - Symmetrical Convergent"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 70,  "Continuous Sweep - Horizontal - Regular - Symmetrical Convergent"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 71,  "Continuous Sweep - Horizontal - Fast - Symmetrical Convergent"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 72,  "Single Sweep - Horizontal - Slow - Symmetrical Convergent"                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 73,  "Single Sweep - Horizontal - Regular - Symmetrical Convergent"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 74,  "Single Sweep - Horizontal - Fast - Symmetrical Convergent"                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 75,  "Continuous Sweep - Horizontal - Slow - Symmetrical Divergent"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 76,  "Continuous Sweep - Horizontal - Regular - Symmetrical Divergent"                    , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 77,  "Continuous Sweep - Horizontal - Fast - Symmetrical Divergent"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-ContinuousSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 78,  "Single Sweep - Horizontal - Slow - Symmetrical Divergent"                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Slow" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 79,  "Single Sweep - Horizontal - Regular - Symmetrical Divergent"                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Regular" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 80,  "Single Sweep - Horizontal - Fast - Symmetrical Divergent"                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Horizontal", "MovingHead-Anim-Fast" } );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 81,  "Single Move - Vertical - Parallel - Very Slow - Up Down"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 82,  "Single Move - Vertical - Parallel - Slow - Up Down"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 83,  "Single Move - Vertical - Parallel - Regular - Up Down"                              , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 84,  "Single Move - Vertical - Parallel - Fast - Up Down"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 85,  "Single Move - Vertical - Parallel - Very Slow - Down Up"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 86,  "Single Move - Vertical - Parallel - Slow - Down Up"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 87,  "Single Move - Vertical - Parallel - Regular - Down Up"                              , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 88,  "Single Move - Vertical - Parallel - Fast - Down Up"                                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 89,  "Single Move - Vertical - Parallel - Very Slow - Opposite Up Down"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 90,  "Single Move - Vertical - Parallel - Slow - Opposite Up Down"                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 91,  "Single Move - Vertical - Parallel - Regular - Opposite Up Down"                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 92,  "Single Move - Vertical - Parallel - Fast - Opposite Up Down"                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 93,  "Single Move - Vertical - Parallel - Very Slow - Opposite Down Up"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 94,  "Single Move - Vertical - Parallel - Slow - Opposite Down Up"                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 95,  "Single Move - Vertical - Parallel - Regular - Opposite Down Up"                     , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 96,  "Single Move - Vertical - Parallel - Fast - Opposite Down Up"                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Parallel", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 97,  "Single Move - Vertical - Divergent - Very Slow - Up Down"                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 98,  "Single Move - Vertical - Divergent - Slow - Up Down"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 99,  "Single Move - Vertical - Divergent - Regular - Up Down"                             , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 100, "Single Move - Vertical - Divergent - Fast - Up Down"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 101, "Single Move - Vertical - Divergent - Very Slow - Down Up"                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 102, "Single Move - Vertical - Divergent - Slow - Down Up"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 103, "Single Move - Vertical - Divergent - Regular - Down Up"                             , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 104, "Single Move - Vertical - Divergent - Fast - Down Up"                                , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 105, "Single Move - Vertical - Divergent - Very Slow - Opposite Up Down"                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 106, "Single Move - Vertical - Divergent - Slow - Opposite Up Down"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 107, "Single Move - Vertical - Divergent - Regular - Opposite Up Down"                    , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 108, "Single Move - Vertical - Divergent - Fast - Opposite Up Down"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 109, "Single Move - Vertical - Divergent - Very Slow - Opposite Down Up"                  , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 110, "Single Move - Vertical - Divergent - Slow - Opposite Down Up"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 111, "Single Move - Vertical - Divergent - Regular - Opposite Down Up"                    , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 112, "Single Move - Vertical - Divergent - Fast - Opposite Down Up"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Divergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 113, "Single Move - Vertical - Convergent - Very Slow - Up Down"                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 114, "Single Move - Vertical - Convergent - Slow - Up Down"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 115, "Single Move - Vertical - Convergent - Regular - Up Down"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 116, "Single Move - Vertical - Convergent - Fast - Up Down"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 117, "Single Move - Vertical - Convergent - Very Slow - Down Up"                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 118, "Single Move - Vertical - Convergent - Slow - Down Up"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 119, "Single Move - Vertical - Convergent - Regular - Down Up"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 120, "Single Move - Vertical - Convergent - Fast - Down Up"                               , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 121, "Single Move - Vertical - Convergent - Very Slow - Opposite Up Down"                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 122, "Single Move - Vertical - Convergent - Slow - Opposite Up Down"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 123, "Single Move - Vertical - Convergent - Regular - Opposite Up Down"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 124, "Single Move - Vertical - Convergent - Fast - Opposite Up Down"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 125, "Single Move - Vertical - Convergent - Very Slow - Opposite Down Up"                 , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-VerySlow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 126, "Single Move - Vertical - Convergent - Slow - Opposite Down Up"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Slow"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 127, "Single Move - Vertical - Convergent - Regular - Opposite Down Up"                   , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Regular"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 128, "Single Move - Vertical - Convergent - Fast - Opposite Down Up"                      , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-SingleSweep", "MovingHead-Anim-Convergent", "MovingHead-Anim-Fast"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 129, "Random Direction - Noise - Weak - Slow"                                             , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 130, "Random Direction - Noise - Weak - Regular"                                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 131, "Random Direction - Noise - Weak - Fast"                                             , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 132, "Random Direction - Noise - Regular - Slow"                                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 133, "Random Direction - Noise - Regular - Regular"                                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 134, "Random Direction - Noise - Regular - Fast"                                          , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 135, "Random Direction - Noise - Strong - Slow"                                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 136, "Random Direction - Noise - Strong - Regular"                                        , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 137, "Random Direction - Noise - Strong - Fast"                                           , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 138, "All Fixtures - Smooth Beat Sync Random Direction - Very Slow"                       , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 139, "All Fixtures - Smooth Beat Sync Random Direction - Slow"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 140, "All Fixtures - Smooth Beat Sync Random Direction - Regular"                         , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );
  DMXMovingHead_AnimationAttributes = registerAttribute(DMXMovingHead_AnimationAttributes, 141, "All Fixtures - Smooth Beat Sync Random Direction - Fast"                            , new String[] {"MovingHead-Anim-All", "MovingHead-Anim-Random"} );

}


class Attribute {
  int animationNbr;
  String name;
  ArrayList<String> attributes;
  
  Attribute(int animationNbr, String attributename, String[] attributeList) {
    this.animationNbr = animationNbr;
    this.name = attributename;
    attributes = new ArrayList<String>();
    
    for (int i = 0; i < attributeList.length; i++) {
      attributes.add(attributeList[i]);
      
      //If not already registered, register this attribute as a possibility for the filter
      if (registeredAttributes.hasValue(attributeList[i]) == false) {
        registeredAttributes.append(attributeList[i]);
      }
    }
    
  }
  
  public String printAttribute() {
    String tmp = "Animation no " + animationNbr + " : ";
    for (int i=0; i < attributes.size(); i++) {
      String attribute = attributes.get(i);
      tmp += attribute;
      if (i < attributes.size() - 1) {
        tmp += ", ";
      }
    }
    return tmp;
  }
  
  public String printAttributePHP() {
    String tmp = "";
    tmp = "        $attributeList[] = array (";
    for (int i=0; i < attributes.size(); i++) {
      String attribute = attributes.get(i);
      tmp += "\'" + attribute + "\'";
      if (i < attributes.size() - 1) {
        tmp += ", ";
      }
    }
    tmp += ");";
    return tmp;
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////
// Protocol Buffer parser - deserialize the data sent by the SignalProcessor plugin instances //
////////////////////////////////////////////////////////////////////////////////////////////////





//Code used for the MIDI messages transmitted over the network
final int MIDIDATA_NOTE_OFF = 1;
final int MIDIDATA_NOTE_ON = 2;
final int MIDIDATA_CC_CHANGE = 3;

//ID numbers for the incoming signals - these are set according to the configuration file
int SIGNAL_ID_KICK    = 1;
int SIGNAL_ID_SNARE   = 2;
int SIGNAL_ID_CYMBALS = 3;
int SIGNAL_ID_BASS    = 4;
int SIGNAL_ID_KEYS    = 5;
int SIGNAL_ID_GUITAR  = 6;

//Ring buffers used to store audio data - energy average
CircularArrayList<Float> audioInputBuffer_Kick;
CircularArrayList<Float> audioInputBuffer_Snare;
CircularArrayList<Float> audioInputBuffer_Cymbals;
CircularArrayList<Float> audioInputBuffer_Bass;
CircularArrayList<Float> audioInputBuffer_Keys;
CircularArrayList<Float> audioInputBuffer_Guitar;

//Ring buffers used to store audio data - signal instant value
CircularArrayList<Float> audioInputBuffer_instantVal_Kick;
CircularArrayList<Float> audioInputBuffer_instantVal_Snare;
CircularArrayList<Float> audioInputBuffer_instantVal_Cymbals;
CircularArrayList<Float> audioInputBuffer_instantVal_Bass;
CircularArrayList<Float> audioInputBuffer_instantVal_Keys;
CircularArrayList<Float> audioInputBuffer_instantVal_Guitar;

//Containers to hold the FFT values
SignalFFT signalFFT_Kick;
SignalFFT signalFFT_Snare;
SignalFFT signalFFT_Cymbals;
SignalFFT signalFFT_Bass;
SignalFFT signalFFT_Keys;
SignalFFT signalFFT_Guitar;

//Flags triggered when an impulse is received. These are to be set back to false each cycle so that no old data will be processed
boolean impulse_Kick    = false;
boolean impulse_Snare   = false;
boolean impulse_Cymbals = false;
boolean impulse_Bass    = false;
boolean impulse_Keys    = false;
boolean impulse_Guitar  = false;
long previousImpulseTimestamp_Kick    = System.nanoTime();
long previousImpulseTimestamp_Snare   = System.nanoTime();
long previousImpulseTimestamp_Cymbals = System.nanoTime();
long previousImpulseTimestamp_Bass    = System.nanoTime();
long previousImpulseTimestamp_Keys    = System.nanoTime();
long previousImpulseTimestamp_Guitar  = System.nanoTime();
boolean impulseMessageProcessed = false;        //Flag set by the animations which use the impulse : after the data processing, this flag is set to true so that at the end of the cycle, the old messages are reset
long OUTDATED_IMPULSE_AGE = 250*1000*1000;      //Consider that after OUTDATED_IMPULSE_AGE ns, the previous impulse is outdated, and should be invalidated

// Port number must be greater than 1000
int midiDataPortNumber        = 7000;
int audioDataPortNumber       = 7001;
int audioInstantValPortNumber = 7002;
int impulsePortNumber         = 7003;
int timeInfoPortNumber        = 7004;
int fftPortNumber             = 7005;
DatagramSocket MidiDataServer        = null;
DatagramSocket AudioDataServer       = null;
DatagramSocket AudioInstantValServer = null;
DatagramSocket ImpulseServer         = null;
DatagramSocket TimeInfoServer        = null;
DatagramSocket FFTServer             = null;
 
final int midiDataMessageSize         = 8;
final int timeInfoMessageSize         = 12;
final int signalLevelMessageSize      = 7;
final int signalInstantValMessageSize = 7;
final int impulseMessageSize          = 2;
final int fftMessageSize              = 67;
final int THREAD_SLEEP_TIME           = 20;   //20 ms (for reference, 50 fps means a 20ms period)
final int THREAD_SLEEP_TIME_MIDI_SVR  = 15;   //15 ms (for the MIDI and the TimeInfo servers, check if messages are available more often : this is important to have no latency between the music and the lights) . Note: TimeInfo messages are sent every 25ms

//Audio buffer size, big enough to have one value for each LED pixel (= 4 pixels in Processing)
//Important note : the number of panels is hard coded, so that even when using 3 panels, the buffer is the same
//This is important, as the thresholds set in the Auto mode depend on this value
final int AUDIO_BUFFER_SIZE      = max(PANEL_RESOLUTION_X*5, PANEL_RESOLUTION_Y);

// These thresholds are used to determine the intensity of the incoming sources
// The different thresholds between the sources are due to the natural waveforms of the sounds
// A bass's RMS value will always be higher than that of a snare which is only hit on beats 2 and 4
final float INTENSITY_THRESHOLD_KICK    = 0.003f * AUDIO_BUFFER_SIZE;    //About equal to 0.12 with an audio buffer size equal to 40
final float INTENSITY_THRESHOLD_SNARE   = 0.001f * AUDIO_BUFFER_SIZE;    //About equal to 0.04
final float INTENSITY_THRESHOLD_CYMBALS = 0.002f * AUDIO_BUFFER_SIZE;    //About equal to 0.08
final float INTENSITY_THRESHOLD_BASS    = 0.010f * AUDIO_BUFFER_SIZE;    //About equal to 0.40
final float INTENSITY_THRESHOLD_KEYS    = 0.010f * AUDIO_BUFFER_SIZE;    //About equal to 0.40
final float INTENSITY_THRESHOLD_GUITAR  = 0.010f * AUDIO_BUFFER_SIZE;    //About equal to 0.40

// Initial value of the signal's band intensities, when no other value has been received
final float FFT_DUMMY_VALUE = -1.0f;

public void initializeCircularBuffers() {
  // Initialize the ring buffers used to store the incoming signal data
  // Set the size of these buffers to be equal to the largest value between the screen width and the screen height
  
  audioInputBuffer_Kick    = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_Snare   = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_Cymbals = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_Bass    = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_Keys    = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_Guitar  = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  
  audioInputBuffer_instantVal_Kick    = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_instantVal_Snare   = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_instantVal_Cymbals = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_instantVal_Bass    = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_instantVal_Keys    = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  audioInputBuffer_instantVal_Guitar  = new CircularArrayList<Float>(AUDIO_BUFFER_SIZE);
  
  // Initialize all the buffers with 0s
  for (int i = 0; i<AUDIO_BUFFER_SIZE; i++) {
    audioInputBuffer_Kick.addAndRemoveLast(0f);
    audioInputBuffer_Snare.addAndRemoveLast(0f);
    audioInputBuffer_Cymbals.addAndRemoveLast(0f);
    audioInputBuffer_Bass.addAndRemoveLast(0f);
    audioInputBuffer_Keys.addAndRemoveLast(0f);
    audioInputBuffer_Guitar.addAndRemoveLast(0f);
    
    audioInputBuffer_instantVal_Kick.addAndRemoveLast(0f);
    audioInputBuffer_instantVal_Snare.addAndRemoveLast(0f);
    audioInputBuffer_instantVal_Cymbals.addAndRemoveLast(0f);
    audioInputBuffer_instantVal_Bass.addAndRemoveLast(0f);
    audioInputBuffer_instantVal_Keys.addAndRemoveLast(0f);
    audioInputBuffer_instantVal_Guitar.addAndRemoveLast(0f);
  }

}

public void initializeSignalFFTBuffers() {
  signalFFT_Kick    = new SignalFFT(SIGNAL_ID_KICK);
  signalFFT_Snare   = new SignalFFT(SIGNAL_ID_SNARE);
  signalFFT_Cymbals = new SignalFFT(SIGNAL_ID_CYMBALS);
  signalFFT_Bass    = new SignalFFT(SIGNAL_ID_BASS);
  signalFFT_Keys    = new SignalFFT(SIGNAL_ID_KEYS);
  signalFFT_Guitar  = new SignalFFT(SIGNAL_ID_GUITAR);
}

/////////////////////////////////////////////////////////////////////////


public void startAudioSignalMonitoringThread() {
  // Create the Java servers which will listen to the different SignalProcessor plugin instances
  
  thread("createMidiDataServer");
  thread("createAudioDataServer");
  thread("createAudioInstantValServer");
  thread("createImpulseServer");
  thread("createTimeInfoServer");
  //thread("createFFTServer");

}

///////////////////////////////////////////////////////////////////////////


public void createMidiDataServer() {
  try {
    outputLog.println("MIDI-through-UDP server initialization");
    MidiDataServer = new DatagramSocket(midiDataPortNumber);
    
    //Specify a timeout for the receive, in order to avoid useless CPU usage
    MidiDataServer.setSoTimeout(THREAD_SLEEP_TIME_MIDI_SVR);
     
    //buffer to receive incoming data
    byte[] bufferMidiData = new byte[midiDataMessageSize];
    DatagramPacket incomingMidiData = new DatagramPacket(bufferMidiData, bufferMidiData.length);

    while(true)
    {
      try {
        MidiDataServer.receive(incomingMidiData);
        processMidiDataMessage(SignalMessages.MidiData.parseFrom(incomingMidiData.getData()));
      }
      catch (Exception e) {}
    }
  }
  catch (Exception e) {
    outputLog.println("MIDI Data server error : " + e);
  }  
}

public void createAudioDataServer() {
  try {
    outputLog.println("Audio Data server initialization");
    AudioDataServer = new DatagramSocket(audioDataPortNumber);
    
    //Specify a timeout for the receive, in order to avoid useless CPU usage
    AudioDataServer.setSoTimeout(THREAD_SLEEP_TIME);
     
    //buffer to receive incoming data
    byte[] bufferAudioData = new byte[signalLevelMessageSize];
    DatagramPacket incomingAudioData = new DatagramPacket(bufferAudioData, bufferAudioData.length);

    while(true)
    {
      try {
        AudioDataServer.receive(incomingAudioData);
        processSignalLevelMessage(SignalMessages.SignalLevel.parseFrom(incomingAudioData.getData()));
      }
      catch (Exception e) {}
    }
  }
  catch (Exception e) {
    outputLog.println("Audio Data server error : " + e);
  }
}


public void createAudioInstantValServer() {
  try {
    outputLog.println("Audio Data (instant signal value) server initialization");
    AudioInstantValServer = new DatagramSocket(audioInstantValPortNumber);
    
    //Specify a timeout for the receive, in order to avoid useless CPU usage
    AudioInstantValServer.setSoTimeout(THREAD_SLEEP_TIME);
     
    //buffer to receive incoming data
    byte[] bufferAudioInstantVal = new byte[signalInstantValMessageSize];
    DatagramPacket incomingAudioInstantVal = new DatagramPacket(bufferAudioInstantVal, bufferAudioInstantVal.length);

    while(true)
    {
      try {
        AudioInstantValServer.receive(incomingAudioInstantVal);
        processSignalInstantValMessage(SignalMessages.SignalInstantVal.parseFrom(incomingAudioInstantVal.getData()));
      }
      catch (Exception e) {}
    }
  }
  catch (Exception e) {
    outputLog.println("Audio Instant Value server error : " + e);
  }
}


public void createImpulseServer() {
  try {
    outputLog.println("Impulse server initialization");
    ImpulseServer = new DatagramSocket(impulsePortNumber);
    
    //Specify a timeout for the receive, in order to avoid useless CPU usage
    ImpulseServer.setSoTimeout(THREAD_SLEEP_TIME);
     
    //buffer to receive incoming data
    byte[] bufferImpulse = new byte[impulseMessageSize];
    DatagramPacket incomingImpulse = new DatagramPacket(bufferImpulse, bufferImpulse.length);

    while(true)
    {
      try {
        ImpulseServer.receive(incomingImpulse);
        processImpulseMessage(SignalMessages.Impulse.parseFrom(incomingImpulse.getData()));
      }
      catch (Exception e) {}
    }
  }
  catch (Exception e) {
    outputLog.println("Audio impulse server error : " + e);
  }
}


public void createTimeInfoServer() {
  try {
    outputLog.println("TimeInfo server initialization");
    TimeInfoServer = new DatagramSocket(timeInfoPortNumber);
    
    //Specify a timeout for the receive, in order to avoid useless CPU usage
    TimeInfoServer.setSoTimeout(THREAD_SLEEP_TIME);
     
    //buffer to receive incoming data
    byte[] bufferTimeInfo = new byte[timeInfoMessageSize];
    DatagramPacket incomingTimeInfo = new DatagramPacket(bufferTimeInfo, bufferTimeInfo.length);

    while(true)
    {
      try {
        TimeInfoServer.receive(incomingTimeInfo);
        processTimeInfoMessage(SignalMessages.TimeInfo.parseFrom(incomingTimeInfo.getData()));
      }
      catch (Exception e) {}
    }
  }
  catch (Exception e) {
    outputLog.println("Time info server error : " + e);
  }
}

public void createFFTServer() {
  try {
    outputLog.println("FFT server initialization");
    FFTServer = new DatagramSocket(fftPortNumber);
    
    //Specify a timeout for the receive, in order to avoid useless CPU usage
    FFTServer.setSoTimeout(THREAD_SLEEP_TIME);
     
    //buffer to receive incoming data
    byte[] bufferFFT = new byte[fftMessageSize];
    DatagramPacket incomingFFT = new DatagramPacket(bufferFFT, bufferFFT.length);

    while(true)
    {
      try {
        FFTServer.receive(incomingFFT);
        processFFTMessage(SignalMessages.LogFFT.parseFrom(incomingFFT.getData()));
      }
      catch (Exception e) {}
    }
  }
  catch (Exception e) {
    outputLog.println("FFT server error : " + e);
  }
}


///////////////////////////////////////////////////////////////////////////////

public void processMidiDataMessage(SignalMessages.MidiData midiData) {
  if (midiData.getMsgType() == MIDIDATA_NOTE_OFF) {
    noteOff(midiData.getChannel(), midiData.getData1(), midiData.getData2(), System.nanoTime(), myMainBus.getBusName());
  }
  else if (midiData.getMsgType() == MIDIDATA_NOTE_ON) {
    noteOn(midiData.getChannel(), midiData.getData1(), midiData.getData2(), System.nanoTime(), myMainBus.getBusName());
  }
  else if (midiData.getMsgType() == MIDIDATA_CC_CHANGE) {
    controllerChange(midiData.getChannel(), midiData.getData1(), midiData.getData2(), System.nanoTime(), myMainBus.getBusName());
  }
}

public void processTimeInfoMessage(SignalMessages.TimeInfo timeInfo) {
  automaticSequencer.isPlaying = timeInfo.getIsPlaying();
  automaticSequencer.currentBPM = timeInfo.getTempo();
  automaticSequencer.currentPosition = timeInfo.getPosition();
}

public void processSignalLevelMessage(SignalMessages.SignalLevel signalLevel) {
  //Store the signal information in the correct ring buffer
  if (signalLevel.getSignalID() == SIGNAL_ID_KICK)          { audioInputBuffer_Kick.addAndRemoveLast(signalLevel.getSignalLevel()); }
  else if (signalLevel.getSignalID() == SIGNAL_ID_SNARE)    { audioInputBuffer_Snare.addAndRemoveLast(signalLevel.getSignalLevel()); }
  else if (signalLevel.getSignalID() == SIGNAL_ID_CYMBALS)  { audioInputBuffer_Cymbals.addAndRemoveLast(signalLevel.getSignalLevel()); }
  else if (signalLevel.getSignalID() == SIGNAL_ID_BASS)     { audioInputBuffer_Bass.addAndRemoveLast(signalLevel.getSignalLevel()); }
  else if (signalLevel.getSignalID() == SIGNAL_ID_KEYS)     { audioInputBuffer_Keys.addAndRemoveLast(signalLevel.getSignalLevel()); }
  else if (signalLevel.getSignalID() == SIGNAL_ID_GUITAR)   { audioInputBuffer_Guitar.addAndRemoveLast(signalLevel.getSignalLevel()); }
}

public void processSignalInstantValMessage(SignalMessages.SignalInstantVal signalInstantVal) {
  //Store the signal information in the correct ring buffer
    
  if (signalInstantVal.getSignalID() == SIGNAL_ID_KICK)          { audioInputBuffer_instantVal_Kick.addAndRemoveLast(signalInstantVal.getSignalInstantVal()); }
  else if (signalInstantVal.getSignalID() == SIGNAL_ID_SNARE)    { audioInputBuffer_instantVal_Snare.addAndRemoveLast(signalInstantVal.getSignalInstantVal()); }
  else if (signalInstantVal.getSignalID() == SIGNAL_ID_CYMBALS)  { audioInputBuffer_instantVal_Cymbals.addAndRemoveLast(signalInstantVal.getSignalInstantVal()); }
  else if (signalInstantVal.getSignalID() == SIGNAL_ID_BASS)     { audioInputBuffer_instantVal_Bass.addAndRemoveLast(signalInstantVal.getSignalInstantVal()); }
  else if (signalInstantVal.getSignalID() == SIGNAL_ID_KEYS)     { audioInputBuffer_instantVal_Keys.addAndRemoveLast(signalInstantVal.getSignalInstantVal()); }
  else if (signalInstantVal.getSignalID() == SIGNAL_ID_GUITAR)   { audioInputBuffer_instantVal_Guitar.addAndRemoveLast(signalInstantVal.getSignalInstantVal()); }
}

public void processImpulseMessage(SignalMessages.Impulse impulse) {
  //Raise the correct flag, according to the signal's ID
  if (impulse.getSignalID() == SIGNAL_ID_KICK)             { impulse_Kick    = true; previousImpulseTimestamp_Kick    = System.nanoTime();}
  else if (impulse.getSignalID() == SIGNAL_ID_SNARE)       { impulse_Snare   = true; previousImpulseTimestamp_Snare   = System.nanoTime();}
  else if (impulse.getSignalID() == SIGNAL_ID_CYMBALS)     { impulse_Cymbals = true; previousImpulseTimestamp_Cymbals = System.nanoTime();}
  else if (impulse.getSignalID() == SIGNAL_ID_BASS)        { impulse_Bass    = true; previousImpulseTimestamp_Bass    = System.nanoTime();}
  else if (impulse.getSignalID() == SIGNAL_ID_KEYS)        { impulse_Keys    = true; previousImpulseTimestamp_Keys    = System.nanoTime();}
  else if (impulse.getSignalID() == SIGNAL_ID_GUITAR)      { impulse_Guitar  = true; previousImpulseTimestamp_Guitar  = System.nanoTime();}
}

public void processFFTMessage(SignalMessages.LogFFT fft) {
  //Put the FFT's data in the correct buffers, according to the signal's ID
  if (fft.getSignalID() == SIGNAL_ID_KICK)             { signalFFT_Kick.setFFTBandValues(fft.getFundamentalFreq(), fft.getBand1(), fft.getBand2(), fft.getBand3(), fft.getBand4(), fft.getBand5(), fft.getBand6(), fft.getBand7(), fft.getBand8(), fft.getBand9(), fft.getBand10(), fft.getBand11(), fft.getBand12()); }
  else if (fft.getSignalID() == SIGNAL_ID_SNARE)       { signalFFT_Snare.setFFTBandValues(fft.getFundamentalFreq(), fft.getBand1(), fft.getBand2(), fft.getBand3(), fft.getBand4(), fft.getBand5(), fft.getBand6(), fft.getBand7(), fft.getBand8(), fft.getBand9(), fft.getBand10(), fft.getBand11(), fft.getBand12()); }
  else if (fft.getSignalID() == SIGNAL_ID_CYMBALS)     { signalFFT_Cymbals.setFFTBandValues(fft.getFundamentalFreq(), fft.getBand1(), fft.getBand2(), fft.getBand3(), fft.getBand4(), fft.getBand5(), fft.getBand6(), fft.getBand7(), fft.getBand8(), fft.getBand9(), fft.getBand10(), fft.getBand11(), fft.getBand12()); }
  else if (fft.getSignalID() == SIGNAL_ID_BASS)        { signalFFT_Bass.setFFTBandValues(fft.getFundamentalFreq(), fft.getBand1(), fft.getBand2(), fft.getBand3(), fft.getBand4(), fft.getBand5(), fft.getBand6(), fft.getBand7(), fft.getBand8(), fft.getBand9(), fft.getBand10(), fft.getBand11(), fft.getBand12()); }
  else if (fft.getSignalID() == SIGNAL_ID_KEYS)        { signalFFT_Keys.setFFTBandValues(fft.getFundamentalFreq(), fft.getBand1(), fft.getBand2(), fft.getBand3(), fft.getBand4(), fft.getBand5(), fft.getBand6(), fft.getBand7(), fft.getBand8(), fft.getBand9(), fft.getBand10(), fft.getBand11(), fft.getBand12()); }
  else if (fft.getSignalID() == SIGNAL_ID_GUITAR)      { signalFFT_Guitar.setFFTBandValues(fft.getFundamentalFreq(), fft.getBand1(), fft.getBand2(), fft.getBand3(), fft.getBand4(), fft.getBand5(), fft.getBand6(), fft.getBand7(), fft.getBand8(), fft.getBand9(), fft.getBand10(), fft.getBand11(), fft.getBand12()); }
}

// May be called by audio-responsive animations, invalidate old impulses
public void invalidateOutdatedImpulseFlags() {
  if (System.nanoTime() - previousImpulseTimestamp_Kick    > OUTDATED_IMPULSE_AGE) {impulse_Kick    = false;}
  if (System.nanoTime() - previousImpulseTimestamp_Snare   > OUTDATED_IMPULSE_AGE) {impulse_Snare   = false;}
  if (System.nanoTime() - previousImpulseTimestamp_Cymbals > OUTDATED_IMPULSE_AGE) {impulse_Cymbals = false;}
  if (System.nanoTime() - previousImpulseTimestamp_Bass    > OUTDATED_IMPULSE_AGE) {impulse_Bass    = false;}
  if (System.nanoTime() - previousImpulseTimestamp_Keys    > OUTDATED_IMPULSE_AGE) {impulse_Keys    = false;}
  if (System.nanoTime() - previousImpulseTimestamp_Guitar  > OUTDATED_IMPULSE_AGE) {impulse_Guitar  = false;}
}

// May be called by audio-responsive animations (ie at the end of each cycle), reset all the flags
public void resetImpulseFlags() {
  impulse_Kick    = false;
  impulse_Snare   = false;
  impulse_Cymbals = false;
  impulse_Bass    = false;
  impulse_Keys    = false;
  impulse_Guitar  = false;  
}


////////////////////////////////////////////////////
//   SignalFFT class to hold the signals' freqs   //
////////////////////////////////////////////////////

public class SignalFFT {
  int signalID;
  float mainFreq;          //Frequency of the first harmonic in Hz
  float band1;             //Energy in the 0 to 11 Hz band
  float band2;             //Energy in the 11 to 22 Hz band
  float band3;             //Energy in the 22 to 43 Hz band
  float band4;             //Energy in the 43 to 86 Hz band
  float band5;             //Energy in the 86 to 172 Hz band
  float band6;             //Energy in the 172 to 344 Hz band
  float band7;             //Energy in the 344 to 689 Hz band
  float band8;             //Energy in the 689 to 1378 Hz band
  float band9;             //Energy in the 1378 to 2756 Hz band
  float band10;            //Energy in the 2756 to 5512 Hz band
  float band11;            //Energy in the 5512 to 11025 Hz band
  float band12;            //Energy in the 11025 to 22050 Hz band
  
  SignalFFT(int _signalID) {
    // Initialize the signal with dummy values, to prevent confusing a low value from an undefined value
    signalID = _signalID;
    mainFreq = FFT_DUMMY_VALUE;
    band1  = FFT_DUMMY_VALUE;
    band2  = FFT_DUMMY_VALUE;
    band3  = FFT_DUMMY_VALUE;
    band4  = FFT_DUMMY_VALUE;
    band5  = FFT_DUMMY_VALUE;
    band6  = FFT_DUMMY_VALUE;
    band7  = FFT_DUMMY_VALUE;
    band8  = FFT_DUMMY_VALUE;
    band9  = FFT_DUMMY_VALUE;
    band10 = FFT_DUMMY_VALUE;
    band11 = FFT_DUMMY_VALUE;
    band12 = FFT_DUMMY_VALUE;
  }
  
  public void setFFTBandValues(float freq, float val1, float val2, float val3, float val4, float val5, float val6, float val7, float val8, float val9, float val10, float val11, float val12) {
    mainFreq = freq;
    band1  = val1;
    band2  = val2;
    band3  = val3;
    band4  = val4;
    band5  = val5;
    band6  = val6;
    band7  = val7;
    band8  = val8;
    band9  = val9;
    band10 = val10;
    band11 = val11;
    band12 = val12;
  }
}

////////////////////////////////////////////////////
//   Ring buffer class to store the signal data   //
////////////////////////////////////////////////////

public class CircularArrayList<E>
        extends AbstractList<E> implements RandomAccess {
  
    private final int n; // buffer length
    private final List<E> buf; // a List implementing RandomAccess
    private int head = 0;
    private int tail = 0;
  
    public CircularArrayList(int capacity) {
        n = capacity + 1;
        buf = new ArrayList<E>(Collections.nCopies(n, (E) null));
    }
  
    public int capacity() {
        return n - 1;
    }
  
    private int wrapIndex(int i) {
        int m = i % n;
        if (m < 0) { // java modulus can be negative
            m += n;
        }
        return m;
    }
  
    // This method is O(n) but will never be called if the
    // CircularArrayList is used in its typical/intended role.
    private void shiftBlock(int startIndex, int endIndex) {
        assert (endIndex > startIndex);
        for (int i = endIndex - 1; i >= startIndex; i--) {
            set(i + 1, get(i));
        }
    }
  
    @Override
    public int size() {
        return tail - head + (tail < head ? n : 0);
    }
  
    @Override
    public E get(int i) {
        if (i < 0 || i >= size()) {
            throw new IndexOutOfBoundsException();
        }
        return buf.get(wrapIndex(head + i));
    }
  
    @Override
    public E set(int i, E e) {
        if (i < 0 || i >= size()) {
            throw new IndexOutOfBoundsException();
        }
        return buf.set(wrapIndex(head + i), e);
    }
  
    @Override
    public void add(int i, E e) {
        int s = size();
        if (s == n - 1) {
            throw new IllegalStateException("Cannot add element."
                    + " CircularArrayList is filled to capacity.");
        }
        if (i < 0 || i > s) {
            throw new IndexOutOfBoundsException();
        }
        tail = wrapIndex(tail + 1);
        if (i < s) {
            shiftBlock(i, s);
        }
        set(i, e);
    }
  
    @Override
    public E remove(int i) {
        int s = size();
        if (i < 0 || i >= s) {
            throw new IndexOutOfBoundsException();
        }
        E e = get(i);
        if (i > 0) {
            shiftBlock(0, i);
        }
        head = wrapIndex(head + 1);
        return e;
    }
    
    public void addAndRemoveLast(E e) {
      if (size() == capacity()) {
        remove(0);
      }
      add(e);
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Automatic light selector, A.I. responding to input MIDI messages and selecting appropriately the correct animations  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
The automatic engine relies on audio which may be sent by the DAW, using the SignalProcessor VST plugin.
The plugin is to be put as an effect on each track with a special function :
- Kick
- Snare
- Hats/Cymbals
- Bass
- Keys (high synths, leads, piano)
- Guitar (even if in Xi's case, the guitar is not to be routed to the master output)

The six plugin instances can send the following messages :
- Signal level : an instant value of the track's output level, averaged on a user-defined buffer
- Impulses : the plugin detects important changes in intensity, and associates them to beats, or impulses
- FFT : 12-band Fast Fourier Transform of the signal, averaged over a few values for more precision. Fairly expensive CPU-wise, so only switch it on for the instances which really need it (Bass for example) 
- TimeInfo : Transport informations, ie current position, BPM and whether playback is active. Only one instance should be set to send these messages, it's enough !
These messages are received by the different threads in AudioSignalProcessing, and the variables they set are to be consumed by this class

--------------------------------
-- Setting up SignalProcessor --
--------------------------------
Different settings may be recommended depending on the source
For the kick : short averaging buffer (512) to have a lot of messages per second (and be reactive if the intensity changes)
For the snare : longer averaging buffer (2048) to have a picture over a longer period whether the snare is here or not


An ultra-general all-powerful AI is too hard to make, and realistically speaking, would probably fail at being ultra-dynamic
and always appropriated to the musical context.
The first version of the AI (before the complete rewrite) was using this paradigm, and even though it kinda worked, it wasn't
too fancy : an algorithmic main animation - transition - another main animation AI can only go so far without being redundant,
or without being a CPU hog. It's also to be noted that the transitions which were chosen by the AI, while not out of context, 
had an "average" feeling to them, the difference between machine-made and man-made sequences  would have been clear to the public.
A lot of animations are way too specific to be integrated in an auto-mode like that without looking bland (sets, multi-controls, rhythm...)

To do something more usable live, and generally speaking more impressive, a compromise was made : part of the work still needs to
be done by a human.
The AI processes a general intensity using all these messages, and creates a set of variables which correspond more or less to a "I
think that something like that is going on with the music" declaration. These variables are then used, following a certain number of
scenarios, to pick in specific banks of animation sequences.
These sequences are short MIDI clips created by the user, containing DMX, panel or custom device animations. They are divided into banks 
of different intensities, and processed at the start of the program.

*/


//Intensity levels
final int INTENSITY_DEFAULT  = 0;
final int INTENSITY_LOW      = 1;
final int INTENSITY_MEDIUM   = 2;
final int INTENSITY_HIGH     = 3;
final int INTENSITY_MAX      = 4;

//Color sets : declare them as finals for better code readability
final int COLORSET_WHITE     = 0;
final int COLORSET_RED       = 1;
final int COLORSET_COLORFUL  = 2;

//Number of samples to calculate the partial intensity on (in numbers of messages sent by SignalProcessor, 1 SP sample = a certain number of audio samples)
final int PARTIAL_INTENSITY_SAMPLE_NUMBER = AUDIO_BUFFER_SIZE/2;

// Print real time auto mode debug data - MUST be set to false for the final release
final boolean printSystemDebugData = false;

// Energy ratio between the high and the low frequencies - used when detecting the filtered bass only special scenario
// When the processed FFT's ratio between the high end and the low end is higher than this threshold, consider the bass to be filtered
float HI_LO_RATIO_THRESHOLD = 100;

//Automatic mode flag : set to true or false by input MIDI notes
boolean AUTOMATIC_MODE = false;


class PlayMeSequencer {

  boolean isPlaying = false;                            //State of the host, is equal to true if playback is set to true
  float currentBPM = 120.0f;                             //Current BPM of the host
  float currentPosition = 0.0f;                          //Current position, in pulses-per-quarter-note (ie, 1:1:1 -> 0.0,  1:2:4 -> 1.75, 2:1:1 -> 4.0)
  
  int currentIntensity = INTENSITY_DEFAULT;             //Intensity of the sequences which will be played, defined the incoming audio
  int previousSelectedIntensity = currentIntensity;     //Intensity which was detected at the time the sequence started
  int currentColorSet  = COLORSET_WHITE;
  
  MidiSequence currentSequence;                         //Sequence being currently played by the sequencer (for the panels)
  MidiSequence currentSequenceDMX;                      //Sequence being currently played by the sequencer (for the DMX and the custom devices)
  float currentLoopTimeElapsed     = 0.0f;               //Elapsed time for the current loop iteration. Necessary to use this variable instead of a simple math based on the DAW's position, because the transport can jump at anytime (loop/restart/scene change)
  float currentDMXLoopTimeElapsed  = 0.0f;               //The same, for the DMX loop. Two different variables are used because the panel and the DMX sequences are not necessary the same size
  float globalSequenceTimeElapsed  = 0.0f;               //How long the current sequence has been active. Incremented every time the loop is restarted 
  float previouslyCheckedTimestamp = 0.0f;   
  boolean sequencerHasBeenStopped  = false;
  boolean timestampChanged         = true;              //Set to true when the timestamp has changed since the last time we checked. If the time has not changed, it is not necessary to perform all the checks
  
  // Sum of all the signal samples in the buffer
  float globalIntensity_Kick    = 0;
  float globalIntensity_Snare   = 0;
  float globalIntensity_Cymbals = 0;
  float globalIntensity_Bass    = 0;
  float globalIntensity_Keys    = 0;
  float globalIntensity_Guitar  = 0;
  // Sum of only the most recent signal samples in the buffer
  // Since these variables are computed on less samples, they allow a more reactive analysis and can be used to detect sudden changes faster
  // Will be uncommented when a scenario using this is made 
//  float partialIntensity_Kick    = 0;
//  float partialIntensity_Snare   = 0;
//  float partialIntensity_Cymbals = 0;
//  float partialIntensity_Bass    = 0;
//  float partialIntensity_Keys    = 0;
//  float partialIntensity_Guitar  = 0;
  
  //Flags raised by user input, MIDI keyboard related animations
  boolean setStrobeAutoMode4th      = false;
  boolean setStrobeAutoMode8th      = false;
  boolean setStrobeAutoMode16th     = false;
  boolean setStrobeAutoMode32nd     = false;
  boolean setStrobeAutoMode64th     = false;
  boolean setKillLedPanel           = false;
  boolean setBlackOutAutomode       = false;
  int blackoutPower                 = 0;
  boolean setWhiteOutAutomode       = false;
  int whiteoutPower                 = 0;
  boolean setShredderAutoMode       = false; 
  int shredderPower                 = 0;
  boolean setWhiteJamaMonoAutoMode  = false;
  int whiteJamaMonoPower            = 0;
  boolean setColorChangeAutoMode    = false;
  int colorChangePower              = 0;
      
  //Flags raised by the scenario functions : set depending on the audio/transport conditions
  boolean tempoIsVerySlow           = false;
  boolean onlyGuitarIsPlaying       = false;
  boolean onlyFilteredBassIsPlaying = false;
  boolean firstBeat                 = false;
  
  //Flag used to indicate that special conditions are met and that the normal intensity detection is bypassed
  //In this case, the intensity following the immediate fall of the flag shall be set to Max
  boolean specialRuleActive        = false;
  
  PlayMeSequencer() {
    chooseNewMidiSequence(true);
  }
  
  
  // Perform any action on the list, depending on the current system time based on the beat
  public void performAutomaticActions() {
    
    //Check the current time
    checkCurrentTime();
    
    // If the timestamp is the same as during the previous analysis, don't try to do the work a second time
    if (timestampChanged) {
      if (sequencerHasBeenStopped == false) {
        // Check what's going on with the audio, if the sequencer is not stopped (in that case, we'll be starting with Default intensity patterns, since we can't predict the future)
        determineAudioModeVariables();
        
        // No need to print the auto mode debug in the release version
        if (printSystemDebugData) {
          printSystemDebugData();
        }
      }
      
      //If the sequencer has been stopped, force a reinitialization of the sequence
      if (sequencerHasBeenStopped) {
        chooseNewMidiSequence(true);
      }
            
      // Only the guitar is playing, this is a special case where the intensity cannot be computed normally
      if (onlyGuitarIsPlaying) {
        specialRuleActive = true;
        playSpecialActions_onlyGuitar();
      }
      else if (onlyFilteredBassIsPlaying) {
        specialRuleActive = true;
        playSpecialActions_onlyFilteredBass();
      }
      // No special scenario has been detected, execute the normal auto actions
      else {
        //Execute the actions relative to the current loop (ex: "set animation #x", "set effect #y")        
        playCurrentMidiLoop();
        playCurrentDMXMidiLoop();        
      }
      
      // The timestamp has changed, so the sequencer is necessary moving again
      sequencerHasBeenStopped = false;
    }
    
    // Fallback actions : if the sequencer has stopped, reset the DMX actions and the custom devices
    // Leave the panel animation as it is, but stop all which is "too risky" (we don't want a strobe party with a perfect silence)
    if (isPlaying == false) {
      playActionsWhenSequencerStopped();
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // Now that we've determined which animations should be played, play them
    
    specific_draw();
    drawAdditionalManualEffects();
    
  }

  // Check the current MIDI loop : is an action to be executed ? If so, do it
  public void playCurrentMidiLoop() {
    if (currentSequence.actionQueue.size() > 0) {
      if (currentSequence.actionQueue.get(0).timestamp <= currentLoopTimeElapsed) {
        playAction(currentSequence.actionQueue.get(0).eventType, currentSequence.actionQueue.get(0).actionType, currentSequence.actionQueue.get(0).actionVal);
        currentSequence.actionQueue.remove(0);
      }
    }
    // No action to play anymore in the queue ? It's either time to reinit the loop, or to change the sequence
    else {
      // Don't try to reinitialize the sequence if it's empty anyways
      if (currentSequence.actionBank.size() != 0) {
         
        // Rule to choose a new sequence : Either the intensity has changed (and the clip is actually over), or the clip has looped for 8 bars (2*4*4 beats)
        // However, if the sequence is changed because the detected intensity has changed, do not reset the global elapsed time for the sequence : everything should stay 4/4, aligned with 4 bars per block
        if (currentIntensity != previousSelectedIntensity && currentLoopTimeElapsed >= currentSequence.lengthInBars * 4) {
          boolean resetGlobalSequenceTimeElapsed = false;
          chooseNewMidiSequence(resetGlobalSequenceTimeElapsed);
        }
        else if (globalSequenceTimeElapsed >= 2 * 4 * 4) {
          boolean resetGlobalSequenceTimeElapsed = true;
          chooseNewMidiSequence(resetGlobalSequenceTimeElapsed);
        }
        // If the clip is over but it's not yet time to change it, loop it
        else if (currentLoopTimeElapsed >= currentSequence.lengthInBars * 4 ) {
          loopCurrentSequence();
        }
      }
    } 
  }
  
  public void playCurrentDMXMidiLoop() {
    // Execute the DMX / Custom Devices sequence
    if (currentSequenceDMX.actionQueue.size() > 0) {
      if (currentSequenceDMX.actionQueue.get(0).timestamp <= currentDMXLoopTimeElapsed) {
        playAction(currentSequenceDMX.actionQueue.get(0).eventType, currentSequenceDMX.actionQueue.get(0).actionType, currentSequenceDMX.actionQueue.get(0).actionVal);
        currentSequenceDMX.actionQueue.remove(0);
      }
    }
    else {
      if (currentSequenceDMX.actionBank.size() != 0) {
        // For the DMX Sequence, the only choice possible is to loop the clip : the panel sequence is the master, and will be the trigger for the DMX clip change
        if (currentDMXLoopTimeElapsed >= currentSequenceDMX.lengthInBars * 4 ) {
          loopCurrentDMXSequence();
        }
      }
    }    
  }
  
  public void playAction(int eventType, int actionNumber, int actionValue) {
    // The actions done here are similar to those done in MidiControl, though restrictions apply
    
    if (eventType == NOTE_ON) {
      switch (actionNumber) {
        case PITCH_DMX_ANIMATION_STROBE:                        loadDMXAnimation_strobe(actionValue); break;
        case PITCH_DMX_ANIMATION_PAR:                           loadDMXAnimation_par(actionValue); break;
        
        case PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION:    loadDMXAnimation_movingHead_initDirection(actionValue); break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR:         loadDMXAnimation_movingHead_setColor(actionValue);      break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE:   loadDMXAnimation_movingHead_setLightStyle(actionValue); break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1:   loadDMXAnimation_movingHead_setAnimation1(actionValue); break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2:   loadDMXAnimation_movingHead_setAnimation2(actionValue); break;

        case PITCH_CUSTOM_DEVICE_BANK1:                         loadCustomDeviceAnimation1(actionValue);break;
        case PITCH_CUSTOM_DEVICE_BANK2:                         loadCustomDeviceAnimation2(actionValue);break;
        case PITCH_CUSTOM_DEVICE_BANK3:                         loadCustomDeviceAnimation3(actionValue);break;
        case PITCH_DISPLAY_EFFECT:                              activateAdditionalEffect(actionValue);break;
        case PITCH_LOAD_ANIMATION_BANK1:                        loadAnimation1(actionValue);break;
        case PITCH_LOAD_ANIMATION_BANK2:                        loadAnimation2(actionValue);break;
        case PITCH_LOAD_ANIMATION_BANK3:                        loadAnimation3(actionValue);break;
        case PITCH_LOAD_ANIMATION_BANK4:                        loadAnimation4(actionValue);break;
        case PITCH_LOAD_IMAGE_BANK1:                            loadImage1(actionValue);break;
        default: break;
      }
    }
    else if (eventType == NOTE_OFF) {
      switch (actionNumber) {        
        case PITCH_DMX_ANIMATION_STROBE:                        unloadDMXAnimation_strobe(); break;
        case PITCH_DMX_ANIMATION_PAR:                           unloadDMXAnimation_par(); break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION:    break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR:         break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE:   break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1:   unloadDMXAnimation_movingHead(); break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2:   unloadDMXAnimation_movingHead(); break;
        case PITCH_DISPLAY_EFFECT:                              deactivateAdditionalEffect(actionValue);break;
        default: break;
      }
    }
  }
  
  // Loop the current Midi clip - panel animations
  public void loopCurrentSequence() {
    
    // Reset currentLoopTimeElapsed - not to 0, but to the current position normalized to a bar, for more precision
    currentLoopTimeElapsed = currentPosition%4;    
    currentSequence.initActions();
    
  }
  
  // Loop the current Midi clip - DMX and custom animations
  public void loopCurrentDMXSequence() {
        
    // Reset currentDMXLoopTimeElapsed - not to 0, but to the current position normalized to a bar, for more precision
    currentDMXLoopTimeElapsed = currentPosition%4;    
    currentSequenceDMX.initActions();
    
  }

  public void chooseNewMidiSequence(boolean resetSequenceElapsedTime) {

    // Choose a new sequence for the panels
    if (currentColorSet == COLORSET_WHITE) {
      if (currentIntensity == INTENSITY_DEFAULT) {
        currentSequence = MidiSequences_White_DefaultIntensity.get((int)random(MidiSequences_White_DefaultIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_LOW) {
        currentSequence = MidiSequences_White_LowIntensity.get((int)random(MidiSequences_White_LowIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_MEDIUM) {
        currentSequence = MidiSequences_White_MediumIntensity.get((int)random(MidiSequences_White_MediumIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_HIGH) {
        currentSequence = MidiSequences_White_HighIntensity.get((int)random(MidiSequences_White_HighIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_MAX) {
        currentSequence = MidiSequences_White_MaxIntensity.get((int)random(MidiSequences_White_MaxIntensity.size()));
      }
    }
    else if (currentColorSet == COLORSET_RED) {
      if (currentIntensity == INTENSITY_DEFAULT) {
        currentSequence = MidiSequences_Red_DefaultIntensity.get((int)random(MidiSequences_Red_DefaultIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_LOW) {
        currentSequence = MidiSequences_Red_LowIntensity.get((int)random(MidiSequences_Red_LowIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_MEDIUM) {
        currentSequence = MidiSequences_Red_MediumIntensity.get((int)random(MidiSequences_Red_MediumIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_HIGH) {
        currentSequence = MidiSequences_Red_HighIntensity.get((int)random(MidiSequences_Red_HighIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_MAX) {
        currentSequence = MidiSequences_Red_MaxIntensity.get((int)random(MidiSequences_Red_MaxIntensity.size()));
      }
    }
    else {
      if (currentIntensity == INTENSITY_DEFAULT) {
        currentSequence = MidiSequences_Colorful_DefaultIntensity.get((int)random(MidiSequences_Colorful_DefaultIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_LOW) {
        currentSequence = MidiSequences_Colorful_LowIntensity.get((int)random(MidiSequences_Colorful_LowIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_MEDIUM) {
        currentSequence = MidiSequences_Colorful_MediumIntensity.get((int)random(MidiSequences_Colorful_MediumIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_HIGH) {
        currentSequence = MidiSequences_Colorful_HighIntensity.get((int)random(MidiSequences_Colorful_HighIntensity.size()));
      }
      else if (currentIntensity == INTENSITY_MAX) {
        currentSequence = MidiSequences_Colorful_MaxIntensity.get((int)random(MidiSequences_Colorful_MaxIntensity.size()));
      }
    }
    
    // Same goes for the DMX and the Custom Devices
    if (currentIntensity == INTENSITY_DEFAULT) {
      currentSequenceDMX = MidiSequences_Devices_DefaultIntensity.get((int)random(MidiSequences_Devices_DefaultIntensity.size()));
    }
    else if (currentIntensity == INTENSITY_LOW) {
      currentSequenceDMX = MidiSequences_Devices_LowIntensity.get((int)random(MidiSequences_Devices_LowIntensity.size()));
    }
    else if (currentIntensity == INTENSITY_MEDIUM) {
      currentSequenceDMX = MidiSequences_Devices_MediumIntensity.get((int)random(MidiSequences_Devices_MediumIntensity.size()));
    }
    else if (currentIntensity == INTENSITY_HIGH) {
      currentSequenceDMX = MidiSequences_Devices_HighIntensity.get((int)random(MidiSequences_Devices_HighIntensity.size()));
    }
    else if (currentIntensity == INTENSITY_MAX) {
      currentSequenceDMX = MidiSequences_Devices_MaxIntensity.get((int)random(MidiSequences_Devices_MaxIntensity.size()));
    }
    
    
    currentSequence.initActions();
    currentSequenceDMX.initActions();
    
    currentLoopTimeElapsed    = currentPosition%4;
    currentDMXLoopTimeElapsed = currentPosition%4;
    
    // In some cases, the sequence time might not want to be reset : for example, the first 4 beats are used to compute the sound's intensity at startup.
    // After these first 4 beats, a more appropriate sequence is used, but it should only go on for 3 bars before changing again : stay square !
    if (resetSequenceElapsedTime) {
      globalSequenceTimeElapsed = currentPosition%4;
    }
        
    previousSelectedIntensity = currentIntensity;
    
    // Fix for a shitty case which might occur : if playback is cut off when an effect is active, playback restart will forces a new animation, without killing off any effect
    // The same goes for the DMX animations for that matter, so kill any DMX device
    deactivateAdditionalEffect(0);
    unloadDMXAnimation_strobe();
    unloadDMXAnimation_movingHead();
    unloadDMXAnimation_par();

    
    // If a special scenario had been detected previously, now's the time to reset the flag
    // When the special rule is active, the following sequence change is defined not by the audio's intensity, but by the algorithm
    // Ex : when only the guitar is playing, when all the other parts start playing again, the desired intensity would be max
    // However, following the audio algo, the buffers do not contain enough energy yet, so the processed intensity is Low
    // This flag is set when a scenario is detected, and reset when the next sequence change is requested
    specialRuleActive = false;

  }
  
  // Check the current time : increment currentLoopTimeElapsed each elapsed beat
  // Since there is no way to predict if the time won't go back in the past (loop/restart), only the beat subdivision is used to calculate the elapsed time
  // Enough time messages are sent for the system to have at least 4-5 messages per beat.
  // In DAWs such as Maschine or Ableton, the position may jump with no warning (particularly during scene changes), even if the position suddenly flies
  // 16 bars ahead, only to come back 2 beats later, the elapsed time must still be incremented properly
  public void checkCurrentTime() {
    if (isPlaying == false) {
      currentLoopTimeElapsed     = 0;
      currentDMXLoopTimeElapsed  = 0;
      globalSequenceTimeElapsed  = 0;
      sequencerHasBeenStopped    = true;
      timestampChanged           = false;
      //Since playback has stopped, we don't know how things will restart, so use Default intensity patterns
      currentIntensity           = INTENSITY_DEFAULT;
    }
    else {
      // Playback just started, so check where we are on the grid. The scene's starting point is set to the current bar's first beat
      if (sequencerHasBeenStopped) {
        currentLoopTimeElapsed     = currentPosition%4.0f;
        currentDMXLoopTimeElapsed  = currentPosition%4.0f;
        //We've lost how long the sequence has been going for, so take the first beat as reference
        globalSequenceTimeElapsed  = currentPosition%4.0f;
        
        //Also, if the sequencer has stopped, it might be time to choose a new color set
        chooseNewColorset();        
      }
      
      if (currentPosition > previouslyCheckedTimestamp) {
        currentLoopTimeElapsed    += (currentPosition - previouslyCheckedTimestamp)%1.0f;
        currentDMXLoopTimeElapsed += (currentPosition - previouslyCheckedTimestamp)%1.0f;
        globalSequenceTimeElapsed += (currentPosition - previouslyCheckedTimestamp)%1.0f;
        previouslyCheckedTimestamp = currentPosition;
        timestampChanged           = true;
      }
      else if (currentPosition < previouslyCheckedTimestamp) {
        currentLoopTimeElapsed    += 1.0f - ((previouslyCheckedTimestamp - currentPosition)%1.0f);
        currentDMXLoopTimeElapsed += 1.0f - ((previouslyCheckedTimestamp - currentPosition)%1.0f);
        globalSequenceTimeElapsed += 1.0f - ((previouslyCheckedTimestamp - currentPosition)%1.0f);
        previouslyCheckedTimestamp = currentPosition;
        timestampChanged           = true;
      }
      else {
        //If currentPosition is equal to previouslyCheckedTimestamp, no need to go further in analyzing stuff
        timestampChanged           = false;
      }
    }
  }
  
  // When in Auto mode, if the sequencer stops, kill the DMX and the custom devices
  public void playActionsWhenSequencerStopped() {
    dmxAnimationNumber_strobe  = 1;
    customDeviceAnimation(1);
  }
  
  // Using the different scenarios, set the different variables which will be used to determine which animation is to play
  public void determineAudioModeVariables() {
    computeSignalIntensity();
    
    isTheTempoVerySlow();
    isFirstBeat();
    isOnlyTheGuitarPlaying();
    isOnlyTheFilteredBassPlaying();
    determineIntensity();
  }
  
  // Scenario functions : the following functions check specific parts of the data transmitted the plugin, and set internal variables accordingly
  public void isTheTempoVerySlow() {
    if (currentBPM <= 90.0f) {
      tempoIsVerySlow = true;
    }
    else {
      tempoIsVerySlow = false;
    } 
  }
  
  public void isFirstBeat() {
    if (PApplet.parseInt(currentPosition%4) == 0) {
      firstBeat = true;
    }
    else {
      firstBeat = false;
    }
  }
  
  public void isOnlyTheGuitarPlaying() {
    float INTENSITY_THRESHOLD = 0.005f; 
    // Since this is an extremely local check, do not consider the averaged signal over the entirety of the buffer for the signals other than the guitar : only the most recent signal counts
    if (globalIntensity_Guitar > INTENSITY_THRESHOLD_GUITAR
        && globalIntensity_Kick < INTENSITY_THRESHOLD_KICK
        && audioInputBuffer_Snare.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD
        && audioInputBuffer_Cymbals.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD
        && audioInputBuffer_Bass.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD
        && audioInputBuffer_Keys.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD) 
    {
      onlyGuitarIsPlaying = true;
    }
    else {
      onlyGuitarIsPlaying = false;
    }
  }
  
  public void isOnlyTheFilteredBassPlaying() {
    float INTENSITY_THRESHOLD_FILTEREDBASS = 0.005f;    //The intensity may be very low, as the bass can be heavily filtered 
    float INTENSITY_THRESHOLD = 0.005f;
    
    // Since this is an extremely local check, do not consider the averaged signal over the entirety of the buffer for the signals other than the bass : only the most recent signal counts
    // An exception is made for the kick, to prevent false positives (the kick's plugin is usually set to send a lot of signal messages so this is not a problem)
    // Furthermore, this scenario also considers the FFT the bass SignalProcessor sends : activate only if the HPF is active
    
    float lowEnergy = signalFFT_Bass.band1;
    float hiEnergy  = (signalFFT_Bass.band8 + signalFFT_Bass.band9 + signalFFT_Bass.band10 + signalFFT_Bass.band11 + signalFFT_Bass.band12);
    
    if (globalIntensity_Bass > INTENSITY_THRESHOLD_FILTEREDBASS
        && (hiEnergy / lowEnergy) > HI_LO_RATIO_THRESHOLD
        && signalFFT_Bass.band1 != FFT_DUMMY_VALUE
        && globalIntensity_Kick < INTENSITY_THRESHOLD_KICK
        && audioInputBuffer_Snare.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD
        && audioInputBuffer_Cymbals.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD
        && audioInputBuffer_Guitar.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD
        && audioInputBuffer_Keys.get(AUDIO_BUFFER_SIZE-1) < INTENSITY_THRESHOLD) 
    {
      onlyFilteredBassIsPlaying = true;
    }
    else {
      onlyFilteredBassIsPlaying = false;
    }
  }
  
  public void computeSignalIntensity() {
    globalIntensity_Kick    = 0;
    globalIntensity_Snare   = 0;
    globalIntensity_Cymbals = 0;
    globalIntensity_Bass    = 0;
    globalIntensity_Keys    = 0;
    globalIntensity_Guitar  = 0;
    
    // Will be uncommented when a scenario using this is made
//    partialIntensity_Kick    = 0;
//    partialIntensity_Snare   = 0;
//    partialIntensity_Cymbals = 0;
//    partialIntensity_Bass    = 0;
//    partialIntensity_Keys    = 0;
//    partialIntensity_Guitar  = 0;
    
    for (int i=1; i<AUDIO_BUFFER_SIZE; i++) {
      globalIntensity_Kick    += audioInputBuffer_Kick.get(i);
      globalIntensity_Snare   += audioInputBuffer_Snare.get(i);
      globalIntensity_Cymbals += audioInputBuffer_Cymbals.get(i);
      globalIntensity_Bass    += audioInputBuffer_Bass.get(i);
      globalIntensity_Keys    += audioInputBuffer_Keys.get(i);
      globalIntensity_Guitar  += audioInputBuffer_Guitar.get(i);
    }
    
    // Will be uncommented when a scenario using this is made 
//    for (int i=1; i<PARTIAL_INTENSITY_SAMPLE_NUMBER; i++) {
//      partialIntensity_Kick    += audioInputBuffer_Kick.get(i);
//      partialIntensity_Snare   += audioInputBuffer_Snare.get(i);
//      partialIntensity_Cymbals += audioInputBuffer_Cymbals.get(i);
//      partialIntensity_Bass    += audioInputBuffer_Bass.get(i);
//      partialIntensity_Keys    += audioInputBuffer_Keys.get(i);
//      partialIntensity_Guitar  += audioInputBuffer_Guitar.get(i);
//    }
  }
  
  public void determineIntensity() {
    // Check all the instrument buffers, define the intensity according to the audio :
    // Check also if a special scenario is currently active - in this case, the intensity is set by default, not according to the audio
    
    if (specialRuleActive) {
      currentIntensity = INTENSITY_MAX;
    }
    else if (globalIntensity_Kick  > 5*INTENSITY_THRESHOLD_KICK
        && globalIntensity_Snare   > INTENSITY_THRESHOLD_SNARE
        && globalIntensity_Cymbals > INTENSITY_THRESHOLD_CYMBALS
        && globalIntensity_Bass    > INTENSITY_THRESHOLD_BASS
        && globalIntensity_Keys    > INTENSITY_THRESHOLD_KEYS)
    {
      currentIntensity = INTENSITY_MAX;
    }
    else if (globalIntensity_Kick  > INTENSITY_THRESHOLD_KICK
       && globalIntensity_Snare    > INTENSITY_THRESHOLD_SNARE
       && globalIntensity_Cymbals  > INTENSITY_THRESHOLD_CYMBALS
       && globalIntensity_Bass     > INTENSITY_THRESHOLD_BASS)
    {
      currentIntensity = INTENSITY_HIGH;
    }
    else if (globalIntensity_Kick > INTENSITY_THRESHOLD_KICK
       && globalIntensity_Snare   > INTENSITY_THRESHOLD_SNARE
       && (tempoIsVerySlow == false))
    {
      currentIntensity = INTENSITY_MEDIUM;
    }
    // Even if there is both kick and snare, if the tempo is very low, consider the intensity to be low
    else if (globalIntensity_Kick > INTENSITY_THRESHOLD_KICK
       && globalIntensity_Snare   > INTENSITY_THRESHOLD_SNARE)
    {
      currentIntensity = INTENSITY_LOW;
    }
    else {
      currentIntensity = INTENSITY_LOW;
    }
  }
  
  public void drawAdditionalManualEffects() {
    if (setBlackOutAutomode == true) {
      draw_AutoModeBlackOut(blackoutPower);
    }
    
    if (setWhiteOutAutomode == true) {
      draw_AutoModeWhiteOut(whiteoutPower);
    }
    
    if (setColorChangeAutoMode == true) {
      draw_AutoModeColorChange();
    }
    if (setWhiteJamaMonoAutoMode == true) {
      draw_whiteJamaMono(this.whiteJamaMonoPower);
    }
  }
  
  public void chooseNewColorset() {
    float rollTheDice = random(1);
    if (rollTheDice <= 0.5f) {
      //50% chance to choose the white colorset
      currentColorSet = COLORSET_WHITE;
      //outputLog.println("Automatic mode info : current color set is White");
    }
    else if (rollTheDice <= 0.8f) {
      //30% chance to choose the red colorset
      currentColorSet = COLORSET_RED;
      //outputLog.println("Automatic mode info : current color set is Red");
    }
    else {
      //20% chance to choose the colorful colorset
      currentColorSet = COLORSET_COLORFUL;
      //outputLog.println("Automatic mode info : current color set is Colorful");
    }
  }

  //Debug function used for tuning the system, print the most important informations in a clear, readable way
  public void printSystemDebugData() {
    String debugString = "Automatic mode debug info : ";
    if (currentIntensity == INTENSITY_MAX)          {debugString += "Intensity=Max";}
    else if (currentIntensity == INTENSITY_HIGH)    {debugString += "Intensity=High";}
    else if (currentIntensity == INTENSITY_MEDIUM)  {debugString += "Intensity=Medium";}
    else if (currentIntensity == INTENSITY_LOW)     {debugString += "Intensity=Low";}
    else if (currentIntensity == INTENSITY_DEFAULT) {debugString += "Intensity=Default";}
    debugString += ", GuitarOnly="         + onlyGuitarIsPlaying;
    debugString += ", FilteredBassOnly="         + onlyFilteredBassIsPlaying;
    debugString += ", Intensity[Kick|Snare|Cymbal|Bass|Keys|Guitar]=[" + globalIntensity_Kick + "|" + globalIntensity_Snare + "|" + globalIntensity_Cymbals + "|" + globalIntensity_Bass + "|" + globalIntensity_Keys + "|" + globalIntensity_Guitar + "]";
    debugString += ", SpecialScenarioDetected=" + specialRuleActive;
    debugString += ", CurrentPosition=" + currentPosition;
    debugString += ", CurrentLoopTimeElapsed=" + currentLoopTimeElapsed;
    debugString += ", GlobalSequenceTimeElapsed=" + globalSequenceTimeElapsed;
    println(debugString);
    //outputLog.println(debugString);
  }
  
  ///////////////////////////////////////////////////////////////////
  // Special actions to be executed when specific conditions are met
  
  public void playSpecialActions_onlyGuitar() {
    // No need to reset dmxAnimationNumber_strobe when this special condition ends, as the auto mode will force back whatever DMX animations it wants to play
    // Only light up the left side's stroboscope, full power 
    dmxAnimationNumber_strobe  = 11;
    animationnumber     = 1;
    customDeviceAnimation(1);
    specificActions();
  }
  
  public void playSpecialActions_onlyFilteredBass() {
    // No need to reset dmxAnimationNumber_strobe when this special condition ends, as the auto mode will force back whatever DMX animations it wants to play
    // Only light up the right side's stroboscope, full power 
    dmxAnimationNumber_strobe  = 16;
    animationnumber     = 1;
    customDeviceAnimation(1);
    specificActions();
  }
}

////////////////////////////////////////////////
//       Configuration file management        //
////////////////////////////////////////////////

//Creates a config file in the root path of the application
//This configuration file is persistant, and allows to define which addresses should be used
//for the DMX devices, as well as activate manual input



final String configFilename = "Strobot_config.txt";
BufferedReader configFile_read;
PrintWriter configFile_write;

//Default values are initialised as follows : 1 front stroboscope with the following settings
int DMXAddress_stroboscopeSpeed = 1;
int DMXAddress_stroboscopeBrightness = 2;

int numberOfLEDPanelMicrocontrollersFoundInConf = 0;

public void getInfoFromConfigFile() {
  if (checkIfFileExists(configFilename) == false) {
    //Default configuration, create a new configuration file
    createConfigFile();
  }
  else {
    //Configuration file exists - consider only the DMX devices declared inside the file, reinit the device lists, same goes for custom devices
    empty_DMXDevices();
    empty_CustomDevices();
    
    configFile_read = createReader(configFilename);
    boolean endFile = false;
    String line = "";
    while (endFile != true) {
      try {
        line = configFile_read.readLine();        
      } catch (Exception e) {
        e.printStackTrace();
        endFile = true;
      }
      if (endFile != true && line != null) {
        parseConfigurationFile(line);
        line = "";
      }
      if (line == null) {
        endFile = true;
      }
    }
  }
}


public void createConfigFile() {
    configFile_write = createWriter(configFilename);
    
    configFile_write.println("////////////////////////////////////////////");
    configFile_write.println("//      Strobot - Configuration file      //");
    configFile_write.println("////////////////////////////////////////////");
    configFile_write.println();
    configFile_write.println("General output settings");
    configFile_write.println("Note - for panel mapping, the fastest way to set the correct parameter is by using the MIDI controller, the info shall be automatically written in this file");
    configFile_write.println("------------------------------------");
    configFile_write.println("Microcontroller|DMX:" + DMX_MICROCONTROLLER_NAME);
    configFile_write.println("Microcontroller|CustomDevices:" + CUSTOMDEVICES_MICROCONTROLLER_NAME);
    printLEDPanelMicrocontrollerConfiguration();
    configFile_write.println("------------------------------------");          
    configFile_write.println("Debug|DisableDMXOutput:" + debug_without_dmx);
    configFile_write.println("Debug|ActivatePHPGeneration:" + output_PHP);
    configFile_write.println("Output|NumberOfPanels:" + NUMBER_OF_PANELS);
    configFile_write.println("Output|ScreenOrder:" + getScreenOrderConfiguration());
    configFile_write.println("MIDISettings|MainInputMIDIDevice:" + MIDI_BUS_MAIN_INPUT);
    configFile_write.println("MIDISettings|ControllerInputMIDIDevice:" + MIDI_BUS_CONTROLLER_INPUT);
    configFile_write.println("MIDISettings|PioneerControllerInputMIDIDevice:" + MIDI_BUS_PIONEER_CONTROLLER_INPUT);
    configFile_write.println();
    configFile_write.println();
    configFile_write.println("This section allows persistant DMX mapping - define custom addresses for the DMX devices below");
    printCustomDevicesConfiguration();
    configFile_write.println();
    configFile_write.println();    
    configFile_write.println("This section allows persistant DMX mapping - define custom addresses for the DMX devices below");
    configFile_write.println("For stroboscopes, the following devices can be configured -> FrontStroboscope/BackStroboscope, with the attributes Speed, Brightness and FlashLength"); 
    configFile_write.println();
    printDMXDeviceConfiguration();
    configFile_write.println();
    configFile_write.println("Choose to display the graphic user interface or not - not displaying it will result in a lighter CPU usage");
    configFile_write.println("GeneralSettings|DisplayGUI:" + DISPLAY_GUI);
    configFile_write.println();
    configFile_write.println("This section allows to activate or disable special manual actions during the regular semi-automatic and manual modes, using the keyboard");
    configFile_write.println();
    configFile_write.println("ManualInput|AuthorizeManualInput:" + authorizeGeneralManualMode);
    configFile_write.println("------------------------------------");
    configFile_write.println("ManualInput|AuthorizeKillPanels:" + authorizeKillLedPanelManualMode);
    configFile_write.println("ManualInput|AuthorizeStrobo4:" + authorizeStrobeManualMode4th);
    configFile_write.println("ManualInput|AuthorizeStrobo8:" + authorizeStrobeManualMode8th);
    configFile_write.println("ManualInput|AuthorizeStrobo16:" + authorizeStrobeManualMode16th);
    configFile_write.println("ManualInput|AuthorizeStrobo32:" + authorizeStrobeManualMode32nd);
    configFile_write.println("ManualInput|AuthorizeStrobo64:" + authorizeStrobeManualMode64th);
    configFile_write.println("ManualInput|AuthorizeBlackOut:" + authorizeBlackOutManualMode);
    configFile_write.println("ManualInput|AuthorizeWhiteOut:" + authorizeWhiteOutManualMode);
    configFile_write.println("ManualInput|AuthorizeShredder:" + authorizeShredderManualMode);
    configFile_write.println("ManualInput|AuthorizeColorChange:" + authorizeColorChangeManualMode);
    configFile_write.println("ManualInput|AuthorizeWhiteJamaMono:" + authorizeWhiteJamaMonoManualMode);
    configFile_write.println("ManualInput|AuthorizeWhiteNoiseManualMode:" + authorizeWhiteNoiseManualMode);
    configFile_write.println("------------------------------------");
    configFile_write.println("ManualInput|ManualStrobe->DMX:" + authorizeDMXStrobe);
    configFile_write.println("ManualInput|ManualStrobe->Panels:" + authorizePanelStrobe);
    configFile_write.println();
    configFile_write.println("Configure the MIDI noteOn pitches used for these manual actions");
    configFile_write.println("The notes can either be written as regular integers (0-127), or as note names, following the MIDI implementation chart (ie C-1, A#2, F0...)");
    configFile_write.println("------------------------------------");
    configFile_write.println("ManualInput|Pad|KillPanels:" + getStringFromNoteInt(PITCH_PAD_KILL_LED_PANELS));
    configFile_write.println("ManualInput|Pad|Strobo4:" + getStringFromNoteInt(PITCH_PAD_STROBE_4TH));
    configFile_write.println("ManualInput|Pad|Strobo8:" + getStringFromNoteInt(PITCH_PAD_STROBE_8TH));
    configFile_write.println("ManualInput|Pad|Strobo16:" + getStringFromNoteInt(PITCH_PAD_STROBE_16TH));
    configFile_write.println("ManualInput|Pad|Strobo32:" + getStringFromNoteInt(PITCH_PAD_STROBE_32ND));
    configFile_write.println("ManualInput|Pad|Strobo64:" + getStringFromNoteInt(PITCH_PAD_STROBE_64TH));
    configFile_write.println("ManualInput|Knob|BlackOut:" + PITCH_KNOB_BLACKOUT);
    configFile_write.println("ManualInput|Knob|WhiteOut:" + PITCH_KNOB_WHITEOUT);
    configFile_write.println("ManualInput|Knob|Shredder:" + PITCH_KNOB_SHREDDER);
    configFile_write.println("ManualInput|Knob|ColorChange:" + PITCH_KNOB_COLORCHANGE);
    configFile_write.println("ManualInput|Knob|WhiteJamaMono:" + PITCH_KNOB_WHITEJAMAMONO);
    configFile_write.println();
    configFile_write.println();
    configFile_write.println("This section allows to map the IDs of the audio signals sent by the different SignalProcessor instances to a specific function");
    configFile_write.println();
    configFile_write.println("------------------------------------");
    configFile_write.println("AudioInput|SignalID|Kick:" + SIGNAL_ID_KICK);
    configFile_write.println("AudioInput|SignalID|Snare:" + SIGNAL_ID_SNARE);
    configFile_write.println("AudioInput|SignalID|Cymbals:" + SIGNAL_ID_CYMBALS);
    configFile_write.println("AudioInput|SignalID|Bass:" + SIGNAL_ID_BASS);
    configFile_write.println("AudioInput|SignalID|Keys:" + SIGNAL_ID_KEYS);
    configFile_write.println("AudioInput|SignalID|Guitar:" + SIGNAL_ID_GUITAR);
    configFile_write.println("AudioInput|HiLoFilterThreshold|Bass:" + HI_LO_RATIO_THRESHOLD);
    configFile_write.println();
    configFile_write.flush();
    configFile_write.close();  
}

public void printLEDPanelMicrocontrollerConfiguration() {
  for (String microcontroller: TEENSY_SERIAL_PORT_LIST_5) {
    configFile_write.println("Microcontroller|LEDPanels:" + microcontroller);
  }
}

public void printDMXDeviceConfiguration() {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    configFile_write.println("FrontLeftStroboscope|" + stroboscope.printStatus());
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    configFile_write.println("FrontRightStroboscope|" + stroboscope.printStatus());
  }
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    configFile_write.println("BackStroboscope|" + stroboscope.printStatus());
  }
}

public void printCustomDevicesConfiguration() {
  for (CustomDevice_LEDTube ledTube: CustomDeviceList_LEDTubes) {
    configFile_write.println("LEDTube|" + ledTube.printStatus());
  }
  for (CustomDevice_RackLight rackLight: CustomDeviceList_RackLights) {
    configFile_write.println("RackLight|" + rackLight.printStatus());
  }
}



public String getScreenOrderConfiguration() {
  String temp = "[" + screen_order_configuration[0] + ",";
  for (int i=1; i<screen_order_configuration.length-1;i++) {temp += screen_order_configuration[i] + ","; }
  temp += screen_order_configuration[screen_order_configuration.length-1] + "]";
  return temp;  
}

public void parseScreenOrderConfiguration(String config) {
  IntList tempValues = new IntList();
  try {
    boolean rejectLine = false;
    String[] configSplit1 = split(config, "[");

    if (configSplit1.length != 2) {
      rejectLine = true;
      outputLog.println("Panel mapping configuration - improper syntax, impossible to parse the following declaration : " + config + " - example of accepted syntax : [0,1,2,3,4]");
    }
    if (rejectLine == false) {
      String[] configSplit2 = split(configSplit1[1], "]");
      if (configSplit2.length != 2) {
        rejectLine = true;
        outputLog.println("Panel mapping configuration - improper syntax, impossible to parse the following declaration : " + config + " - example of accepted syntax : [0,1,2,3,4]");
      }
      
      if (rejectLine == false) {
        String[] configSplit3 = split(configSplit2[0], ",");
        if (configSplit3.length < 3) {
          outputLog.println("Panel mapping configuration - improper values : " + config + " - this application is not made to work with a single panel, use at least 3");
        }
        for (String element: configSplit3) {
          int intElement = Integer.parseInt(element);
          if (intElement < 0) {
            rejectLine = true;
            outputLog.println("Panel mapping configuration - invalid value, impossible to parse the following declaration : " + config + " - example of accepted syntax : [0,1,2,3,4]");
          }
          else {
            tempValues.append(intElement);
          }
        }
      }
    }
    
    if (rejectLine == false) {
      if (tempValues.size() != NUMBER_OF_PANELS) {
        rejectLine = true;
        outputLog.println("Invalid panel mapping configuration (not enough values, expected " + NUMBER_OF_PANELS + " values) - setting default mapping");
        setDefaultScreenOrderConfiguration();
      }
      if (rejectLine == false) {
        screen_order_configuration = new int[NUMBER_OF_PANELS];
        for (int i=0; i<tempValues.size(); i++) {
          screen_order_configuration[i] = tempValues.get(i);
        }
        outputLog.println("Panel mapping configuration - Successfully parsed configuration file : " + config); 
      }
    }
    else {
      outputLog.println("Invalid panel mapping configuration (bad parsing) - setting default mapping");
      setDefaultScreenOrderConfiguration(); 
    }
    
    
  }
  catch (Exception e) {
    outputLog.println("Panel mapping configuration - improper syntax, impossible to parse the following declaration : " + config + " - example of accepted syntax : [0,1,2,3,4]");
  }
//    if (rejectLine == false) {
//      if (lineSplit[0].contains("Microcontroller|DMX")) {
  
}


public boolean checkIfFileExists(String filename) {
  String filepath = sketchPath("") + "/" + filename;
  File file = new File(filepath);
  return file.exists();
}

public void parseConfigurationFile(String line) {
  try {
    String[] lineSplit = split(line, ":");
    boolean rejectLine = false;
    if (lineSplit.length < 2) {
      rejectLine = true;
    }
    if (rejectLine == false) {
      if (lineSplit[0].contains("Microcontroller|DMX")) {
        DMX_MICROCONTROLLER_NAME = lineSplit[1];
      }
      else if (lineSplit[0].contains("Microcontroller|CustomDevices")) {
        CUSTOMDEVICES_MICROCONTROLLER_NAME = lineSplit[1];
      }
      else if (lineSplit[0].contains("Microcontroller|LEDPanels")) {
        if (numberOfLEDPanelMicrocontrollersFoundInConf < 5) {
          TEENSY_SERIAL_PORT_LIST_5[numberOfLEDPanelMicrocontrollersFoundInConf] = lineSplit[1];
        }
        else {
          outputLog.println("!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!");
          outputLog.println("Too many microcontrollers for the panels found registered inside the configuration file !");
          outputLog.println("!!!!!!!!!!!!!!! WARNING !!!!!!!!!!!!!!!");
        }
        numberOfLEDPanelMicrocontrollersFoundInConf += 1;
      }

      else if (lineSplit[0].contains("Debug|DisableDMXOutput")) {
        debug_without_dmx = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("Debug|ActivatePHPGeneration")) {
        output_PHP = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("Output|NumberOfPanels")) {
        NUMBER_OF_PANELS = Integer.parseInt(lineSplit[1]);
        outputLog.println("Configuration file parsing : setting number of LED panels to " + NUMBER_OF_PANELS);
      }
      else if (lineSplit[0].contains("Output|ScreenOrder")) {
        parseScreenOrderConfiguration(lineSplit[1]); 
      }
      else if (lineSplit[0].contains("MIDISettings|MainInputMIDIDevice")) {
        MIDI_BUS_MAIN_INPUT = lineSplit[1];
      }
      else if (lineSplit[0].contains("MIDISettings|PioneerControllerInputMIDIDevice")) {
        MIDI_BUS_PIONEER_CONTROLLER_INPUT = lineSplit[1];
      }
      else if (lineSplit[0].contains("MIDISettings|ControllerInputMIDIDevice")) {
        MIDI_BUS_CONTROLLER_INPUT = lineSplit[1];
      }
      
      //////////////////////////////////////////////////
      
      
      else if (lineSplit[0].contains("GeneralSettings|DisplayGUI")) {
        DISPLAY_GUI = getBooleanFromString(lineSplit[1]);
      }
        
      //////////////////////////////////////////////////
      
      else if (lineSplit[0].contains("LEDTube")) {
        parseCustomDeviceSpecificLine_LEDTube(line);
      }
      else if (lineSplit[0].contains("RackLight")) {
        parseCustomDeviceSpecificLine_RackLight(line);
      }
      
      //////////////////////////////////////////////////
      
      else if (lineSplit[0].contains("FrontLeftStroboscope")) {
        parseDMXSpecificLine_FrontLeftStroboscope(line);
      }
      else if (lineSplit[0].contains("FrontRightStroboscope")) {
        parseDMXSpecificLine_FrontRightStroboscope(line);
      }
      else if (lineSplit[0].contains("BackStroboscope")) {
        parseDMXSpecificLine_BackStroboscope(line);
      }
      else if (lineSplit[0].contains("Projector")) {
        parseDMXSpecificLine_Projector(line);
      }
      
      //////////////////////////////////////////////////
      
      
      else if (lineSplit[0].contains("ManualInput|AuthorizeManualInput")) {
        authorizeGeneralManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeKillPanels")) {
        authorizeKillLedPanelManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeKillPanels")) {
        authorizeKillLedPanelManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeStrobo4")) {
        authorizeStrobeManualMode4th = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeStrobo8")) {
        authorizeStrobeManualMode8th = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeStrobo16")) {
        authorizeStrobeManualMode16th = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeStrobo32")) {
        authorizeStrobeManualMode32nd = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeStrobo64")) {
        authorizeStrobeManualMode64th = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeBlackOut")) {
        authorizeBlackOutManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeWhiteOut")) {
        authorizeWhiteOutManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeShredder")) {
        authorizeShredderManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeColorChange")) {
        authorizeColorChangeManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeWhiteJamaMono")) {
        authorizeWhiteJamaMonoManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|AuthorizeWhiteNoiseManualMode")) {
        authorizeWhiteNoiseManualMode = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|ManualStrobe->DMX")) {
        authorizeDMXStrobe = getBooleanFromString(lineSplit[1]);
      }
      else if (lineSplit[0].contains("ManualInput|ManualStrobe->Panels")) {
        authorizePanelStrobe = getBooleanFromString(lineSplit[1]);
      }
  
      //////////////////////////////////////////////////
      
//      else if (lineSplit[0].contains("ManualInput|Pad|KillPanels")) {
//        PITCH_PAD_KILL_LED_PANELS = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Pad|Strobo4")) {
//        PITCH_PAD_STROBE_4TH = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Pad|Strobo8")) {
//        PITCH_PAD_STROBE_8TH = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Pad|Strobo16")) {
//        PITCH_PAD_STROBE_16TH = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Pad|Strobo32")) {
//        PITCH_PAD_STROBE_32ND = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Pad|Strobo64")) {
//        PITCH_PAD_STROBE_64TH = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Knob|BlackOut")) {
//        PITCH_KNOB_BLACKOUT = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Knob|WhiteOut")) {
//        PITCH_KNOB_WHITEOUT = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Knob|Shredder")) {
//        PITCH_KNOB_SHREDDER = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Knob|ColorChange")) {
//        PITCH_KNOB_COLORCHANGE = convertStringToInt(lineSplit[1]);
//      }
//      else if (lineSplit[0].contains("ManualInput|Knob|WhiteJamaMono")) {
//        PITCH_KNOB_WHITEJAMAMONO = convertStringToInt(lineSplit[1]);
//      }

      //////////////////////////////////////////////////
      
      else if (lineSplit[0].contains("AudioInput|SignalID|Kick")) {
        SIGNAL_ID_KICK = convertStringToInt(lineSplit[1]);
      }
      else if (lineSplit[0].contains("AudioInput|SignalID|Snare")) {
        SIGNAL_ID_SNARE = convertStringToInt(lineSplit[1]);
      }
      else if (lineSplit[0].contains("AudioInput|SignalID|Cymbals")) {
        SIGNAL_ID_CYMBALS = convertStringToInt(lineSplit[1]);
      }
      else if (lineSplit[0].contains("AudioInput|SignalID|Bass")) {
        SIGNAL_ID_BASS = convertStringToInt(lineSplit[1]);
      }
      else if (lineSplit[0].contains("AudioInput|SignalID|Keys")) {
        SIGNAL_ID_KEYS = convertStringToInt(lineSplit[1]);
      }
      else if (lineSplit[0].contains("AudioInput|SignalID|Guitar")) {
        SIGNAL_ID_GUITAR = convertStringToInt(lineSplit[1]);
      }
      else if (lineSplit[0].contains("AudioInput|HiLoFilterThreshold|Bass")) {
        HI_LO_RATIO_THRESHOLD = convertStringToFloat(lineSplit[1]);
      }
      
    }
  }
  catch (Exception e) {
    outputLog.println("Error while trying to parse the configuration file : " + e);
  }
}

public void parseCustomDeviceSpecificLine_LEDTube(String line) {
  int deviceNumber = -1;
  
  try {
    String[] lineSplit = split(line, "|");
    for (String element: lineSplit) {
      String[] elementSplit = split(element, ":");
      
      boolean rejectLine = false;
      if (elementSplit.length != 2) {
        rejectLine = true;
      }
      if (rejectLine == false) {
        if (elementSplit[0].contains("DeviceNumber")) {
          deviceNumber = convertStringToInt(elementSplit[1]);
        }
      }
    }
  }
  catch (Exception e) {
    outputLog.println("Error while parsing the CustomDevice|LEDTube line (" + line + ") : " + e);
  }
  boolean dataAvailable = true;
  if (deviceNumber < 0) {
    dataAvailable = false;
  }
  if (dataAvailable == true) {
    outputLog.println("Adding a LEDTube : DeviceNumber:" + deviceNumber);
    CustomDeviceList_LEDTubes.add(new CustomDevice_LEDTube(deviceNumber));
  }
}


public void parseCustomDeviceSpecificLine_RackLight(String line) {
  int deviceNumber = -1;
  
  try {
    String[] lineSplit = split(line, "|");
    for (String element: lineSplit) {
      String[] elementSplit = split(element, ":");
      
      boolean rejectLine = false;
      if (elementSplit.length != 2) {
        rejectLine = true;
      }
      if (rejectLine == false) {
        if (elementSplit[0].contains("DeviceNumber")) {
          deviceNumber = convertStringToInt(elementSplit[1]);
        }
      }
    }
  }
  catch (Exception e) {
    outputLog.println("Error while parsing the CustomDevice|RackLight line (" + line + ") : " + e);
  }
  boolean dataAvailable = true;
  if (deviceNumber < 0) {
    dataAvailable = false;
  }
  if (dataAvailable == true) {
    outputLog.println("Adding a RackLight : DeviceNumber:" + deviceNumber);
    CustomDeviceList_RackLights.add(new CustomDevice_RackLight(deviceNumber));
  }
}


public void parseDMXSpecificLine_FrontLeftStroboscope(String line) {
  int dmx_speed       = -1;
  int dmx_brightness  = -1;
  int dmx_flashLength = -1;
  int dmx_specialFX   = -1;
  
  try {
    String[] lineSplit = split(line, "|");
    for (String element: lineSplit) {
      String[] elementSplit = split(element, ":");
      
      boolean rejectLine = false;
      if (elementSplit.length != 2) {
        rejectLine = true;
      }
      if (rejectLine == false) {
        if (elementSplit[0].contains("Speed")) {
          dmx_speed = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("Brightness")) {
          dmx_brightness = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("FlashLength")) {
          dmx_flashLength = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("SpecialFX")) {
          dmx_specialFX = convertStringToInt(elementSplit[1]);
        }
      }
    }
  }
  catch (Exception e) {
    outputLog.println("Error while parsing the DMX|FrontLeftStroboscope line (" + line + ") : " + e);
  }
  
  boolean dataAvailable = true;
  if (dmx_speed < 0 || dmx_brightness < 0) {
    dataAvailable = false;
  }
  if (dataAvailable == true) {
    if (dmx_flashLength < 0) {
      outputLog.println("Adding a 2-channel front left stroboscope : Speed:" + dmx_speed + "|Brightness:" + dmx_brightness);
      DMXList_FrontLeftStroboscopes.add(new DMX_Stroboscope(dmx_speed, dmx_brightness));
    }
    else {
      outputLog.println("Adding a 4-channel front left stroboscope : Brightness:" + dmx_brightness + "|FlashLength:" + dmx_flashLength + "|Speed: " + dmx_speed + "|SpecialFX:" + dmx_specialFX);
      DMXList_FrontLeftStroboscopes.add(new DMX_Stroboscope(dmx_brightness, dmx_flashLength, dmx_speed, dmx_specialFX));
    }
  }
  else {
    outputLog.println("Error while creating the DMX FrontLeftStroboscope object, not enough data is available. Speed:" + dmx_speed + "|Brightness:" + dmx_brightness);
  }
}

public void parseDMXSpecificLine_FrontRightStroboscope(String line) {
  int dmx_speed = -1;
  int dmx_brightness = -1;
  int dmx_flashLength = -1;
  int dmx_specialFX   = -1;
  
  try {
    String[] lineSplit = split(line, "|");
    for (String element: lineSplit) {
      String[] elementSplit = split(element, ":");
      
      boolean rejectLine = false;
      if (elementSplit.length != 2) {
        rejectLine = true;
      }
      if (rejectLine == false) {
        if (elementSplit[0].contains("Speed")) {
          dmx_speed = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("Brightness")) {
          dmx_brightness = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("FlashLength")) {
          dmx_flashLength = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("SpecialFX")) {
          dmx_specialFX = convertStringToInt(elementSplit[1]);
        }
      }
    }
  }
  catch (Exception e) {
    outputLog.println("Error while parsing the DMX|FrontRightStroboscope line (" + line + ") : " + e);
  }
  
  boolean dataAvailable = true;
  if (dmx_speed < 0 || dmx_brightness < 0) {
    dataAvailable = false;
  }
  if (dataAvailable == true) {
    if (dmx_flashLength < 0) {
      outputLog.println("Adding a 2-channel front right stroboscope : Speed:" + dmx_speed + "|Brightness:" + dmx_brightness);
      DMXList_FrontRightStroboscopes.add(new DMX_Stroboscope(dmx_speed, dmx_brightness));
    }
    else {
      outputLog.println("Adding a 4-channel front right stroboscope : Brightness:" + dmx_brightness + "|FlashLength:" + dmx_flashLength + "|Speed: " + dmx_speed + "|SpecialFX:" + dmx_specialFX);
      DMXList_FrontRightStroboscopes.add(new DMX_Stroboscope(dmx_brightness, dmx_flashLength, dmx_speed, dmx_specialFX));
    }
  }
  else {
    outputLog.println("Error while creating the DMX FrontRightStroboscope object, not enough data is available. Speed:" + dmx_speed + "|Brightness:" + dmx_brightness);
  }
}

public void parseDMXSpecificLine_BackStroboscope(String line) {
  int dmx_speed = -1;
  int dmx_brightness = -1;
  int dmx_flashLength = -1;
  int dmx_specialFX = -1;
  
  try {
    String[] lineSplit = split(line, "|");
    for (String element: lineSplit) {
      String[] elementSplit = split(element, ":");
      
      boolean rejectLine = false;
      if (elementSplit.length != 2) {
        rejectLine = true;
      }
      if (rejectLine == false) {
        if (elementSplit[0].contains("Speed")) {
          dmx_speed = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("Brightness")) {
          dmx_brightness = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("FlashLength")) {
          dmx_flashLength = convertStringToInt(elementSplit[1]);
        }
        else if (elementSplit[0].contains("SpecialFX")) {
          dmx_specialFX = convertStringToInt(elementSplit[1]);
        }
      }
    }
  }
  catch (Exception e) {
    outputLog.println("Error while parsing the DMX|Backstroboscope line (" + line + ") : " + e);
  }
  
  boolean dataAvailable = true;
  if (dmx_speed < 0 || dmx_brightness < 0) {
    dataAvailable = false;
  }
  if (dataAvailable == true) {
    if (dmx_flashLength < 0) {
      outputLog.println("Adding a 2-channel back stroboscope : Speed:" + dmx_speed + "|Brightness:" + dmx_brightness);
      DMXList_BackStroboscopes.add(new DMX_Stroboscope(dmx_speed, dmx_brightness));
    }
    else {
      outputLog.println("Adding a 4-channel back stroboscope : Brightness:" + dmx_brightness + "|FlashLength:" + dmx_flashLength + "|Speed: " + dmx_speed + "|SpecialFX:" + dmx_specialFX);
      DMXList_BackStroboscopes.add(new DMX_Stroboscope(dmx_brightness, dmx_flashLength, dmx_speed, dmx_specialFX));
    }
  }
  else {
    outputLog.println("Error while creating the DMX BackStroboscope object, not enough data is available. Speed:" + dmx_speed + "|Brightness:" + dmx_brightness);
  }
}

public void parseDMXSpecificLine_Projector(String line) {
  //TBIL
  outputLog.println("//// PAR parsing is yet to be implemented ////");
}

///////////////////////////////////////////////////////
// Utility functions to parse the configuration file //
///////////////////////////////////////////////////////

public boolean getBooleanFromString(String input) {
  if (input.contains("true") || input.contains("1") || input.contains("on") || input.contains("True") || input.contains("On") || input.contains("yes") || input.contains("Yes")) {
    return true;
  }
  else {
    return false;
  }
}

//Get the 0-127 int value corresponding to a MIDI note, ie E-2 or G#3
public int getIntFromNoteString(String note) {
  int baseValue;
  if (note.charAt(note.length()-2) == '-') {
    if (note.charAt(note.length()-1) == '2') {    //-2
      baseValue = 0;
    }
    else {    //-1
      baseValue = 12;
    } 
  }
  else {
    baseValue = 24 + 12*Integer.parseInt(str(note.charAt(note.length()-1)));
  }
  
  int bonusValue = 0;
  if (note.charAt(1) == '#') {bonusValue = 1;}
  if (note.charAt(1) == 'b') {bonusValue = -1;}
  
  int noteValue = 0;
  if (note.charAt(0) == 'C') {noteValue = 0;}
  else if (note.charAt(0) == 'D') {noteValue = 2;}
  else if (note.charAt(0) == 'E') {noteValue = 4;}
  else if (note.charAt(0) == 'F') {noteValue = 5;}
  else if (note.charAt(0) == 'G') {noteValue = 7;}
  else if (note.charAt(0) == 'A') {noteValue = 9;}
  else if (note.charAt(0) == 'B') {noteValue = 11;}
  else {outputLog.println("Configuration file parsing : invalid value for note || " + note);}
  
  return baseValue + noteValue + bonusValue;
}

//Get the note name corresponding to its numeric MIDI counterpart 
public String getStringFromNoteInt(int note) {
  if (note >= 128) {
    outputLog.println("Configuration file parsing : invalid value for note int > 128 || " + note);
    return "";
  }
  else {
    int baseValue = note/12;    //Valid because dealing with int values
    int noteValue = note%12;  
    String octave = str(baseValue - 2);;
    String noteName = "";
    switch(noteValue) {
      case 0: noteName = "C";break;
      case 1: noteName = "C#";break;
      case 2: noteName = "D";break;
      case 3: noteName = "D#";break;
      case 4: noteName = "E";break;
      case 5: noteName = "F";break;
      case 6: noteName = "F#";break;
      case 7: noteName = "G";break;
      case 8: noteName = "G#";break;
      case 9: noteName = "A";break;
      case 10: noteName = "A#";break;
      case 11: noteName = "B";break;
      default: break;
    }
    return noteName + octave;
  }
}

//Get the note+velocity corresponding to the input animation number
public String getStringFromAnimationNumber(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK1) + "  |  " + str(animNbr);
  }                                                                                              
  else if (animNbr <= 254) {
    temp = getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK2) + "  |  " + str(animNbr - 127);
  }                                                                                              
  else if (animNbr <= 381) {
    temp = getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK3) + "  |  " + str(animNbr - 254);    
  }
  else if (animNbr <= 508) {
    temp = getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK4) + "  |  " + str(animNbr - 381);
  }  
  return temp;
}

public String getStringFromCustomDeviceAnimationNumber(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_CUSTOM_DEVICE_BANK1) + "  |  " + str(animNbr);
  }                                                                                              
  else if (animNbr <= 254) {
    temp = getStringFromNoteInt(PITCH_CUSTOM_DEVICE_BANK2) + "  |  " + str(animNbr - 127);
  }                                                                                              
  else if (animNbr <= 381) {
    temp = getStringFromNoteInt(PITCH_CUSTOM_DEVICE_BANK3) + "  |  " + str(animNbr - 254);    
  }
  return temp;
}

public String getStringFromDMXAnimationNumber_strobe(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_STROBE) + "  |  " + str(animNbr);
  }
  return temp;
}

public String getStringFromDMXAnimationNumber_par(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_PAR) + "  |  " + str(animNbr);
  }
  
  return temp;
}

public String getStringFromDMXAnimationNumber_movingHead_Movement(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION) + "  |  " + str(animNbr);
  }
  return temp;
}

public String getStringFromDMXAnimationNumber_movingHead_Color(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR) + "  |  " + str(animNbr);
  }
  return temp;
}

public String getStringFromDMXAnimationNumber_movingHead_Rhythm(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_RHYTHM) + "  |  " + str(animNbr);
  }
  return temp;
}

public String getStringFromDMXAnimationNumber_movingHead_LightStyle(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE) + "  |  " + str(animNbr);
  }
  return temp;
}

public String getStringFromDMXAnimationNumber_movingHead_Animation(int animNbr) {
  String temp = "Undefined";
  if (animNbr <= 127) {                                                                   
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1) + "  |  " + str(animNbr);
  }                                                                                              
  else if (animNbr <= 254) {
    temp = getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2) + "  |  " + str(animNbr - 127);
  }                                                                                              

  return temp;
}



public int convertStringToInt(String text) {
  //Allow to parse either regular ints (ie MIDI notes "0", "1"...), or real notes (ie "C3", "A#-1"...) 
  
  int a = -1;
  try {
    a = Integer.parseInt(text);
  }
  catch(NumberFormatException nfe) {
    a = getIntFromNoteString(text);
  }
  return a;
}

public float convertStringToFloat(String text) {
  //Allow to parse a float String 
  
  float a = -1;
  try {
    a = Float.parseFloat(text);
  }
  catch(NumberFormatException nfe) {
    outputLog.println("Exception when parsing float : " + text);
  }
  return a;
}

public void writeScreenOrderInConfigurationFile() {
  //Rewrite completely the configuration file, with the updated screen order
  outputLog.println("Rewriting configuration file to conserve the updated screen order...");
  createConfigFile();  
}
///////////////////////////////////////////////////
// Animations using custom devices as a display  //
///////////////////////////////////////////////////



/*
**  ///////////////////////////////////
**  //Custom devices - Animation list// 
**  ///////////////////////////////////
**
**  This list is the ID of the animations as implemented in the devices'
**  microcontroller.
**  The animations coming as a pair (notified with a "_2" suffix) are rhythmic
**  Calling them in turns allows animation reinitialization on the device
**
*/

final int CUSTOMDEV_ANIM_BLACKOUT                           = 0;
final int CUSTOMDEV_ANIM_WHITEOUT                           = 1;
final int CUSTOMDEV_ANIM_REDOUT                             = 2;
final int CUSTOMDEV_ANIM_BLUEOUT                            = 3;
final int CUSTOMDEV_ANIM_RAINBOWOUT                         = 4;

final int CUSTOMDEV_ANIM_FASTWHITEFLASH                     = 5;
final int CUSTOMDEV_ANIM_FASTWHITEFLASH_2                   = 6;
final int CUSTOMDEV_ANIM_FASTREDFLASH                       = 7;
final int CUSTOMDEV_ANIM_FASTREDFLASH_2                     = 8;
final int CUSTOMDEV_ANIM_FASTBLUEFLASH                      = 9;
final int CUSTOMDEV_ANIM_FASTBLUEFLASH_2                    = 10;
final int CUSTOMDEV_ANIM_FASTRAINBOWFLASH                   = 11;
final int CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2                 = 12;
final int CUSTOMDEV_ANIM_SLOWWHITEFLASH                     = 13;
final int CUSTOMDEV_ANIM_SLOWWHITEFLASH_2                   = 14;
final int CUSTOMDEV_ANIM_SLOWREDFLASH                       = 15;
final int CUSTOMDEV_ANIM_SLOWREDFLASH_2                     = 16;
final int CUSTOMDEV_ANIM_SLOWBLUEFLASH                      = 17;
final int CUSTOMDEV_ANIM_SLOWBLUEFLASH_2                    = 18;
final int CUSTOMDEV_ANIM_SLOWRAINBOWFLASH                   = 19;
final int CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2                 = 20;

final int CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE                = 21;
final int CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE                  = 22;
final int CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE                 = 23;
final int CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE              = 24;
final int CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE                = 25;
final int CUSTOMDEV_ANIM_FASTREDSMOOTHSINE                  = 26;
final int CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE                 = 27;
final int CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE              = 28;

final int CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE               = 29;
final int CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE                 = 30;
final int CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE                = 31;
final int CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE              = 32;
final int CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE        = 33;
final int CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2      = 34;
final int CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE          = 35;
final int CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2        = 36;

final int CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE             = 37;
final int CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE               = 38;
final int CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE              = 39;
final int CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE            = 40;
final int CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE      = 41;
final int CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2    = 42;
final int CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE        = 43;
final int CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2      = 44;

final int CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE               = 45;
final int CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE                 = 46;
final int CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE                = 47;
final int CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE              = 48;
final int CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE        = 49;
final int CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2      = 50;
final int CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE          = 51;
final int CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2        = 52;

final int CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE           = 53;
final int CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE             = 54;
final int CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE            = 55;
final int CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE          = 56;
final int CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE    = 57;
final int CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2  = 58;
final int CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE      = 59;
final int CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2    = 60;

final int CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE         = 61;
final int CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2       = 62;
final int CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE           = 63;
final int CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2         = 64;
final int CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE          = 65;
final int CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2        = 66;
final int CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE          = 67;
final int CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2        = 68;
final int CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE            = 69;
final int CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2          = 70;
final int CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE           = 71;
final int CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2         = 72;

final int CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE       = 73;
final int CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2     = 74;
final int CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE         = 75;
final int CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2       = 76;
final int CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE        = 77;
final int CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2      = 78;
final int CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE        = 79;
final int CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2      = 80;
final int CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE          = 81;
final int CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2        = 82;
final int CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE         = 83;
final int CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2       = 84;

final int CUSTOMDEV_ANIM_FASTWHITEBUILDUP                   = 85;
final int CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2                 = 86;
final int CUSTOMDEV_ANIM_FASTREDBUILDUP                     = 87;
final int CUSTOMDEV_ANIM_FASTREDBUILDUP_2                   = 88;
final int CUSTOMDEV_ANIM_FASTBLUEBUILDUP                    = 89;
final int CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2                  = 90;
final int CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP                 = 91;
final int CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2               = 92;

final int CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP                 = 93;
final int CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2               = 94;
final int CUSTOMDEV_ANIM_MEDIUMREDBUILDUP                   = 95;
final int CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2                 = 96;
final int CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP                  = 97;
final int CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2                = 98;
final int CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP               = 99;
final int CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2             = 100;

final int CUSTOMDEV_ANIM_SLOWWHITEBUILDUP                   = 101;
final int CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2                 = 102;
final int CUSTOMDEV_ANIM_SLOWREDBUILDUP                     = 103;
final int CUSTOMDEV_ANIM_SLOWREDBUILDUP_2                   = 104;
final int CUSTOMDEV_ANIM_SLOWBLUEBUILDUP                    = 105;
final int CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2                  = 106;
final int CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP                 = 107;
final int CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2               = 108;

final int CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP               = 109;
final int CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2             = 110;
final int CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP                 = 111;
final int CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2               = 112;
final int CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP                = 113;
final int CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2              = 114;
final int CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP             = 115;
final int CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2           = 116;

final int CUSTOMDEV_ANIM_WHITENOISE                         = 117;
final int CUSTOMDEV_ANIM_REDNOISE                           = 118;
final int CUSTOMDEV_ANIM_BLUENOISE                          = 119;
final int CUSTOMDEV_ANIM_RAINBOWNOISE                       = 120;

final int CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE               = 121;
final int CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE                 = 122;
final int CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE                = 123;
final int CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE             = 124;
final int CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE               = 125;
final int CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE                 = 126;
final int CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE                = 127;
final int CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE             = 128;

int currentRandomLEDTube = 0;
int currentRandomRackLight = 0;
boolean customDevicesRandomDirection = true;


public void customDeviceAnimation(int customDevAnimationNumber) {
  switch(customDevAnimationNumber) {
    case 0:   customDev_totalBlackout();break;        //0 is here mostly for coherence, most sequencers to not send 0-velocity MIDI messages (apart from Maschine)
    
    //Flat colors
    case 1:   customDev_totalBlackout();break;
    case 2:   customDev_rackLightBlackout();break;
    case 3:   customDev_LEDTubeBlackout();break;
    case 4:   customDev_totalWhiteout();break;
    case 5:   customDev_rackLightWhiteout();break;
    case 6:   customDev_LEDTubeWhiteout();break;
    case 7:   customDev_totalRedout();break;
    case 8:   customDev_rackLightRedout();break;
    case 9:   customDev_LEDTubeRedout();break;
    case 10:  customDev_totalBlueout();break;
    case 11:  customDev_rackLightBlueout();break;
    case 12:  customDev_LEDTubeBlueout();break;
    case 13:  customDev_totalRainbowout();break;
    case 14:  customDev_rackLightRainbowout();break;
    case 15:  customDev_LEDTubeRainbowout();break;
    
    //Flat colors - rhythmic
    case 16:  customDev_totalSingleWhiteOut();break;            //Before: Randomly select devices to light up (p=0.5), and turn off the others. Now: light up one device, in a sequence
    case 17:  customDev_LEDTubeSingleWhiteOut();break;
    case 18:  customDev_totalSingleRedOut();break;
    case 19:  customDev_LEDTubeSingleRedOut();break;
    case 20:  customDev_totalSingleBlueOut();break;
    case 21:  customDev_LEDTubeSingleBlueOut();break;
    case 22:  customDev_totalSingleRainbowOut();break;
    case 23:  customDev_LEDTubeSingleRainbowOut();break;
    
    //One time flash - short
    case 24:  customDev_totalFastWhiteFlash();break;
    case 25:  customDev_LEDTubeFastWhiteFlash();break;
    case 26:  customDev_rackLightFastWhiteFlash();break;
    case 27:  customDev_totalFastRedFlash();break;
    case 28:  customDev_LEDTubeFastRedFlash();break;
    case 29:  customDev_rackLightFastRedFlash();break;
    case 30:  customDev_totalFastBlueFlash();break;
    case 31:  customDev_LEDTubeFastBlueFlash();break;
    case 32:  customDev_rackLightFastBlueFlash();break;
    case 33:  customDev_totalFastRainbowFlash();break;
    case 34:  customDev_LEDTubeFastRainbowFlash();break;
    case 35:  customDev_rackLightFastRainbowFlash();break;
    
    //One time flash - short - random 1 device out of 2
    case 36:  customDev_totalSingleFastWhiteFlash();break;
    case 37:  customDev_LEDTubeSingleFastWhiteFlash();break;
    case 38:  customDev_totalSingleFastRedFlash();break;
    case 39:  customDev_LEDTubeSingleFastRedFlash();break;
    case 40:  customDev_totalSingleFastBlueFlash();break;
    case 41:  customDev_LEDTubeSingleFastBlueFlash();break;
    case 42:  customDev_totalSingleFastRainbowFlash();break;
    case 43:  customDev_LEDTubeSingleFastRainbowFlash();break;

    //One time flash - long
    case 44:  customDev_totalSlowWhiteFlash();break;
    case 45:  customDev_LEDTubeSlowWhiteFlash();break;
    case 46:  customDev_rackLightSlowWhiteFlash();break;
    case 47:  customDev_totalSlowRedFlash();break;
    case 48:  customDev_LEDTubeSlowRedFlash();break;
    case 49:  customDev_rackLightSlowRedFlash();break;
    case 50:  customDev_totalSlowBlueFlash();break;
    case 51:  customDev_LEDTubeSlowBlueFlash();break;
    case 52:  customDev_rackLightSlowBlueFlash();break;
    case 53:  customDev_totalSlowRainbowFlash();break;
    case 54:  customDev_LEDTubeSlowRainbowFlash();break;
    case 55:  customDev_rackLightSlowRainbowFlash();break;
    
    //One time flash - long - random 1 device out of 2
    case 56:  customDev_totalSingleSlowWhiteFlash();break;
    case 57:  customDev_LEDTubeSingleSlowWhiteFlash();break;
    case 58:  customDev_totalSingleSlowRedFlash();break;
    case 59:  customDev_LEDTubeSingleSlowRedFlash();break;
    case 60:  customDev_totalSingleSlowBlueFlash();break;
    case 61:  customDev_LEDTubeSingleSlowBlueFlash();break;
    case 62:  customDev_totalSingleSlowRainbowFlash();break;
    case 63:  customDev_LEDTubeSingleSlowRainbowFlash();break;

    //Smooth sine - slow
    case 64:  customDev_totalSlowWhiteSmoothSine();break;
    case 65:  customDev_rackLightSlowWhiteSmoothSine();break;
    case 66:  customDev_LEDTubeSlowWhiteSmoothSine();break;
    case 67:  customDev_totalSlowRedSmoothSine();break;
    case 68:  customDev_rackLightSlowRedSmoothSine();break;
    case 69:  customDev_LEDTubeSlowRedSmoothSine();break;
    case 70:  customDev_totalSlowBlueSmoothSine();break;
    case 71:  customDev_rackLightSlowBlueSmoothSine();break;
    case 72:  customDev_LEDTubeSlowBlueSmoothSine();break;
    case 73:  customDev_totalSlowRainbowSmoothSine();break;
    case 74:  customDev_rackLightSlowRainbowSmoothSine();break;
    case 75:  customDev_LEDTubeSlowRainbowSmoothSine();break;
    
    //Smooth sine - slow - rhythmic
    case 76:  customDev_totalSingleSlowWhiteSmoothSine();break;            //Randomly select devices to light up (p=0.5), and turn off the others
    case 77:  customDev_LEDTubeSingleSlowWhiteSmoothSine();break;
    case 78:  customDev_totalSingleSlowRedSmoothSine();break;
    case 79:  customDev_LEDTubeSingleSlowRedSmoothSine();break;
    case 80:  customDev_totalSingleSlowBlueSmoothSine();break;
    case 81:  customDev_LEDTubeSingleSlowBlueSmoothSine();break;
    case 82:  customDev_totalSingleSlowRainbowSmoothSine();break;
    case 83:  customDev_LEDTubeSingleSlowRainbowSmoothSine();break;
    
    //Smooth sine - fast
    case 84:  customDev_totalFastWhiteSmoothSine();break;
    case 85:  customDev_rackLightFastWhiteSmoothSine();break;
    case 86:  customDev_LEDTubeFastWhiteSmoothSine();break;
    case 87:  customDev_totalFastRedSmoothSine();break;
    case 88:  customDev_rackLightFastRedSmoothSine();break;
    case 89:  customDev_LEDTubeFastRedSmoothSine();break;
    case 90:  customDev_totalFastBlueSmoothSine();break;
    case 91:  customDev_rackLightFastBlueSmoothSine();break;
    case 92:  customDev_LEDTubeFastBlueSmoothSine();break;
    case 93:  customDev_totalFastRainbowSmoothSine();break;
    case 94:  customDev_rackLightFastRainbowSmoothSine();break;
    case 95:  customDev_LEDTubeFastRainbowSmoothSine();break;
    
    //Smooth sine - fast - rhythmic
    case 96:  customDev_totalSingleFastWhiteSmoothSine();break;            //Randomly select devices to light up (p=0.5), and turn off the others
    case 97:  customDev_LEDTubeSingleFastWhiteSmoothSine();break;
    case 98:  customDev_totalSingleFastRedSmoothSine();break;
    case 99:  customDev_LEDTubeSingleFastRedSmoothSine();break;
    case 100: customDev_totalSingleFastBlueSmoothSine();break;
    case 101: customDev_LEDTubeSingleFastBlueSmoothSine();break;
    case 102: customDev_totalSingleFastRainbowSmoothSine();break;
    case 103: customDev_LEDTubeSingleFastRainbowSmoothSine();break;    
    
    //Stroboscope
    case 104: customDev_totalFastWhiteStroboscope();break;
    case 105: customDev_LEDTubeFastWhiteStroboscope();break;
    case 106: customDev_rackLightFastWhiteStroboscope();break;
    case 107: customDev_totalFastRedStroboscope();break;
    case 108: customDev_LEDTubeFastRedStroboscope();break;
    case 109: customDev_rackLightFastRedStroboscope();break;
    case 110: customDev_totalFastBlueStroboscope();break;
    case 111: customDev_LEDTubeFastBlueStroboscope();break;
    case 112: customDev_rackLightFastBlueStroboscope();break;
    case 113: customDev_totalFastRandomColorStroboscope();break;
    case 114: customDev_LEDTubeFastRandomColorStroboscope();break;
    case 115: customDev_rackLightFastRandomColorStroboscope();break;

    case 116: customDev_totalMediumWhiteStroboscope();break;
    case 117: customDev_LEDTubeMediumWhiteStroboscope();break;
    case 118: customDev_rackLightMediumWhiteStroboscope();break;
    case 119: customDev_totalMediumRedStroboscope();break;
    case 120: customDev_LEDTubeMediumRedStroboscope();break;
    case 121: customDev_rackLightMediumRedStroboscope();break;
    case 122: customDev_totalMediumBlueStroboscope();break;
    case 123: customDev_LEDTubeMediumBlueStroboscope();break;
    case 124: customDev_rackLightMediumBlueStroboscope();break;
    case 125: customDev_totalMediumRandomColorStroboscope();break;
    case 126: customDev_LEDTubeMediumRandomColorStroboscope();break;
    case 127: customDev_rackLightMediumRandomColorStroboscope();break;
    
    case 128: customDev_totalSlowWhiteStroboscope();break;
    case 129: customDev_LEDTubeSlowWhiteStroboscope();break;
    case 130: customDev_rackLightSlowWhiteStroboscope();break;
    case 131: customDev_totalSlowRedStroboscope();break;
    case 132: customDev_LEDTubeSlowRedStroboscope();break;
    case 133: customDev_rackLightSlowRedStroboscope();break;
    case 134: customDev_totalSlowBlueStroboscope();break;
    case 135: customDev_LEDTubeSlowBlueStroboscope();break;
    case 136: customDev_rackLightSlowBlueStroboscope();break;
    case 137: customDev_totalSlowRandomColorStroboscope();break;
    case 138: customDev_LEDTubeSlowRandomColorStroboscope();break;
    case 139: customDev_rackLightSlowRandomColorStroboscope();break;
    
    case 140: customDev_totalVerySlowWhiteStroboscope();break;
    case 141: customDev_LEDTubeVerySlowWhiteStroboscope();break;
    case 142: customDev_rackLightVerySlowWhiteStroboscope();break;
    case 143: customDev_totalVerySlowRedStroboscope();break;
    case 144: customDev_LEDTubeVerySlowRedStroboscope();break;
    case 145: customDev_rackLightVerySlowRedStroboscope();break;
    case 146: customDev_totalVerySlowBlueStroboscope();break;
    case 147: customDev_LEDTubeVerySlowBlueStroboscope();break;
    case 148: customDev_rackLightVerySlowBlueStroboscope();break;
    case 149: customDev_totalVerySlowRandomColorStroboscope();break;
    case 150: customDev_LEDTubeVerySlowRandomColorStroboscope();break;
    case 151: customDev_rackLightVerySlowRandomColorStroboscope();break;
    
    
    //Growing stroboscope
    case 152: customDev_totalFastWhiteGrowingStroboscope();break;
    case 153: customDev_LEDTubeFastWhiteGrowingStroboscope();break;
    case 154: customDev_rackLightFastWhiteGrowingStroboscope();break;
    case 155: customDev_totalFastRedGrowingStroboscope();break;
    case 156: customDev_LEDTubeFastRedGrowingStroboscope();break;
    case 157: customDev_rackLightFastRedGrowingStroboscope();break;
    
    case 158: customDev_totalMediumWhiteGrowingStroboscope();break;
    case 159: customDev_LEDTubeMediumWhiteGrowingStroboscope();break;
    case 160: customDev_rackLightMediumWhiteGrowingStroboscope();break;
    case 161: customDev_totalMediumRedGrowingStroboscope();break;
    case 162: customDev_LEDTubeMediumRedGrowingStroboscope();break;
    case 163: customDev_rackLightMediumRedGrowingStroboscope();break;    

    case 164: customDev_totalSlowWhiteGrowingStroboscope();break;
    case 165: customDev_LEDTubeSlowWhiteGrowingStroboscope();break;
    case 166: customDev_rackLightSlowWhiteGrowingStroboscope();break;
    case 167: customDev_totalSlowRedGrowingStroboscope();break;
    case 168: customDev_LEDTubeSlowRedGrowingStroboscope();break;
    case 169: customDev_rackLightSlowRedGrowingStroboscope();break;

    case 170: customDev_totalVerySlowWhiteGrowingStroboscope();break;
    case 171: customDev_LEDTubeVerySlowWhiteGrowingStroboscope();break;
    case 172: customDev_rackLightVerySlowWhiteGrowingStroboscope();break;
    case 173: customDev_totalVerySlowRedGrowingStroboscope();break;
    case 174: customDev_LEDTubeVerySlowRedGrowingStroboscope();break;
    case 175: customDev_rackLightVerySlowRedGrowingStroboscope();break;
    
    //Single wave - upwards
    case 176: customDev_totalLongWhiteUpwardSingleWave();break;
    case 177: customDev_LEDTubeLongWhiteUpwardSingleWave();break;
    case 178: customDev_rackLightLongWhiteUpwardSingleWave();break;
    case 179: customDev_totalLongRedUpwardSingleWave();break;
    case 180: customDev_LEDTubeLongRedUpwardSingleWave();break;
    case 181: customDev_rackLightLongRedUpwardSingleWave();break;
    case 182: customDev_totalLongBlueUpwardSingleWave();break;
    case 183: customDev_LEDTubeLongBlueUpwardSingleWave();break;
    case 184: customDev_rackLightLongBlueUpwardSingleWave();break;

    case 185: customDev_totalShortWhiteUpwardSingleWave();break;
    case 186: customDev_LEDTubeShortWhiteUpwardSingleWave();break;
    case 187: customDev_rackLightShortWhiteUpwardSingleWave();break;
    case 188: customDev_totalShortRedUpwardSingleWave();break;
    case 189: customDev_LEDTubeShortRedUpwardSingleWave();break;
    case 190: customDev_rackLightShortRedUpwardSingleWave();break;
    case 191: customDev_totalShortBlueUpwardSingleWave();break;
    case 192: customDev_LEDTubeShortBlueUpwardSingleWave();break;
    case 193: customDev_rackLightShortBlueUpwardSingleWave();break;    
    
    //Single wave - downwards
    case 194: customDev_totalLongWhiteDownwardSingleWave();break;
    case 195: customDev_LEDTubeLongWhiteDownwardSingleWave();break;
    case 196: customDev_rackLightLongWhiteDownwardSingleWave();break;
    case 197: customDev_totalLongRedDownwardSingleWave();break;
    case 198: customDev_LEDTubeLongRedDownwardSingleWave();break;
    case 199: customDev_rackLightLongRedDownwardSingleWave();break;
    case 200: customDev_totalLongBlueDownwardSingleWave();break;
    case 201: customDev_LEDTubeLongBlueDownwardSingleWave();break;
    case 202: customDev_rackLightLongBlueDownwardSingleWave();break;

    case 203: customDev_totalShortWhiteDownwardSingleWave();break;
    case 204: customDev_LEDTubeShortWhiteDownwardSingleWave();break;
    case 205: customDev_rackLightShortWhiteDownwardSingleWave();break;
    case 206: customDev_totalShortRedDownwardSingleWave();break;
    case 207: customDev_LEDTubeShortRedDownwardSingleWave();break;
    case 208: customDev_rackLightShortRedDownwardSingleWave();break;
    case 209: customDev_totalShortBlueDownwardSingleWave();break;
    case 210: customDev_LEDTubeShortBlueDownwardSingleWave();break;
    case 211: customDev_rackLightShortBlueDownwardSingleWave();break;        

    
    //Buildup
    case 212: customDev_totalFastWhiteBuildUp();break;
    case 213: customDev_LEDTubeFastWhiteBuildUp();break;
    case 214: customDev_rackLightFastWhiteBuildUp();break;
    case 215: customDev_totalFastRedBuildUp();break;
    case 216: customDev_LEDTubeFastRedBuildUp();break;
    case 217: customDev_rackLightFastRedBuildUp();break;
    case 218: customDev_totalFastBlueBuildUp();break;
    case 219: customDev_LEDTubeFastBlueBuildUp();break;
    case 220: customDev_rackLightFastBlueBuildUp();break;
    case 221: customDev_totalFastRainbowBuildUp();break;
    case 222: customDev_LEDTubeFastRainbowBuildUp();break;
    case 223: customDev_rackLightFastRainbowBuildUp();break; 

    case 224: customDev_totalMediumWhiteBuildUp();break;
    case 225: customDev_LEDTubeMediumWhiteBuildUp();break;
    case 226: customDev_rackLightMediumWhiteBuildUp();break;
    case 227: customDev_totalMediumRedBuildUp();break;
    case 228: customDev_LEDTubeMediumRedBuildUp();break;
    case 229: customDev_rackLightMediumRedBuildUp();break;
    case 230: customDev_totalMediumBlueBuildUp();break;
    case 231: customDev_LEDTubeMediumBlueBuildUp();break;
    case 232: customDev_rackLightMediumBlueBuildUp();break;
    case 233: customDev_totalMediumRainbowBuildUp();break;
    case 234: customDev_LEDTubeMediumRainbowBuildUp();break;
    case 235: customDev_rackLightMediumRainbowBuildUp();break;

    case 236: customDev_totalSlowWhiteBuildUp();break;
    case 237: customDev_LEDTubeSlowWhiteBuildUp();break;
    case 238: customDev_rackLightSlowWhiteBuildUp();break;
    case 239: customDev_totalSlowRedBuildUp();break;
    case 240: customDev_LEDTubeSlowRedBuildUp();break;
    case 241: customDev_rackLightSlowRedBuildUp();break;
    case 242: customDev_totalSlowBlueBuildUp();break;
    case 243: customDev_LEDTubeSlowBlueBuildUp();break;
    case 244: customDev_rackLightSlowBlueBuildUp();break;
    case 245: customDev_totalSlowRainbowBuildUp();break;
    case 246: customDev_LEDTubeSlowRainbowBuildUp();break;
    case 247: customDev_rackLightSlowRainbowBuildUp();break;

    case 248: customDev_totalVerySlowWhiteBuildUp();break;
    case 249: customDev_LEDTubeVerySlowWhiteBuildUp();break;
    case 250: customDev_rackLightVerySlowWhiteBuildUp();break;
    case 251: customDev_totalVerySlowRedBuildUp();break;
    case 252: customDev_LEDTubeVerySlowRedBuildUp();break;
    case 253: customDev_rackLightVerySlowRedBuildUp();break;
    case 254: customDev_totalVerySlowBlueBuildUp();break;
    case 255: customDev_LEDTubeVerySlowBlueBuildUp();break;
    case 256: customDev_rackLightVerySlowBlueBuildUp();break;
    case 257: customDev_totalVerySlowRainbowBuildUp();break;
    case 258: customDev_LEDTubeVerySlowRainbowBuildUp();break;
    case 259: customDev_rackLightVerySlowRainbowBuildUp();break;    

    case 260: customDev_totalWhiteNoise();break;
    case 261: customDev_rackLightWhiteNoise();break;
    case 262: customDev_LEDTubeWhiteNoise();break;
    case 263: customDev_totalRedNoise();break;
    case 264: customDev_rackLightRedNoise();break;
    case 265: customDev_LEDTubeRedNoise();break;
    case 266: customDev_totalBlueNoise();break;
    case 267: customDev_rackLightBlueNoise();break;
    case 268: customDev_LEDTubeBlueNoise();break;
    case 269: customDev_totalRainbowNoise();break;
    case 270: customDev_rackLightRainbowNoise();break;
    case 271: customDev_LEDTubeRainbowNoise();break;


    //Smooth noise
    case 272: customDev_totalFastWhiteSmoothNoise();break;
    case 273: customDev_rackLightFastWhiteSmoothNoise();break;
    case 274: customDev_LEDTubeFastWhiteSmoothNoise();break;
    case 275: customDev_totalFastRedSmoothNoise();break;
    case 276: customDev_rackLightFastRedSmoothNoise();break;
    case 277: customDev_LEDTubeFastRedSmoothNoise();break;
    case 278: customDev_totalFastBlueSmoothNoise();break;
    case 279: customDev_rackLightFastBlueSmoothNoise();break;
    case 280: customDev_LEDTubeFastBlueSmoothNoise();break;
    case 281: customDev_totalFastRainbowSmoothNoise();break;
    case 282: customDev_rackLightFastRainbowSmoothNoise();break;
    case 283: customDev_LEDTubeFastRainbowSmoothNoise();break;
    
    case 284: customDev_totalSlowWhiteSmoothNoise();break;
    case 285: customDev_rackLightSlowWhiteSmoothNoise();break;
    case 286: customDev_LEDTubeSlowWhiteSmoothNoise();break;
    case 287: customDev_totalSlowRedSmoothNoise();break;
    case 288: customDev_rackLightSlowRedSmoothNoise();break;
    case 289: customDev_LEDTubeSlowRedSmoothNoise();break;
    case 290: customDev_totalSlowBlueSmoothNoise();break;
    case 291: customDev_rackLightSlowBlueSmoothNoise();break;
    case 292: customDev_LEDTubeSlowBlueSmoothNoise();break;
    case 293: customDev_totalSlowRainbowSmoothNoise();break;
    case 294: customDev_rackLightSlowRainbowSmoothNoise();break;
    case 295: customDev_LEDTubeSlowRainbowSmoothNoise();break;    
    
    //Single/Random tube animations
    case 296: customDev_LEDTubeRandomWhiteout();break;
    case 297: customDev_LEDTubeRandomRedout();break;
    case 298: customDev_LEDTubeRandomBlueout();break;
    case 299: customDev_LEDTubeRandomRainbowout();break;
    
    case 300: customDev_LEDTubeRandomFastWhiteStroboscope();break;
    case 301: customDev_LEDTubeRandomFastRedStroboscope();break;
    case 302: customDev_LEDTubeRandomFastBlueStroboscope();break;
    case 303: customDev_LEDTubeRandomMediumWhiteStroboscope();break;
    case 304: customDev_LEDTubeRandomMediumRedStroboscope();break;
    case 305: customDev_LEDTubeRandomMediumBlueStroboscope();break;
    case 306: customDev_LEDTubeRandomSlowWhiteStroboscope();break;
    case 307: customDev_LEDTubeRandomSlowRedStroboscope();break;
    case 308: customDev_LEDTubeRandomSlowBlueStroboscope();break;
    
    case 309: customDev_LEDTubeRandomSlowWhiteFlash();break;
    case 310: customDev_LEDTubeRandomSlowRedFlash();break;
    case 311: customDev_LEDTubeRandomSlowBlueFlash();break;
    case 312: customDev_LEDTubeRandomFastWhiteFlash();break;
    case 313: customDev_LEDTubeRandomFastRedFlash();break;
    case 314: customDev_LEDTubeRandomFastBlueFlash();break;
    
    case 315: customDev_LEDTubeLeftSideWhiteout();break;
    case 316: customDev_LEDTubeLeftSideRedout();break;
    case 317: customDev_LEDTubeLeftSideWhiteFlash();break;
    case 318: customDev_LEDTubeLeftSideRedFlash();break;
    case 319: customDev_LEDTubeLeftSideWhiteStroboscope();break;
    case 320: customDev_LEDTubeLeftSideRedStroboscope();break;
    case 321: customDev_LEDTubeLeftSideShortWhiteUpwardSingleWave();break;
    case 322: customDev_LEDTubeLeftSideShortRedUpwardSingleWave();break;
    case 323: customDev_LEDTubeLeftSideShortWhiteDownwardSingleWave();break;
    case 324: customDev_LEDTubeLeftSideShortRedDownwardSingleWave();break;
    case 325: customDev_LEDTubeLeftSideLongWhiteUpwardSingleWave();break;
    case 326: customDev_LEDTubeLeftSideLongRedUpwardSingleWave();break;
    case 327: customDev_LEDTubeLeftSideLongWhiteDownwardSingleWave();break;
    case 328: customDev_LEDTubeLeftSideLongRedDownwardSingleWave();break;
    
    case 329: customDev_LEDTubeRightSideWhiteout();break;
    case 330: customDev_LEDTubeRightSideRedout();break;
    case 331: customDev_LEDTubeRightSideWhiteFlash();break;
    case 332: customDev_LEDTubeRightSideRedFlash();break;
    case 333: customDev_LEDTubeRightSideWhiteStroboscope();break;
    case 334: customDev_LEDTubeRightSideRedStroboscope();break;
    case 335: customDev_LEDTubeRightSideShortWhiteUpwardSingleWave();break;
    case 336: customDev_LEDTubeRightSideShortRedUpwardSingleWave();break;
    case 337: customDev_LEDTubeRightSideShortWhiteDownwardSingleWave();break;
    case 338: customDev_LEDTubeRightSideShortRedDownwardSingleWave();break;
    case 339: customDev_LEDTubeRightSideLongWhiteUpwardSingleWave();break;
    case 340: customDev_LEDTubeRightSideLongRedUpwardSingleWave();break;
    case 341: customDev_LEDTubeRightSideLongWhiteDownwardSingleWave();break;
    case 342: customDev_LEDTubeRightSideLongRedDownwardSingleWave();break;
    
    case 343: customDev_LEDTubeRandomShortWhiteUpwardSingleWave();break;
    case 344: customDev_LEDTubeRandomShortRedUpwardSingleWave();break;
    case 345: customDev_LEDTubeRandomLongWhiteUpwardSingleWave();break;
    case 346: customDev_LEDTubeRandomLongRedUpwardSingleWave();break;
    case 347: customDev_LEDTubeRandomShortWhiteDownwardSingleWave();break;
    case 348: customDev_LEDTubeRandomShortRedDownwardSingleWave();break;
    case 349: customDev_LEDTubeRandomLongWhiteDownwardSingleWave();break;
    case 350: customDev_LEDTubeRandomLongRedDownwardSingleWave();break;
    
    case 351: customDev_LEDTubeSingleShortWhiteUpwardSingleWave();break;
    case 352: customDev_LEDTubeSingleShortRedUpwardSingleWave();break;
    case 353: customDev_LEDTubeSingleLongWhiteUpwardSingleWave();break;
    case 354: customDev_LEDTubeSingleLongRedUpwardSingleWave();break;
    case 355: customDev_LEDTubeSingleShortWhiteDownwardSingleWave();break;
    case 356: customDev_LEDTubeSingleShortRedDownwardSingleWave();break;
    case 357: customDev_LEDTubeSingleLongWhiteDownwardSingleWave();break;
    case 358: customDev_LEDTubeSingleLongRedDownwardSingleWave();break;
    default: break;                                 //Don't do anything
  }
  
}

///////////////////////////////////
// Helper functions
///////////////////////////////////

public void incrementLEDTubeCpt(boolean positive) {
  //Get the number of the current single LED tube in the list
  int devIndex = 0;
  for (int i=0; i<CustomDeviceList_LEDTubes.size(); i++) {
    if (CustomDeviceList_LEDTubes.get(i).CustomDevice_deviceNumber == currentRandomLEDTube) {
      devIndex = i;
      break;
    }
  }
  
  if (positive) {
    currentRandomLEDTube = CustomDeviceList_LEDTubes.get((devIndex+1)%CustomDeviceList_LEDTubes.size()).CustomDevice_deviceNumber;
  }
  else {
    currentRandomLEDTube = CustomDeviceList_LEDTubes.get((devIndex-1)%CustomDeviceList_LEDTubes.size()).CustomDevice_deviceNumber;
  }  
  
}

public void incrementRackLightCpt(boolean positive) {
  int devIndex = 0;
  for (int i=0; i<CustomDeviceList_RackLights.size(); i++) {
    if (CustomDeviceList_RackLights.get(i).CustomDevice_deviceNumber == currentRandomRackLight) {
      devIndex = i;
      break;
    }
  }
  
  if (positive) {
    currentRandomRackLight = CustomDeviceList_RackLights.get((devIndex+1)%CustomDeviceList_RackLights.size()).CustomDevice_deviceNumber;
  }
  else {
    currentRandomRackLight = CustomDeviceList_RackLights.get((devIndex-1)%CustomDeviceList_RackLights.size()).CustomDevice_deviceNumber;
  }
}

///////////////////////////////////
// Flat colors
///////////////////////////////////

public void customDev_totalBlackout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
  }
}

public void customDev_rackLightBlackout() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
  }
}

public void customDev_LEDTubeBlackout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
  }
}

//------------------------//
public void customDev_totalWhiteout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
  }
}

public void customDev_rackLightWhiteout() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
  }
}

public void customDev_LEDTubeWhiteout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
  }
}

//------------------------//
public void customDev_totalRedout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
  }
}

public void customDev_rackLightRedout() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
  }
}

public void customDev_LEDTubeRedout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
  }
}

//------------------------//
public void customDev_totalBlueout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT);
  }
}

public void customDev_rackLightBlueout() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT);
  }
}

public void customDev_LEDTubeBlueout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT);
  }
}

//------------------------//
public void customDev_totalRainbowout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT);
  }
}

public void customDev_rackLightRainbowout() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT);
  }
}

public void customDev_LEDTubeRainbowout() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT);
  }
}


///////////////////////////////////
// Uniform colors - rhythmic
///////////////////////////////////

public void customDev_totalSingleWhiteOut() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) {  rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT); }
                                                             else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);

}

public void customDev_LEDTubeSingleWhiteOut() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }  
  incrementLEDTubeCpt(customDevicesRandomDirection);  
}

public void customDev_totalSingleRedOut() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }                  
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) {  rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT); }
                                                             else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleRedOut() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }  
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleBlueOut() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }                  
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT); }
                                                             else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleBlueOut() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLUEOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }  
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleRainbowOut() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }                  
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT); }
                                                             else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleRainbowOut() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWOUT); } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }  
  incrementLEDTubeCpt(customDevicesRandomDirection);
}


///////////////////////////////////
// One time flash - short
///////////////////////////////////

public void customDev_totalFastWhiteFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
  }
}

public void customDev_LEDTubeFastWhiteFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
  }
}

public void customDev_rackLightFastWhiteFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
  }
}

//------------------------//

public void customDev_totalFastRedFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
  }
}

public void customDev_LEDTubeFastRedFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
  }
}

public void customDev_rackLightFastRedFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
  }
}

//------------------------//

public void customDev_totalFastBlueFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); }
  }
}

public void customDev_LEDTubeFastBlueFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); }
  }
}

public void customDev_rackLightFastBlueFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); }
  }
}

//------------------------//

public void customDev_totalFastRainbowFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); }
  }
}

public void customDev_LEDTubeFastRainbowFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); }
  }
}

public void customDev_rackLightFastRainbowFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); }
  }
}

///////////////////////////////////
// One time flash - short - 1 device out of 2
///////////////////////////////////

public void customDev_totalSingleFastWhiteFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleFastWhiteFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleFastRedFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleFastRedFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleFastBlueFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleFastBlueFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleFastRainbowFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleFastRainbowFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

///////////////////////////////////
// One time flash - short
///////////////////////////////////

public void customDev_totalSlowWhiteFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); }
  }
}

public void customDev_LEDTubeSlowWhiteFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); }
  }
}

public void customDev_rackLightSlowWhiteFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); }
  }
}

//------------------------//

public void customDev_totalSlowRedFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); }
  }
}

public void customDev_LEDTubeSlowRedFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); }
  }
}

public void customDev_rackLightSlowRedFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); }
  }
}

//------------------------//

public void customDev_totalSlowBlueFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); }
  }
}

public void customDev_LEDTubeSlowBlueFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); }
  }
}

public void customDev_rackLightSlowBlueFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); }
  }
}

//------------------------//

public void customDev_totalSlowRainbowFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); }
  }
}

public void customDev_LEDTubeSlowRainbowFlash() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); }
  }
}

public void customDev_rackLightSlowRainbowFlash() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); }
  }
}

///////////////////////////////////
// One time flash - short - 1 device out of 2
///////////////////////////////////

public void customDev_totalSingleSlowWhiteFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleSlowWhiteFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleSlowRedFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);

}

public void customDev_LEDTubeSingleSlowRedFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleSlowBlueFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleSlowBlueFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}

public void customDev_totalSingleSlowRainbowFlash() {
  int LEDTubeToBePoweredOn = 0;
  int RackToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.CustomDevice_deviceNumber == currentRandomRackLight) { if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                                                                                           else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); } }
                                                                  else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
  incrementRackLightCpt(customDevicesRandomDirection);
}

public void customDev_LEDTubeSingleSlowRainbowFlash() {
  int LEDTubeToBePoweredOn = 0;
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.CustomDevice_deviceNumber == currentRandomLEDTube) { if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH);   }
                                                                                                     else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2); } } 
                                                              else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); } 
  }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}



///////////////////////////////////
// Smooth sine - slow
///////////////////////////////////



public void customDev_totalSlowWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE);
  }
}

public void customDev_rackLightSlowWhiteSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE);
  }
}

public void customDev_LEDTubeSlowWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE);
  }
}

//------------------------//
public void customDev_totalSlowRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE);
  }
}

public void customDev_rackLightSlowRedSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE);
  }
}

public void customDev_LEDTubeSlowRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE);
  }
}

//------------------------//
public void customDev_totalSlowBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE);
  }
}

public void customDev_rackLightSlowBlueSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE);
  }
}

public void customDev_LEDTubeSlowBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE);
  }
}

//------------------------//
public void customDev_totalSlowRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE);
  }
}

public void customDev_rackLightSlowRainbowSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE);
  }
}

public void customDev_LEDTubeSlowRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE);
  }
}


///////////////////////////////////
// Smooth sine - slow - rhythmic (half of the devices light up, the others shut off)
///////////////////////////////////

public void customDev_totalSingleSlowWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleSlowWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}

public void customDev_totalSingleSlowRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleSlowRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}

public void customDev_totalSingleSlowBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleSlowBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}

public void customDev_totalSingleSlowRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleSlowRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}


///////////////////////////////////
// Smooth sine - fast
///////////////////////////////////



public void customDev_totalFastWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE);
  }
}

public void customDev_rackLightFastWhiteSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE);
  }
}

public void customDev_LEDTubeFastWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE);
  }
}

//------------------------//
public void customDev_totalFastRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE);
  }
}

public void customDev_rackLightFastRedSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE);
  }
}

public void customDev_LEDTubeFastRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE);
  }
}

//------------------------//
public void customDev_totalFastBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE);
  }
}

public void customDev_rackLightFastBlueSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE);
  }
}

public void customDev_LEDTubeFastBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE);
  }
}

//------------------------//
public void customDev_totalFastRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE);
  }
}

public void customDev_rackLightFastRainbowSmoothSine() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE);
  }
}

public void customDev_LEDTubeFastRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE);
  }
}


///////////////////////////////////
// Smooth sine - fast - rhythmic (half of the devices light up, the others shut off)
///////////////////////////////////

public void customDev_totalSingleFastWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleFastWhiteSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}

public void customDev_totalSingleFastRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleFastRedSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}

public void customDev_totalSingleFastBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleFastBlueSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}

public void customDev_totalSingleFastRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (random(1) > 0.5f) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE); }
                    else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }    
  }
}

public void customDev_LEDTubeSingleFastRainbowSmoothSine() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (random(1) > 0.5f) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE); }
                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT); }
  }
}



///////////////////////////////////
// Normal Stroboscope - Fast
///////////////////////////////////


public void customDev_totalFastWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE);
  }
}

public void customDev_rackLightFastWhiteStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE);
  }
}

public void customDev_LEDTubeFastWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalFastRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE);
  }
}

public void customDev_rackLightFastRedStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE);
  }
}

public void customDev_LEDTubeFastRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalFastBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE);
  }
}

public void customDev_rackLightFastBlueStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE);
  }
}

public void customDev_LEDTubeFastBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalFastRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE);
  }
}

public void customDev_rackLightFastRandomColorStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE);
  }
}

public void customDev_LEDTubeFastRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE);
  }
}


///////////////////////////////////
// Normal Stroboscope - Medium
///////////////////////////////////


public void customDev_totalMediumWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
  }
}

public void customDev_rackLightMediumWhiteStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
  }
}

public void customDev_LEDTubeMediumWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalMediumRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
  }
}

public void customDev_rackLightMediumRedStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
  }
}

public void customDev_LEDTubeMediumRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalMediumBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE);
  }
}

public void customDev_rackLightMediumBlueStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE);
  }
}

public void customDev_LEDTubeMediumBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalMediumRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE);
  }
}

public void customDev_rackLightMediumRandomColorStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE);
  }
}

public void customDev_LEDTubeMediumRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE);
  }
}

///////////////////////////////////
// Normal Stroboscope - Slow
///////////////////////////////////


public void customDev_totalSlowWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE);
  }
}

public void customDev_rackLightSlowWhiteStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE);
  }
}

public void customDev_LEDTubeSlowWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalSlowRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE);
  }
}

public void customDev_rackLightSlowRedStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE);
  }
}

public void customDev_LEDTubeSlowRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalSlowBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE);
  }
}

public void customDev_rackLightSlowBlueStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE);
  }
}

public void customDev_LEDTubeSlowBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalSlowRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE);
  }
}

public void customDev_rackLightSlowRandomColorStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE);
  }
}

public void customDev_LEDTubeSlowRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE);
  }
}


///////////////////////////////////
// Normal Stroboscope - VerySlow
///////////////////////////////////


public void customDev_totalVerySlowWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE);
  }
}

public void customDev_rackLightVerySlowWhiteStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE);
  }
}

public void customDev_LEDTubeVerySlowWhiteStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalVerySlowRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE);
  }
}

public void customDev_rackLightVerySlowRedStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE);
  }
}

public void customDev_LEDTubeVerySlowRedStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalVerySlowBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE);
  }
}

public void customDev_rackLightVerySlowBlueStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE);
  }
}

public void customDev_LEDTubeVerySlowBlueStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE);
  }
}

//------------------------//

public void customDev_totalVerySlowRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE);
  }
}

public void customDev_rackLightVerySlowRandomColorStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE);
  }
}

public void customDev_LEDTubeVerySlowRandomColorStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE);
  }
}


///////////////////////////////////
// Growing Stroboscope - Fast
///////////////////////////////////


public void customDev_totalFastWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeFastWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_rackLightFastWhiteGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2); }
  }
}

//------------------------//

public void customDev_totalFastRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeFastRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_rackLightFastRedGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2); }
  }
}


///////////////////////////////////
// Growing Stroboscope - Medium
///////////////////////////////////


public void customDev_totalMediumWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeMediumWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_rackLightMediumWhiteGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2); }
  }
}

//------------------------//

public void customDev_totalMediumRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeMediumRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_rackLightMediumRedGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2); }
  }
}


///////////////////////////////////
// Growing Stroboscope - Slow
///////////////////////////////////


public void customDev_totalSlowWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeSlowWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_rackLightSlowWhiteGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2); }
  }
}

//------------------------//

public void customDev_totalSlowRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeSlowRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_rackLightSlowRedGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2); }
  }
}


///////////////////////////////////
// Growing Stroboscope - VerySlow
///////////////////////////////////


public void customDev_totalVerySlowWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeVerySlowWhiteGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2); }
  }
}

public void customDev_rackLightVerySlowWhiteGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2); }
  }
}

//------------------------//

public void customDev_totalVerySlowRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_LEDTubeVerySlowRedGrowingStroboscope() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2); }
  }
}

public void customDev_rackLightVerySlowRedGrowingStroboscope() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2); }
  }
}



///////////////////////////////////
// Long single wave - Upwards
///////////////////////////////////

public void customDev_totalLongWhiteUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
  }
}

public void customDev_LEDTubeLongWhiteUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
  }
}

public void customDev_rackLightLongWhiteUpwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalLongRedUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
  }
}

public void customDev_LEDTubeLongRedUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
  }
}

public void customDev_rackLightLongRedUpwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalLongBlueUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2); }
  }
}

public void customDev_LEDTubeLongBlueUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2); }
  }
}

public void customDev_rackLightLongBlueUpwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2); }
  }
}



///////////////////////////////////
// Short single wave - Upwards
///////////////////////////////////

public void customDev_totalShortWhiteUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
  }
}

public void customDev_LEDTubeShortWhiteUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
  }
}

public void customDev_rackLightShortWhiteUpwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalShortRedUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
  }
}

public void customDev_LEDTubeShortRedUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
  }
}

public void customDev_rackLightShortRedUpwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalShortBlueUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2); }
  }
}

public void customDev_LEDTubeShortBlueUpwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2); }
  }
}

public void customDev_rackLightShortBlueUpwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2); }
  }
}




///////////////////////////////////
// Long single wave - Downwards
///////////////////////////////////

public void customDev_totalLongWhiteDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
  }
}

public void customDev_LEDTubeLongWhiteDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
  }
}

public void customDev_rackLightLongWhiteDownwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalLongRedDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
  }
}

public void customDev_LEDTubeLongRedDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
  }
}

public void customDev_rackLightLongRedDownwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalLongBlueDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2); }
  }
}

public void customDev_LEDTubeLongBlueDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2); }
  }
}

public void customDev_rackLightLongBlueDownwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2); }
  }
}



///////////////////////////////////
// Short single wave - Downwards
///////////////////////////////////

public void customDev_totalShortWhiteDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
  }
}

public void customDev_LEDTubeShortWhiteDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
  }
}

public void customDev_rackLightShortWhiteDownwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalShortRedDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
  }
}

public void customDev_LEDTubeShortRedDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
  }
}

public void customDev_rackLightShortRedDownwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
  }
}

//------------------------//

public void customDev_totalShortBlueDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2); }
  }
}

public void customDev_LEDTubeShortBlueDownwardSingleWave() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2); }
  }
}

public void customDev_rackLightShortBlueDownwardSingleWave() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2); }
  }
}


///////////////////////////////////
// Fast Buildup
///////////////////////////////////

public void customDev_totalFastWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2); }
  }
}

public void customDev_LEDTubeFastWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2); }
  }
}

public void customDev_rackLightFastWhiteBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalFastRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP_2); }
  }
}

public void customDev_LEDTubeFastRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP_2); }
  }
}

public void customDev_rackLightFastRedBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalFastBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2); }
  }
}

public void customDev_LEDTubeFastBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2); }
  }
}

public void customDev_rackLightFastBlueBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalFastRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2); }
  }
}

public void customDev_LEDTubeFastRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2); }
  }
}

public void customDev_rackLightFastRainbowBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2); }
  }
}




///////////////////////////////////
// Medium Buildup
///////////////////////////////////

public void customDev_totalMediumWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2); }
  }
}

public void customDev_LEDTubeMediumWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2); }
  }
}

public void customDev_rackLightMediumWhiteBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalMediumRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2); }
  }
}

public void customDev_LEDTubeMediumRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2); }
  }
}

public void customDev_rackLightMediumRedBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalMediumBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2); }
  }
}

public void customDev_LEDTubeMediumBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2); }
  }
}

public void customDev_rackLightMediumBlueBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalMediumRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2); }
  }
}

public void customDev_LEDTubeMediumRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2); }
  }
}

public void customDev_rackLightMediumRainbowBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2); }
  }
}

///////////////////////////////////
// Slow Buildup
///////////////////////////////////

public void customDev_totalSlowWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2); }
  }
}

public void customDev_LEDTubeSlowWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2); }
  }
}

public void customDev_rackLightSlowWhiteBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalSlowRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP_2); }
  }
}

public void customDev_LEDTubeSlowRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP_2); }
  }
}

public void customDev_rackLightSlowRedBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalSlowBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2); }
  }
}

public void customDev_LEDTubeSlowBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2); }
  }
}

public void customDev_rackLightSlowBlueBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalSlowRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2); }
  }
}

public void customDev_LEDTubeSlowRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2); }
  }
}

public void customDev_rackLightSlowRainbowBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2); }
  }
}


///////////////////////////////////
// VerySlow Buildup
///////////////////////////////////

public void customDev_totalVerySlowWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2); }
  }
}

public void customDev_LEDTubeVerySlowWhiteBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2); }
  }
}

public void customDev_rackLightVerySlowWhiteBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalVerySlowRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2); }
  }
}

public void customDev_LEDTubeVerySlowRedBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2); }
  }
}

public void customDev_rackLightVerySlowRedBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalVerySlowBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2); }
  }
}

public void customDev_LEDTubeVerySlowBlueBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2); }
  }
}

public void customDev_rackLightVerySlowBlueBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2); }
  }
}

//------------------------//

public void customDev_totalVerySlowRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2); }
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2); }
  }
}

public void customDev_LEDTubeVerySlowRainbowBuildUp() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    if (LEDTube.executionCount % 2 == 0) { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP);   }
                                    else { LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2); }
  }
}

public void customDev_rackLightVerySlowRainbowBuildUp() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    if (rackLight.executionCount % 2 == 0) { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP);   }
                                      else { rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2); }
  }
}


///////////////////////////////////
// Noise
///////////////////////////////////


public void customDev_totalWhiteNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_WHITENOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_WHITENOISE);
  }
}

public void customDev_rackLightWhiteNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_WHITENOISE);
  }
}

public void customDev_LEDTubeWhiteNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_WHITENOISE);
  }
}

//------------------------//

public void customDev_totalRedNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_REDNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_REDNOISE);
  }
}

public void customDev_rackLightRedNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_REDNOISE);
  }
}

public void customDev_LEDTubeRedNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_REDNOISE);
  }
}

//------------------------//

public void customDev_totalBlueNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLUENOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLUENOISE);
  }
}

public void customDev_rackLightBlueNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_BLUENOISE);
  }
}

public void customDev_LEDTubeBlueNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_BLUENOISE);
  }
}

//------------------------//

public void customDev_totalRainbowNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWNOISE);
  }
}

public void customDev_rackLightRainbowNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWNOISE);
  }
}

public void customDev_LEDTubeRainbowNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_RAINBOWNOISE);
  }
}




///////////////////////////////////
// Smooth noise - Fast
///////////////////////////////////

public void customDev_totalFastWhiteSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE);
  }
}

public void customDev_rackLightFastWhiteSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE);
  }
}

public void customDev_LEDTubeFastWhiteSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE);
  }
}

//------------------------//

public void customDev_totalFastRedSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE);
  }
}

public void customDev_rackLightFastRedSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE);
  }
}

public void customDev_LEDTubeFastRedSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE);
  }
}

//------------------------//

public void customDev_totalFastBlueSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE);
  }
}

public void customDev_rackLightFastBlueSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE);
  }
}

public void customDev_LEDTubeFastBlueSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE);
  }
}

//------------------------//

public void customDev_totalFastRainbowSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE);
  }
}

public void customDev_rackLightFastRainbowSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE);
  }
}

public void customDev_LEDTubeFastRainbowSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE);
  }
}


///////////////////////////////////
// Smooth noise - Slow
///////////////////////////////////

public void customDev_totalSlowWhiteSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE);
  }
}

public void customDev_rackLightSlowWhiteSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE);
  }
}

public void customDev_LEDTubeSlowWhiteSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE);
  }
}

//------------------------//

public void customDev_totalSlowRedSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE);
  }
}

public void customDev_rackLightSlowRedSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE);
  }
}

public void customDev_LEDTubeSlowRedSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE);
  }
}

//------------------------//

public void customDev_totalSlowBlueSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE);
  }
}

public void customDev_rackLightSlowBlueSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE);
  }
}

public void customDev_LEDTubeSlowBlueSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE);
  }
}

//------------------------//

public void customDev_totalSlowRainbowSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE);
  }
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE);
  }
}

public void customDev_rackLightSlowRainbowSmoothNoise() {
  for (CustomDevice_RackLight rackLight:CustomDeviceList_RackLights) {
    rackLight.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE);
  }
}

public void customDev_LEDTubeSlowRainbowSmoothNoise() {
  for (CustomDevice_LEDTube LEDTube:CustomDeviceList_LEDTubes) {
    LEDTube.setDeviceAnimation(CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE);
  }
}

//------------------------//

public int getRandomTube() {
  int randomTube = currentRandomLEDTube;
  while (randomTube  == currentRandomLEDTube) {
    randomTube = floor(random(CustomDeviceList_LEDTubes.size()));
  }
  currentRandomLEDTube = randomTube;
  return randomTube;
}

public void customDev_singleTubeAnimation(int animationNumber) {
  int randomTube = getRandomTube();
  for (int i=0; i<CustomDeviceList_LEDTubes.size(); i++) {
    if (i == randomTube) {
      CustomDeviceList_LEDTubes.get(i).setDeviceAnimation(animationNumber);
    }
    else {
      CustomDeviceList_LEDTubes.get(i).setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
    }
  }
}

public void customDev_LEDTubeRandomWhiteout() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_WHITEOUT);
}

public void customDev_LEDTubeRandomRedout() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_REDOUT);
}

public void customDev_LEDTubeRandomBlueout() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_BLUEOUT);
}

public void customDev_LEDTubeRandomRainbowout() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_RAINBOWOUT);
}




public void customDev_LEDTubeRandomFastWhiteStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE);
}


public void customDev_LEDTubeRandomFastRedStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE);
}


public void customDev_LEDTubeRandomFastBlueStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE);
}


public void customDev_LEDTubeRandomMediumWhiteStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
}


public void customDev_LEDTubeRandomMediumRedStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
}


public void customDev_LEDTubeRandomMediumBlueStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE);
}


public void customDev_LEDTubeRandomSlowWhiteStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE);
}


public void customDev_LEDTubeRandomSlowRedStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE);
}


public void customDev_LEDTubeRandomSlowBlueStroboscope() {
  customDev_singleTubeAnimation(CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE);
}


//------------------------//

public void customDev_LEDTubeRandomRhythmicAnim(int mainAnim, int fallbackAnim) {
  int randomTube = getRandomTube();
  if (CustomDeviceList_LEDTubes.get(randomTube).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(randomTube).setDeviceAnimation(mainAnim);   }
                                                                    else { CustomDeviceList_LEDTubes.get(randomTube).setDeviceAnimation(fallbackAnim); }    
}

public void customDev_LEDTubeRandomSlowWhiteFlash() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SLOWWHITEFLASH, CUSTOMDEV_ANIM_SLOWWHITEFLASH_2);
}

public void customDev_LEDTubeRandomSlowRedFlash() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SLOWREDFLASH, CUSTOMDEV_ANIM_SLOWREDFLASH_2);  
}

public void customDev_LEDTubeRandomSlowBlueFlash() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SLOWBLUEFLASH, CUSTOMDEV_ANIM_SLOWBLUEFLASH_2);  
}

public void customDev_LEDTubeRandomFastWhiteFlash() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_FASTWHITEFLASH, CUSTOMDEV_ANIM_FASTWHITEFLASH_2);
}

public void customDev_LEDTubeRandomFastRedFlash() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_FASTREDFLASH, CUSTOMDEV_ANIM_FASTREDFLASH_2);  
}

public void customDev_LEDTubeRandomFastBlueFlash() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_FASTBLUEFLASH, CUSTOMDEV_ANIM_FASTBLUEFLASH_2);  
}

//------------------------//

public void customDev_LEDTubeLeftSideWhiteout() {
  CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
  CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
}

public void customDev_LEDTubeLeftSideRedout() {
  CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
  CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
}

public void customDev_LEDTubeLeftSideWhiteFlash() {
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
}

public void customDev_LEDTubeLeftSideRedFlash() {
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
}

public void customDev_LEDTubeLeftSideWhiteStroboscope() {
  CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
  CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
}

public void customDev_LEDTubeLeftSideRedStroboscope() {
  CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
  CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
}

public void customDev_LEDTubeLeftSideShortWhiteUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideShortRedUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideShortWhiteDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideShortRedDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideLongWhiteUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideLongRedUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideLongWhiteDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
}
public void customDev_LEDTubeLeftSideLongRedDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(0).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(0).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(1).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(1).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
}



//------------------------//

public void customDev_LEDTubeRightSideWhiteout() {
  CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
  CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
}

public void customDev_LEDTubeRightSideRedout() {
  CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
  CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_REDOUT);
}

public void customDev_LEDTubeRightSideWhiteFlash() {
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_FASTWHITEFLASH_2); }
}

public void customDev_LEDTubeRightSideRedFlash() {
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_FASTREDFLASH_2); }
}

public void customDev_LEDTubeRightSideWhiteStroboscope() {
  CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
  CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE);
}

public void customDev_LEDTubeRightSideRedStroboscope() {
  CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
  CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE);
}

public void customDev_LEDTubeRightSideShortWhiteUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideShortRedUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideShortWhiteDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideShortRedDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideLongWhiteUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideLongRedUpwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideLongWhiteDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2); }
}
public void customDev_LEDTubeRightSideLongRedDownwardSingleWave(){
  if (CustomDeviceList_LEDTubes.get(2).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(2).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
  if (CustomDeviceList_LEDTubes.get(3).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE);   }
                                                           else { CustomDeviceList_LEDTubes.get(3).setDeviceAnimation(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2); }
}

public void customDev_LEDTubeRandomShortWhiteUpwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2);
}

public void customDev_LEDTubeRandomShortRedUpwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2);
}

public void customDev_LEDTubeRandomLongWhiteUpwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2);
}

public void customDev_LEDTubeRandomLongRedUpwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2);
}


public void customDev_LEDTubeRandomShortWhiteDownwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2);
}

public void customDev_LEDTubeRandomShortRedDownwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2);
}

public void customDev_LEDTubeRandomLongWhiteDownwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2);
}

public void customDev_LEDTubeRandomLongRedDownwardSingleWave() {
  customDev_LEDTubeRandomRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2);
}


/////////////////////////////////////////////////////////////////


public void customDev_LEDTubeSingleRhythmicAnim(int mainAnim, int fallbackAnim) {
  if (CustomDeviceList_LEDTubes.get(currentRandomLEDTube).executionCount % 2 == 0) { CustomDeviceList_LEDTubes.get(currentRandomLEDTube).setDeviceAnimation(mainAnim);   }
                                                                              else { CustomDeviceList_LEDTubes.get(currentRandomLEDTube).setDeviceAnimation(fallbackAnim); }
  incrementLEDTubeCpt(customDevicesRandomDirection);
}


public void customDev_LEDTubeSingleShortWhiteUpwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2);
}

public void customDev_LEDTubeSingleShortRedUpwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2);
}

public void customDev_LEDTubeSingleLongWhiteUpwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2);
}

public void customDev_LEDTubeSingleLongRedUpwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2);
}


public void customDev_LEDTubeSingleShortWhiteDownwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2);
}

public void customDev_LEDTubeSingleShortRedDownwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2);
}

public void customDev_LEDTubeSingleLongWhiteDownwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2);
}

public void customDev_LEDTubeSingleLongRedDownwardSingleWave() {
  customDev_LEDTubeSingleRhythmicAnim(CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE, CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2);
}

////////////////////////////////
// Commands for CustomDevices //
////////////////////////////////

//Send commands to all sorts of custom devices
//For these devices, this Processing program does not actually compute the animations, it 
//just sends general commands (ie. "Custom device #3 -> animation #12"), the onboard IC then
//generates the custom graphics
//These commands are sent to a microcontroller which then dispatchs wirelessly the different
//commands to individual devices.
//A common implementation for the onboard animations would smooth out a lot the actual creation
//of the shows, please follow this general guidance for program numbering :



//Create a CustomDeviceController object - initialize the serial port for the microcontroller responsible for the DMX equipments
CustomDeviceController myCustomDeviceController;

//Create lists of custom equipments (ex)
ArrayList<CustomDevice_LEDTube> CustomDeviceList_LEDTubes;
ArrayList<CustomDevice_RackLight> CustomDeviceList_RackLights;

//If an exception is raised when trying to send a CustomDevice command, raise the flag, and do not try anymore
boolean exceptionRaisedCustomDevice = false;

//General custom device object, serves as en entry point to send actual data over the network
public class CustomDeviceController{
 
  Serial myPort;
 
  CustomDeviceController(PApplet myPApplet) {
    if (debug_without_custom_devices == false) {
      for (int element = 0; element < Serial.list().length; element++){
        if (Serial.list()[element].contains(CUSTOMDEVICES_MICROCONTROLLER_NAME) == true) {
          this.myPort = new Serial(myPApplet, Serial.list()[element], 57600);
          break;
        }
      }
    }
  }

  // Send command to Arduino to update a specific custom device
  public void setCustomDeviceAnimation(int deviceNumber, int animation) throws SerialPortException {
    // Convert the parameters into a message of the form: 123c45w where 123 is the number of the device and 45 is the animation
    // then send to the Arduino
    if (debug_without_custom_devices == false) 
    {
      if (exceptionRaisedCustomDevice == false) {
        try {
          this.myPort.write( str(deviceNumber) + "c" + str(animation) + "w" );
        }
        catch (Exception e) {
          throw new SerialPortException("CustomDevice Output error: no serial port found! " + e);
        }
      }
    }
  }
}


//Generic custom device object
class CustomDevice {

  // This parameter is useful for rhythmic animations, by determining if it even or odd, the animation number can be changed correctly - this way, the animation is reinit
  int executionCount = 0;
  // The device number is also its index in the RF address table (directly in the nRF24 Arduino firmware)
  int CustomDevice_deviceNumber;
  // Not really useful per se, but acts as a save of the last order which was set. This parameter is used by the simulator, unlike the remote Arduino, without
  // this parameter, this app would have no info on the active animation going on on the custom devices 
  int lastAnimationExecuted = 0;
  
  boolean exceptionRaisedCustomDevice = false;
  
  CustomDevice(int deviceNumber) {
    this.CustomDevice_deviceNumber = deviceNumber;
    this.executionCount = 0;
  }
  
  
  //Used to print the informations regarding this device in the configuration file
  public String printStatus() {
    return "DeviceNumber:" + this.CustomDevice_deviceNumber;
  }
  
  public void setDeviceAnimation(int animation) {
    // Update the execution count - do it outside the try{} to allow offline simulator debug 
    this.executionCount += 1;
    
    if (this.exceptionRaisedCustomDevice == false) {
      try {
        // Send the message
        myCustomDeviceController.setCustomDeviceAnimation(this.CustomDevice_deviceNumber,animation);
      }
      catch (Exception e) {
        outputLog.println("Custom device exception : " + e);
        this.exceptionRaisedCustomDevice = true;
      }
    }
    //This is done outside the try catch block, so that even with just the simulator, with no ext device, the command is still seen
    lastAnimationExecuted = animation;
  }
}

//Specific object for the LED tubes
class CustomDevice_LEDTube extends CustomDevice {

  CustomDevice_LEDTube(int deviceNumber) {
    super(deviceNumber);
  }
}

//Specific object for the Rack lights
class CustomDevice_RackLight extends CustomDevice {
  CustomDevice_RackLight(int deviceNumber) {
    super(deviceNumber);
  }
}


public void init_defaultCustomDevices() {
  CustomDeviceList_LEDTubes   = new ArrayList<CustomDevice_LEDTube>();
  CustomDeviceList_RackLights = new ArrayList<CustomDevice_RackLight>();
  
  //The default CustomDevices consist of 4 tubes (device numbers 1 to 4), and 3 rack lights (device numbers 5 to 7)
  CustomDeviceList_LEDTubes.add(new CustomDevice_LEDTube(0));
  CustomDeviceList_LEDTubes.add(new CustomDevice_LEDTube(1));
  CustomDeviceList_LEDTubes.add(new CustomDevice_LEDTube(2));
  CustomDeviceList_LEDTubes.add(new CustomDevice_LEDTube(3));
  //CustomDeviceList_RackLights.add(new CustomDevice_RackLight(4));
  //CustomDeviceList_RackLights.add(new CustomDevice_RackLight(5));
  //CustomDeviceList_RackLights.add(new CustomDevice_RackLight(6));
}

public void empty_CustomDevices() {
  CustomDeviceList_LEDTubes   = new ArrayList<CustomDevice_LEDTube>();
  CustomDeviceList_RackLights = new ArrayList<CustomDevice_RackLight>();
}

///////////////////////////////
//   DMX generic functions   //
///////////////////////////////

// Important note:
// Due to the project's development history, the strobes are dealt with in a particular way
// A possible future evolution could be to harmonize the behaviour of all devices - this shall be done if enough time is available



//Create a DMX object - initialize the serial port for the microcontroller responsible for the DMX equipments
DMX myDMX;

//Create lists of DMX equipments corresponding to "families"
ArrayList<DMX_Stroboscope> DMXList_FrontLeftStroboscopes;
ArrayList<DMX_Stroboscope> DMXList_FrontRightStroboscopes;
ArrayList<DMX_Stroboscope> DMXList_BackStroboscopes;
ArrayList<DMX_MovingHead>  DMXList_MovingHeads;

//Create sublists of the registered devices
ArrayList<DMX_MovingHead>  DMXList_MovingHeads_side;
ArrayList<DMX_MovingHead>  DMXList_MovingHeads_center;
ArrayList<DMX_MovingHead>  DMXList_MovingHeads_right;
ArrayList<DMX_MovingHead>  DMXList_MovingHeads_left;
IntList                    DMX_registeredDeviceID_MovingHeads;

//If an exception is raised when trying to send a DMX command, raise the flag, and do not try anymore for this particular device
boolean exceptionRaisedDMX = false;

//For 4 channel stroboscopes, default values for the special channels
final int DMXStroboscope_defaultFlashLengthValue = 50;
final int DMXStroboscope_defaultSpecialFXValue   = 0;      // No effect  

//General DMX object, serves as en entry point to send actual DMX data over the network
public class DMX {
 
  Serial myPort;
 
  DMX(PApplet myPApplet) {
    if (debug_without_dmx == false) {
      for (int element = 0; element < Serial.list().length; element++){
        if (Serial.list()[element].contains(DMX_MICROCONTROLLER_NAME) == true) {
          this.myPort = new Serial(myPApplet, Serial.list()[element], 9600);      
        }
      }
    }
  }

  // Send command to Teensy2 to update DMX channel
  public void setDmxChannel(int channel, int value) throws SerialPortException {
    // Convert the parameters into a message of the form: 123c45w where 123 is the channel and 45 is the value
    // then send to the Arduino
    if (debug_without_dmx == false) 
    {
      if (exceptionRaisedDMX == false) {
        try {
          this.myPort.write( str(channel) + "c" + str(value) + "w" );
        }
        catch (Exception e) {
          throw new SerialPortException("DMX Output error: no serial port found! " + e);
        }
      }
    }
  } 
}

public void init_defaultDMXDevices() {

  dmxInit_registerDefaultStrobes();
  dmxInit_registerDefaultMovingHeads();

}

public void empty_DMXDevices() {
  DMXList_FrontLeftStroboscopes  = new ArrayList<DMX_Stroboscope>();
  DMXList_FrontRightStroboscopes = new ArrayList<DMX_Stroboscope>();
  DMXList_BackStroboscopes       = new ArrayList<DMX_Stroboscope>();
}

public boolean checkDmxAddressMapping(int startAddr, int nbChNewFixture) {
  //TBIL - check that no fixture conflicts with another
  return true;
}


public void dmxInit_registerDefaultStrobes() {
  DMXList_FrontLeftStroboscopes  = new ArrayList<DMX_Stroboscope>();
  DMXList_FrontRightStroboscopes = new ArrayList<DMX_Stroboscope>();
  DMXList_BackStroboscopes       = new ArrayList<DMX_Stroboscope>();
  DMXList_MovingHeads            = new ArrayList<DMX_MovingHead>();

  //The default DMX devices consist of two small stroboscopes on the left and on the right, and one big in the middle
  DMXList_BackStroboscopes.add(new DMX_Stroboscope(5,6,7,8));
  DMXList_FrontLeftStroboscopes.add(new DMX_Stroboscope(1, 2));
  DMXList_FrontRightStroboscopes.add(new DMX_Stroboscope(3, 4));
}

public void dmxInit_registerDefaultMovingHeads() {
  DMXList_MovingHeads            = new ArrayList<DMX_MovingHead>();

  // New style fixtures
  try {
    DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 0, 10 + 0*24));
    DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 1, 10 + 1*24));
    DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 2, 10 + 2*24));
    DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 3, 10 + 3*24));
    // DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 4, 10 + 4*24));
    // DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 5, 10 + 5*24));
    // DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 6, 10 + 6*24));
    // DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 7, 10 + 7*24));
    // DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 8, 10 + 7*24));
    // DMXList_MovingHeads.add(new DMX_MovingHead("Robe Pointe (24 channels)", 9, 10 + 7*24));
    
  }
  catch (UndefinedFixtureException e) {
    println("Undefined Fixture");
  }

  // Execute all the subtasks needed to complete the DMX init
  dmxInit_buildSubObjects();
  
}

public void dmxInit_buildSubObjects() {
  // Now build the center/side/right/left sublists
  dmx_buildFixtureSublists_movingHead();
  // Check the registered deviceIDs
  dmx_buildDeviceIDLists();
}

public void dmx_buildFixtureSublists_movingHead() {
  //Initialize the sublists
  DMXList_MovingHeads_side       = new ArrayList<DMX_MovingHead>();
  DMXList_MovingHeads_center     = new ArrayList<DMX_MovingHead>();
  DMXList_MovingHeads_right      = new ArrayList<DMX_MovingHead>();
  DMXList_MovingHeads_left       = new ArrayList<DMX_MovingHead>();

  int nbMovingHeads = DMXList_MovingHeads.size();
  
  // Consider that about one third of the fixtures go in the "center" group
  float centerRatio = 1.0f/3.0f;

  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    if (nbMovingHeads%2 == 1) {
      // Left / Right fixtures
      if (movingHead.getDeviceID() < (nbMovingHeads-1)/2) {
        DMXList_MovingHeads_left.add(movingHead);
      }
      else if (movingHead.getDeviceID() > (nbMovingHeads-1)/2) {
        DMXList_MovingHeads_right.add(movingHead);
      }
      
      // Side / Center fixtures
      int nbCenterMovingHeads = ceil(nbMovingHeads*centerRatio) + ( (ceil(nbMovingHeads*centerRatio) + 1) % 2);
      if (movingHead.getDeviceID() < (nbMovingHeads-nbCenterMovingHeads)/2 || movingHead.getDeviceID() >= (nbMovingHeads-nbCenterMovingHeads)/2 + nbCenterMovingHeads) {
        DMXList_MovingHeads_side.add(movingHead);
      }
      else {
        DMXList_MovingHeads_center.add(movingHead);
      }

    }
    else {
      // Left / Right fixtures
      if (movingHead.getDeviceID() <= (nbMovingHeads-1)/2) {
        DMXList_MovingHeads_left.add(movingHead);
      }
      else {
        DMXList_MovingHeads_right.add(movingHead);
      }

      // Side / Center fixtures
      int nbCenterMovingHeads = ceil(nbMovingHeads*centerRatio) + ( (ceil(nbMovingHeads*centerRatio) + 1) % 2);
      if (movingHead.getDeviceID() <= (nbMovingHeads-nbCenterMovingHeads)/2 || movingHead.getDeviceID() >= (nbMovingHeads-nbCenterMovingHeads)/2 + nbCenterMovingHeads) {
        DMXList_MovingHeads_side.add(movingHead);
      }
      else {
        DMXList_MovingHeads_center.add(movingHead);
      }
    }
  }

  // Special case: if not enough moving heads are declared, the side list might be empty (ex: 2 fixtures -> "2 center fixtures"). In this case, consider the side and the center lists to be equal
  if (DMXList_MovingHeads_side.size() == 0) {
    DMXList_MovingHeads_side = DMXList_MovingHeads_center;
  }
  if (DMXList_MovingHeads_center.size() == 0) {
    DMXList_MovingHeads_center = DMXList_MovingHeads_side;
  }
  if (DMXList_MovingHeads.size() == 1) {
    DMXList_MovingHeads_left  = DMXList_MovingHeads;
    DMXList_MovingHeads_right = DMXList_MovingHeads;
  }

  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    println("DMXList_MovingHeads_side - " + movingHead.getDeviceID());
  }
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    println("DMXList_MovingHeads_center - " + movingHead.getDeviceID());
  }
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    println("DMXList_MovingHeads_right - " + movingHead.getDeviceID());
  }
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    println("DMXList_MovingHeads_left - " + movingHead.getDeviceID());
  }

}

public void dmx_buildDeviceIDLists() {
  DMX_registeredDeviceID_MovingHeads = new IntList();
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    DMX_registeredDeviceID_MovingHeads.append(movingHead.getDeviceID());
  }
  DMX_registeredDeviceID_MovingHeads.sort();
}

///////////////////////////////////////////////////////////////
//   DMX animations - Sequences used by the automatic mode   //
///////////////////////////////////////////////////////////////


// Strobe related constants
final int SINGLEFLASH_INITVAL = 6;
final float SIDESTROBE_MAX_SPEED = 0.8f;    //Max speed ratio for the side strobes (1 -> full speed => 255 DMX speed)
final float BACKSTROBE_MAX_SPEED = 0.8f;

int dmxAnimationNumber_strobe                       = 0;
int dmxAnimationNumber_movingHead_initDirection     = 0;
int dmxAnimationNumber_movingHead_setColor          = 0;
int dmxAnimationNumber_movingHead_setRhythm         = 0;
int dmxAnimationNumber_movingHead_setLightStyle     = 0;
int dmxAnimationNumber_movingHead_setAnimation      = 0;
int dmxAnimationNumber_par                          = 0;

float dmxAnim_movingHead_globalAnimCpt              = 0;          // Global counter used for the animations
int dmxAnim_movingHead_nbRhythmSyncedDev            = 0;
int dmxAnim_movingHead_currentSelectionIdx          = 0;
IntList dmxAnim_syncedMovingHeads;                                // IntList containing the deviceIDs of the concerned fixtures

public void playDMXAnimation() {
  playDMXAnimation_strobe();
  playDMXAnimation_movingHead();
}

// Play the DMX animations
public void playDMXAnimation_strobe() {
  switch(dmxAnimationNumber_strobe) {
    case 1:   dmxAnim_strobe_blackout();                         break;         // 1 -   Full Blackout
                                                                 
    case 2:   dmxAnim_fullStrobeVerySlow();                      break;         // 2 -   Full Strobe - Very Slow
    case 3:   dmxAnim_fullStrobeSlow();                          break;         // 3 -   Full Strobe - Slow
    case 4:   dmxAnim_fullStrobeMedium();                        break;         // 4 -   Full Strobe - Medium
    case 5:   dmxAnim_fullStrobeFast();                          break;         // 5 -   Full Strobe - Fast
    case 6:   dmxAnim_fullStrobeVeryFast();                      break;         // 6 -   Full Strobe - Very Fast
                                                                 
    case 7:   dmxAnim_leftStrobeVerySlow();                      break;         // 7 -   Left Strobe - Very Slow
    case 8:   dmxAnim_leftStrobeSlow();                          break;         // 8 -   Left Strobe - Slow     
    case 9:   dmxAnim_leftStrobeMedium();                        break;         // 9 -   Left Strobe - Medium   
    case 10:  dmxAnim_leftStrobeFast();                          break;         // 10 -  Left Strobe - Fast     
    case 11:  dmxAnim_leftStrobeVeryFast();                      break;         // 11 -  Left Strobe - Very Fast
    case 12:  dmxAnim_rightStrobeVerySlow();                     break;         // 12 -  Right Strobe - Very Slow
    case 13:  dmxAnim_rightStrobeSlow();                         break;         // 13 -  Right Strobe - Slow     
    case 14:  dmxAnim_rightStrobeMedium();                       break;         // 14 -  Right Strobe - Medium   
    case 15:  dmxAnim_rightStrobeFast();                         break;         // 15 -  Right Strobe - Fast     
    case 16:  dmxAnim_rightStrobeVeryFast();                     break;         // 16 -  Right Strobe - Very Fast
    case 17:  dmxAnim_backStrobeVerySlow();                      break;         // 17 -  Back Strobe - Very Slow
    case 18:  dmxAnim_backStrobeSlow();                          break;         // 18 -  Back Strobe - Slow
    case 19:  dmxAnim_backStrobeMedium();                        break;         // 19 -  Back Strobe - Medium
    case 20:  dmxAnim_backStrobeFast();                          break;         // 20 -  Back Strobe - Fast
    case 21:  dmxAnim_backStrobeVeryFast();                      break;         // 21 -  Back Strobe - Very Fast
                                                                 
    case 22:  dmxAnim_leftRightStrobeVerySlow();                 break;         // 22 -  Left/Right Strobe - Very Slow
    case 23:  dmxAnim_leftRightStrobeSlow();                     break;         // 23 -  Left/Right Strobe - Slow     
    case 24:  dmxAnim_leftRightStrobeMedium();                   break;         // 24 -  Left/Right Strobe - Medium   
    case 25:  dmxAnim_leftRightStrobeFast();                     break;         // 25 -  Left/Right Strobe - Fast     
    case 26:  dmxAnim_leftRightStrobeVeryFast();                 break;         // 26 -  Left/Right Strobe - Very Fast    
                                                                 
    case 27:  dmxAnim_alternateStrobe2();                        break;         // 27 -  Alternate Strobe - Left/Right - 2/4
    case 28:  dmxAnim_alternateStrobe4();                        break;         // 28 -  Alternate Strobe - Left/Right - 1/4
    case 29:  dmxAnim_alternateStrobe8();                        break;         // 29 -  Alternate Strobe - Left/Right - 1/8
    case 30:  dmxAnim_alternateStrobe16();                       break;         // 30 -  Alternate Strobe - Left/Right - 1/16
                                                                 
    case 31:  dmxAnim_rotatingStrobe2();                         break;         // 31 -  Rotating Strobe - Left/Center/Right - 2/4
    case 32:  dmxAnim_rotatingStrobe4();                         break;         // 32 -  Rotating Strobe - Left/Center/Right - 1/4
    case 33:  dmxAnim_rotatingStrobe8();                         break;         // 33 -  Rotating Strobe - Left/Center/Right - 1/8
    case 34:  dmxAnim_rotatingStrobe16();                        break;         // 34 -  Rotating Strobe - Left/Center/Right - 1/16
                                                                 
    case 35:  dmxAnim_growingFullStrobe();                       break;         // 35 -  Growing Strobe - Full
    case 36:  dmxAnim_growingLeftStrobe();                       break;         // 36 -  Growing Strobe - Left
    case 37:  dmxAnim_growingRightStrobe();                      break;         // 37 -  Growing Strobe - Right
    case 38:  dmxAnim_growingBackStrobe();                       break;         // 38 -  Growing Strobe - Back
    case 39:  dmxAnim_growingLeftRightStrobe();                  break;         // 39 -  Growing Strobe - Left/Right
                                                                 
    case 40:  dmxAnim_growingAlternateStrobe2();                 break;         // 40 -  Growing Strobe - Alternate Left/Right - 2/4
    case 41:  dmxAnim_growingAlternateStrobe4();                 break;         // 41 -  Growing Strobe - Alternate Left/Right - 1/4
    case 42:  dmxAnim_growingAlternateStrobe8();                 break;         // 42 -  Growing Strobe - Alternate Left/Right - 1/8
    case 43:  dmxAnim_growingAlternateStrobe16();                break;         // 43 -  Growing Strobe - Alternate Left/Right - 1/16
                                                                 
    case 44:  dmxAnim_growingRotatingStrobe2();                  break;         // 44 -  Growing Strobe - Rotating Left/Center/Right - 2/4
    case 45:  dmxAnim_growingRotatingStrobe4();                  break;         // 45 -  Growing Strobe - Rotating Left/Center/Right - 1/4
    case 46:  dmxAnim_growingRotatingStrobe8();                  break;         // 46 -  Growing Strobe - Rotating Left/Center/Right - 1/8
    case 47:  dmxAnim_growingRotatingStrobe16();                 break;         // 47 -  Growing Strobe - Rotating Left/Center/Right - 1/16
                                                                 
    case 48:  dmxAnim_shortSingleFlash();                        break;         // 48 -  Short Single Flash - Atomic 3000
    case 49:  dmxAnim_longSingleFlash();                         break;         // 49 -  Long Single Flash - Atomic 3000
    case 50:  dmxAnim_impulseFlasher_kick();                     break;         // 50 -  Impulse Flasher - Kick    : flash once the Atomic 3000 when an impulse is processed
    case 51:  dmxAnim_impulseFlasher_snare();                    break;         // 51 -  Impulse Flasher - Snare   : flash once the Atomic 3000 when an impulse is processed
    case 52:  dmxAnim_impulseFlasher_cymbals();                  break;         // 52 -  Impulse Flasher - Cymbals : flash once the Atomic 3000 when an impulse is processed
    case 53:  dmxAnim_impulseFlasher_bass();                     break;         // 53 -  Impulse Flasher - Bass    : flash once the Atomic 3000 when an impulse is processed
    case 54:  dmxAnim_impulseFlasher_keys();                     break;         // 54 -  Impulse Flasher - Keys    : flash once the Atomic 3000 when an impulse is processed
    case 55:  dmxAnim_impulseFlasher_guitar();                   break;         // 55 -  Impulse Flasher - Guitar  : flash once the Atomic 3000 when an impulse is processed
                                                                 
    case 56:  dmxAnim_atomicFX_rampUp_SlowFlash();               break;         // 56 -  Atomic 3000 SpecialFX - Ramp up - Slow Flash
    case 57:  dmxAnim_atomicFX_rampUp_MediumFlash();             break;         // 57 -  Atomic 3000 SpecialFX - Ramp up - Medium Flash
    case 58:  dmxAnim_atomicFX_rampUp_FastFlash();               break;         // 58 -  Atomic 3000 SpecialFX - Ramp up - Fast Flash
    case 59:  dmxAnim_atomicFX_rampUp_SlowContinuous();          break;         // 59 -  Atomic 3000 SpecialFX - Ramp up - Slow Continuous
    case 60:  dmxAnim_atomicFX_rampUp_MediumContinuous();        break;         // 60 -  Atomic 3000 SpecialFX - Ramp up - Medium Continuous
    case 61:  dmxAnim_atomicFX_rampUp_FastContinuous();          break;         // 61 -  Atomic 3000 SpecialFX - Ramp up - Fast Continuous
                                                                 
    case 62:  dmxAnim_atomicFX_rampDown_SlowFlash();             break;         // 62 -  Atomic 3000 SpecialFX - Ramp down - Slow Flash
    case 63:  dmxAnim_atomicFX_rampDown_MediumFlash();           break;         // 63 -  Atomic 3000 SpecialFX - Ramp down - Medium Flash
    case 64:  dmxAnim_atomicFX_rampDown_FastFlash();             break;         // 64 -  Atomic 3000 SpecialFX - Ramp down - Fast Flash
    case 65:  dmxAnim_atomicFX_rampDown_SlowContinuous();        break;         // 65 -  Atomic 3000 SpecialFX - Ramp down - Slow Continuous
    case 66:  dmxAnim_atomicFX_rampDown_MediumContinuous();      break;         // 66 -  Atomic 3000 SpecialFX - Ramp down - Medium Continuous
    case 67:  dmxAnim_atomicFX_rampDown_FastContinuous();        break;         // 67 -  Atomic 3000 SpecialFX - Ramp down - Fast Continuous
    
    case 68:  dmxAnim_atomicFX_rampUpDown_SlowFlash();           break;         // 68 -  Atomic 3000 SpecialFX - Ramp up/down - Slow Flash
    case 69:  dmxAnim_atomicFX_rampUpDown_MediumFlash();         break;         // 69 -  Atomic 3000 SpecialFX - Ramp up/down - Medium Flash
    case 70:  dmxAnim_atomicFX_rampUpDown_FastFlash();           break;         // 70 -  Atomic 3000 SpecialFX - Ramp up/down - Fast Flash
    case 71:  dmxAnim_atomicFX_rampUpDown_SlowContinuous();      break;         // 71 -  Atomic 3000 SpecialFX - Ramp up/down - Slow Continuous
    case 72:  dmxAnim_atomicFX_rampUpDown_MediumContinuous();    break;         // 72 -  Atomic 3000 SpecialFX - Ramp up/down - Medium Continuous
    case 73:  dmxAnim_atomicFX_rampUpDown_FastContinuous();      break;         // 73 -  Atomic 3000 SpecialFX - Ramp up/down - Fast Continuous
    
    case 74:  dmxAnim_atomicFX_random();                         break;         // 74 -  Atomic 3000 SpecialFX - Random
    case 75:  dmxAnim_atomicFX_lightning();                      break;         // 75 -  Atomic 3000 SpecialFX - Lightning
    
    case 76:  dmxAnim_atomicFX_slowSpikes();                     break;         // 76 -  Atomic 3000 SpecialFX - Spikes - Slow
    case 77:  dmxAnim_atomicFX_mediumSpikes();                   break;         // 77 -  Atomic 3000 SpecialFX - Spikes - Medium
    case 78:  dmxAnim_atomicFX_fastSpikes();                     break;         // 78 -  Atomic 3000 SpecialFX - Spikes - Fast
    
    case 79:  dmxAnim_atomicFX_Blinder_VeryWeak();               break;         // 79 -  Atomic 3000 SpecialFX - Blinder - Very Weak
    case 80:  dmxAnim_atomicFX_Blinder_Weak();                   break;         // 80 -  Atomic 3000 SpecialFX - Blinder - Weak
    case 81:  dmxAnim_atomicFX_Blinder_Medium();                 break;         // 81 -  Atomic 3000 SpecialFX - Blinder - Medium
    case 82:  dmxAnim_atomicFX_Blinder_Strong();                 break;         // 82 -  Atomic 3000 SpecialFX - Blinder - Strong
    case 83:  dmxAnim_atomicFX_Blinder_VeryStrong();             break;         // 83 -  Atomic 3000 SpecialFX - Blinder - Very Strong
    
    case 84:  dmxAnim_leftStrobeVeryWeak();                      break;         // 84 -  Left Strobe - Very Weak / Full speed
    case 85:  dmxAnim_rightStrobeVeryWeak();                     break;         // 85 -  Right Strobe - Very Weak / Full speed
    case 86:  dmxAnim_backStrobeVeryWeak();                      break;         // 86 -  Center Strobe - Very Weak / Full speed
    case 87:  dmxAnim_leftRightStrobeVeryWeak();                 break;         // 87 -  Left/Right Strobe - Very Weak / Full speed
    case 88:  dmxAnim_fullStrobeVeryWeak();                      break;         // 88 -  Full Strobe - Very Weak / Full speed
    
    case 89:  dmxAnim_leftStrobeWeak();                          break;         // 89 -  Left Strobe - Weak / Full speed
    case 90:  dmxAnim_rightStrobeWeak();                         break;         // 90 -  Right Strobe - Weak / Full speed
    case 91:  dmxAnim_backStrobeWeak();                          break;         // 91 -  Center Strobe - Weak / Full speed
    case 92:  dmxAnim_leftRightStrobeWeak();                     break;         // 92 -  Left/Right Strobe - Weak / Full speed
    case 93:  dmxAnim_fullStrobeWeak();                          break;         // 93 -  Full Strobe - Weak / Full speed
    
    case 94:  dmxAnim_leftStrobeModerate();                      break;         // 94 -  Left Strobe - Moderate / Full speed
    case 95:  dmxAnim_rightStrobeModerate();                     break;         // 95 -  Right Strobe - Moderate / Full speed
    case 96:  dmxAnim_backStrobeModerate();                      break;         // 96 -  Center Strobe - Moderate / Full speed
    case 97:  dmxAnim_leftRightStrobeModerate();                 break;         // 97 -  Left/Right Strobe - Moderate / Full speed
    case 98:  dmxAnim_fullStrobeModerate();                      break;         // 98 -  Full Strobe - Moderate / Full speed

    case 99:  dmxAnim_leftStrobeStrong();                        break;         // 99 -  Left Strobe - Strong / Full speed
    case 100: dmxAnim_rightStrobeStrong();                       break;         // 100 - Right Strobe - Strong / Full speed
    case 101: dmxAnim_backStrobeStrong();                        break;         // 101 - Center Strobe - Strong / Full speed
    case 102: dmxAnim_leftRightStrobeStrong();                   break;         // 102 - Left/Right Strobe - Strong / Full speed
    case 103: dmxAnim_fullStrobeStrong();                        break;         // 103 - Full Strobe - Strong / Full speed
        
    default:  dmxAnim_strobe_blackout();                         break;
  }
}

// Must be called whenever dmxAnimationNumber_strobe is modified
public void setupDMXAnimation_strobe() {
  switch(dmxAnimationNumber_strobe) {
    case 1:   break;
    case 35:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 36:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 37:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 38:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 39:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 40:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 41:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 42:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 43:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 44:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 45:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 46:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 47:  growingStrobe_speed = 255; growingStrobe_intensity = 0; break;
    case 48:  singleFlash_cpt = SINGLEFLASH_INITVAL; simuResetAnimCpt_AtomicStrobe(); break;
    case 49:  singleFlash_cpt = SINGLEFLASH_INITVAL; simuResetAnimCpt_AtomicStrobe(); break;
    case 56:  simuResetAnimCpt_AtomicStrobe(); break;
    case 57:  simuResetAnimCpt_AtomicStrobe(); break;
    case 58:  simuResetAnimCpt_AtomicStrobe(); break;
    case 59:  simuResetAnimCpt_AtomicStrobe(); break;
    case 60:  simuResetAnimCpt_AtomicStrobe(); break;
    case 61:  simuResetAnimCpt_AtomicStrobe(); break;
    case 62:  simuResetAnimCpt_AtomicStrobe(); break;
    case 63:  simuResetAnimCpt_AtomicStrobe(); break;
    case 64:  simuResetAnimCpt_AtomicStrobe(); break;
    case 65:  simuResetAnimCpt_AtomicStrobe(); break;
    case 66:  simuResetAnimCpt_AtomicStrobe(); break;
    case 67:  simuResetAnimCpt_AtomicStrobe(); break;
    case 68:  simuResetAnimCpt_AtomicStrobe(); break;
    case 69:  simuResetAnimCpt_AtomicStrobe(); break;
    case 70:  simuResetAnimCpt_AtomicStrobe(); break;
    case 71:  simuResetAnimCpt_AtomicStrobe(); break;
    case 72:  simuResetAnimCpt_AtomicStrobe(); break;
    case 73:  simuResetAnimCpt_AtomicStrobe(); break;
    default:  break;
  } 
}

public void setupDMXAnimation_movingHead_initDirection() {
  switch(dmxAnimationNumber_movingHead_initDirection) {
    // Prepare direction : set all moving heads facing towards a specific direction in order to anticipate the subsequent animation
    case 1:   dmxAnim_movingHead_prepareDirection_CenterPan_LowTilt();                                                       break;
    case 2:   dmxAnim_movingHead_prepareDirection_LeftPan_LowTilt();                                                         break;
    case 3:   dmxAnim_movingHead_prepareDirection_RightPan_LowTilt();                                                        break;
    case 4:   dmxAnim_movingHead_prepareDirection_CenterPan_FrontTilt();                                                     break;
    case 5:   dmxAnim_movingHead_prepareDirection_LeftPan_FrontTilt();                                                       break;
    case 6:   dmxAnim_movingHead_prepareDirection_RightPan_FrontTilt();                                                      break;
    case 7:   dmxAnim_movingHead_prepareDirection_CenterPan_HighTilt();                                                      break;
    case 8:   dmxAnim_movingHead_prepareDirection_LeftPan_HighTilt();                                                        break;
    case 9:   dmxAnim_movingHead_prepareDirection_RightPan_HighTilt();                                                       break;
    case 10:  dmxAnim_movingHead_prepareDirection_CenterPan_UprightTilt();                                                   break;
    case 11:  dmxAnim_movingHead_prepareDirection_LeftPan_UprightTilt();                                                     break;
    case 12:  dmxAnim_movingHead_prepareDirection_RightPan_UprightTilt();                                                    break;
    case 13:  dmxAnim_movingHead_prepareDirection_CenterPan_BackTilt();                                                      break;
    case 14:  dmxAnim_movingHead_prepareDirection_LeftPan_BackTilt();                                                        break;
    case 15:  dmxAnim_movingHead_prepareDirection_RightPan_BackTilt();                                                       break;

    case 16:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_LowTilt();                                 break;
    case 17:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_LowTilt();                              break;
    case 18:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_LowTilt();                               break;
    case 19:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_FrontTilt();                               break;
    case 20:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_FrontTilt();                            break;
    case 21:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_FrontTilt();                             break;
    case 22:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_HighTilt();                                break;
    case 23:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_HighTilt();                             break;
    case 24:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_HighTilt();                              break;
    case 25:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_UprightTilt();                             break;
    case 26:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_UprightTilt();                          break;
    case 27:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_UprightTilt();                           break;

    case 28:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_LowTilt();                                break;
    case 29:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_LowTilt();                             break;
    case 30:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_LowTilt();                              break;
    case 31:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_FrontTilt();                              break;
    case 32:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_FrontTilt();                           break;
    case 33:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_FrontTilt();                            break;
    case 34:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_HighTilt();                               break;
    case 35:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_HighTilt();                            break;
    case 36:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_HighTilt();                             break;
    case 37:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_UprightTilt();                            break;
    case 38:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_UprightTilt();                         break;
    case 39:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_UprightTilt();                          break;

    case 40:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_WideNegTilt();            break;
    case 41:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_NarrowNegTilt();          break;
    case 42:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_WideNegTilt();               break;
    case 43:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_NarrowNegTilt();             break;
    case 44:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_WidePosTilt();            break;
    case 45:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_NarrowPosTilt();          break;
    case 46:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_WidePosTilt();               break;
    case 47:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_NarrowPosTilt();             break;

    case 48:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_LowOppositeTilt();                         break;
    case 49:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_LowOppositeTilt();                      break;
    case 50:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_LowOppositeTilt();                       break;
    case 51:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_FrontOppositeTilt();                       break;
    case 52:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_FrontOppositeTilt();                    break;
    case 53:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_FrontOppositeTilt();                     break;
    case 54:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_HighOppositeTilt();                        break;
    case 55:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_HighOppositeTilt();                     break;
    case 56:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_HighOppositeTilt();                      break;
    case 57:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_UprightOppositeTilt();                     break;
    case 58:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_UprightOppositeTilt();                  break;
    case 59:  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_UprightOppositeTilt();                   break;

    case 60:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_LowOppositeTilt();                        break;
    case 61:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_LowOppositeTilt();                     break;
    case 62:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_LowOppositeTilt();                      break;
    case 63:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_FrontOppositeTilt();                      break;
    case 64:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_FrontOppositeTilt();                   break;
    case 65:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_FrontOppositeTilt();                    break;
    case 66:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_HighOppositeTilt();                       break;
    case 67:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_HighOppositeTilt();                    break;
    case 68:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_HighOppositeTilt();                     break;
    case 69:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_UprightOppositeTilt();                    break;
    case 70:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_UprightOppositeTilt();                 break;
    case 71:  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_UprightOppositeTilt();                  break;

    case 72:  dmxAnim_movingHead_prepareDirection_centerDev_CenterPan_FrontTilt();                                           break;
    case 73:  dmxAnim_movingHead_prepareDirection_centerDev_LeftPan_FrontTilt();                                             break;
    case 74:  dmxAnim_movingHead_prepareDirection_centerDev_RightPan_FrontTilt();                                            break;
    case 75:  dmxAnim_movingHead_prepareDirection_centerDev_CenterPan_HighTilt();                                            break;
    case 76:  dmxAnim_movingHead_prepareDirection_centerDev_LeftPan_HighTilt();                                              break;
    case 77:  dmxAnim_movingHead_prepareDirection_centerDev_RightPan_HighTilt();                                             break;
    case 78:  dmxAnim_movingHead_prepareDirection_centerDev_CenterPan_UprightTilt();                                         break;
    case 79:  dmxAnim_movingHead_prepareDirection_centerDev_LeftPan_UprightTilt();                                           break;
    case 80:  dmxAnim_movingHead_prepareDirection_centerDev_RightPan_UprightTilt();                                          break;

    case 81:  dmxAnim_movingHead_prepareDirection_sideDev_CenterPan_FrontTilt();                                           break;
    case 82:  dmxAnim_movingHead_prepareDirection_sideDev_LeftPan_FrontTilt();                                             break;
    case 83:  dmxAnim_movingHead_prepareDirection_sideDev_RightPan_FrontTilt();                                            break;
    case 84:  dmxAnim_movingHead_prepareDirection_sideDev_CenterPan_HighTilt();                                            break;
    case 85:  dmxAnim_movingHead_prepareDirection_sideDev_LeftPan_HighTilt();                                              break;
    case 86:  dmxAnim_movingHead_prepareDirection_sideDev_RightPan_HighTilt();                                             break;
    case 87:  dmxAnim_movingHead_prepareDirection_sideDev_CenterPan_UprightTilt();                                         break;
    case 88:  dmxAnim_movingHead_prepareDirection_sideDev_LeftPan_UprightTilt();                                           break;
    case 89:  dmxAnim_movingHead_prepareDirection_sideDev_RightPan_UprightTilt();                                          break;

    case 90:  dmxAnim_movingHead_prepareDirection_leftDev_CenterPan_FrontTilt();                                           break;
    case 91:  dmxAnim_movingHead_prepareDirection_leftDev_LeftPan_FrontTilt();                                             break;
    case 92:  dmxAnim_movingHead_prepareDirection_leftDev_RightPan_FrontTilt();                                            break;
    case 93:  dmxAnim_movingHead_prepareDirection_leftDev_CenterPan_HighTilt();                                            break;
    case 94:  dmxAnim_movingHead_prepareDirection_leftDev_LeftPan_HighTilt();                                              break;
    case 95:  dmxAnim_movingHead_prepareDirection_leftDev_RightPan_HighTilt();                                             break;
    case 96:  dmxAnim_movingHead_prepareDirection_leftDev_CenterPan_UprightTilt();                                         break;
    case 97:  dmxAnim_movingHead_prepareDirection_leftDev_LeftPan_UprightTilt();                                           break;
    case 98:  dmxAnim_movingHead_prepareDirection_leftDev_RightPan_UprightTilt();                                          break;

    case 99:  dmxAnim_movingHead_prepareDirection_rightDev_CenterPan_FrontTilt();                                           break;
    case 100: dmxAnim_movingHead_prepareDirection_rightDev_LeftPan_FrontTilt();                                             break;
    case 101: dmxAnim_movingHead_prepareDirection_rightDev_RightPan_FrontTilt();                                            break;
    case 102: dmxAnim_movingHead_prepareDirection_rightDev_CenterPan_HighTilt();                                            break;
    case 103: dmxAnim_movingHead_prepareDirection_rightDev_LeftPan_HighTilt();                                              break;
    case 104: dmxAnim_movingHead_prepareDirection_rightDev_RightPan_HighTilt();                                             break;
    case 105: dmxAnim_movingHead_prepareDirection_rightDev_CenterPan_UprightTilt();                                         break;
    case 106: dmxAnim_movingHead_prepareDirection_rightDev_LeftPan_UprightTilt();                                           break;
    case 107: dmxAnim_movingHead_prepareDirection_rightDev_RightPan_UprightTilt();                                          break;

    default: break;
  }
}

public void setupDMXAnimation_movingHead_setColor() {
  switch(dmxAnimationNumber_movingHead_setColor) {
    // For the more complex animations: set the color for the different devices (all/center/side/left/right)

    case 1:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_white();                                         break;
    case 2:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_red();                                           break;
    case 3:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_deepRed();                                       break;
    case 4:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_blue();                                          break;
    case 5:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_deepBlue();                                      break;
    case 6:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_yellow();                                        break;
    case 7:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_green();                                         break;
    case 8:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_ultraviolet();                                   break;
    case 9:   dmxAnim_movingHead_setColorForCompositeAnimations_allDev_orange();                                        break;
    case 10:  dmxAnim_movingHead_setColorForCompositeAnimations_allDev_CTO();                                           break;

    case 11:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_white();                                      break;
    case 12:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_red();                                        break;
    case 13:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_deepRed();                                    break;
    case 14:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_blue();                                       break;
    case 15:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_deepBlue();                                   break;
    case 16:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_yellow();                                     break;
    case 17:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_green();                                      break;
    case 18:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_ultraviolet();                                break;
    case 19:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_orange();                                     break;
    case 20:  dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_CTO();                                        break;

    case 21:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_white();                                        break;
    case 22:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_red();                                          break;
    case 23:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_deepRed();                                      break;
    case 24:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_blue();                                         break;
    case 25:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_deepBlue();                                     break;
    case 26:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_yellow();                                       break;
    case 27:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_green();                                        break;
    case 28:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_ultraviolet();                                  break;
    case 29:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_orange();                                       break;
    case 30:  dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_CTO();                                          break;

    case 31:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_white();                                        break;
    case 32:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_red();                                          break;
    case 33:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_deepRed();                                      break;
    case 34:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_blue();                                         break;
    case 35:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_deepBlue();                                     break;
    case 36:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_yellow();                                       break;
    case 37:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_green();                                        break;
    case 38:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_ultraviolet();                                  break;
    case 39:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_orange();                                       break;
    case 40:  dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_CTO();                                          break;

    case 41:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_white();                                       break;
    case 42:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_red();                                         break;
    case 43:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_deepRed();                                     break;
    case 44:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_blue();                                        break;
    case 45:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_deepBlue();                                    break;
    case 46:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_yellow();                                      break;
    case 47:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_green();                                       break;
    case 48:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_ultraviolet();                                 break;
    case 49:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_orange();                                      break;
    case 50:  dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_CTO();                                         break;


    default: break;
  }
}

public void setupDMXAnimation_movingHead_setRhythm() {
  switch(dmxAnimationNumber_movingHead_setRhythm) {
    case 1:   dmxAnim_movingHead_setLightRhythm_allDev_noSync();                                                        break;      // 1 - Reset the rhythm of all devices
    case 2:   dmxAnim_movingHead_setLightRhythm_centerDev_noSync();                                                     break;
    case 3:   dmxAnim_movingHead_setLightRhythm_sideDev_noSync();                                                       break;
    case 4:   dmxAnim_movingHead_setLightRhythm_leftDev_noSync();                                                       break;
    case 5:   dmxAnim_movingHead_setLightRhythm_rightDev_noSync();                                                      break;

    case 6:   dmxAnim_movingHead_setLightRhythm_allDev_together_32ndSync();                                             break;
    case 7:   dmxAnim_movingHead_setLightRhythm_allDev_together_16thSync();                                             break;
    case 8:   dmxAnim_movingHead_setLightRhythm_allDev_together_8thSync();                                              break;
    case 9:   dmxAnim_movingHead_setLightRhythm_allDev_together_4thSync();                                              break;
    case 10:  dmxAnim_movingHead_setLightRhythm_allDev_together_2ndSync();                                              break;
    case 11:  dmxAnim_movingHead_setLightRhythm_allDev_together_barSync();                                              break;

    case 12:  dmxAnim_movingHead_setLightRhythm_allDev_clockwise_32ndSync();                                            break;
    case 13:  dmxAnim_movingHead_setLightRhythm_allDev_clockwise_16thSync();                                            break;
    case 14:  dmxAnim_movingHead_setLightRhythm_allDev_clockwise_8thSync();                                             break;
    case 15:  dmxAnim_movingHead_setLightRhythm_allDev_clockwise_4thSync();                                             break;
    case 16:  dmxAnim_movingHead_setLightRhythm_allDev_clockwise_2ndSync();                                             break;
    case 17:  dmxAnim_movingHead_setLightRhythm_allDev_clockwise_barSync();                                             break;

    case 18:  dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_32ndSync();                                        break;
    case 19:  dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_16thSync();                                        break;
    case 20:  dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_8thSync();                                         break;
    case 21:  dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_4thSync();                                         break;
    case 22:  dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_2ndSync();                                         break;
    case 23:  dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_barSync();                                         break;

    case 24:  dmxAnim_movingHead_setLightRhythm_allDev_random_32ndSync();                                               break;
    case 25:  dmxAnim_movingHead_setLightRhythm_allDev_random_16thSync();                                               break;
    case 26:  dmxAnim_movingHead_setLightRhythm_allDev_random_8thSync();                                                break;
    case 27:  dmxAnim_movingHead_setLightRhythm_allDev_random_4thSync();                                                break;
    case 28:  dmxAnim_movingHead_setLightRhythm_allDev_random_2ndSync();                                                break;
    case 29:  dmxAnim_movingHead_setLightRhythm_allDev_random_barSync();                                                break;
    
    case 30:  dmxAnim_movingHead_setLightRhythm_centerDev_together_32ndSync();                                          break;
    case 31:  dmxAnim_movingHead_setLightRhythm_centerDev_together_16thSync();                                          break;
    case 32:  dmxAnim_movingHead_setLightRhythm_centerDev_together_8thSync();                                           break;
    case 33:  dmxAnim_movingHead_setLightRhythm_centerDev_together_4thSync();                                           break;
    case 34:  dmxAnim_movingHead_setLightRhythm_centerDev_together_2ndSync();                                           break;
    case 35:  dmxAnim_movingHead_setLightRhythm_centerDev_together_barSync();                                           break;

    case 36:  dmxAnim_movingHead_setLightRhythm_centerDev_random_32ndSync();                                            break;
    case 37:  dmxAnim_movingHead_setLightRhythm_centerDev_random_16thSync();                                            break;
    case 38:  dmxAnim_movingHead_setLightRhythm_centerDev_random_8thSync();                                             break;
    case 39:  dmxAnim_movingHead_setLightRhythm_centerDev_random_4thSync();                                             break;
    case 40:  dmxAnim_movingHead_setLightRhythm_centerDev_random_2ndSync();                                             break;
    case 41:  dmxAnim_movingHead_setLightRhythm_centerDev_random_barSync();                                             break;

    case 42:  dmxAnim_movingHead_setLightRhythm_sideDev_together_32ndSync();                                            break;
    case 43:  dmxAnim_movingHead_setLightRhythm_sideDev_together_16thSync();                                            break;
    case 44:  dmxAnim_movingHead_setLightRhythm_sideDev_together_8thSync();                                             break;
    case 45:  dmxAnim_movingHead_setLightRhythm_sideDev_together_4thSync();                                             break;
    case 46:  dmxAnim_movingHead_setLightRhythm_sideDev_together_2ndSync();                                             break;
    case 47:  dmxAnim_movingHead_setLightRhythm_sideDev_together_barSync();                                             break;

    case 48:  dmxAnim_movingHead_setLightRhythm_sideDev_random_32ndSync();                                              break;
    case 49:  dmxAnim_movingHead_setLightRhythm_sideDev_random_16thSync();                                              break;
    case 50:  dmxAnim_movingHead_setLightRhythm_sideDev_random_8thSync();                                               break;
    case 51:  dmxAnim_movingHead_setLightRhythm_sideDev_random_4thSync();                                               break;
    case 52:  dmxAnim_movingHead_setLightRhythm_sideDev_random_2ndSync();                                               break;
    case 53:  dmxAnim_movingHead_setLightRhythm_sideDev_random_barSync();                                               break;

    case 54:  dmxAnim_movingHead_setLightRhythm_leftDev_together_32ndSync();                                            break;
    case 55:  dmxAnim_movingHead_setLightRhythm_leftDev_together_16thSync();                                            break;
    case 56:  dmxAnim_movingHead_setLightRhythm_leftDev_together_8thSync();                                             break;
    case 57:  dmxAnim_movingHead_setLightRhythm_leftDev_together_4thSync();                                             break;
    case 58:  dmxAnim_movingHead_setLightRhythm_leftDev_together_2ndSync();                                             break;
    case 59:  dmxAnim_movingHead_setLightRhythm_leftDev_together_barSync();                                             break;    
 
    case 60:  dmxAnim_movingHead_setLightRhythm_leftDev_random_32ndSync();                                              break;
    case 61:  dmxAnim_movingHead_setLightRhythm_leftDev_random_16thSync();                                              break;
    case 62:  dmxAnim_movingHead_setLightRhythm_leftDev_random_8thSync();                                               break;
    case 63:  dmxAnim_movingHead_setLightRhythm_leftDev_random_4thSync();                                               break;
    case 64:  dmxAnim_movingHead_setLightRhythm_leftDev_random_2ndSync();                                               break;
    case 65:  dmxAnim_movingHead_setLightRhythm_leftDev_random_barSync();                                               break;

    case 66:  dmxAnim_movingHead_setLightRhythm_rightDev_together_32ndSync();                                           break;
    case 67:  dmxAnim_movingHead_setLightRhythm_rightDev_together_16thSync();                                           break;
    case 68:  dmxAnim_movingHead_setLightRhythm_rightDev_together_8thSync();                                            break;
    case 69:  dmxAnim_movingHead_setLightRhythm_rightDev_together_4thSync();                                            break;
    case 70:  dmxAnim_movingHead_setLightRhythm_rightDev_together_2ndSync();                                            break;
    case 71:  dmxAnim_movingHead_setLightRhythm_rightDev_together_barSync();                                            break;

    case 72:  dmxAnim_movingHead_setLightRhythm_rightDev_random_32ndSync();                                             break;
    case 73:  dmxAnim_movingHead_setLightRhythm_rightDev_random_16thSync();                                             break;
    case 74:  dmxAnim_movingHead_setLightRhythm_rightDev_random_8thSync();                                              break;
    case 75:  dmxAnim_movingHead_setLightRhythm_rightDev_random_4thSync();                                              break;
    case 76:  dmxAnim_movingHead_setLightRhythm_rightDev_random_2ndSync();                                              break;
    case 77:  dmxAnim_movingHead_setLightRhythm_rightDev_random_barSync();                                              break;
    default: break;
  }  
}

public void setupDMXAnimation_movingHead_setLightStyle() {
  switch(dmxAnimationNumber_movingHead_setLightStyle) {
    case 1:  dmxAnim_movingHead_setLightStyle_allDev_continuousLight();                                                 break;
    case 2:  dmxAnim_movingHead_setLightStyle_allDev_slowCrescendoLight();                                              break;
    case 3:  dmxAnim_movingHead_setLightStyle_allDev_fastCrescendoLight();                                              break;
    case 4:  dmxAnim_movingHead_setLightStyle_allDev_singleShortFlash();                                                break;
    case 5:  dmxAnim_movingHead_setLightStyle_allDev_singleLongFlash();                                                 break;
    case 6:  dmxAnim_movingHead_setLightStyle_allDev_slowStrobe();                                                      break;
    case 7:  dmxAnim_movingHead_setLightStyle_allDev_mediumStrobe();                                                    break;
    case 8:  dmxAnim_movingHead_setLightStyle_allDev_fastStrobe();                                                      break;
    case 9:  dmxAnim_movingHead_setLightStyle_allDev_slowClockwiseSineWave();                                           break;
    case 10: dmxAnim_movingHead_setLightStyle_allDev_fastClockwiseSineWave();                                           break;
    case 11: dmxAnim_movingHead_setLightStyle_allDev_slowAntiClockwiseSineWave();                                       break;
    case 12: dmxAnim_movingHead_setLightStyle_allDev_fastAntiClockwiseSineWave();                                       break;
    case 13: dmxAnim_movingHead_setLightStyle_allDev_randomGlitch();                                                    break;
    case 14: dmxAnim_movingHead_setLightStyle_allDev_minimalApertureBeam();                                             break;

    case 15: dmxAnim_movingHead_setLightStyle_centerDev_continuousLight();                                              break;
    case 16: dmxAnim_movingHead_setLightStyle_centerDev_slowCrescendoLight();                                           break;
    case 17: dmxAnim_movingHead_setLightStyle_centerDev_fastCrescendoLight();                                           break;
    case 18: dmxAnim_movingHead_setLightStyle_centerDev_singleShortFlash();                                             break;
    case 19: dmxAnim_movingHead_setLightStyle_centerDev_singleLongFlash();                                              break;
    case 20: dmxAnim_movingHead_setLightStyle_centerDev_slowStrobe();                                                   break;
    case 21: dmxAnim_movingHead_setLightStyle_centerDev_mediumStrobe();                                                 break;
    case 22: dmxAnim_movingHead_setLightStyle_centerDev_fastStrobe();                                                   break;
    case 23: dmxAnim_movingHead_setLightStyle_centerDev_slowClockwiseSineWave();                                        break;
    case 24: dmxAnim_movingHead_setLightStyle_centerDev_fastClockwiseSineWave();                                        break;
    case 25: dmxAnim_movingHead_setLightStyle_centerDev_slowAntiClockwiseSineWave();                                    break;
    case 26: dmxAnim_movingHead_setLightStyle_centerDev_fastAntiClockwiseSineWave();                                    break;
    case 27: dmxAnim_movingHead_setLightStyle_centerDev_randomGlitch();                                                 break;
    case 28: dmxAnim_movingHead_setLightStyle_centerDev_minimalApertureBeam();                                          break;

    case 29: dmxAnim_movingHead_setLightStyle_sideDev_continuousLight();                                                break;
    case 30: dmxAnim_movingHead_setLightStyle_sideDev_slowCrescendoLight();                                             break;
    case 31: dmxAnim_movingHead_setLightStyle_sideDev_fastCrescendoLight();                                             break;
    case 32: dmxAnim_movingHead_setLightStyle_sideDev_singleShortFlash();                                               break;
    case 33: dmxAnim_movingHead_setLightStyle_sideDev_singleLongFlash();                                                break;
    case 34: dmxAnim_movingHead_setLightStyle_sideDev_slowStrobe();                                                     break;
    case 35: dmxAnim_movingHead_setLightStyle_sideDev_mediumStrobe();                                                   break;
    case 36: dmxAnim_movingHead_setLightStyle_sideDev_fastStrobe();                                                     break;
    case 37: dmxAnim_movingHead_setLightStyle_sideDev_slowClockwiseSineWave();                                          break;
    case 38: dmxAnim_movingHead_setLightStyle_sideDev_fastClockwiseSineWave();                                          break;
    case 39: dmxAnim_movingHead_setLightStyle_sideDev_slowAntiClockwiseSineWave();                                      break;
    case 40: dmxAnim_movingHead_setLightStyle_sideDev_fastAntiClockwiseSineWave();                                      break;
    case 41: dmxAnim_movingHead_setLightStyle_sideDev_randomGlitch();                                                   break;
    case 42: dmxAnim_movingHead_setLightStyle_sideDev_minimalApertureBeam();                                            break;
    
    case 43: dmxAnim_movingHead_setLightStyle_leftDev_continuousLight();                                                break;
    case 44: dmxAnim_movingHead_setLightStyle_leftDev_slowCrescendoLight();                                             break;
    case 45: dmxAnim_movingHead_setLightStyle_leftDev_fastCrescendoLight();                                             break;
    case 46: dmxAnim_movingHead_setLightStyle_leftDev_singleShortFlash();                                               break;
    case 47: dmxAnim_movingHead_setLightStyle_leftDev_singleLongFlash();                                                break;
    case 48: dmxAnim_movingHead_setLightStyle_leftDev_slowStrobe();                                                     break;
    case 49: dmxAnim_movingHead_setLightStyle_leftDev_mediumStrobe();                                                   break;
    case 50: dmxAnim_movingHead_setLightStyle_leftDev_fastStrobe();                                                     break;
    case 51: dmxAnim_movingHead_setLightStyle_leftDev_slowClockwiseSineWave();                                          break;
    case 52: dmxAnim_movingHead_setLightStyle_leftDev_fastClockwiseSineWave();                                          break;
    case 53: dmxAnim_movingHead_setLightStyle_leftDev_slowAntiClockwiseSineWave();                                      break;
    case 54: dmxAnim_movingHead_setLightStyle_leftDev_fastAntiClockwiseSineWave();                                      break;
    case 55: dmxAnim_movingHead_setLightStyle_leftDev_randomGlitch();                                                   break;
    case 56: dmxAnim_movingHead_setLightStyle_leftDev_minimalApertureBeam();                                            break;
    
    case 57: dmxAnim_movingHead_setLightStyle_rightDev_continuousLight();                                               break;
    case 58: dmxAnim_movingHead_setLightStyle_rightDev_slowCrescendoLight();                                            break;
    case 59: dmxAnim_movingHead_setLightStyle_rightDev_fastCrescendoLight();                                            break;
    case 60: dmxAnim_movingHead_setLightStyle_rightDev_singleShortFlash();                                              break;
    case 61: dmxAnim_movingHead_setLightStyle_rightDev_singleLongFlash();                                               break;
    case 62: dmxAnim_movingHead_setLightStyle_rightDev_slowStrobe();                                                    break;
    case 63: dmxAnim_movingHead_setLightStyle_rightDev_mediumStrobe();                                                  break;
    case 64: dmxAnim_movingHead_setLightStyle_rightDev_fastStrobe();                                                    break;
    case 65: dmxAnim_movingHead_setLightStyle_rightDev_slowClockwiseSineWave();                                         break;
    case 66: dmxAnim_movingHead_setLightStyle_rightDev_fastClockwiseSineWave();                                         break;
    case 67: dmxAnim_movingHead_setLightStyle_rightDev_slowAntiClockwiseSineWave();                                     break;
    case 68: dmxAnim_movingHead_setLightStyle_rightDev_fastAntiClockwiseSineWave();                                     break;
    case 69: dmxAnim_movingHead_setLightStyle_rightDev_randomGlitch();                                                  break;
    case 70: dmxAnim_movingHead_setLightStyle_rightDev_minimalApertureBeam();                                           break;

    default: break;
  }
}

public void playDMXAnimation_movingHead() {

  switch(dmxAnimationNumber_movingHead_setAnimation) {

    case 0:   dmxAnim_movingHead_blackout();                                                                   break;

    // Simple commands for the various possible lightings and colors, without changing the direction of the projector

    case 1:   dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();                                 break;
    case 2:   dmxAnim_movingHead_noMovement_centerDev_performCurrentLightStyle();                              break;
    case 3:   dmxAnim_movingHead_noMovement_sideDev_performCurrentLightStyle();                                break;
    case 4:   dmxAnim_movingHead_noMovement_leftDev_performCurrentLightStyle();                                break;
    case 5:   dmxAnim_movingHead_noMovement_rightDev_performCurrentLightStyle();                               break;

    //////////////////////////////////////////////////////////// 

    case 6:  dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_LowTilt();                                   break;
    case 7:  dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_LowTilt();                                     break;
    case 8:  dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_LowTilt();                                    break;
    case 9:  dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_FrontTilt();                                 break;
    case 10: dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_FrontTilt();                                   break;
    case 11: dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_FrontTilt();                                  break;
    case 12: dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_HighTilt();                                  break;
    case 13: dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_HighTilt();                                    break;
    case 14: dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_HighTilt();                                   break;
    case 15: dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_UprightTilt();                               break;
    case 16: dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_UprightTilt();                                 break;
    case 17: dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_UprightTilt();                                break;
    case 18: dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_BackTilt();                                  break;
    case 19: dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_BackTilt();                                    break;
    case 20: dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_BackTilt();                                   break;
    case 21: dmxAnim_movingHead_lightOn_fastMove_allDev_WideDivergentPan_FrontTilt();                          break;
    case 22: dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicDivergentPan_FrontTilt();                       break;
    case 23: dmxAnim_movingHead_lightOn_fastMove_allDev_WideDivergentPan_HighTilt();                           break;
    case 24: dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicDivergentPan_HighTilt();                        break;
    case 25: dmxAnim_movingHead_lightOn_fastMove_allDev_WideConvergentPan_FrontTilt();                         break;
    case 26: dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicConvergentPan_FrontTilt();                      break;
    case 27: dmxAnim_movingHead_lightOn_fastMove_allDev_WideConvergentPan_HighTilt();                          break;
    case 28: dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicConvergentPan_HighTilt();                       break;
    case 29: dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_WideNegTilt();                     break;
    case 30: dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_NarrowNegTilt();                   break;
    case 31: dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_WidePosTilt();                     break;
    case 32: dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_NarrowPosTilt();                   break;

    ////////////////////////////////////

    case 33: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_LeftToRight();                  break;
    case 34: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_LeftToRight();               break;
    case 35: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_LeftToRight();                  break;
    case 36: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_RightToLeft();                  break;
    case 37: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_RightToLeft();               break;
    case 38: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_RightToLeft();                  break;
    case 39: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_LeftToRight();                      break;
    case 40: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_LeftToRight();                   break;
    case 41: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_LeftToRight();                      break;
    case 42: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_RightToLeft();                      break;
    case 43: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_RightToLeft();                   break;
    case 44: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_RightToLeft();                      break;

    case 45: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Slow_LeftToRight();                    break;
    case 46: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Regular_LeftToRight();                 break;
    case 47: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Fast_LeftToRight();                    break;
    case 48: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Slow_RightToLeft();                    break;
    case 49: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Regular_RightToLeft();                 break;
    case 50: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Fast_RightToLeft();                    break;
    case 51: dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Slow_LeftToRight();                        break;
    case 52: dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Regular_LeftToRight();                     break;
    case 53: dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Fast_LeftToRight();                        break;
    case 54: dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Slow_RightToLeft();                        break;
    case 55: dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Regular_RightToLeft();                     break;
    case 56: dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Fast_RightToLeft();                        break;

    case 57: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Slow_LeftToRight();                    break;
    case 58: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Regular_LeftToRight();                 break;
    case 59: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Fast_LeftToRight();                    break;
    case 60: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Slow_RightToLeft();                    break;
    case 61: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Regular_RightToLeft();                 break;
    case 62: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Fast_RightToLeft();                    break;
    case 63: dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Slow_LeftToRight();                        break;
    case 64: dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Regular_LeftToRight();                     break;
    case 65: dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Fast_LeftToRight();                        break;
    case 66: dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Slow_RightToLeft();                        break;
    case 67: dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Regular_RightToLeft();                     break;
    case 68: dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Fast_RightToLeft();                        break;

    case 69: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_SymmetricalConvergent();        break;
    case 70: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_SymmetricalConvergent();     break;
    case 71: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_SymmetricalConvergent();        break;
    case 72: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_SymmetricalConvergent();            break;
    case 73: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_SymmetricalConvergent();         break;
    case 74: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_SymmetricalConvergent();            break;

    case 75: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_SymmetricalDivergent();         break;
    case 76: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_SymmetricalDivergent();      break;
    case 77: dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_SymmetricalDivergent();         break;
    case 78: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_SymmetricalDivergent();             break;
    case 79: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_SymmetricalDivergent();          break;
    case 80: dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_SymmetricalDivergent();             break;

    ////////////////////////////////////

    case 81: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_VerySlow();                 break;
    case 82: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_Slow();                     break;
    case 83: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_Regular();                  break;
    case 84: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_Fast();                     break;
    case 85: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_VerySlow();                 break;
    case 86: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_Slow();                     break;
    case 87: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_Regular();                  break;
    case 88: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_Fast();                     break;
    case 89: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_VerySlow();         break;
    case 90: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_Slow();             break;
    case 91: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_Regular();          break;
    case 92: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_Fast();             break;
    case 93: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_VerySlow();         break;
    case 94: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_Slow();             break;
    case 95: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_Regular();          break;
    case 96: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_Fast();             break;

    case 97: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_VerySlow();                break;
    case 98: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_Slow();                    break;
    case 99: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_Regular();                 break;
    case 100: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_Fast();                   break;
    case 101: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_VerySlow();               break;
    case 102: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_Slow();                   break;
    case 103: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_Regular();                break;
    case 104: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_Fast();                   break;
    case 105: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_VerySlow();       break;
    case 106: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_Slow();           break;
    case 107: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_Regular();        break;
    case 108: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_Fast();           break;
    case 109: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_VerySlow();       break;
    case 110: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_Slow();           break;
    case 111: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_Regular();        break;
    case 112: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_Fast();           break;

    case 113: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_VerySlow();              break;
    case 114: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_Slow();                  break;
    case 115: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_Regular();               break;
    case 116: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_Fast();                  break;
    case 117: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_VerySlow();              break;
    case 118: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_Slow();                  break;
    case 119: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_Regular();               break;
    case 120: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_Fast();                  break;
    case 121: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_VerySlow();      break;
    case 122: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_Slow();          break;
    case 123: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_Regular();       break;
    case 124: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_Fast();          break;
    case 125: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_VerySlow();      break;
    case 126: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_Slow();          break;
    case 127: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_Regular();       break;
    case 128: dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_Fast();          break;


    case 129: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_weak_slow();                              break;
    case 130: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_weak_regular();                           break;
    case 131: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_weak_fast();                              break;
    case 132: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_regular_slow();                           break;
    case 133: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_regular_regular();                        break;
    case 134: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_regular_fast();                           break;
    case 135: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_strong_slow();                            break;
    case 136: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_strong_regular();                         break;
    case 137: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_strong_fast();                            break;

    case 138: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_verySlow();                   break;
    case 139: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_slow();                       break;
    case 140: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_regular();                    break;
    case 141: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_fast();                       break;



    // case xxx: dmxAnim_movingHead_lightOn_fastMove_centerDev_Symmetric_CenterPan_LowTilt();                      break;
    // case xxx: dmxAnim_movingHead_lightOn_fastMove_centerDev_Symmetric_CenterPan_LowTilt();                      break;



                                                                        
    // case 165: dmxAnim_movingHead_fastMove_allDev_fastStrobe_CenterPan_LowTilt();                                        break;
    // case 166: dmxAnim_movingHead_fastMove_allDev_fastStrobe_LeftPan_LowTilt();                                          break;
    // case 167: dmxAnim_movingHead_fastMove_allDev_fastStrobe_RightPan_LowTilt();                                         break;
    // case 168: dmxAnim_movingHead_fastMove_allDev_fastStrobe_CenterPan_FrontTilt();                                      break;
    // case 169: dmxAnim_movingHead_fastMove_allDev_fastStrobe_LeftPan_FrontTilt();                                        break;
    // case 170: dmxAnim_movingHead_fastMove_allDev_fastStrobe_RightPan_FrontTilt();                                       break;
    // case 171: dmxAnim_movingHead_fastMove_allDev_fastStrobe_CenterPan_HighTilt();                                       break;
    // case 172: dmxAnim_movingHead_fastMove_allDev_fastStrobe_LeftPan_HighTilt();                                         break;
    // case 173: dmxAnim_movingHead_fastMove_allDev_fastStrobe_RightPan_HighTilt();                                        break;
    // case 174: dmxAnim_movingHead_fastMove_allDev_fastStrobe_CenterPan_UprightTilt();                                    break;
    // case 175: dmxAnim_movingHead_fastMove_allDev_fastStrobe_LeftPan_UprightTilt();                                      break;
    // case 176: dmxAnim_movingHead_fastMove_allDev_fastStrobe_RightPan_UprightTilt();                                     break;
    // case 177: dmxAnim_movingHead_fastMove_allDev_fastStrobe_CenterPan_BackTilt();                                       break;
    // case 178: dmxAnim_movingHead_fastMove_allDev_fastStrobe_LeftPan_BackTilt();                                         break;
    // case 179: dmxAnim_movingHead_fastMove_allDev_fastStrobe_RightPan_BackTilt();                                        break;
    // case 180: dmxAnim_movingHead_fastMove_allDev_fastStrobe_WideDivergentPan_FrontTilt();                               break;
    // case 181: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ClassicDivergentPan_FrontTilt();                            break;
    // case 182: dmxAnim_movingHead_fastMove_allDev_fastStrobe_WideDivergentPan_HighTilt();                                break;
    // case 183: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ClassicDivergentPan_HighTilt();                             break;
    // case 184: dmxAnim_movingHead_fastMove_allDev_fastStrobe_WideConvergentPan_FrontTilt();                              break;
    // case 185: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ClassicConvergentPan_FrontTilt();                           break;
    // case 186: dmxAnim_movingHead_fastMove_allDev_fastStrobe_WideConvergentPan_HighTilt();                               break;
    // case 187: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ClassicConvergentPan_HighTilt();                            break;
    // case 189: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ExtremeDivergentPan_WideNegTilt();                          break;
    // case 190: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ExtremeDivergentPan_NarrowNegTilt();                        break;
    // case 191: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ExtremeDivergentPan_WidePosTilt();                          break;
    // case 192: dmxAnim_movingHead_fastMove_allDev_fastStrobe_ExtremeDivergentPan_NarrowPosTilt();                        break;
    

    // // From here on, slightly more complex animations

    // case 193: dmxAnim_movingHead_beatMove_1
    default: break;
  }
}

public void setupDMXAnimation_movingHeadAnimation() {
  switch(dmxAnimationNumber_movingHead_setAnimation) {

    case 33: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 34: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 35: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 36: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 37: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 38: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 39: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 40: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 41: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 42: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 43: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 44: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 45: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 46: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 47: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 48: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 49: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 50: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 51: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 52: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 53: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 54: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 55: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 56: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 57: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 58: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 59: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 60: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 61: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 62: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 63: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 64: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 65: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 66: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 67: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 68: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;

    case 69: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 70: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 71: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 72: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 73: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 74: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 75: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 76: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 77: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 78: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 79: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 80: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_setupReinit_allDevices(); dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;

    case 81: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 82: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 83: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 84: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 85: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 86: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 87: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 88: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 89: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 90: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 91: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 92: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 93: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 94: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 95: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 96: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 97: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 98: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 99: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                    break;
    case 100: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 101: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 102: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 103: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 104: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 105: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 106: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 107: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 108: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 109: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 110: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 111: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 112: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 113: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 114: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 115: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 116: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 117: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 118: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 119: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 120: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 121: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 122: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 123: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 124: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 125: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 126: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 127: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;
    case 128: dmxAnim_movingHead_globalAnimCpt = 0; dmxAnim_movingHead_reinitLightStyleCpt_allDevices();                                                   break;

    case 129: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 130: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 131: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 132: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 133: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 134: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 135: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 136: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;
    case 137: dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup();                   dmxAnim_movingHead_reinitLightStyleCpt_allDevices();       break;

    case 138: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setup();                                                                  break;
    case 139: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setup();                                                                  break;
    case 140: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setup();                                                                  break;
    case 141: dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setup();                                                                  break;

    default:  dmxAnim_movingHead_reinitLightStyleCpt_allDevices(); break;
  }
}


public void playDMXAnimation_par() {
  switch(dmxAnimationNumber_par) {
    default: break;
  }
}

public void setupDMXAnimation_par() {
  switch(dmxAnimationNumber_par) {
    default: break;
  }
}

///////////////////////////////////////////////////////////
// Generic blackout functions for all the different devices

public void dmxAnim_total_blackout() {
  dmxAnim_strobe_blackout();
  dmxAnim_par_blackout();
  dmxAnim_movingHead_blackout();
}

// Stop all strobe fixtures, create a complete blackout
public void dmxAnim_strobe_blackout() {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    stroboscope.stopDMX();
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.stopDMX();
  }
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.stopDMX();
  }
}

public void dmxAnim_par_blackout() {

}

public void dmxAnim_movingHead_blackout() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setDimmer(0);
    movingHead.setSpeed_maxSpeed();
    movingHead.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
  }
}
///////////////////////////////////////////
//   Fixture management - moving heads   //
///////////////////////////////////////////

final String DMX_MOVINGHEAD_DIMMER                           = "DIMMER";
final String DMX_MOVINGHEAD_PAN                              = "PAN";
final String DMX_MOVINGHEAD_TILT                             = "TILT";
final String DMX_MOVINGHEAD_COLOR                            = "COLOR";
final String DMX_MOVINGHEAD_SPEED                            = "SPEED";
final String DMX_MOVINGHEAD_SPEEDMODE                        = "SPEEDMODE";
final String DMX_MOVINGHEAD_SHUTTER                          = "SHUTTER";
final String DMX_MOVINGHEAD_APERTURE                         = "APERTURE";
final String DMX_MOVINGHEAD_GOBO                             = "GOBO";

final int    DMX_MOVINGHEAD_COLORMODE_UNDEFINED              = 0;
final int    DMX_MOVINGHEAD_COLORMODE_WHEEL                  = 1;
final String DMX_MOVINGHEAD_COLORMODE_WHEEL_TEXT             = "WHEEL";
final int    DMX_MOVINGHEAD_COLORMODE_RGB                    = 2;
final String DMX_MOVINGHEAD_COLORMODE_RGB_TEXT               = "RGB";
final int    DMX_MOVINGHEAD_COLORMODE_CMY                    = 3;
final String DMX_MOVINGHEAD_COLORMODE_CMY_TEXT               = "CMY";
final int    DMX_MOVINGHEAD_COLORMODE_RGBW                   = 4;
final String DMX_MOVINGHEAD_COLORMODE_RGBW_TEXT              = "RGBW";

final String DMX_MOVINGHEAD_COLORMODE_RGB_R                  = "R";
final String DMX_MOVINGHEAD_COLORMODE_RGB_G                  = "G";
final String DMX_MOVINGHEAD_COLORMODE_RGB_B                  = "B";
final String DMX_MOVINGHEAD_COLORMODE_RGB_W                  = "W";
final String DMX_MOVINGHEAD_COLORMODE_CMY_C                  = "C";
final String DMX_MOVINGHEAD_COLORMODE_CMY_M                  = "M";
final String DMX_MOVINGHEAD_COLORMODE_CMY_Y                  = "Y";

final String DMX_MOVINGHEAD_COLORWHEEL_WHITE_TEXT            = "WHITE";
final String DMX_MOVINGHEAD_COLORWHEEL_RED_TEXT              = "RED";
final String DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED_TEXT         = "DEEP_RED";
final String DMX_MOVINGHEAD_COLORWHEEL_BLUE_TEXT             = "BLUE";
final String DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE_TEXT        = "DEEP_BLUE";
final String DMX_MOVINGHEAD_COLORWHEEL_YELLOW_TEXT           = "YELLOW";
final String DMX_MOVINGHEAD_COLORWHEEL_GREEN_TEXT            = "GREEN";
final String DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET_TEXT      = "ULTRAVIOLET";
final String DMX_MOVINGHEAD_COLORWHEEL_ORANGE_TEXT           = "ORANGE";
final String DMX_MOVINGHEAD_COLORWHEEL_CTO_TEXT              = "CTO";
final int    DMX_MOVINGHEAD_COLORWHEEL_WHITE                 = 0;
final int    DMX_MOVINGHEAD_COLORWHEEL_RED                   = 1;
final int    DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED              = 2;
final int    DMX_MOVINGHEAD_COLORWHEEL_BLUE                  = 3;
final int    DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE             = 4;
final int    DMX_MOVINGHEAD_COLORWHEEL_YELLOW                = 5;
final int    DMX_MOVINGHEAD_COLORWHEEL_GREEN                 = 6;
final int    DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET           = 7;
final int    DMX_MOVINGHEAD_COLORWHEEL_ORANGE                = 8;
final int    DMX_MOVINGHEAD_COLORWHEEL_CTO                   = 9;

final int    DMX_MOVINGHEAD_SPEEDMODE_DEFAULT                = 0;
final int    DMX_MOVINGHEAD_SPEEDMODE_MAX                    = 1;
final int    DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE            = 2;
final int    DMX_MOVINGHEAD_SPEEDMODE_FIXED                  = 3;
final String DMX_MOVINGHEAD_SPEEDMODE_DEFAULT_TEXT           = "STANDARD";
final String DMX_MOVINGHEAD_SPEEDMODE_MAX_TEXT               = "MAX_SPEED";
final String DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE_TEXT       = "SPEED";

final String DMX_MOVINGHEAD_SHUTTER_OPEN                     = "OPEN";
final String DMX_MOVINGHEAD_SHUTTER_CLOSED                   = "CLOSED";
final String DMX_MOVINGHEAD_SHUTTER_STROBE                   = "STROBE";
final int    DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT              = 0;
final int    DMX_MOVINGHEAD_SHUTTERMODE_STROBE               = 1;

final int    DMX_MOVINGHEAD_APERTUREMODE_DEFAULT             = 0;          // Default Aperture control means no aperture control !
final String DMX_MOVINGHEAD_APERTUREMODE_DEFAULT_TEXT        = "DEFAULT";
final int    DMX_MOVINGHEAD_APERTUREMODE_PROGRESSIVE         = 1;
final String DMX_MOVINGHEAD_APERTUREMODE_PROGRESSIVE_TEXT    = "APERTURE";
final int    DMX_MOVINGHEAD_APERTUREMODE_STEP                = 2;
final String DMX_MOVINGHEAD_APERTUREMODE_STEP_TEXT           = "APERTURE_STEP";  // ChannelSet defined either in an aperture, or a gobo channel. Combined with an int suffix, aperture size (the larger the int, the smaller the aperture)

final int    DMX_MOVINGHEAD_DEFAULT_FALLBACK_VAL             = 0;          // Default value used at initialisation, and in case of error

final int    DMX_MOVINGHEAD_DEFAULT_PAN_TOTALRANGE           = 540;
final int    DMX_MOVINGHEAD_DEFAULT_TILT_TOTALRANGE          = 540;

// Constants used for the animations
final int    DMXANIM_MOVINGHEAD_BLACKOUT                     = 0;
final int    DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT             = 1;
final int    DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH            = 2;
final int    DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH           = 3;
final int    DMXANIM_MOVINGHEAD_SLOW_CRESCENDO               = 4;
final int    DMXANIM_MOVINGHEAD_FAST_CRESCENDO               = 5;
final int    DMXANIM_MOVINGHEAD_SLOW_STROBE                  = 6;
final int    DMXANIM_MOVINGHEAD_MEDIUM_STROBE                = 7;
final int    DMXANIM_MOVINGHEAD_FAST_STROBE                  = 8;
final int    DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE     = 9;
final int    DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE     = 10;
final int    DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE = 11;
final int    DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE = 12;
final int    DMXANIM_MOVINGHEAD_RANDOM_GLITCH                = 13;
final int    DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM            = 14;

// Constants used for the light rhythms
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC                     = 0;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC          = 1;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC          = 2;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC           = 3;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC           = 4;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC           = 5;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC           = 6;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_32NDSYNC         = 7;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_16THSYNC         = 8;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_8THSYNC          = 9;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_4THSYNC          = 10;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_2NDSYNC          = 11;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_BARSYNC          = 12;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_32NDSYNC     = 13;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_16THSYNC     = 14;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_8THSYNC      = 15;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_4THSYNC      = 16;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_2NDSYNC      = 17;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_BARSYNC      = 18;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC            = 19;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC            = 20;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC             = 21;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC             = 22;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC             = 23;
final int    DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC             = 24;



class DMX_MovingHead {

  Fixture movingHead;                                 // The fixture defining this object
  int deviceID;                                       // Device ID: defined at device instanciation, 0 for the fixtures located on house left, n for the fixtures on house right
  int dmxStartAddr;                                   // Address of the first channel
  int syncIdx                              = 0;       // Among the BPM-synced fixtures, define the index

  int nbChannels                           = 0;
  int[] dmxVal;                                       // Array which shall contain all the instant DMX values for all of this fixture's channels

  // Config parameters - depending on these values, the library functions will behave differently
  int chIndex_dimmer                       = -1;
  int chIndex_dimmerFine                   = -1;
  boolean fineDimmerControl                = false;
  int dimmer_minVal                        = -1;
  int dimmer_maxVal                        = -1;

  int chIndex_pan                          = -1;
  int chIndex_panFine                      = -1;
  boolean finePanControl                   = false;
  int pan_minVal                           = -1;
  int pan_maxVal                           = -1;

  int chIndex_tilt                         = -1;
  int chIndex_tiltFine                     = -1;
  boolean fineTiltControl                  = false;
  int tilt_minVal                          = -1;
  int tilt_maxVal                          = -1;
  
  
  IntList available_chIndex_color;
  int colorControlMode                     = DMX_MOVINGHEAD_COLORMODE_UNDEFINED;
  int chIndex_color_WHEEL                  = -1;
  int chIndex_color_CMY_C                  = -1;      // Shall be defined only if used
  int chIndex_color_CMY_M                  = -1;      // Shall be defined only if used
  int chIndex_color_CMY_Y                  = -1;      // Shall be defined only if used
  int chIndex_color_RGB_R                  = -1;      // Shall be defined only if used
  int chIndex_color_RGB_G                  = -1;      // Shall be defined only if used
  int chIndex_color_RGB_B                  = -1;      // Shall be defined only if used
  int chIndex_color_RGB_W                  = -1;      // Shall be defined only if used
    

  int speedMode                            = DMX_MOVINGHEAD_SPEEDMODE_DEFAULT;    
  int chIndex_speedMode                    = -1;
  int chIndex_speedSet                     = -1;   // May be equal to chIndex_speedMode (in most cases)
  int speedMode_standardSpeed_val          = -1;   // Set speedSet channel to this value to shift to the default speed
  int speedMode_maxSpeed_val               = -1;   // Set speedSet channel to this value to shift to the maximum speed
  int speedMode_fine_range_max             = -1;   // Set speedSet channel to a value between the max/min range to set a smooth speed
  int speedMode_fine_range_min             = -1;

  int shutterMode                          = DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT;
  int chIndex_shutter                      = -1;
  int shutter_open                         = -1;
  int shutter_closed                       = -1;
  int shutter_strobe_minSpeed              = -1;
  int shutter_strobe_maxSpeed              = -1;

  int apertureMode                         = DMX_MOVINGHEAD_APERTUREMODE_DEFAULT;
  int chIndex_aperture                     = -1;
  int aperture_defaultVal                  = -1;
  int aperture_progressive_max             = -1;   // Large aperture / wide beam
  int aperture_progressive_min             = -1;   // Small aperture / narrow beam
  ArrayList<int[]> aperture_steps;                 // List of the different aperture settings. Arranged from large to narrow - last values correspond to a narrow beam 
  

  // Constants corresponding to specific values
  int dmxVal_color_colorWheel_white        = -1;
  int dmxVal_color_colorWheel_red          = -1;
  int dmxVal_color_colorWheel_deepRed      = -1;
  int dmxVal_color_colorWheel_blue         = -1;
  int dmxVal_color_colorWheel_deepBlue     = -1;
  int dmxVal_color_colorWheel_yellow       = -1;
  int dmxVal_color_colorWheel_green        = -1;
  int dmxVal_color_colorWheel_ultraviolet  = -1;
  int dmxVal_color_colorWheel_orange       = -1;
  int dmxVal_color_colorWheel_cto          = -1;

  int dmxVal_pan_totalRange_degrees        = -1;   // Most moving heads have a 540\u00b0 pan range - center val is half of this
  float dmxVal_specificVal_pan_center_perCent;
  float dmxVal_specificVal_pan_left_perCent;
  float dmxVal_specificVal_pan_right_perCent;
  int dmxVal_tilt_totalRange_degrees       = -1;   // Most moving heads have a 270\u00b0 tilt range
  float dmxVal_specificVal_tilt_low_perCent;
  float dmxVal_specificVal_tilt_front_perCent;
  float dmxVal_specificVal_tilt_high_perCent;
  float dmxVal_specificVal_tilt_upright_perCent;
  float dmxVal_specificVal_tilt_back_perCent;

  //// - End of the physical moving head description - ////

  int currentLightStyle                   = DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT;         // Used by the global animations
  int currentRhythmPattern                = DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC;       // Used by the global animations
  int animCpt1_performLight               = 0;                                // Counters used for the global animations
  int animCpt2                            = 0;
  int animCpt3                            = 0;
  int animCpt4                            = 0;
  int animCpt5                            = 0;


  
  //Additional variables which might be used by other non-DMX related functions (most notably, the simulator)
  int[] simulator_colorRGB;


  // Fixtures are instanciated using their name: the constructor will then look up in the fixture library if such a device exists, and throw an exception if not
  DMX_MovingHead(String name, int deviceID, int startAddr) throws UndefinedFixtureException {

    this.deviceID = deviceID;
    this.dmxStartAddr = startAddr;

    // Init
    movingHead = getFixtureFromName(name);
    if (movingHead.isValidFixture() == false) {
      throw new UndefinedFixtureException("Undefined fixture: " + name);
    }

    nbChannels       = movingHead.getNbChannels();
    dmxVal           = new int[nbChannels];
    for (int i=0; i<nbChannels; i++) {
      dmxVal[i] = DMX_MOVINGHEAD_DEFAULT_FALLBACK_VAL;
    }

    boolean fixtureCanBeCreated = checkDmxAddressMapping(dmxStartAddr, nbChannels);
    if (fixtureCanBeCreated == false) {
      outputLog.println("Moving Head DMX instanciation failure - check the mapping for device ID " + this.deviceID + " (start address=" + startAddr + ", number of channels=" + nbChannels);
    }

    // Now parse individual functions

    parseFixtureDimmerControl();
    
    parseFixturePanControl();

    parseFixtureTiltControl();

    // If more than one color mode is available, the priority goes to the color wheel. If not, use what's possible
    parseFixtureColorModes();
    colorControlMode = defineColorMode();

    parseFixtureSpeedModes();
    speedMode = defineSpeedMode();

    parseFixtureShutterModes();

    parseFixtureApertureModes();

    // Check other functions this fixture may have - search for all channels with a recommended channel set - this will become the default value for these channels
    parseDefaultChannels();

    setMainChannelsDefaultValues();
    setMiscVariablesDefaultValues();
  }

  public int getDeviceID() {
    return this.deviceID;
  }

  public void setSyncIdx(int idx) {
    this.syncIdx = idx;
  }

  // Set the default values for the main channels
  public void setMainChannelsDefaultValues() {
    dmxVal[chIndex_pan]  = 127;
    dmxVal[chIndex_tilt] = 127;
    if (chIndex_panFine != -1) {
      dmxVal[chIndex_panFine]  = 127;
    }
    if (chIndex_tiltFine != -1) {
      dmxVal[chIndex_tiltFine]  = 127;
    }
  }

  // Set the default values for non-dmx related variables
  public void setMiscVariablesDefaultValues() {
    simulator_colorRGB = new int[3];
    simulator_colorRGB[0] = 255;   // White
    simulator_colorRGB[1] = 255;   // White
    simulator_colorRGB[2] = 255;   // White
  }

  public void parseFixtureDimmerControl() {
    chIndex_dimmer   = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_DIMMER);
    if (movingHead.getLinkedChannelIndexCorrespondingToIndex(chIndex_dimmer) != -1) {
      fineDimmerControl = true;
      chIndex_dimmerFine = movingHead.getLinkedChannelIndexCorrespondingToIndex(chIndex_dimmer);
    }

    ChannelDesc channel = movingHead.getChannelCorrespondingToIndex(chIndex_dimmer);
    ArrayList<ChannelSet> channelSets = channel.getAllChannelSets();
    for (ChannelSet channelSet: channelSets) {
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_DIMMER)) {
        if (channelSet.isProportional_Increasing()) {  // The dimmer is always proportional - only need to check if it's increasing or decreasing
          dimmer_minVal = channelSet.getFrom_dmx();
          dimmer_maxVal = channelSet.getTo_dmx();
        }
        else if (channelSet.isProportional() && (channelSet.isProportional_Increasing() == false)) {
          dimmer_minVal = channelSet.getTo_dmx();
          dimmer_maxVal = channelSet.getFrom_dmx();
        }
        else {    // Default : increasing proportional - the user may have forgotten to mark the channel set as proportional
          dimmer_minVal = channelSet.getFrom_dmx();
          dimmer_maxVal = channelSet.getTo_dmx();
        }
      }
    }
  }

  public void parseFixturePanControl() {
    chIndex_pan      = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_PAN);
    if (movingHead.getLinkedChannelIndexCorrespondingToIndex(chIndex_pan) != -1) {
      finePanControl = true;
      chIndex_panFine = movingHead.getLinkedChannelIndexCorrespondingToIndex(chIndex_pan);
    }

    ChannelDesc channel = movingHead.getChannelCorrespondingToIndex(chIndex_pan);
    ArrayList<ChannelSet> channelSets = channel.getAllChannelSets();
    for (ChannelSet channelSet: channelSets) {
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_PAN)) {
        if (channelSet.isProportional_Increasing()) {  // The pan is always proportional - only need to check if it's increasing or decreasing
          pan_minVal = channelSet.getFrom_dmx();
          pan_maxVal = channelSet.getTo_dmx();
        }
        else if (channelSet.isProportional() && (channelSet.isProportional_Increasing() == false)) {
          pan_minVal = channelSet.getTo_dmx();
          pan_maxVal = channelSet.getFrom_dmx();
        }
        else {    // Default : increasing proportional - the user may have forgotten to mark the channel set as proportional
          pan_minVal = channelSet.getFrom_dmx();
          pan_maxVal = channelSet.getTo_dmx();
        }

        //Get the range of this moving head's pan: how many degrees for a 0-100% change
        dmxVal_pan_totalRange_degrees = channelSet.getChannelRange();
      }
    }
    
    if (dmxVal_pan_totalRange_degrees == -1) {
      dmxVal_pan_totalRange_degrees = DMX_MOVINGHEAD_DEFAULT_PAN_TOTALRANGE;   //Default value for the range - consider it to be equal to 540\u00b0
    }
    dmxVal_specificVal_pan_left_perCent   = 100 * (dmxVal_pan_totalRange_degrees/2.0f - 90) / dmxVal_pan_totalRange_degrees;
    dmxVal_specificVal_pan_right_perCent  = 100 * (dmxVal_pan_totalRange_degrees/2.0f + 90) / dmxVal_pan_totalRange_degrees;
    dmxVal_specificVal_pan_center_perCent = 100 * (dmxVal_pan_totalRange_degrees/2.0f + 0)  / dmxVal_pan_totalRange_degrees;
  }

  public void parseFixtureTiltControl() {
    chIndex_tilt     = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_TILT);
    if (movingHead.getLinkedChannelIndexCorrespondingToIndex(chIndex_tilt) != -1) {
      fineTiltControl = true;
      chIndex_tiltFine = movingHead.getLinkedChannelIndexCorrespondingToIndex(chIndex_tilt);
    }

    ChannelDesc channel = movingHead.getChannelCorrespondingToIndex(chIndex_tilt);
    ArrayList<ChannelSet> channelSets = channel.getAllChannelSets();
    for (ChannelSet channelSet: channelSets) {
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_TILT)) {
        if (channelSet.isProportional_Increasing()) {  // The tilt is always proportional - only need to check if it's increasing or decreasing
          pan_minVal = channelSet.getFrom_dmx();
          pan_maxVal = channelSet.getTo_dmx();
        }
        else if (channelSet.isProportional() && (channelSet.isProportional_Increasing() == false)) {
          pan_minVal = channelSet.getTo_dmx();
          pan_maxVal = channelSet.getFrom_dmx();
        }
        else {    // Default : increasing proportional - the user may have forgotten to mark the channel set as proportional
          pan_minVal = channelSet.getFrom_dmx();
          pan_maxVal = channelSet.getTo_dmx();
        }
      }

      //Get the range of this moving head's tilt: how many degrees for a 0-100% change
      dmxVal_tilt_totalRange_degrees = channelSet.getChannelRange();
    }
    
    if (dmxVal_tilt_totalRange_degrees == -1) {
      dmxVal_tilt_totalRange_degrees = DMX_MOVINGHEAD_DEFAULT_PAN_TOTALRANGE;   //Default value for the range - consider it to be equal to 540\u00b0
    }
    dmxVal_specificVal_tilt_low_perCent     = 100 * (dmxVal_tilt_totalRange_degrees/2.0f - 135) / dmxVal_tilt_totalRange_degrees;
    dmxVal_specificVal_tilt_front_perCent   = 100 * (dmxVal_tilt_totalRange_degrees/2.0f - 90)  / dmxVal_tilt_totalRange_degrees;
    dmxVal_specificVal_tilt_high_perCent    = 100 * (dmxVal_tilt_totalRange_degrees/2.0f - 45)  / dmxVal_tilt_totalRange_degrees;
    dmxVal_specificVal_tilt_upright_perCent = 100 * (dmxVal_tilt_totalRange_degrees/2.0f - 0)   / dmxVal_tilt_totalRange_degrees;
    dmxVal_specificVal_tilt_back_perCent    = 100 * (dmxVal_tilt_totalRange_degrees/2.0f + 90)  / dmxVal_tilt_totalRange_degrees;

  }

  public void parseFixtureColorModes() {
    // Define the available color modes
    available_chIndex_color = movingHead.getAllChannelIndexesCorrespondingToFunction(DMX_MOVINGHEAD_COLOR);
    for (int chIndex: available_chIndex_color) {
      ChannelDesc channel = movingHead.getChannelCorrespondingToIndex(chIndex);
      if (channel.getOption().equals(DMX_MOVINGHEAD_COLORMODE_WHEEL_TEXT)) {
        chIndex_color_WHEEL = channel.getIndex();
        parseColorWheelChannel(channel);
      }
      else if (channel.getOption().equals(DMX_MOVINGHEAD_COLORMODE_RGB_TEXT)) {
        if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_R)) {
          chIndex_color_RGB_R = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_G)) {
          chIndex_color_RGB_G = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_B)) {
          chIndex_color_RGB_B = channel.getIndex();
        }
      }
      else if (channel.getOption().equals(DMX_MOVINGHEAD_COLORMODE_CMY_TEXT)) {
        if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_CMY_C)) {
          chIndex_color_CMY_C = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_CMY_M)) {
          chIndex_color_CMY_M = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_CMY_Y)) {
          chIndex_color_CMY_Y = channel.getIndex();
        }
      }
      else if (channel.getOption().equals(DMX_MOVINGHEAD_COLORMODE_RGBW_TEXT)) {
        if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_R)) {
          chIndex_color_RGB_R = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_G)) {
          chIndex_color_RGB_G = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_B)) {
          chIndex_color_RGB_B = channel.getIndex();
        }
        else if (channel.getOptionArgument().equals(DMX_MOVINGHEAD_COLORMODE_RGB_W)) {
          chIndex_color_RGB_W = channel.getIndex();
        }
      }
    }
  }

  public void parseColorWheelChannel(ChannelDesc colorWheelCh) {
    ArrayList<ChannelSet> channelSets = colorWheelCh.getAllChannelSets();
    for (ChannelSet channelSet: channelSets) {
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_WHITE_TEXT)) {
        dmxVal_color_colorWheel_white = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_RED_TEXT)) {
        dmxVal_color_colorWheel_red = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED_TEXT)) {
        dmxVal_color_colorWheel_deepRed = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_BLUE_TEXT)) {
        dmxVal_color_colorWheel_blue = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE_TEXT)) {
        dmxVal_color_colorWheel_deepBlue = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_YELLOW_TEXT)) {
        dmxVal_color_colorWheel_yellow = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_GREEN_TEXT)) {
        dmxVal_color_colorWheel_green = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET_TEXT)) {
        dmxVal_color_colorWheel_ultraviolet = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_ORANGE_TEXT)) {
        dmxVal_color_colorWheel_orange = channelSet.getFrom_dmx();
      }
      else if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_COLORWHEEL_CTO_TEXT)) {
        dmxVal_color_colorWheel_cto = channelSet.getFrom_dmx();
      }
    }
  }

  public int defineColorMode() {
    if (chIndex_color_WHEEL != -1) {
      return DMX_MOVINGHEAD_COLORMODE_WHEEL;
    }
    else if (chIndex_color_RGB_R != -1 && chIndex_color_RGB_G != -1 && chIndex_color_RGB_B != -1 && chIndex_color_RGB_W != -1) {
      return DMX_MOVINGHEAD_COLORMODE_RGBW;
    }
    else if (chIndex_color_RGB_R != -1 && chIndex_color_RGB_G != -1 && chIndex_color_RGB_B != -1) {
      return DMX_MOVINGHEAD_COLORMODE_RGB;
    }
    else if (chIndex_color_CMY_C != -1 && chIndex_color_CMY_M != -1 && chIndex_color_CMY_Y != -1) {
      return DMX_MOVINGHEAD_COLORMODE_CMY;
    }
    else {
      return DMX_MOVINGHEAD_COLORMODE_UNDEFINED;
    }
  }

  public void parseFixtureSpeedModes() {
    // Either there is a special channel dedicated to setting the speed mode, either a single channel does both
    chIndex_speedSet  = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_SPEED);
    if (movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_SPEEDMODE) == -1) {
      chIndex_speedMode = chIndex_speedSet;
    }
    else {
      chIndex_speedMode = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_SPEEDMODE);
    }

    if (chIndex_speedSet == -1) {
      speedMode = DMX_MOVINGHEAD_SPEEDMODE_FIXED;
    }

    // Now parse the Channel sets describing the values which must be sent
    ArrayList<ChannelSet> channelSets = movingHead.getChannelCorrespondingToIndex(chIndex_speedMode).getAllChannelSets();

    for (ChannelSet channelSet: channelSets) {
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_SPEEDMODE_DEFAULT_TEXT)) {   //DMX Value to send to set the default mode
        speedMode_standardSpeed_val = channelSet.getFrom_dmx();
      }
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_SPEEDMODE_MAX_TEXT)) {
        speedMode_maxSpeed_val = channelSet.getFrom_dmx();
      }
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE_TEXT)) {
        if (channelSet.isProportional()) {
          if (channelSet.isProportional_Increasing()) {
            speedMode_fine_range_min = channelSet.getFrom_dmx();
            speedMode_fine_range_max = channelSet.getTo_dmx();
          }
          else {
            speedMode_fine_range_min = channelSet.getTo_dmx();
            speedMode_fine_range_max = channelSet.getFrom_dmx(); 
          }
        }
        else {
          // Shouldn't really matter as the channel is set as "non-proportional". However, it is strange that the progressive mode should be defined as such
          // By default, set these values as proportional-decreasing (ie this channel set describes the time the fixture takes to go from one position to another)
          speedMode_fine_range_min = channelSet.getTo_dmx();
          speedMode_fine_range_max = channelSet.getFrom_dmx();
        }
      }
    }
  }

  public int defineSpeedMode() {
    //The default speed mode should be the max speed mode. If no solution is found, consider the device to be speed-fixed
    if (speedMode_maxSpeed_val != -1) {
      return DMX_MOVINGHEAD_SPEEDMODE_MAX;
    }
    else if (speedMode_standardSpeed_val != -1) {
      return DMX_MOVINGHEAD_SPEEDMODE_DEFAULT;
    }
    else if (speedMode_fine_range_min != -1 && speedMode_fine_range_max != -1) {
      return DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE;
    }
    else {
      return DMX_MOVINGHEAD_SPEEDMODE_FIXED;
    }
  }

  public void parseFixtureShutterModes() {
    chIndex_shutter = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_SHUTTER);
    ArrayList<ChannelSet> channelSets = movingHead.getChannelCorrespondingToIndex(chIndex_shutter).getAllChannelSets();

    for (ChannelSet channelSet: channelSets) {
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_SHUTTER_OPEN)) {
        shutter_open = channelSet.getFrom_dmx();
      }
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_SHUTTER_CLOSED)) { 
        shutter_closed = channelSet.getFrom_dmx();
      }
      if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_SHUTTER_STROBE)) { 
        if (channelSet.isProportional()) {
          if (channelSet.isProportional_Increasing()) {
            shutter_strobe_minSpeed = channelSet.getFrom_dmx();
            shutter_strobe_maxSpeed = channelSet.getTo_dmx();
          }
        }
        else {
          // Shouldn't really matter as the channel is set as "non-proportional". However, it is strange that the progressive mode should be defined as such
          // By default, set these values as proportional-increasing
          shutter_strobe_minSpeed = channelSet.getFrom_dmx();
          shutter_strobe_maxSpeed = channelSet.getTo_dmx();
        }
      }
    }
  }

  // Aperture is a bit particular - this is very device-specific, this function might have to be modified to deal with different implementations
  public void parseFixtureApertureModes() {
    chIndex_aperture = movingHead.getChannelIndexCorrespondingToFunction(DMX_MOVINGHEAD_APERTURE);
    aperture_steps = new ArrayList<int[]>();
    

    if (chIndex_aperture != -1) {
      // A "normal" aperture channel is available
      ArrayList<ChannelSet> channelSets = movingHead.getChannelCorrespondingToIndex(chIndex_aperture).getAllChannelSets();
      for (ChannelSet channelSet: channelSets) {
        if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_APERTUREMODE_DEFAULT_TEXT)) {
          aperture_defaultVal = channelSet.getFrom_dmx();
        }

        if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_APERTUREMODE_PROGRESSIVE_TEXT)) {
          apertureMode = DMX_MOVINGHEAD_APERTUREMODE_PROGRESSIVE;
          if (channelSet.isProportional()) {
            if (channelSet.isProportional_Increasing()) {
              aperture_progressive_min = channelSet.getFrom_dmx();
              aperture_progressive_max = channelSet.getTo_dmx();
            }
          }
          else {
            aperture_progressive_min = channelSet.getTo_dmx();
            aperture_progressive_max = channelSet.getFrom_dmx();            
          }
        }

        if (channelSet.getSubfunction().contains(DMX_MOVINGHEAD_APERTUREMODE_STEP_TEXT)) {
          parseApertureStep(channelSet);
          apertureMode = DMX_MOVINGHEAD_APERTUREMODE_STEP;
        }

      }
    }
    else {
      // Check if an alternative aperture channel is available
      IntList available_gobo_channels = movingHead.getAllChannelIndexesCorrespondingToFunction(DMX_MOVINGHEAD_GOBO);
      for (int index: available_gobo_channels) {
        ChannelDesc channel = movingHead.getChannelCorrespondingToIndex(index);
        ArrayList<ChannelSet> channelSets = channel.getAllChannelSets();
        for (ChannelSet channelSet: channelSets) {
          if (channelSet.getSubfunction().equals(DMX_MOVINGHEAD_APERTUREMODE_DEFAULT_TEXT)) {
            aperture_defaultVal = channelSet.getFrom_dmx();
          }
          else if (channelSet.getSubfunction().contains(DMX_MOVINGHEAD_APERTUREMODE_STEP_TEXT)) {
            chIndex_aperture = channel.getIndex();    // Even though this is not a "real" aperture channel, consider the gobo channel to be the aperture channel
            parseApertureStep(channelSet);
            apertureMode = DMX_MOVINGHEAD_APERTUREMODE_STEP;
          }
        }
      }
    }
    
  }

  public void parseApertureStep(ChannelSet channelSet) {
    int suffix = PApplet.parseInt(channelSet.getSubfunction().split("_")[ channelSet.getSubfunction().split("_").length - 1 ]);
    int min = channelSet.getFrom_dmx();
    int max = channelSet.getTo_dmx();
    int[] dataStruct = new int[3];
    dataStruct[0] = suffix;
    dataStruct[1] = min;
    dataStruct[2] = max;
    
    //TODO: reorder aperture_steps, just in case
    aperture_steps.add(dataStruct);

  }


  public void parseDefaultChannels() {
    ArrayList<ChannelDesc> channelsWithDefaultVal = movingHead.getAllChannelsWithDefaultVal();
    for (ChannelDesc channel: channelsWithDefaultVal) {
      int index = channel.getIndex();
      int val = 0;
      for (ChannelSet channelSet: channel.getAllChannelSets()) {
        if (channelSet.recommended == true) {
          val = channelSet.getFrom_dmx();
          break;
        }
      }
      // Set the requested default value for the corresponding channel index
      dmxVal[index] = val;
    }
  }


  //// BASIC LIB FUNCTIONS
  //////////////////////////////

  //DMX control : use percentage values

  public void setDimmer(float val_percent) {
    if (fineDimmerControl) {
      int val = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, 0, 65535) );
      dmxVal[chIndex_dimmer]     = (val & 0xffff) >> 8;
      dmxVal[chIndex_dimmerFine] = (val & 0xffff) &  0xFF;
    }
    else {
      dmxVal[chIndex_dimmer] = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, dimmer_minVal, dimmer_maxVal) );
    }
  }

  public void setPan(float val_percent) {
    if (finePanControl) {
      int val = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, 0, 65535) );
      dmxVal[chIndex_pan]     = (val & 0xffff) >> 8;
      dmxVal[chIndex_panFine] = (val & 0xffff) &  0xFF;
    }
    else {
      dmxVal[chIndex_pan] = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, pan_minVal, pan_maxVal) );
    }
  }

  public void setTilt(float val_percent) {
    if (fineTiltControl) {
      int val = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, 0, 65535) );
      dmxVal[chIndex_tilt]     = (val & 0xffff) >> 8;
      dmxVal[chIndex_tiltFine] = (val & 0xffff) &  0xFF;
    }
    else {
      dmxVal[chIndex_tilt] = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, tilt_minVal, tilt_maxVal) );
    }
  }

  public void setSpeed(float val_percent) {
    switch (speedMode) {
      case DMX_MOVINGHEAD_SPEEDMODE_DEFAULT:       dmxVal[chIndex_speedSet] = speedMode_standardSpeed_val; break;  //Ignore the input argument: default speed mode
      case DMX_MOVINGHEAD_SPEEDMODE_MAX:           dmxVal[chIndex_speedSet] = speedMode_maxSpeed_val; break;       //Ignore the input argument: max speed mode
      case DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE:   dmxVal[chIndex_speedSet] = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, speedMode_fine_range_min, speedMode_fine_range_max) ); break;
      case DMX_MOVINGHEAD_SPEEDMODE_FIXED:         break;  // Nothing to do, no channel reserved for pan/tilt movement speed
      default: break;
    }
  }

  public void setSpeedMode(int requestedMode) {
    if (requestedMode == DMX_MOVINGHEAD_SPEEDMODE_DEFAULT) {
      if (chIndex_speedSet != -1 && speedMode_standardSpeed_val != -1) {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_DEFAULT;
      }
      else {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_FIXED;
      }
    }
    else if (requestedMode == DMX_MOVINGHEAD_SPEEDMODE_MAX) {
      if (chIndex_speedSet != -1 && speedMode_maxSpeed_val != -1) {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_MAX;
      }
      else if (chIndex_speedSet != -1 && speedMode_standardSpeed_val != -1) {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_DEFAULT;
      }
      else {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_FIXED;
      }
    }
    else if (requestedMode == DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE) {
      if (chIndex_speedSet != -1 && speedMode_fine_range_min != -1 && speedMode_fine_range_max != -1) {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_MAX;
      }
      else if (chIndex_speedSet != -1 && speedMode_standardSpeed_val != -1) {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_DEFAULT;
      }
      else {
        speedMode = DMX_MOVINGHEAD_SPEEDMODE_FIXED;
      }
    }
    else {
      speedMode = DMX_MOVINGHEAD_SPEEDMODE_FIXED;
    }
  }

  public void setSpeed_defaultSpeed() {
    setSpeedMode(DMX_MOVINGHEAD_SPEEDMODE_DEFAULT);
    setSpeed(50.0f);
  }

  public void setSpeed_maxSpeed() {
    setSpeedMode(DMX_MOVINGHEAD_SPEEDMODE_MAX);
    setSpeed(100.0f);
  }

  public void setSpeed_progressiveSpeed(float val) {
    setSpeedMode(DMX_MOVINGHEAD_SPEEDMODE_PROGRESSIVE);
    setSpeed(val);
  }


  public void setShutter(float val_percent) {
    if (chIndex_shutter != -1 && shutter_open != -1 && shutter_closed != -1) {
      if (shutterMode == DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT) {
        if (val_percent < 50.0f) {
          dmxVal[chIndex_shutter] = shutter_open;
        }
        else {
          dmxVal[chIndex_shutter] = shutter_closed;
        }
      }
      else if (shutterMode == DMX_MOVINGHEAD_SHUTTERMODE_STROBE) {
        if (shutter_strobe_maxSpeed != -1 && shutter_strobe_minSpeed != -1) {
          dmxVal[chIndex_shutter] = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, shutter_strobe_minSpeed, shutter_strobe_maxSpeed) );
        }
        else {
          dmxVal[chIndex_shutter] = shutter_open;   // This fuxture does not have a strobe control incorporated to its shutter channel
        }
      }
    }
    else {
      // Do nothing - this fixture does not support shutter control
    }
  }

  public void setShutterMode(int requestedMode) {
    if (requestedMode == DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT) {
      shutterMode = DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT;
    }
    else if (requestedMode == DMX_MOVINGHEAD_SHUTTERMODE_STROBE) {
      if (shutter_strobe_maxSpeed != -1 && shutter_strobe_minSpeed != -1) {
        shutterMode = DMX_MOVINGHEAD_SHUTTERMODE_STROBE;
      }
      else {
        shutterMode = DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT;  // Unsupoorted strobe mode   
      }
    }
  }

  public void setColor(int requestedColor) {
    switch (requestedColor) {
      case DMX_MOVINGHEAD_COLORWHEEL_WHITE      : setColor_white();break;
      case DMX_MOVINGHEAD_COLORWHEEL_RED        : setColor_red();break;
      case DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED   : setColor_deepRed();break;
      case DMX_MOVINGHEAD_COLORWHEEL_BLUE       : setColor_blue();break;
      case DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE  : setColor_deepBlue();break;
      case DMX_MOVINGHEAD_COLORWHEEL_YELLOW     : setColor_yellow();break;
      case DMX_MOVINGHEAD_COLORWHEEL_GREEN      : setColor_green();break;
      case DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET: setColor_ultraviolet();break;
      case DMX_MOVINGHEAD_COLORWHEEL_ORANGE     : setColor_orange();break;
      case DMX_MOVINGHEAD_COLORWHEEL_CTO        : setColor_cto();break;
      default: break;
    }
  }

  public void setColor_genericColor(int colorWheel_code, int[] colorRGB, int[] colorRGBW) {
    int[] colorCMY   = {255 - colorRGB[0], 255 - colorRGB[1], 255 - colorRGB[2]};
    switch (colorControlMode) {
      case DMX_MOVINGHEAD_COLORMODE_WHEEL    : dmxVal[chIndex_color_WHEEL] = colorWheel_code; break; 
      case DMX_MOVINGHEAD_COLORMODE_RGB      : dmxVal[chIndex_color_RGB_R] = colorRGB[0];       dmxVal[chIndex_color_RGB_G] = colorRGB[1];       dmxVal[chIndex_color_RGB_B] = colorRGB[2];       break; 
      case DMX_MOVINGHEAD_COLORMODE_CMY      : dmxVal[chIndex_color_CMY_C] = 255 - colorRGB[0]; dmxVal[chIndex_color_CMY_M] = 255 - colorRGB[1]; dmxVal[chIndex_color_CMY_Y] = 255 - colorRGB[2]; break; 
      case DMX_MOVINGHEAD_COLORMODE_RGBW     : dmxVal[chIndex_color_RGB_R] = colorRGB[0];       dmxVal[chIndex_color_RGB_G] = colorRGB[1];       dmxVal[chIndex_color_RGB_B] = colorRGB[2];       dmxVal[chIndex_color_RGB_W] = colorRGB[3]; break; 
      case DMX_MOVINGHEAD_COLORMODE_UNDEFINED: break; 
      default: break;
    }

    // Save colorRGB in order to have the simulator know which color is currently active easily
    simulator_colorRGB = colorRGB;
  }

  public int getFallbackColorIfInvalidColorVal(int inputColor) {
    if (inputColor == -1) {
      if (dmxVal_color_colorWheel_white != -1) {
        return dmxVal_color_colorWheel_white;
      }
      else {
        return 0;
      }
    }
    else {
      return inputColor;
    }
  }

  public int getFallbackColorIfInvalidColorVal(int inputColor, int fallbackColor) {
    if (inputColor == -1) {
      if (fallbackColor != -1) {
        return fallbackColor;
      }
      else if (dmxVal_color_colorWheel_white != -1) {
        return dmxVal_color_colorWheel_white;
      }
      else {
        return 0;
      }
    }
    else {
      return inputColor;
    }
  }

  public void setColor_white() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_white);
    int[] colorRGB   = {255, 255, 255};
    int[] colorRGBW  = {0,   0,   0, 255};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW);
  }

  public void setColor_red() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_red);
    int[] colorRGB   = {255, 0,   0};
    int[] colorRGBW  = {255, 0,   0,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW); 
  }

  public void setColor_deepRed() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_deepRed, dmxVal_color_colorWheel_red);
    int[] colorRGB   = {139, 0,   0};
    int[] colorRGBW  = {139, 0,   0,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW); 
  }

  public void setColor_blue() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_blue);
    int[] colorRGB   = {0,   0, 255};
    int[] colorRGBW  = {0,   0, 255,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW); 
  }

  public void setColor_deepBlue() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_deepBlue, dmxVal_color_colorWheel_blue);
    int[] colorRGB   = {0,   0, 155};
    int[] colorRGBW  = {0,   0, 155,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW); 
  }

  public void setColor_yellow() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_yellow);
    int[] colorRGB   = {255, 240, 0};
    int[] colorRGBW  = {255, 240, 0,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW);  
  }

  public void setColor_green() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_green);
    int[] colorRGB   = {71, 182, 164};
    int[] colorRGBW  = {71, 182, 164,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW);  
  }

  public void setColor_ultraviolet() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_ultraviolet, dmxVal_color_colorWheel_blue);
    int[] colorRGB   = {62,  6, 148};
    int[] colorRGBW  = {62,  6, 148,   0};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW);  
  }

  public void setColor_orange() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_orange, dmxVal_color_colorWheel_red);
    int[] colorRGB   = {253, 141, 28};
    int[] colorRGBW  = {255,   0,  0, 160};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW);  
  }

  public void setColor_cto() {
    int   colorWheel = getFallbackColorIfInvalidColorVal(dmxVal_color_colorWheel_cto);
    int[] colorRGB   = {255, 241, 224};
    int[] colorRGBW  = {200,   0,  0, 255};
    setColor_genericColor(colorWheel, colorRGB, colorRGBW);  
  }



  public void setApertureReduction(float val_percent) {
    // 100% -> closed aperture. 0% -> open aperture
    // Different implementations available for the aperture:
    // - Iris width (continuous control)
    // - Beam reduction using gobos (step control)
    if (apertureMode == DMX_MOVINGHEAD_APERTUREMODE_DEFAULT) {
      // Do nothing: no aperture control for this device
    }
    else if (apertureMode == DMX_MOVINGHEAD_APERTUREMODE_PROGRESSIVE) {
      if (chIndex_aperture != -1 && aperture_progressive_min != -1 && aperture_progressive_max != -1) {
        dmxVal[chIndex_aperture] = PApplet.parseInt( map(val_percent, 0.0f, 100.0f, aperture_progressive_min, aperture_progressive_max) );
      }
    }
    else if (apertureMode == DMX_MOVINGHEAD_APERTUREMODE_STEP) {
      if (aperture_steps.size() > 0) {
        int step =  PApplet.parseInt( map(val_percent,0,100.0f, 0, aperture_steps.size()));
        dmxVal[chIndex_aperture] = aperture_steps.get(min(step, aperture_steps.size()-1))[1];
      }
    }
  }

  public void setCurrentLightStyle(int style) {
    currentLightStyle = style;
  }

  public void setCurrentRhythmPattern(int rhythm) {
    currentRhythmPattern = rhythm;
    dmxAnim_movingHead_computeNbSyncedFixtures();
  }

  public boolean checkBPMSync() {
    switch(currentRhythmPattern) {
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC:                      return true;
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC:           return checkBPMSync_syncedRhythm(8.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC:           return checkBPMSync_syncedRhythm(4.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC:            return checkBPMSync_syncedRhythm(2.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC:            return checkBPMSync_syncedRhythm(1.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC:            return checkBPMSync_syncedRhythm(0.5f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC:            return checkBPMSync_syncedRhythm(0.25f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_32NDSYNC:          return checkBPMSync_clockwiseRhythm(8.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_16THSYNC:          return checkBPMSync_clockwiseRhythm(4.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_8THSYNC:           return checkBPMSync_clockwiseRhythm(2.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_4THSYNC:           return checkBPMSync_clockwiseRhythm(1.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_2NDSYNC:           return checkBPMSync_clockwiseRhythm(0.5f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_BARSYNC:           return checkBPMSync_clockwiseRhythm(0.25f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_32NDSYNC:      return checkBPMSync_antiClockwiseRhythm(8.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_16THSYNC:      return checkBPMSync_antiClockwiseRhythm(4.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_8THSYNC:       return checkBPMSync_antiClockwiseRhythm(2.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_4THSYNC:       return checkBPMSync_antiClockwiseRhythm(1.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_2NDSYNC:       return checkBPMSync_antiClockwiseRhythm(0.5f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_BARSYNC:       return checkBPMSync_antiClockwiseRhythm(0.25f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC:             return checkBPMSync_randomRhythm(8.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC:             return checkBPMSync_randomRhythm(4.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC:              return checkBPMSync_randomRhythm(2.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC:              return checkBPMSync_randomRhythm(1.0f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC:              return checkBPMSync_randomRhythm(0.5f);
      case DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC:              return checkBPMSync_randomRhythm(0.25f);

      default:                                              return false;
    }
  }

  public boolean checkBPMSync_clockwiseRhythm(float factor) {
    int seqRef = PApplet.parseInt((automaticSequencer.currentPosition*factor % dmxAnim_syncedMovingHeads.size()));
    if (seqRef == this.syncIdx) {
      return true;
    }
    else {
      return false;
    }
  }

  public boolean checkBPMSync_antiClockwiseRhythm(float factor) {
    int seqRef = PApplet.parseInt((automaticSequencer.currentPosition*factor % dmxAnim_syncedMovingHeads.size()));
    seqRef = dmxAnim_syncedMovingHeads.size() - seqRef;
    if (seqRef == this.syncIdx) {
      return true;
    }
    else {
      return false;
    }
  }

  public boolean checkBPMSync_randomRhythm(float factor) {

    //outils: frameCount --- frameRate ?
    //nbDevRhythm
    //int dmxAnim_movingHead_nbRhythmSyncedDev            = 0;
    //int dmxAnim_movingHead_currentSelectionIdx          = 0;
    //automaticSequencer.currentPosition

    // automaticSequencer.currentPosition: x.0 -> 
    // automaticSequencer.currentPosition: x.1 -> 
    // automaticSequencer.currentPosition: x.2 -> 
    // automaticSequencer.currentPosition: x.3 -> 

    // nbTotalDev ### deviceId
    // -> Diviser une mesure en fractions de devices ?
    // Modulo de automaticSequencer.currentPosition + deviceID*factor par nbTotalDev

    // -> random: on peut utiliser un seed particulier ? En se liant a framecount, on peut recuperer une valeur random pareille pour chaque dev

    // noise(frameCount)

    // int candidateIdx = dmxAnim_movingHead_currentSelectionIdx;
    // while (candidateIdx == dmxAnim_movingHead_currentSelectionIdx) {
    //   candidateIdx = int(random(min(dmxAnim_movingHead_nbRhythmSyncedDev,2)));   //At least 2, even when only one fixture is in the group
    // }


    // TBIL
    // DOES NOT WORK YET
    int seqRef = PApplet.parseInt((automaticSequencer.currentPosition*factor % dmxAnim_syncedMovingHeads.size()));
    seqRef = dmxAnim_syncedMovingHeads.size() - seqRef;
    if (seqRef == this.syncIdx) {
      return true;
    }
    else {
      return false;
    }
  }

  public boolean checkBPMSync_syncedRhythm(float factor) {
    // println(this.getDeviceID() + " - " + automaticSequencer.currentPosition + " -- " + ((int)(automaticSequencer.currentPosition * factor * 2.0)) + " // " + ((int)(automaticSequencer.currentPosition * factor * 2.0) % 2 == 0));
    if ((int)(automaticSequencer.currentPosition * factor * 2.0f) % 2 == 0) {
      return true;
    }
    else {
      return false;
    }
  }

  public void reinitAnimVars() {
    this.animCpt1_performLight = 0;
    this.animCpt2 = 0;
    this.animCpt3 = 0;
  }


  public void reinitLightStyleCpt() {
    this.animCpt1_performLight = 0;
  }

  ////////////////////////////////////////////////////////////////////////////////
  // MOVING HEAD VARIABLES ACCESSORS
  //////////////////////


  public int[] getSimulatorColor() {
    return simulator_colorRGB;
  }

  public int getSimulatorDimmer() {
    return PApplet.parseInt( map(dmxVal[chIndex_dimmer], dimmer_minVal, dimmer_maxVal, 0.0f, 255.0f) );
  }

  public int getSimulatorTilt() {
    return dmxVal[chIndex_tilt];
  }

  public float getSimulatorPan() {
    if (chIndex_panFine != -1) {
      return (255.0f*dmxVal[chIndex_pan] + dmxVal[chIndex_panFine]) / 255.0f;
    }
    else {
      return dmxVal[chIndex_pan];
    }
  }

  public int getSimulatorShutterMode() {
    return shutterMode;
  }

  public int getSimulatorShutter() {
    return PApplet.parseInt( map(dmxVal[chIndex_shutter], shutter_strobe_minSpeed, shutter_strobe_maxSpeed, 0.0f, 255.0f) );
  }


  ////////////////////////////////////////////////////////////////////////////////
  // ANIMATION FUNCTIONS
  //////////////////////

  public void performLight_standbyBlackout() {
    performLight_blackout();
    reinitLightStyleCpt();
  }

  public void performLight_currentStyle() {
    boolean performEnabled = this.checkBPMSync();
    if (performEnabled) {
      switch (this.currentLightStyle) {
        case DMXANIM_MOVINGHEAD_BLACKOUT:                       this.performLight_blackout();                  break;
        case DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT:               this.performLight_continuousLight();           break;
        case DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH:              this.performLight_singleLongFlash();           break;
        case DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH:             this.performLight_singleShortFlash();          break;
        case DMXANIM_MOVINGHEAD_SLOW_CRESCENDO:                 this.performLight_slowCrescendo();             break;
        case DMXANIM_MOVINGHEAD_FAST_CRESCENDO:                 this.performLight_fastCrescendo();             break;
        case DMXANIM_MOVINGHEAD_SLOW_STROBE:                    this.performLight_slowStrobe();                break;
        case DMXANIM_MOVINGHEAD_MEDIUM_STROBE:                  this.performLight_mediumStrobe();              break;
        case DMXANIM_MOVINGHEAD_FAST_STROBE:                    this.performLight_fastStrobe();                break;
        case DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE:       this.performLight_slowClockwiseSineWave();     break;
        case DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE:       this.performLight_fastClockwiseSineWave();     break;
        case DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE:   this.performLight_slowAntiClockwiseSineWave(); break;
        case DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE:   this.performLight_fastAntiClockwiseSineWave(); break;
        case DMXANIM_MOVINGHEAD_RANDOM_GLITCH:                  this.performLight_randomGlitch();              break;
        case DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM:              this.performLight_minimalApertureBeam();       break;
        default:                                     break;
      }
    }
    else {
      this.performLight_standbyBlackout();
    }
  }

  public void performLight_blackout() {
    this.setDimmer(0);
  }

  public void performLight_continuousLight() {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(100);
    this.setApertureReduction(0);
  }

  public void performLight_singleLongFlash() {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(max(0,100-this.animCpt1_performLight));
    this.setApertureReduction(0);
    this.animCpt1_performLight += 1;
  }

  public void performLight_singleShortFlash() {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(max(0,100-4*this.animCpt1_performLight));
    this.setApertureReduction(0);
    this.animCpt1_performLight += 1;
  }

  public void performLight_slowCrescendo() {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(min(100,this.animCpt1_performLight));
    this.setApertureReduction(0);
    this.animCpt1_performLight += 1;
  }

  public void performLight_fastCrescendo() {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(min(100,4*this.animCpt1_performLight));
    this.setApertureReduction(0);
    this.animCpt1_performLight += 1;
  }

  public void performLight_strobe(float dimmer_perCent, float strobeSpeed_perCent) {
    this.setShutter(strobeSpeed_perCent);
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_STROBE);
    this.setDimmer(dimmer_perCent);
    this.setApertureReduction(0);
  }

  public void performLight_slowStrobe() {
    performLight_strobe(100, 20);
  }

  public void performLight_mediumStrobe() {
    performLight_strobe(100, 50);
  }

  public void performLight_fastStrobe() {
    performLight_strobe(100, 90);
  }

  public void performLight_sineWave(float speed, boolean clockwise) {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    float offset = this.deviceID * TWO_PI/PApplet.parseFloat(DMXList_MovingHeads.size());
    if (clockwise) {
      this.setDimmer(100 *  (0.5f + 0.5f*sin(offset + animCpt1_performLight * speed)));
    }
    else {
      this.setDimmer(100 *  (0.5f + 0.5f*sin(offset - animCpt1_performLight * speed)));
    }
    this.setApertureReduction(0);
    this.animCpt1_performLight += 1;
  }

  public void performLight_slowClockwiseSineWave() {
    performLight_sineWave(0.125f, true);
  }

  public void performLight_fastClockwiseSineWave() {
    performLight_sineWave(0.250f, true);
  }

  public void performLight_slowAntiClockwiseSineWave() {
    performLight_sineWave(0.125f, false);
  }

  public void performLight_fastAntiClockwiseSineWave() {
    performLight_sineWave(0.250f, false);
  }

  public void performLight_randomGlitch() {
    // Use perlin noise + deviceID as random seed
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(100 * noise(frameCount*0.1f));
    this.setApertureReduction(0);
  }

  public void performLight_minimalApertureBeam() {
    this.setShutterMode(DMX_MOVINGHEAD_SHUTTERMODE_DEFAULT);
    this.setDimmer(100);
    this.setApertureReduction(80);
  }



}

public void dmxAnim_movingHead_setupReinit_allDevices() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.reinitAnimVars();
  }
}

public void dmxAnim_movingHead_reinitLightStyleCpt_allDevices() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.reinitLightStyleCpt();
  }
}

public void dmxAnim_movingHead_computeNbSyncedFixtures() {
  dmxAnim_movingHead_nbRhythmSyncedDev = 0;
  dmxAnim_syncedMovingHeads = new IntList();
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    if (movingHead.currentRhythmPattern != DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC) {
      movingHead.setSyncIdx(dmxAnim_movingHead_nbRhythmSyncedDev);
      dmxAnim_syncedMovingHeads.append(movingHead.getDeviceID());
      dmxAnim_movingHead_nbRhythmSyncedDev += 1;
    }
  }
}

/////////////////////////////////////////////////////////////////////////////////////
// Each individual function is a single animation using the registered DMX devices

// Note :
// These animations can use every Moving Head device and call startDMX with the desired values
// When implementing these animations, be careful to stay modular : everything needs to be scalable, and look good no matter the number of fixtures
// Also, consider "left" to be House Left, and "right" to be House Right


// Basic directions, with the dimmer off

public void dmxAnim_movingHead_prepareDirection_CenterPan_LowTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_low_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_LeftPan_LowTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_low_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_RightPan_LowTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_low_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_CenterPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_LeftPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_RightPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_CenterPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_LeftPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_RightPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_CenterPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_LeftPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_RightPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_CenterPan_BackTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_back_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_LeftPan_BackTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_back_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_RightPan_BackTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_back_perCent);
  }
}


////////////////////////////////////////////////////////////


public void dmxAnim_movingHead_prepareDirection_centerDev_CenterPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_LeftPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_RightPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_CenterPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_LeftPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_RightPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_CenterPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_LeftPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_centerDev_RightPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

////////////////////////////////////////////////////////////


public void dmxAnim_movingHead_prepareDirection_sideDev_CenterPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_LeftPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_RightPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_CenterPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_LeftPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_RightPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_CenterPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_LeftPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_sideDev_RightPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

////////////////////////////////////////////////////////////


public void dmxAnim_movingHead_prepareDirection_leftDev_CenterPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_LeftPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_RightPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_CenterPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_LeftPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_RightPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_CenterPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_LeftPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_leftDev_RightPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

////////////////////////////////////////////////////////////


public void dmxAnim_movingHead_prepareDirection_rightDev_CenterPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_LeftPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_RightPan_FrontTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_CenterPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_LeftPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_RightPan_HighTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_high_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_CenterPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_LeftPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_rightDev_RightPan_UprightTilt() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setSpeed_maxSpeed();
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_right_perCent);
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_upright_perCent);
  }
}

////////////////////////////////////////////////////////////

// openingWidthAngle_perCent: % of the angle between "front" and "full sideways"
// tiltValue_perCent: % of the angle between "max low" and "upright"
public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(float openingWidthAngle_perCent, float tiltValue_perCent) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    float panHalfWidth = map(openingWidthAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_pan_center_perCent, movingHead.dmxVal_specificVal_pan_left_perCent);
    float pan_perCent  = map(movingHead.getDeviceID(), 0, DMXList_MovingHeads.size()-1, panHalfWidth, 100 - panHalfWidth);
    float tilt_perCent = map(tiltValue_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_low_perCent, movingHead.dmxVal_specificVal_tilt_upright_perCent);
    movingHead.setPan(pan_perCent);
    movingHead.setTilt(tilt_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(80, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(60, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(30, 0);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(80, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(60, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(30, 100 - 100*90.0f/135.0f);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(80, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(60, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(30, 100 - 100*45.0f/135.0f);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(80, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(60, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(30, 100);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(float openingWidthAngle_perCent, float tiltValue_perCent) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    float panHalfWidth = map(openingWidthAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_pan_center_perCent, movingHead.dmxVal_specificVal_pan_left_perCent);
    float pan_perCent  = map(movingHead.getDeviceID(), 0, DMXList_MovingHeads.size()-1, 100 - panHalfWidth, panHalfWidth);
    float tilt_perCent = map(tiltValue_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_low_perCent, movingHead.dmxVal_specificVal_tilt_upright_perCent);
    movingHead.setPan(pan_perCent);
    movingHead.setTilt(tilt_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(80, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(60, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(30, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(80, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(60, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(30, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(80, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(60, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(30, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(80, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(60, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(30, 100);
}


////////////////////////////////////////////////////////////

public void dmxAnim_movingHead_prepareDirection_SymmetricalExtremePan_DivergentTilt(float openingTiltAngle_perCent) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();

    float pan_perCent = movingHead.dmxVal_specificVal_pan_center_perCent;
    if (DMXList_MovingHeads.size() % 2 == 0) {
      if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {
        pan_perCent = movingHead.dmxVal_specificVal_pan_left_perCent;
      }
      else {
        pan_perCent = movingHead.dmxVal_specificVal_pan_right_perCent;
      }
    }
    else {
      if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {
        pan_perCent = movingHead.dmxVal_specificVal_pan_left_perCent;
      }
      else if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {
        pan_perCent = movingHead.dmxVal_specificVal_pan_left_perCent;
      }
      else {
        pan_perCent = movingHead.dmxVal_specificVal_pan_center_perCent;
      }
    }
    float minTiltAngle = map(openingTiltAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_upright_perCent, movingHead.dmxVal_specificVal_tilt_front_perCent);
    float tilt_perCent = movingHead.dmxVal_specificVal_tilt_upright_perCent - (movingHead.dmxVal_specificVal_tilt_upright_perCent - minTiltAngle) * abs( movingHead.getDeviceID()-0.5f*(DMXList_MovingHeads.size()-1) ) / (0.5f*(DMXList_MovingHeads.size()-1));

    movingHead.setPan(pan_perCent);
    movingHead.setTilt(tilt_perCent);
  }
}

// openingTiltAngle_perCent corresponds to the angle between the front position (upright + 90\u00b0) and the upright position
public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt(float openingWidthAngle_perCent, float openingTiltAngle_perCent) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    float panHalfWidth   = map(openingWidthAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_pan_center_perCent, movingHead.dmxVal_specificVal_pan_left_perCent);
    float pan_perCent    = map(movingHead.getDeviceID(), 0, DMXList_MovingHeads.size()-1, panHalfWidth, 100 - panHalfWidth);

    float minTiltAngle = map(openingTiltAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_upright_perCent, movingHead.dmxVal_specificVal_tilt_front_perCent);
    float tilt_perCent = movingHead.dmxVal_specificVal_tilt_upright_perCent - (movingHead.dmxVal_specificVal_tilt_upright_perCent - minTiltAngle) * abs( movingHead.getDeviceID()-0.5f*(DMXList_MovingHeads.size()-1) ) / (0.5f*(DMXList_MovingHeads.size()-1));

    movingHead.setPan(pan_perCent);
    movingHead.setTilt(tilt_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_WideNegTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalExtremePan_DivergentTilt(100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_NarrowNegTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalExtremePan_DivergentTilt(60);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_WideNegTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt(100.0f, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_NarrowNegTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt(100.0f, 60);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_WidePosTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalExtremePan_DivergentTilt(-100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_NarrowPosTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalExtremePan_DivergentTilt(-60);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_WidePosTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt(100.0f, -100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_WidePan_NarrowPosTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt(100.0f, -60);
}



public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(float openingWidthAngle_perCent, float tiltValue_perCent) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    float panHalfWidth = map(openingWidthAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_pan_center_perCent, movingHead.dmxVal_specificVal_pan_left_perCent);
    float pan_perCent  = map(movingHead.getDeviceID(), 0, DMXList_MovingHeads.size()-1, panHalfWidth, 100 - panHalfWidth);
    float tilt_perCent = map(tiltValue_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_low_perCent, movingHead.dmxVal_specificVal_tilt_upright_perCent);
    if (movingHead.getDeviceID() % 2 == 0) {
      tilt_perCent = map(tiltValue_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_upright_perCent, movingHead.dmxVal_specificVal_tilt_low_perCent);
    }
    movingHead.setPan(pan_perCent);
    movingHead.setTilt(tilt_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_LowOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(80, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_LowOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(60, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_LowOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(30, 0);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_FrontOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(80, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_FrontOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(60, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_FrontOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(30, 100 - 100*90.0f/135.0f);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_HighOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(80, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_HighOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(60, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_HighOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(30, 100 - 100*45.0f/135.0f);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_UprightOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(80, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_UprightOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(60, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_NarrowPan_UprightOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(30, 100);
}


public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(float openingWidthAngle_perCent, float tiltValue_perCent) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    float panHalfWidth = map(openingWidthAngle_perCent, 0, 100, movingHead.dmxVal_specificVal_pan_center_perCent, movingHead.dmxVal_specificVal_pan_left_perCent);
    float pan_perCent  = map(movingHead.getDeviceID(), 0, DMXList_MovingHeads.size()-1, 100 - panHalfWidth, panHalfWidth);
    float tilt_perCent = map(tiltValue_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_low_perCent, movingHead.dmxVal_specificVal_tilt_upright_perCent);
    if (movingHead.getDeviceID() % 2 == 0) {
      tilt_perCent = map(tiltValue_perCent, 0, 100, movingHead.dmxVal_specificVal_tilt_upright_perCent, movingHead.dmxVal_specificVal_tilt_low_perCent);
    }
    movingHead.setPan(pan_perCent);
    movingHead.setTilt(tilt_perCent);
  }
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_LowOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(80, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_LowOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(60, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_LowOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(30, 0);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_FrontOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(80, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_FrontOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(60, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_FrontOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(30, 100 - 100*90.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_HighOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(80, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_HighOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(60, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_HighOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(30, 100 - 100*45.0f/135.0f);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_UprightOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(80, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_UprightOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(60, 100);
}

public void dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_NarrowPan_UprightOppositeTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_OppositeTilt(30, 100);
}





////////////////////////////////////////////////////////////
// Set the color to use in the more complex animations

public void dmxAnim_movingHead_setColor_allDev(int colorCode) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setColor(colorCode);
  }
}

public void dmxAnim_movingHead_setColor_centerDev(int colorCode) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setColor(colorCode);
  }
}

public void dmxAnim_movingHead_setColor_sideDev(int colorCode) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setColor(colorCode);
  }
}

public void dmxAnim_movingHead_setColor_leftDev(int colorCode) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setColor(colorCode);
  }
}

public void dmxAnim_movingHead_setColor_rightDev(int colorCode) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setColor(colorCode);
  }
}

////////////////////////////////////////////////////////////
// Perform the current light style

public void dmxAnim_movingHead_noMovement_performCurrentLightStyle(ArrayList<DMX_MovingHead> movingHeadList) {
  for (DMX_MovingHead movingHead: movingHeadList) {
    movingHead.performLight_currentStyle();
  }
}

public void dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle() {
  dmxAnim_movingHead_noMovement_performCurrentLightStyle(DMXList_MovingHeads);
}

public void dmxAnim_movingHead_noMovement_centerDev_performCurrentLightStyle() {
  dmxAnim_movingHead_noMovement_performCurrentLightStyle(DMXList_MovingHeads_center);
}

public void dmxAnim_movingHead_noMovement_sideDev_performCurrentLightStyle() {
  dmxAnim_movingHead_noMovement_performCurrentLightStyle(DMXList_MovingHeads_side);
}

public void dmxAnim_movingHead_noMovement_leftDev_performCurrentLightStyle() {
  dmxAnim_movingHead_noMovement_performCurrentLightStyle(DMXList_MovingHeads_left);
}

public void dmxAnim_movingHead_noMovement_rightDev_performCurrentLightStyle() {
  dmxAnim_movingHead_noMovement_performCurrentLightStyle(DMXList_MovingHeads_right);
}

////////////////////////////////////////////////////////////

public void dmxAnim_movingHead_noMovement_allDev_performStandbyBlackout() {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.performLight_blackout();
  }
}

////////////////////////////////////////////////////////////




/////// Set the color for composite animations

// -> All devices :    o o o o o

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_white() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_WHITE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_red() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_deepRed() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_blue() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_deepBlue() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_yellow() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_YELLOW);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_green() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_GREEN);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_ultraviolet() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_orange() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_ORANGE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_allDev_CTO() {
  dmxAnim_movingHead_setColor_allDev(DMX_MOVINGHEAD_COLORWHEEL_CTO);
}

// -> Center devices :   x o o o x

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_white() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_WHITE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_red() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_deepRed() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_blue() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_deepBlue() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_yellow() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_YELLOW);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_green() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_GREEN);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_ultraviolet() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_orange() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_ORANGE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_centerDev_CTO() {
  dmxAnim_movingHead_setColor_centerDev(DMX_MOVINGHEAD_COLORWHEEL_CTO);
}

// -> Side devices :     o x x x o

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_white() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_WHITE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_red() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_deepRed() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_blue() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_deepBlue() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_yellow() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_YELLOW);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_green() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_GREEN);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_ultraviolet() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_orange() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_ORANGE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_sideDev_CTO() {
  dmxAnim_movingHead_setColor_sideDev(DMX_MOVINGHEAD_COLORWHEEL_CTO);
}

// -> Left devices :     o o x x x

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_white() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_WHITE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_red() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_deepRed() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_blue() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_deepBlue() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_yellow() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_YELLOW);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_green() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_GREEN);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_ultraviolet() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_orange() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_ORANGE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_leftDev_CTO() {
  dmxAnim_movingHead_setColor_leftDev(DMX_MOVINGHEAD_COLORWHEEL_CTO);
}

// -> Right devices :    x x x o o

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_white() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_WHITE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_red() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_deepRed() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_RED);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_blue() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_deepBlue() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_DEEP_BLUE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_yellow() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_YELLOW);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_green() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_GREEN);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_ultraviolet() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_ULTRAVIOLET);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_orange() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_ORANGE);
}

public void dmxAnim_movingHead_setColorForCompositeAnimations_rightDev_CTO() {
  dmxAnim_movingHead_setColor_rightDev(DMX_MOVINGHEAD_COLORWHEEL_CTO);
}


// Set the rhythm pattern for the lights


public void dmxAnim_movingHead_setLightRhythm(ArrayList<DMX_MovingHead> devices, int rhythm) {
  for (DMX_MovingHead movingHead: devices) {
    movingHead.setCurrentRhythmPattern(rhythm);
  }
}

public void dmxAnim_movingHead_setLightRhythm_allDev_noSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_noSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_noSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_noSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_noSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_NOSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_clockwise_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_clockwise_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_clockwise_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_clockwise_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_clockwise_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_clockwise_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_CLOCKWISE_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_antiClockwise_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_ANTICLOCKWISE_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_random_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_random_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_random_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_random_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_random_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_random_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_together_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_together_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_together_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_together_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_together_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_allDev_together_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_random_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_random_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_random_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_random_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_random_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_random_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_together_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_together_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_together_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_together_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_together_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_centerDev_together_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_center, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_random_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_random_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_random_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_random_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_random_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_random_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_together_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_together_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_together_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_together_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_together_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_sideDev_together_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_side, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_random_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_random_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_random_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_random_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_random_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_random_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_together_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_together_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_together_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_together_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_together_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_leftDev_together_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_left, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_random_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_random_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_random_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_random_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_random_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_random_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_RANDOM_BARSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_together_32ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_32NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_together_16thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_16THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_together_8thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_8THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_together_4thSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_4THSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_together_2ndSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_2NDSYNC);
}

public void dmxAnim_movingHead_setLightRhythm_rightDev_together_barSync() {
  dmxAnim_movingHead_setLightRhythm(DMXList_MovingHeads_right, DMXANIM_MOVINGHEAD_LIGHTRHYTHM_TOGETHER_BARSYNC);
}



// Set the light style for the animations

public void dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(int style) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setCurrentLightStyle(style);
  }
}

public void dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(int style) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_center) {
    movingHead.setCurrentLightStyle(style);
  }
}

public void dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(int style) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_side) {
    movingHead.setCurrentLightStyle(style);
  }
}

public void dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(int style) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_left) {
    movingHead.setCurrentLightStyle(style);
  }
}

public void dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(int style) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads_right) {
    movingHead.setCurrentLightStyle(style);
  }
}

public void dmxAnim_movingHead_setLightStyle_allDev_continuousLight() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT);
}

public void dmxAnim_movingHead_setLightStyle_allDev_slowCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_allDev_fastCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_allDev_singleShortFlash() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_allDev_singleLongFlash() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_allDev_slowStrobe() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_mediumStrobe() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_MEDIUM_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_fastStrobe() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_slowClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_fastClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_slowAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_fastAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_allDev_randomGlitch() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_RANDOM_GLITCH);
}

public void dmxAnim_movingHead_setLightStyle_allDev_minimalApertureBeam() {
  dmxAnim_movingHead_setLightStyle_allDev_specificLightStyle(DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM); 
}

////

public void dmxAnim_movingHead_setLightStyle_centerDev_continuousLight() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_slowCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_fastCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_singleShortFlash() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_singleLongFlash() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_slowStrobe() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_mediumStrobe() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_MEDIUM_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_fastStrobe() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_slowClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_fastClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_slowAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_fastAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_randomGlitch() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_RANDOM_GLITCH);
}

public void dmxAnim_movingHead_setLightStyle_centerDev_minimalApertureBeam() {
  dmxAnim_movingHead_setLightStyle_centerDev_specificLightStyle(DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM); 
}

////

public void dmxAnim_movingHead_setLightStyle_sideDev_continuousLight() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_slowCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_fastCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_singleShortFlash() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_singleLongFlash() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_slowStrobe() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_mediumStrobe() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_MEDIUM_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_fastStrobe() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_slowClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_fastClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_slowAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_fastAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_randomGlitch() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_RANDOM_GLITCH);
}

public void dmxAnim_movingHead_setLightStyle_sideDev_minimalApertureBeam() {
  dmxAnim_movingHead_setLightStyle_sideDev_specificLightStyle(DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM); 
}


//////

public void dmxAnim_movingHead_setLightStyle_leftDev_continuousLight() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_slowCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_fastCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_singleShortFlash() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_singleLongFlash() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_slowStrobe() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_mediumStrobe() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_MEDIUM_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_fastStrobe() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_slowClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_fastClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_slowAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_fastAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_randomGlitch() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_RANDOM_GLITCH);
}

public void dmxAnim_movingHead_setLightStyle_leftDev_minimalApertureBeam() {
  dmxAnim_movingHead_setLightStyle_leftDev_specificLightStyle(DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM); 
}

//////

public void dmxAnim_movingHead_setLightStyle_rightDev_continuousLight() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_CONTINUOUS_LIGHT);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_slowCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_fastCrescendoLight() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_CRESCENDO);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_singleShortFlash() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_SHORT_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_singleLongFlash() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_SINGLE_LONG_FLASH);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_slowStrobe() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_mediumStrobe() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_MEDIUM_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_fastStrobe() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_STROBE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_slowClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_fastClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_CLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_slowAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_SLOW_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_fastAntiClockwiseSineWave() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_FAST_SINE_WAVE_ANTICLOCKWISE);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_randomGlitch() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_RANDOM_GLITCH);
}

public void dmxAnim_movingHead_setLightStyle_rightDev_minimalApertureBeam() {
  dmxAnim_movingHead_setLightStyle_rightDev_specificLightStyle(DMXANIM_MOVINGHEAD_MIN_APERTURE_BEAM); 
}





// Reach a certain position with the dimmer on, as fast as the device can

public void dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_CenterPan_LowTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_LeftPan_LowTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_LowTilt() {
  dmxAnim_movingHead_prepareDirection_RightPan_LowTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_CenterPan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_LeftPan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_RightPan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_CenterPan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_LeftPan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_RightPan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_CenterPan_UprightTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_LeftPan_UprightTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_UprightTilt() {
  dmxAnim_movingHead_prepareDirection_RightPan_UprightTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_CenterPan_BackTilt() {
  dmxAnim_movingHead_prepareDirection_CenterPan_BackTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_LeftPan_BackTilt() {
  dmxAnim_movingHead_prepareDirection_LeftPan_BackTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_RightPan_BackTilt() {
  dmxAnim_movingHead_prepareDirection_RightPan_BackTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

//////////////////////////////////////////


public void dmxAnim_movingHead_lightOn_fastMove_allDev_WideDivergentPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicDivergentPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_WideDivergentPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_WidePan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicDivergentPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_ClassicPan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_WideConvergentPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicConvergentPan_FrontTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_FrontTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_WideConvergentPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_WidePan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ClassicConvergentPan_HighTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan_ClassicPan_HighTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}


public void dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_WideNegTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_WideNegTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_NarrowNegTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_NarrowNegTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_WidePosTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_WidePosTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}

public void dmxAnim_movingHead_lightOn_fastMove_allDev_ExtremeDivergentPan_NarrowPosTilt() {
  dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_DivergentTilt_ExtremePan_NarrowPosTilt();
  dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
}


////////////////////////////////////////////////////////////////////////

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_LeftToRight() {
  float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.125f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_LeftToRight() {
  float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.25f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_LeftToRight() {
  float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.5f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.125f, false, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.25f, false, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.5f , false, offset, false);
}




public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_LeftToRight() {
  float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.125f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_LeftToRight() {
  float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.25f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_LeftToRight() {
  float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.5f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.125f, false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.25f, false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(0.5f , false, offset, true);
}

// Each moving head has an equal phase difference - the furthest moving heads have a PI phase difference
// The "performCurrentLightStyle" is only called during the first half of the movement: while the head
// goes "back" to the original position, ready to shine again, the light is off. 
// t0  0       PI/3    2*PI/3  PI
// t1  PI/3    2*PI/3  PI      2*PI/3
// t2  2*PI/3  PI      2*PI/3  PI/3
// t3  PI      2*PI/3  PI/3    0
// t4  2*PI/3  PI/3    0       PI/3
// t5  PI/3    0       PI/3    2*PI/3
// t6  0       PI/3    2*PI/3  PI
public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal(float factor, boolean leftToRight, float offset, boolean oneShot) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    // The initial value must calculated so that in the case of a leftToRight movement, the device the furthest to the right is ready to flash (ie. pan=1, panDiff>0)
    float pan     = 0;
    float panDiff = 0;
    if (leftToRight) {
      pan     = 0.5f+0.5f*sin(offset + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      panDiff = cos(offset + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
    }
    else {
      pan     = 0.5f+0.5f*sin(offset + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      panDiff = cos(offset + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
    }

    movingHead.setPan(map(pan,0,1, movingHead.dmxVal_specificVal_pan_left_perCent, movingHead.dmxVal_specificVal_pan_right_perCent));
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
    
    if (leftToRight) {
      if (panDiff > 0) {
        if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
          movingHead.performLight_currentStyle();
          movingHead.animCpt2 = 1;    //Set the "was lit once" flag
        }
        else {
          movingHead.performLight_blackout();
        }
      }
      else {
        movingHead.performLight_blackout();
        if (movingHead.animCpt2 == 1) {
          movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
        }
      }
    }
    else {
      if (panDiff > 0) {
        movingHead.performLight_blackout();
        movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
      }
      else {
        if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
          movingHead.performLight_currentStyle();
          movingHead.animCpt2 = 1;    //Set the "was lit once" flag
        }
        else {
          movingHead.performLight_blackout();
        }
      }
    }
  }
  float stepSize = factor * 2*PI / (frameRate*60.0f/automaticSequencer.currentBPM);
  dmxAnim_movingHead_globalAnimCpt += stepSize;
}

/////////////////////////////////

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Slow_LeftToRight() {
  //float offset = -(PI*(DMXList_MovingHeads.size()-1)/DMXList_MovingHeads.size() + PI/2);
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.125f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Regular_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.25f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Fast_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.5f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Slow_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.125f, false, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Regular_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.25f, false, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical_Fast_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.5f , false, offset, false);
}




public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Slow_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.125f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Regular_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.25f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Fast_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.5f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Slow_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.125f, false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Regular_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.25f, false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Vertical_Fast_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(0.5f , false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Vertical(float factor, boolean leftToRight, float offset, boolean oneShot) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    // The initial value must calculated so that in the case of a leftToRight movement, the device the furthest to the right is ready to flash (ie. pan=1, panDiff>0)
    float tilt     = 0;
    float tiltDiff = 0;
    if (leftToRight) {
      tilt     = 0.5f+0.5f*sin(offset + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      tiltDiff = cos(offset + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
    }
    else {
      tilt     = 0.5f+0.5f*sin(offset + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      tiltDiff = cos(offset + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
    }

    movingHead.setTilt(map(tilt,0,1, movingHead.dmxVal_specificVal_tilt_front_perCent, movingHead.dmxVal_specificVal_tilt_back_perCent));
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_center_perCent);
    
    if (leftToRight) {
      if (tiltDiff > 0) {
        if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
          movingHead.performLight_currentStyle();
          movingHead.animCpt2 = 1;    //Set the "was lit once" flag
        }
        else {
          movingHead.performLight_blackout();
        }
      }
      else {
        movingHead.performLight_blackout();
        if (movingHead.animCpt2 == 1) {
          movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
        }
      }
    }
    else {
      if (tiltDiff > 0) {
        movingHead.performLight_blackout();
        movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
      }
      else {
        if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
          movingHead.performLight_currentStyle();
          movingHead.animCpt2 = 1;    //Set the "was lit once" flag
        }
        else {
          movingHead.performLight_blackout();
        }
      }
    }
  }
  float stepSize = factor * 2*PI / (frameRate*60.0f/automaticSequencer.currentBPM);
  dmxAnim_movingHead_globalAnimCpt += stepSize;
}


///////////////////////////

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Slow_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.125f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Regular_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.25f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Fast_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.5f, true, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Slow_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.125f, false, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Regular_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.25f, false, offset, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular_Fast_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.5f , false, offset, false);
}




public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Slow_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.125f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Regular_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.25f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Fast_LeftToRight() {
  float offset = 0;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.5f, true, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Slow_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.125f, false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Regular_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.25f, false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Circular_Fast_RightToLeft() {
  float offset = PI/2;
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(0.5f , false, offset, true);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Circular(float factor, boolean leftToRight, float offset, boolean oneShot) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    // The initial value must calculated so that in the case of a leftToRight movement, the device the furthest to the right is ready to flash (ie. pan=1, panDiff>0)
    float tilt     = 0;
    float tiltDiff = 0;
    if (leftToRight) {
      tilt     = 0.5f+0.5f*sin(offset + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      tiltDiff = cos(offset + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
    }
    else {
      tilt     = 0.5f+0.5f*sin(offset + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      tiltDiff = cos(offset + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
    }

    movingHead.setTilt(map(tilt,0,1, movingHead.dmxVal_specificVal_tilt_front_perCent, movingHead.dmxVal_specificVal_tilt_back_perCent));
    movingHead.setPan(movingHead.dmxVal_specificVal_pan_left_perCent);
    
    if (leftToRight) {
      if (tiltDiff > 0) {
        if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
          movingHead.performLight_currentStyle();
          movingHead.animCpt2 = 1;    //Set the "was lit once" flag
        }
        else {
          movingHead.performLight_blackout();
        }
      }
      else {
        movingHead.performLight_blackout();
        if (movingHead.animCpt2 == 1) {
          movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
        }
      }
    }
    else {
      if (tiltDiff > 0) {
        movingHead.performLight_blackout();
        movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
      }
      else {
        if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
          movingHead.performLight_currentStyle();
          movingHead.animCpt2 = 1;    //Set the "was lit once" flag
        }
        else {
          movingHead.performLight_blackout();
        }
      }
    }
  }
  float stepSize = factor * 2*PI / (frameRate*60.0f/automaticSequencer.currentBPM);
  dmxAnim_movingHead_globalAnimCpt += stepSize;
}

/////////////////////////////////////


public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_SymmetricalConvergent() {
  float offset1 = -PI/2 - PI*((DMXList_MovingHeads.size()/2 - 1))/DMXList_MovingHeads.size();
  float offset2 = PI/2 + PI*ceil((DMXList_MovingHeads.size()/2))/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.125f, true, offset1, offset2, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_SymmetricalConvergent() {
  float offset1 = -PI/2 - PI*((DMXList_MovingHeads.size()/2 - 1))/DMXList_MovingHeads.size();
  float offset2 = PI/2 + PI*ceil((DMXList_MovingHeads.size()/2))/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.25f, true, offset1, offset2, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_SymmetricalConvergent() {
  float offset1 = -PI/2 - PI*((DMXList_MovingHeads.size()/2 - 1))/DMXList_MovingHeads.size();
  float offset2 = PI/2 + PI*ceil((DMXList_MovingHeads.size()/2))/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.5f, true, offset1, offset2, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Slow_SymmetricalDivergent() {
  float offset1 = PI/2;
  float offset2 = -PI/2 - PI*(DMXList_MovingHeads.size() - 1)/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.125f, false, offset1, offset2, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Regular_SymmetricalDivergent() {
  float offset1 = PI/2;
  float offset2 = -PI/2 - PI*(DMXList_MovingHeads.size() - 1)/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.25f, false, offset1, offset2, false);
}

public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Fast_SymmetricalDivergent() {
  float offset1 = PI/2;
  float offset2 = -PI/2 - PI*(DMXList_MovingHeads.size() - 1)/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.5f, false, offset1, offset2, false);
}


public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_SymmetricalConvergent() {
  float offset1 = -PI/2 - PI*((DMXList_MovingHeads.size()/2 - 1))/DMXList_MovingHeads.size();
  float offset2 = PI/2 + PI*ceil((DMXList_MovingHeads.size()/2))/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.125f, true, offset1, offset2, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_SymmetricalConvergent() {
  float offset1 = -PI/2 - PI*((DMXList_MovingHeads.size()/2 - 1))/DMXList_MovingHeads.size();
  float offset2 = PI/2 + PI*ceil((DMXList_MovingHeads.size()/2))/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.25f, true, offset1, offset2, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_SymmetricalConvergent() {
  float offset1 = -PI/2 - PI*((DMXList_MovingHeads.size()/2 - 1))/DMXList_MovingHeads.size();
  float offset2 = PI/2 + PI*ceil((DMXList_MovingHeads.size()/2))/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.5f, true, offset1, offset2, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Slow_SymmetricalDivergent() {
  float offset1 = PI/2;
  float offset2 = -PI/2 - PI*(DMXList_MovingHeads.size() - 1)/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.125f, false, offset1, offset2, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Regular_SymmetricalDivergent() {
  float offset1 = PI/2;
  float offset2 = -PI/2 - PI*(DMXList_MovingHeads.size() - 1)/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.25f, false, offset1, offset2, true);
}

public void dmxAnim_movingHead_lightOn_allDev_singleSweep_Horizontal_Fast_SymmetricalDivergent() {
  float offset1 = PI/2;
  float offset2 = -PI/2 - PI*(DMXList_MovingHeads.size() - 1)/DMXList_MovingHeads.size();
  dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(0.5f, false, offset1, offset2, true);
}


public void dmxAnim_movingHead_lightOn_allDev_continuousSweep_Horizontal_Symmetrical(float factor, boolean convergent, float offset1, float offset2, boolean oneShot) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setSpeed_maxSpeed();
    // The initial value must calculated so that in the case of a leftToRight movement, the device the furthest to the right is ready to flash (ie. pan=1, panDiff>0)
    float pan     = 0;
    float panDiff = 0;
    if (convergent) {
      if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {
        pan     = 0.5f+0.5f*sin(offset1 + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
        panDiff = cos(offset1 + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      }
      else if (movingHead.getDeviceID() >= ceil((DMXList_MovingHeads.size()/2))) {
        pan     = 0.5f+0.5f*sin(offset2 + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
        panDiff = cos(offset2 + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      }
      else {
        // Center device in the case of an odd number of projectors
        pan     = 0;
        panDiff = 0;
      }
    }
    else {  // Divergent
      if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {
        pan     = 0.5f+0.5f*sin(offset1 + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
        panDiff = cos(offset1 + dmxAnim_movingHead_globalAnimCpt - PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      }
      else if (movingHead.getDeviceID() >= ceil((DMXList_MovingHeads.size()/2))) {
        pan     = 0.5f+0.5f*sin(offset2 + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
        panDiff = cos(offset2 + dmxAnim_movingHead_globalAnimCpt + PI*movingHead.getDeviceID()/DMXList_MovingHeads.size());
      }
      else {
        // Center device in the case of an odd number of projectors
        pan     = 0;
        panDiff = 0;
      }
    }

    movingHead.setPan(map(pan,0,1, movingHead.dmxVal_specificVal_pan_left_perCent, movingHead.dmxVal_specificVal_pan_right_perCent));
    movingHead.setTilt(movingHead.dmxVal_specificVal_tilt_front_perCent);
    
    if (convergent) {
      if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {    // Left devices
        if (panDiff > 0) {
          if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
            movingHead.performLight_currentStyle();
            movingHead.animCpt2 = 1;    //Set the "was lit once" flag
          }
          else {
            movingHead.performLight_blackout();
          }
        }
        else {
          movingHead.performLight_blackout();
          if (movingHead.animCpt2 == 1) {
            movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
          }
        }
      }
      else if (movingHead.getDeviceID() >= ceil((DMXList_MovingHeads.size()/2))) {    // Right devices
        if (panDiff > 0) {
          movingHead.performLight_blackout();
          movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
        }
        else {
          if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
            movingHead.performLight_currentStyle();
            movingHead.animCpt2 = 1;    //Set the "was lit once" flag
          }
          else {
            movingHead.performLight_blackout();
          }
        }
      }
      else {    // Center device in the case of an odd number of projectors
        movingHead.performLight_blackout();
      }
    }


    else {
      
      if (movingHead.getDeviceID() < DMXList_MovingHeads.size()/2) {    // Left devices
        if (panDiff < 0) {
          if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
            movingHead.performLight_currentStyle();
            movingHead.animCpt2 = 1;    //Set the "was lit once" flag
          }
          else {
            movingHead.performLight_blackout();
          }
        }
        else {
          movingHead.performLight_blackout();
          if (movingHead.animCpt2 == 1) {
            movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
          }
        }
      }
      else if (movingHead.getDeviceID() >= ceil((DMXList_MovingHeads.size()/2))) {    // Right devices
        if (panDiff < 0) {
          movingHead.performLight_blackout();
          movingHead.animCpt3 = 1;    //Set the "was turned off once" flag
        }
        else {
          if (oneShot == false || (oneShot == true && !(movingHead.animCpt2 == 1 && movingHead.animCpt3 == 1))) {
            movingHead.performLight_currentStyle();
            movingHead.animCpt2 = 1;    //Set the "was lit once" flag
          }
          else {
            movingHead.performLight_blackout();
          }
        }
      }
      else {    // Center device in the case of an odd number of projectors
        movingHead.performLight_blackout();
      }



    }
  }
  float stepSize = factor * 2*PI / (frameRate*60.0f/automaticSequencer.currentBPM);
  dmxAnim_movingHead_globalAnimCpt += stepSize;
}


/////////////////////////////////////////////

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical() {
 dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(boolean upDown, boolean opposite, int angleWidth, float factor) {
  if (opposite == false) {
    if (upDown) {
      if (angleWidth < 0) {
        dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(-angleWidth, max(100 - dmxAnim_movingHead_globalAnimCpt, 0));
      }
      else {
        dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(angleWidth, max(100 - dmxAnim_movingHead_globalAnimCpt, 0));
      }
      
    }
    else {
      if (angleWidth < 0) {
        dmxAnim_movingHead_prepareDirection_SymmetricalConvergentPan(-angleWidth, min(dmxAnim_movingHead_globalAnimCpt, 100));
      }
      else {
        dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan(angleWidth, min(dmxAnim_movingHead_globalAnimCpt, 100));
      }
    }
  }
  else {
    if (upDown) {
      dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(angleWidth, max(100 - dmxAnim_movingHead_globalAnimCpt, 0));
    }
    else {
      dmxAnim_movingHead_prepareDirection_SymmetricalDivergentPan_OppositeTilt(angleWidth, min(dmxAnim_movingHead_globalAnimCpt, 100));
    }
  }
  
  if (dmxAnim_movingHead_globalAnimCpt < 100) {
    dmxAnim_movingHead_noMovement_allDev_performCurrentLightStyle();
  }
  else {
    dmxAnim_movingHead_noMovement_allDev_performStandbyBlackout();
  }

  float stepSize = factor * 100 / (frameRate*60.0f/automaticSequencer.currentBPM);
  dmxAnim_movingHead_globalAnimCpt += stepSize;
}


public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 0, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 0, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 0, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_UpDown_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 0, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 0, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 0, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 0, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_DownUp_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 0, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 0, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 0, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 0, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeUpDown_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 0, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 0, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 0, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 0, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Parallel_OppositeDownUp_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 0, 1);
}


public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_UpDown_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, 60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_DownUp_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, 60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeUpDown_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, 60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Divergent_OppositeDownUp_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, 60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, -60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, -60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, -60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_UpDown_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, false, -60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, -60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, -60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, -60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_DownUp_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, false, -60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, -60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, -60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, -60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeUpDown_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(true, true, -60, 1);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_VerySlow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, -60, 0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_Slow() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, -60, 0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_Regular() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, -60, 0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical_Convergent_OppositeDownUp_Fast() {
  dmxAnim_movingHead_lightOn_allDev_singleMove_Vertical(false, true, -60, 1);
}




/////////////////////////////////////////////
public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(float speed, float intensity) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    // movingHead.setPan(constrain(movingHead.animCpt2 + intensity*(noise((movingHead.animCpt2+frameCount)*speed) - 0.5), 0, 100));
    // movingHead.setTilt(constrain(movingHead.animCpt3 + intensity*(noise((movingHead.animCpt3+frameCount)*speed) - 0.5), 0, 100));
    movingHead.setPan(constrain(movingHead.animCpt2 + intensity*(noise((frameCount)*speed) - 0.5f), 0, 100));
    movingHead.setTilt(constrain(movingHead.animCpt3 + intensity*(noise((frameCount)*speed) - 0.5f), 0, 100));
    movingHead.performLight_currentStyle();
  }
}


public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_setup() {
  dmxAnim_movingHead_globalAnimCpt = 0;
  noiseDetail(3,0.5f);

  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.animCpt2 = PApplet.parseInt(random(movingHead.dmxVal_specificVal_pan_left_perCent,movingHead.dmxVal_specificVal_pan_right_perCent));
    movingHead.animCpt3 = PApplet.parseInt(random(movingHead.dmxVal_specificVal_tilt_front_perCent,movingHead.dmxVal_specificVal_tilt_upright_perCent));
  }
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_weak_slow() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.05f,15);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_weak_regular() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.1f,15);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_weak_fast() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.2f,15);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_regular_slow() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.05f,30);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_regular_regular() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.1f,30);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_regular_fast() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.2f,30);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_strong_slow() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.05f,50);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_strong_regular() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.1f,50);
}

public void dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection_strong_fast() {
  dmxAnim_movingHead_lightOn_allDev_randomNoiseDirection(0.2f,50);
}


/////////////////////////////////////////////////

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_verySlow() {
  dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync(0.125f);
}

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_slow() {
  dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync(0.25f);
}

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_regular() {
  dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync(0.5f);
}

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_fast() {
  dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync(1);
}

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync(float factor) {
  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    movingHead.setPan(map(dmxAnim_movingHead_globalAnimCpt, 0, 1, movingHead.animCpt2, movingHead.animCpt4));
    movingHead.setTilt(map(dmxAnim_movingHead_globalAnimCpt, 0, 1, movingHead.animCpt3, movingHead.animCpt5));
    movingHead.performLight_currentStyle();
  }
  float stepSize = factor * 1 / (frameRate*60.0f/automaticSequencer.currentBPM);
  dmxAnim_movingHead_globalAnimCpt += stepSize;
  if (dmxAnim_movingHead_globalAnimCpt > 1) {
    dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setup();
  }
}

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setup() {
  dmxAnim_movingHead_globalAnimCpt = 0; 
  dmxAnim_movingHead_reinitLightStyleCpt_allDevices();
  dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setNewObjective();
}

public void dmxAnim_movingHead_lightOn_allDev_randomStraightDirection_beatSync_setNewObjective() {

  for (DMX_MovingHead movingHead: DMXList_MovingHeads) {
    // If coming from another animation, the "old pan/tilt objectives" variables will be invalid (not in the expected range)
    // Set these variables to the current pan
    int oldPanObjective  = 0;
    int oldTiltObjective = 0;
    if (movingHead.animCpt2 < 20 || movingHead.animCpt2 > 80 || movingHead.animCpt3 < 10 || movingHead.animCpt3 > 50) {
      movingHead.animCpt2 = PApplet.parseInt(map(movingHead.dmxVal[movingHead.chIndex_pan],  0, 255, 0, 100));
      movingHead.animCpt3 = PApplet.parseInt(map(movingHead.dmxVal[movingHead.chIndex_tilt], 0, 255, 0, 100));
      oldPanObjective  = movingHead.animCpt2;
      oldTiltObjective = movingHead.animCpt3;
    }
    else {
      oldPanObjective  = movingHead.animCpt4;
      oldTiltObjective = movingHead.animCpt5;
    }

    // Define a new objective for both pan and tilt, within a set range, and different enough from the current angle
    int panCandidate = PApplet.parseInt(random(20,80));
    int tiltCandidate = PApplet.parseInt(random(10,60));
    while (abs(movingHead.animCpt2 - panCandidate) < 20 || abs(movingHead.animCpt3 - tiltCandidate) < 20) {
      panCandidate = PApplet.parseInt(random(20,80));
      tiltCandidate = PApplet.parseInt(random(10,50));
    }
    movingHead.animCpt2 = oldPanObjective;
    movingHead.animCpt3 = oldTiltObjective;
    movingHead.animCpt4 = panCandidate;    // new pan objective
    movingHead.animCpt5 = tiltCandidate;   // new tilt objective
  }
}
//////////////////////////////////////
//   Fixture management - strobes   //
//////////////////////////////////////

// Important note:
// Due to the project's development history, the strobes are dealt with in a particular way
// A possible future evolution could be to harmonize the behaviour of all devices - this shall be done if enough time is available

//The Atomic strobes have a maximum speed which is way too fast compared to the regular ones
//Harmonize the speeds using the two using this factor
final float ATOMICSTROBE_SPEEDFACTOR = 0.37f;


//Specific object for stroboscopes
class DMX_Stroboscope {
  
  int DMXAddress_stroboscopeSpeed;
  int DMXAddress_stroboscopeBrightness;
  int DMXAddress_stroboscopeFlashLength;
  int DMXAddress_stroboscopeSpecialFX;
  int numberOfChannels;
  int currentSpeed           = 0;
  int currentBrightness      = 0;
  int currentFlashLength     = DMXStroboscope_defaultFlashLengthValue;
  int currentSpecialFX       = DMXStroboscope_defaultSpecialFXValue;
  boolean isActive           = false;
  boolean exceptionRaisedDMX = false;
  
  //Classic 2-channel stroboscope (eg. the cheap ones)
  DMX_Stroboscope(int stroboscopeSpeed, int stroboscopeBrightness) {
    this.DMXAddress_stroboscopeSpeed       = stroboscopeSpeed;
    this.DMXAddress_stroboscopeBrightness  = stroboscopeBrightness;
    this.DMXAddress_stroboscopeFlashLength = -1;
    this.DMXAddress_stroboscopeSpecialFX   = -1;
    this.numberOfChannels = 2;
  }
  
  //More complex 4-channel stroboscope (eg. Martin Atomic 3000)
  DMX_Stroboscope(int stroboscopeBrightness, int stroboscopeFlashLength, int stroboscopeSpeed, int stroboscopeSpecialFX ) {
    this.DMXAddress_stroboscopeSpeed       = stroboscopeSpeed;
    this.DMXAddress_stroboscopeBrightness  = stroboscopeBrightness;
    this.DMXAddress_stroboscopeFlashLength = stroboscopeFlashLength;
    this.DMXAddress_stroboscopeSpecialFX   = stroboscopeSpecialFX;
    this.numberOfChannels = 4;
  }
  
  //Used to print the informations regarding this device in the configuration file
  public String printStatus() {
    if (this.numberOfChannels == 2) {
      return "Speed:" + this.DMXAddress_stroboscopeSpeed + "|Brightness:" + this.DMXAddress_stroboscopeBrightness;
    }
    else {
      return "Brightness:" + this.DMXAddress_stroboscopeBrightness + "|FlashLength:" + this.DMXAddress_stroboscopeFlashLength + "|Speed:" + this.DMXAddress_stroboscopeSpeed + "|SpecialFX:" + this.DMXAddress_stroboscopeSpecialFX;
    }
  }
  
  // Set all the device's channels to 0
  public void stopDMX() {
    //Consider that the strobe is not active anymore
    this.isActive = false;
    this.currentSpeed = 10;      //the default speed is a bit particular : setting it to a non-null value allows to easily make single flashes using the Atomic 3000 strobes
    this.currentBrightness = 0;
        
    if (this.exceptionRaisedDMX == false) {
      try {
        if (this.numberOfChannels == 2) {
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpeed,this.currentSpeed);
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeBrightness,this.currentBrightness);
        }
        else if (this.numberOfChannels == 4) {
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpeed,PApplet.parseInt(this.currentSpeed*ATOMICSTROBE_SPEEDFACTOR));
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeBrightness,this.currentBrightness);
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeFlashLength, DMXStroboscope_defaultFlashLengthValue);
          if (this.DMXAddress_stroboscopeSpecialFX != -1) {
            myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpecialFX, DMXStroboscope_defaultSpecialFXValue);
          }
        }
        
      }
      catch (Exception e) {
        outputLog.println("DMX exception : " + e);
        this.exceptionRaisedDMX = true;
      }    
    }
  }
  
  // Specify the individual channels' value, maximum value is 255
  public void startDMX(int stroboscopeSpeed, int stroboscopeBrightness) {
    //Consider that the strobe is active
    this.isActive = true;
    this.currentSpeed       = stroboscopeSpeed;
    this.currentBrightness  = stroboscopeBrightness;
    this.currentFlashLength = DMXStroboscope_defaultFlashLengthValue; 
    this.currentSpecialFX   = DMXStroboscope_defaultSpecialFXValue;
        
    if (this.exceptionRaisedDMX == false) {
      
      try {
        if (this.numberOfChannels == 2) { 
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpeed,this.currentSpeed);
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeBrightness,this.currentBrightness);
        }
        else if (this.numberOfChannels == 4) {
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpeed,PApplet.parseInt(this.currentSpeed*ATOMICSTROBE_SPEEDFACTOR));
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeBrightness,this.currentBrightness);
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeFlashLength,DMXStroboscope_defaultFlashLengthValue);
          if (this.DMXAddress_stroboscopeSpecialFX != -1) {
            myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpecialFX,DMXStroboscope_defaultSpecialFXValue);
          }
        }
      }
      catch (Exception e) {
        outputLog.println("DMX exception : " + e);
        this.exceptionRaisedDMX = true;
      }
    }
  }
  
  //Alternate function, with additional parameters
  //This function is only used by the Atomic 3000 functions, as such the ATOMICSTROBE_SPEEDFACTOR is not used : the rate is not restrained anymore 
  public void startDMX(int stroboscopeSpeed, int stroboscopeBrightness, int stroboscopeFlashLength, int stroboscopeSpecialFX) {
    //Consider that the strobe is active
    this.isActive = true;
    this.currentSpeed       = stroboscopeSpeed;
    this.currentBrightness  = stroboscopeBrightness;
    this.currentFlashLength = stroboscopeFlashLength;
    this.currentSpecialFX   = stroboscopeSpecialFX;

    //Debug
    //println(this.currentSpeed + " - " + this.currentBrightness + " - " + this.currentFlashLength + " - " + this.currentSpecialFX);
      
    if (this.exceptionRaisedDMX == false) {
      try {
        // Additional security : only allow this function for the 4-channel strobes
        if (this.numberOfChannels == 4) {
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpeed,this.currentSpeed);
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeBrightness,this.currentBrightness);
          myDMX.setDmxChannel(this.DMXAddress_stroboscopeFlashLength,this.currentFlashLength);
          if (this.DMXAddress_stroboscopeSpecialFX != -1) {
            myDMX.setDmxChannel(this.DMXAddress_stroboscopeSpecialFX,this.currentSpecialFX);
          }
        }
        else {
          outputLog.println("Internal DMX error : Tried calling a complete startDMX for devices other than the 4-channel strobes"); 
        }
      }
      catch (Exception e) {
        outputLog.println("DMX exception : " + e);
        this.exceptionRaisedDMX = true;
      }
    }
  }
}




/////////////////////////////////////////////////////////////////////////////////////
// Each individual function is a single animation using the registered DMX devices

// Note :
// These animations can use every device registered inside DMXList_FrontLeftStroboscopes, DMXList_FrontRightStroboscopes, etc.
// and call startDMX with the desired values
// When implementing these animations, be careful to stay modular : everything needs to be scalable, and look good whether the front
// left stroboscopes group contains one, or ten devices.

public void dmxAnim_backStrobe_stop() {
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.stopDMX();
  }
}


/////////////////////////////////////////////////////////////////////////////////
// Generic continuous stroboscopes
/////////////////////////////////////////////////////////////////////////////////

// Switch all stroboscopes on
public void dmxAnim_fullStrobe(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*SIDESTROBE_MAX_SPEED),intensity);
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*SIDESTROBE_MAX_SPEED),intensity);
  }
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*BACKSTROBE_MAX_SPEED),intensity);
  }
}

public void dmxAnim_fullStrobeVerySlow() {
  dmxAnim_fullStrobe(80,255);
}

public void dmxAnim_fullStrobeSlow() {
  dmxAnim_fullStrobe(125,255);
}

public void dmxAnim_fullStrobeMedium() {
  dmxAnim_fullStrobe(170,255);
}

public void dmxAnim_fullStrobeFast() {
  dmxAnim_fullStrobe(215,255);
}

public void dmxAnim_fullStrobeVeryFast() {
  dmxAnim_fullStrobe(255,255);
}

// Switch only the left stroboscopes on
public void dmxAnim_leftStrobe(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*SIDESTROBE_MAX_SPEED),intensity);
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.stopDMX();
  }
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.stopDMX();
  }
}

// Switch the left stroboscopes on, but do not touch the other strobes
public void dmxAnim_leftStrobe_noStop(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*SIDESTROBE_MAX_SPEED),intensity);
  }
}

public void dmxAnim_leftStrobeVerySlow() {
  dmxAnim_leftStrobe(80,255);
}

public void dmxAnim_leftStrobeSlow() {
  dmxAnim_leftStrobe(125,255);
}

public void dmxAnim_leftStrobeMedium() {
  dmxAnim_leftStrobe(170,255);
}

public void dmxAnim_leftStrobeFast() {
  dmxAnim_leftStrobe(215,255);
}

public void dmxAnim_leftStrobeVeryFast() {
  dmxAnim_leftStrobe(255,255);
}

// Switch only the right stroboscopes on
public void dmxAnim_rightStrobe(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    stroboscope.stopDMX();
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*SIDESTROBE_MAX_SPEED),intensity);
  }
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.stopDMX();
  }
}

// Switch the right stroboscopes on, but do not touch the other strobes
public void dmxAnim_rightStrobe_noStop(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*SIDESTROBE_MAX_SPEED),intensity);
  }
}

public void dmxAnim_rightStrobeVerySlow() {
  dmxAnim_rightStrobe(80,255);
}

public void dmxAnim_rightStrobeSlow() {
  dmxAnim_rightStrobe(125,255);
}

public void dmxAnim_rightStrobeMedium() {
  dmxAnim_rightStrobe(170,255);
}

public void dmxAnim_rightStrobeFast() {
  dmxAnim_rightStrobe(215,255);
}

public void dmxAnim_rightStrobeVeryFast() {
  dmxAnim_rightStrobe(255,255);
}

// Switch only the back stroboscopes on
public void dmxAnim_backStrobe(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    stroboscope.stopDMX();
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.stopDMX();
  }
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*BACKSTROBE_MAX_SPEED),intensity);
  }
}

// Switch the back stroboscopes on, but do not touch the other strobes
public void dmxAnim_backStrobe_noStop(int speed, int intensity) {
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    stroboscope.startDMX(PApplet.parseInt(speed*BACKSTROBE_MAX_SPEED),intensity);
  }
}

public void dmxAnim_backStrobeVerySlow() {
  dmxAnim_backStrobe(80,255);
}

public void dmxAnim_backStrobeSlow() {
  dmxAnim_backStrobe(125,255);
}

public void dmxAnim_backStrobeMedium() {
  dmxAnim_backStrobe(170,255);
}

public void dmxAnim_backStrobeFast() {
  dmxAnim_backStrobe(215,255);
}

public void dmxAnim_backStrobeVeryFast() {
  dmxAnim_backStrobe(255,255);
}

// Switch both the left and the right sides on

public void dmxAnim_leftRightStrobeVerySlow() {
  dmxAnim_leftStrobe_noStop(80,255);
  dmxAnim_rightStrobe_noStop(80,255);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_leftRightStrobeSlow() {
  dmxAnim_leftStrobe_noStop(125,255);
  dmxAnim_rightStrobe_noStop(125,255);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_leftRightStrobeMedium() {
  dmxAnim_leftStrobe_noStop(170,255);
  dmxAnim_rightStrobe_noStop(170,255);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_leftRightStrobeFast() {
  dmxAnim_leftStrobe_noStop(215,255);
  dmxAnim_rightStrobe_noStop(215,255);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_leftRightStrobeVeryFast() {
  dmxAnim_leftStrobe_noStop(255,255);
  dmxAnim_rightStrobe_noStop(255,255);
  dmxAnim_backStrobe_stop();
}

/////////////////////////////////////////////////////////////////////////////////
// Alternate continuous stroboscopes
/////////////////////////////////////////////////////////////////////////////////

// Switch the side stroboscopes intermittently on and off
public void dmxAnim_alternateStrobe(float factor) {
  if ((int)(automaticSequencer.currentPosition * factor) % 2 == 0) {
    dmxAnim_rightStrobeVeryFast();
  }
  else {
    dmxAnim_leftStrobeVeryFast();
  }
}

public void dmxAnim_alternateStrobe2() {
  dmxAnim_alternateStrobe(0.5f);
}

public void dmxAnim_alternateStrobe4() {
  dmxAnim_alternateStrobe(1.0f);
}

public void dmxAnim_alternateStrobe8() {
  dmxAnim_alternateStrobe(2.0f);
}

public void dmxAnim_alternateStrobe16() {
  dmxAnim_alternateStrobe(4.0f);
}


// Switch all the stroboscopes intermittently on and off, in a left-center-right sequence
public void dmxAnim_rotatingStrobe(float factor) {
  int strobeNb = (int)(automaticSequencer.currentPosition * factor) % 3;
  switch(strobeNb) {
    case 0:  dmxAnim_leftStrobeVeryFast();  break;
    case 1:  dmxAnim_backStrobeVeryFast();  break;
    case 2:  dmxAnim_rightStrobeVeryFast(); break;
    default: break;
  }
}

public void dmxAnim_rotatingStrobe2() {
  dmxAnim_rotatingStrobe(0.5f);
}

public void dmxAnim_rotatingStrobe4() {
  dmxAnim_rotatingStrobe(1.0f);
}

public void dmxAnim_rotatingStrobe8() {
  dmxAnim_rotatingStrobe(2.0f);
}

public void dmxAnim_rotatingStrobe16() {
  dmxAnim_rotatingStrobe(4.0f);
}

/////////////////////////////////////////////////////////////////////////////////
// Growing stroboscopes
/////////////////////////////////////////////////////////////////////////////////

int growingStrobe_speed     = 255;
int growingStrobe_intensity = 0;
int growingStrobe_increment = 3;

public void dmxAnim_growingFullStrobe() {
  dmxAnim_fullStrobe(growingStrobe_speed, min(growingStrobe_intensity, 255));
  growingStrobe_intensity += growingStrobe_increment;
}

public void dmxAnim_growingLeftStrobe() {
  dmxAnim_leftStrobe(growingStrobe_speed, min(growingStrobe_intensity, 255));
  growingStrobe_intensity += growingStrobe_increment;
}

public void dmxAnim_growingRightStrobe() {
  dmxAnim_rightStrobe(growingStrobe_speed, min(growingStrobe_intensity, 255));
  growingStrobe_intensity += growingStrobe_increment;
}

public void dmxAnim_growingBackStrobe() {
  dmxAnim_backStrobe(growingStrobe_speed, min(growingStrobe_intensity, 255));
  growingStrobe_intensity += growingStrobe_increment;
}

public void dmxAnim_growingLeftRightStrobe() {
  dmxAnim_leftStrobe_noStop(growingStrobe_speed, min(growingStrobe_intensity, 255));
  dmxAnim_rightStrobe_noStop(growingStrobe_speed, min(growingStrobe_intensity, 255));
  dmxAnim_backStrobe_stop();
  growingStrobe_intensity += growingStrobe_increment;
}

// Switch the side stroboscopes intermittently on and off
public void dmxAnim_growingAlternateStrobe(float factor) {
  if ((int)(automaticSequencer.currentPosition * factor) % 2 == 0) {
    dmxAnim_growingRightStrobe();
  }
  else {
    dmxAnim_growingLeftStrobe();
  }
}

public void dmxAnim_growingAlternateStrobe2() {
  dmxAnim_growingAlternateStrobe(0.5f);
}

public void dmxAnim_growingAlternateStrobe4() {
  dmxAnim_growingAlternateStrobe(1.0f);
}

public void dmxAnim_growingAlternateStrobe8() {
  dmxAnim_growingAlternateStrobe(2.0f);
}

public void dmxAnim_growingAlternateStrobe16() {
  dmxAnim_growingAlternateStrobe(4.0f);
}


// Switch all the stroboscopes intermittently on and off, in a left-center-right sequence
public void dmxAnim_growingRotatingStrobe(float factor) {
  int strobeNb = (int)(automaticSequencer.currentPosition * factor) % 3;
  switch(strobeNb) {
    case 0:  dmxAnim_growingLeftStrobe();  break;
    case 1:  dmxAnim_growingBackStrobe();  break;
    case 2:  dmxAnim_growingRightStrobe(); break;
    default: break;
  }
}

public void dmxAnim_growingRotatingStrobe2() {
  dmxAnim_growingRotatingStrobe(0.5f);
}

public void dmxAnim_growingRotatingStrobe4() {
  dmxAnim_growingRotatingStrobe(1.0f);
}

public void dmxAnim_growingRotatingStrobe8() {
  dmxAnim_growingRotatingStrobe(2.0f);
}

public void dmxAnim_growingRotatingStrobe16() {
  dmxAnim_growingRotatingStrobe(4.0f);
}


/////////////////////////////////////////////////////////////////////////////////
// Single flashes using the Atomic-3000 type strobes
/////////////////////////////////////////////////////////////////////////////////

// This counter is set to 1 when a single flash is called, the function then sets it to 0 once the flash has been executed
// This is to deal with the single flash protocol used on the Atomic strobes :
// Start by setting the intensity and the flash rate at 0, then set an intensity on channel 1
int singleFlash_cpt = 0;

public void dmxAnim_shortSingleFlash() {
  dmxAnim_singleFlash(50);
}

public void dmxAnim_longSingleFlash() {
  dmxAnim_singleFlash(250);
}

public void dmxAnim_singleFlash(int flashLength) {
  if (singleFlash_cpt > 0) {
    // Do a single flash by setting an intensity on channel 1

    for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
      //This is a function specific to the Martin strobes, which can be set apart using their number of channels
      if (stroboscope.numberOfChannels == 4) {
        stroboscope.startDMX(0, 255, flashLength, 0);    //Speed = 0, Intensity = Max, specialFX = 0 
      }
    }
    for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
      if (stroboscope.numberOfChannels == 4) {
        stroboscope.startDMX(0, 255, flashLength, 0);    //Speed = 0, Intensity = Max, specialFX = 0
      }
    }
    
    for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
      if (stroboscope.numberOfChannels == 4) {
        stroboscope.startDMX(0, 255, flashLength, 0);    //Speed = 0, Intensity = Max, specialFX = 0
      }
    }
    
    // Decrease the counter
    singleFlash_cpt -= 1;
    
  }
  else {
    // Reset the intensity and the flash rate to 0
    for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
      stroboscope.stopDMX();
    }
    for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
      stroboscope.stopDMX();
    }
    for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
      stroboscope.stopDMX();
    }
  }
}

// Impulse flasher : flash the center strobe once, when an impulse is processed
public void dmxAnim_impulseFlasher_kick() {
  dmxAnim_impulseFlasher(SIGNAL_ID_KICK);
}

public void dmxAnim_impulseFlasher_snare() {
  dmxAnim_impulseFlasher(SIGNAL_ID_SNARE);
}

public void dmxAnim_impulseFlasher_cymbals() {
  dmxAnim_impulseFlasher(SIGNAL_ID_CYMBALS);
}

public void dmxAnim_impulseFlasher_bass() {
  dmxAnim_impulseFlasher(SIGNAL_ID_BASS);
}

public void dmxAnim_impulseFlasher_keys() {
  dmxAnim_impulseFlasher(SIGNAL_ID_KEYS);
}

public void dmxAnim_impulseFlasher_guitar() {
  dmxAnim_impulseFlasher(SIGNAL_ID_GUITAR);
}

public void dmxAnim_impulseFlasher(int signalID) {

  //Reset old flags according to the current system time
  invalidateOutdatedImpulseFlags();
  
  boolean impulse = false;
  
  if (signalID == SIGNAL_ID_KICK)         { impulse = impulse_Kick;    }
  else if (signalID == SIGNAL_ID_SNARE)   { impulse = impulse_Snare;   }
  else if (signalID == SIGNAL_ID_CYMBALS) { impulse = impulse_Cymbals; }
  else if (signalID == SIGNAL_ID_BASS)    { impulse = impulse_Bass;    }
  else if (signalID == SIGNAL_ID_KEYS)    { impulse = impulse_Keys;    }
  else if (signalID == SIGNAL_ID_GUITAR)  { impulse = impulse_Guitar;  }
  
  if (impulse) {
    singleFlash_cpt = SINGLEFLASH_INITVAL;
    dmxAnim_longSingleFlash();
    simuResetAnimCpt_AtomicStrobe();    // Make the simulator understand the strobe just flashed
  }
  else {
    dmxAnim_strobe_blackout();
  }
  
  //Set all the impulse flags to be reset at the end of the cycle, as they have been processed
  impulseMessageProcessed = true;
}


/////////////////////////////////////////////////////////////////////////////////
// Special FX using the Atomic 3000 stroboscopes
/////////////////////////////////////////////////////////////////////////////////

final int ATOMICFX_BLINDER        = 1;    //Not a real FX per se, but it's easier to deal with the simulator's implementation this way
final int ATOMICFX_RAMPUP         = 10;
final int ATOMICFX_RAMPDOWN       = 50;
final int ATOMICFX_RAMPUPDOWN     = 100;
final int ATOMICFX_RANDOM         = 150;
final int ATOMICFX_LIGHTNING      = 200;
final int ATOMICFX_SPIKES         = 250;
///////////////////////////////////////
final int ATOMICFX_SPEED_VERYSLOW = 25;
final int ATOMICFX_SPEED_SLOW     = 60;
final int ATOMICFX_SPEED_MEDIUM   = 160;
final int ATOMICFX_SPEED_FAST     = 250;
final int ATOMICFX_INTENSITY      = 255;
final int ATOMICFX_FLASH          = 150;
final int ATOMICFX_CONTINUOUS     = 255;

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX_rampUp_SlowFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_SLOW, ATOMICFX_RAMPUP);
}

public void dmxAnim_atomicFX_rampUp_MediumFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_MEDIUM, ATOMICFX_RAMPUP);
}

public void dmxAnim_atomicFX_rampUp_FastFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_FAST, ATOMICFX_RAMPUP);
}

public void dmxAnim_atomicFX_rampUp_SlowContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_SLOW, ATOMICFX_RAMPUP);
}

public void dmxAnim_atomicFX_rampUp_MediumContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_MEDIUM, ATOMICFX_RAMPUP);
}

public void dmxAnim_atomicFX_rampUp_FastContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_RAMPUP);
}

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX_rampDown_SlowFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_SLOW, ATOMICFX_RAMPDOWN);
}

public void dmxAnim_atomicFX_rampDown_MediumFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_MEDIUM, ATOMICFX_RAMPDOWN);
}

public void dmxAnim_atomicFX_rampDown_FastFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_FAST, ATOMICFX_RAMPDOWN);
}

public void dmxAnim_atomicFX_rampDown_SlowContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_SLOW, ATOMICFX_RAMPDOWN);
}

public void dmxAnim_atomicFX_rampDown_MediumContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_MEDIUM, ATOMICFX_RAMPDOWN);
}

public void dmxAnim_atomicFX_rampDown_FastContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_RAMPDOWN);
}

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX_rampUpDown_SlowFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_SLOW, ATOMICFX_RAMPUPDOWN);
}

public void dmxAnim_atomicFX_rampUpDown_MediumFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_MEDIUM, ATOMICFX_RAMPUPDOWN);
}

public void dmxAnim_atomicFX_rampUpDown_FastFlash() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_FAST, ATOMICFX_RAMPUPDOWN);
}

public void dmxAnim_atomicFX_rampUpDown_SlowContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_SLOW, ATOMICFX_RAMPUPDOWN);
}

public void dmxAnim_atomicFX_rampUpDown_MediumContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_MEDIUM, ATOMICFX_RAMPUPDOWN);
}

public void dmxAnim_atomicFX_rampUpDown_FastContinuous() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_RAMPUPDOWN);
}

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX_random() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_FAST, ATOMICFX_RANDOM);
}

public void dmxAnim_atomicFX_lightning() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_FAST, ATOMICFX_LIGHTNING);
}

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX_slowSpikes() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_VERYSLOW, ATOMICFX_SPIKES);
}

public void dmxAnim_atomicFX_mediumSpikes() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_SLOW, ATOMICFX_SPIKES);
}

public void dmxAnim_atomicFX_fastSpikes() {
  dmxAnim_atomicFX(ATOMICFX_INTENSITY, ATOMICFX_FLASH, ATOMICFX_SPEED_MEDIUM, ATOMICFX_SPIKES);
}

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX_Blinder_VeryWeak() {
  dmxAnim_atomicFX(70, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_BLINDER);
}

public void dmxAnim_atomicFX_Blinder_Weak() {
  dmxAnim_atomicFX(110, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_BLINDER);
}

public void dmxAnim_atomicFX_Blinder_Medium() {
  dmxAnim_atomicFX(160, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_BLINDER);
}

public void dmxAnim_atomicFX_Blinder_Strong() {
  dmxAnim_atomicFX(210, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_BLINDER);
}

public void dmxAnim_atomicFX_Blinder_VeryStrong() {
  dmxAnim_atomicFX(255, ATOMICFX_CONTINUOUS, ATOMICFX_SPEED_FAST, ATOMICFX_BLINDER);
}

////////////////////////////////////////////////////////////

public void dmxAnim_atomicFX(int intensity, int flashLength, int speed, int fxNumber) {
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    //This is a function specific to the Martin strobes, which can be set apart using their number of channels
    if (stroboscope.numberOfChannels == 4) {
      stroboscope.startDMX(speed, intensity, flashLength, fxNumber); 
    }
    else {
      stroboscope.stopDMX();
    }
  }
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    stroboscope.stopDMX();
    if (stroboscope.numberOfChannels == 4) {
      stroboscope.startDMX(speed, intensity, flashLength, fxNumber);
    }
    else {
      stroboscope.stopDMX();
    }
  }
  
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    if (stroboscope.numberOfChannels == 4) {
      stroboscope.startDMX(speed, intensity, flashLength, fxNumber);
    }
    else {
      stroboscope.stopDMX();
    }
  }
}


////////////////////////////////////////////////////////////

final int STROBEINTENSITY_VERYWEAK   = 70;
final int STROBEINTENSITY_WEAK       = 110;
final int STROBEINTENSITY_MODERATE   = 150;
final int STROBEINTENSITY_STRONG     = 200;

public void dmxAnim_leftStrobeVeryWeak() {
  dmxAnim_leftStrobe(255,STROBEINTENSITY_VERYWEAK);
}

public void dmxAnim_rightStrobeVeryWeak() {
  dmxAnim_rightStrobe(255,STROBEINTENSITY_VERYWEAK);
}

public void dmxAnim_backStrobeVeryWeak() {
  dmxAnim_backStrobe(254,STROBEINTENSITY_VERYWEAK);
}

public void dmxAnim_leftRightStrobeVeryWeak() {
  dmxAnim_leftStrobe_noStop(255,STROBEINTENSITY_VERYWEAK);
  dmxAnim_rightStrobe_noStop(255,STROBEINTENSITY_VERYWEAK);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_fullStrobeVeryWeak() {
  dmxAnim_fullStrobe(254,STROBEINTENSITY_VERYWEAK);
}


public void dmxAnim_leftStrobeWeak() {
  dmxAnim_leftStrobe(255,STROBEINTENSITY_WEAK);
}

public void dmxAnim_rightStrobeWeak() {
  dmxAnim_rightStrobe(255,STROBEINTENSITY_WEAK);
}

public void dmxAnim_backStrobeWeak() {
  dmxAnim_backStrobe(254,STROBEINTENSITY_WEAK);
}

public void dmxAnim_leftRightStrobeWeak() {
  dmxAnim_leftStrobe_noStop(255,STROBEINTENSITY_WEAK);
  dmxAnim_rightStrobe_noStop(255,STROBEINTENSITY_WEAK);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_fullStrobeWeak() {
  dmxAnim_fullStrobe(254,STROBEINTENSITY_WEAK);
}


public void dmxAnim_leftStrobeModerate() {
  dmxAnim_leftStrobe(255,STROBEINTENSITY_MODERATE);
}

public void dmxAnim_rightStrobeModerate() {
  dmxAnim_rightStrobe(255,STROBEINTENSITY_MODERATE);
}

public void dmxAnim_backStrobeModerate() {
  dmxAnim_backStrobe(254,STROBEINTENSITY_MODERATE);
}

public void dmxAnim_leftRightStrobeModerate() {
  dmxAnim_leftStrobe_noStop(255,STROBEINTENSITY_MODERATE);
  dmxAnim_rightStrobe_noStop(255,STROBEINTENSITY_MODERATE);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_fullStrobeModerate() {
  dmxAnim_fullStrobe(254,STROBEINTENSITY_MODERATE);
}


public void dmxAnim_leftStrobeStrong() {
  dmxAnim_leftStrobe(255,STROBEINTENSITY_STRONG);
}

public void dmxAnim_rightStrobeStrong() {
  dmxAnim_rightStrobe(255,STROBEINTENSITY_STRONG);
}

public void dmxAnim_backStrobeStrong() {
  dmxAnim_backStrobe(254,STROBEINTENSITY_STRONG);
}

public void dmxAnim_leftRightStrobeStrong() {
  dmxAnim_leftStrobe_noStop(255,STROBEINTENSITY_STRONG);
  dmxAnim_rightStrobe_noStop(255,STROBEINTENSITY_STRONG);
  dmxAnim_backStrobe_stop();
}

public void dmxAnim_fullStrobeStrong() {
  dmxAnim_fullStrobe(254,STROBEINTENSITY_STRONG);
}

///////////////////////////////////////////////////////////
//   Graphical effects to be laid on top of animations   //
///////////////////////////////////////////////////////////


//Effects parameters
float glitcherEffect_noiseFactor = 40;
float glitcherEffect_noiseSpeed = 0.5f;
int glitcherEffect_black = color(0);

int randomStripesEffect_minWidth = 4;
int randomStripesEffect_maxWidth = 20;
int randomStripesEffect_numberOfStripes = PApplet.parseInt(NUMBER_OF_PANELS*3/2.0f);
int randomLinesEffect_minWidth = 4;
int randomLinesEffect_maxWidth = 12;
int randomLinesEffect_numberOfLines = NUMBER_OF_PANELS;

int flutterEffect_slices = 16;
float flutterEffect_unit = 64/flutterEffect_slices;
float flutterEffect_theta = 0;

float fadeout_counter = 0;
float fadein_counter = 0;
float fadeout_speed = 0.7f;
int whiteout_speed = 8;

float blackWaveCircle_counter = 0;
float blackWaveCircle_speed = 16;

float windmill_randAngle = 0;
int windmill_intensity = 0;
int windmill_growthSpeed = 10;

int whiteflash_cpt = 0;
int redflash_cpt = 0;

final float lightBlue_reductionFactor_red = 0.4f;
final float lightBlue_reductionFactor_green = 0.4f;

//General effect switcher
public void draw_effects() {
  if (effectToBeDrawn == true) {
    switch(currentEffectNumber) {   
      case 1:   draw_classicglitcherEffect();break;
      case 2:   draw_rgbGlitcherEffect();break;
      case 3:   draw_180RotateEffect();break;
      case 4:   draw_redocalypseEffect();break;
      case 5:   draw_flickerEffect();break;
      case 6:   draw_randomWhiteStripesEffect();break;
      case 7:   draw_randomRedStripesEffect();break;
      case 8:   draw_randomBlueStripesEffect();break;
      case 9:   draw_randomWhiteLinesEffect();break;
      case 10:  draw_randomRedLinesEffect();break;
      case 11:  draw_randomBlueLinesEffect();break;
      case 12:  draw_flickerSinglePanelEffect(0);break;
      case 13:  draw_flickerSinglePanelEffect(1);break;
      case 14:  draw_flickerSinglePanelEffect(2);break;
      case 15:  draw_flickerSinglePanelEffect(3);break;
      case 16:  draw_flickerSinglePanelEffect(4);break;
      case 17:  draw_flutterEffect();break;
      case 18:  draw_monochromeFilterEffect();break;
      case 19:  draw_invertFilterEffect();break;
      case 20:  draw_onlyLeftEffect();break;
      case 21:  draw_onlyRightEffect();break;
      case 22:  draw_randomPanelFlicker();break;
      case 23:  draw_rainbowColor();break;
      case 24:  draw_additionalfadeout();break;
      case 25:  draw_additionalfadein();break;
      case 26:  draw_additionalfadeout_red();break;
      case 27:  draw_additionalfadein_red();break;
      case 28:  draw_additionalwhiteout();break;
      case 29:  draw_additionalredout();break;
      case 30:  draw_blackWaveCircle();break;
      case 31:  draw_windmill();break;
      case 32:  draw_whiteflash();break;
      case 33:  draw_redflash();break;
      case 34:  draw_randomRedPanelFlicker();break;
      case 35:  draw_lightBlueFilter(); break;
      case 36:  draw_panelsOff(); break;
      default: break;
    }
  }
}

public void initSpecificEffectParams() {
  switch(currentEffectNumber) {
    case 24: fadeout_counter         = 0; break;
    case 25: fadein_counter          = 0; break;
    case 26: fadeout_counter         = 0; break;
    case 27: fadein_counter          = 0; break;
    case 28: fadeout_counter         = 0; break;
    case 29: fadeout_counter         = 0; break;
    case 30: blackWaveCircle_counter = 0; break;
    case 31: windmill_randAngle     += 0.3f*PI; windmill_intensity = 0; break;
    case 32: whiteflash_cpt          = 0; break;
    case 33: redflash_cpt            = 0; break;
    default: break;
  }
}


////////////////////////////////////////////////////////////
// Effects implementation
/////////


public void draw_classicglitcherEffect() {
  loadPixels();
  int[] newPixels = new int[width*height];
  for (int i=0; i<newPixels.length; i++) {
    newPixels[i] = pixels[i];
  }
  int randomiserX = PApplet.parseInt(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*frameCount)-0.5f));
  int randomiserY = PApplet.parseInt(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*(frameCount + 1000))-0.5f));
  for (int i = 0; i<height; i++) {
    for (int j = 0; j<width; j++) {
      if ((i+randomiserX)*width + (j+randomiserY) < pixels.length && (i+randomiserX)*width + (j+randomiserY) >= 0) {
        newPixels[i*width + j] = pixels[(i+randomiserX)*width + (j+randomiserY)];
      }
      else {
        newPixels[i*width + j] = glitcherEffect_black; 
      }
    } 
  }
  for (int i=0; i<newPixels.length; i++) {
    pixels[i] = newPixels[i];
  }
  updatePixels();
}

public void draw_rgbGlitcherEffect() {
  loadPixels();
  int[] newPixelsRed = new int[width*height];
  int[] newPixelsGreen = new int[width*height];
  int[] newPixelsBlue = new int[width*height];
  for (int i=0; i<newPixelsRed.length; i++) {
    newPixelsRed[i] = pixels[i];
    newPixelsGreen[i] = pixels[i];
    newPixelsBlue[i] = pixels[i];
  }
  int randomiserXRed   = PApplet.parseInt(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*frameCount)-0.5f));
  int randomiserYRed   = PApplet.parseInt(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*(frameCount + 1000))-0.5f));
  int randomiserXGreen = PApplet.parseInt(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*(frameCount + 2000))-0.5f));
  int randomiserYGreen = PApplet.parseInt(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*(frameCount + 3000))-0.5f));
  //For XI: it is best not to show too much yellow, because it does not fit the band's visual identity
  //int randomiserXBlue  = int(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*(frameCount + 4000))-0.5));
  //int randomiserYBlue  = int(glitcherEffect_noiseFactor*(noise(glitcherEffect_noiseSpeed*(frameCount + 5000))-0.5));
  int randomiserXBlue = randomiserXGreen;
  int randomiserYBlue = randomiserYGreen;
  for (int i = 0; i<height; i++) {
    for (int j = 0; j<width; j++) {
      if ((i+randomiserXRed)*width + (j+randomiserYRed) < pixels.length && (i+randomiserXRed)*width + (j+randomiserYRed) >= 0) {
        newPixelsRed[i*width + j] = pixels[(i+randomiserXRed)*width + (j+randomiserYRed)];
      }
      else {
        newPixelsRed[i*width + j] = glitcherEffect_black; 
      }
      
      if ((i+randomiserXGreen)*width + (j+randomiserYGreen) < pixels.length && (i+randomiserXGreen)*width + (j+randomiserYGreen) >= 0) {
        newPixelsGreen[i*width + j] = pixels[(i+randomiserXGreen)*width + (j+randomiserYGreen)];
      }
      else {
        newPixelsGreen[i*width + j] = glitcherEffect_black; 
      }
      
      if ((i+randomiserXBlue)*width + (j+randomiserYBlue) < pixels.length && (i+randomiserXBlue)*width + (j+randomiserYBlue) >= 0) {
        newPixelsBlue[i*width + j] = pixels[(i+randomiserXBlue)*width + (j+randomiserYBlue)];
      }
      else {
        newPixelsBlue[i*width + j] = glitcherEffect_black; 
      }
      
    } 
  }
  
  for (int i=0; i<pixels.length; i++) {
    pixels[i] = 255 << 24 | newPixelsRed[i] << 16 | newPixelsGreen[i] << 8 | newPixelsBlue[i];
  }
  updatePixels();
}

public void draw_180RotateEffect() {
  loadPixels();
  int[] newPixels = new int[width*height];
  for (int i=0; i<newPixels.length; i++) {
    newPixels[i] = pixels[newPixels.length - 1 - i];
  }
  for (int i=0; i<newPixels.length; i++) {
    pixels[i] = newPixels[i];
  }
  updatePixels();
}

public void draw_redocalypseEffect() {
  loadPixels();
  for (int i=0; i<pixels.length; i++) {
    pixels[i] = pixels[i]<<16;
  }
  updatePixels();
}

public void draw_lightBlueFilter() {
  loadPixels();
  for (int i=0; i<pixels.length; i++) {
    pixels[i] = color(PApplet.parseInt(lightBlue_reductionFactor_red * ((pixels[i] >> 16) & 0xFF)), 
                      PApplet.parseInt(lightBlue_reductionFactor_green * ((pixels[i] >> 8) & 0xFF)), 
                      pixels[i] & 0xFF, 
                      (pixels[i] >> 24) & 0xFF); 
  }
  updatePixels();
}

public void draw_flickerEffect() {
  if (random(1) > 0.6f) {
    loadPixels();
    for (int i=0; i<pixels.length; i++) {
      pixels[i] = glitcherEffect_black;
    }
    updatePixels();
  }
}


public void draw_randomWhiteStripesEffect() {
  pushStyle();
  noStroke();
  fill(255);
  for (int i = 0; i < randomStripesEffect_numberOfStripes; i++) {
    rect(random(width),0,random(randomStripesEffect_minWidth,randomStripesEffect_maxWidth),height);
  }
  popStyle();
}

public void draw_randomRedStripesEffect() {
  pushStyle();
  noStroke();
  colorMode(RGB);
  fill(255,0,0);
  for (int i = 0; i < randomStripesEffect_numberOfStripes; i++) {
    rect(random(width),0,random(randomStripesEffect_minWidth,randomStripesEffect_maxWidth),height);
  }
  popStyle();
}

public void draw_randomBlueStripesEffect() {
  pushStyle();
  noStroke();
  colorMode(RGB);
  for (int i = 0; i < randomStripesEffect_numberOfStripes; i++) {
    int randomcol = (int) spotsmulticolor_colorselection[floor(random(spotsmulticolor_colorselection.length))];
    fill(randomcol);
    rect(random(width),0,random(randomStripesEffect_minWidth,randomStripesEffect_maxWidth),height);
  }
  popStyle();
}

public void draw_randomWhiteLinesEffect() {
  pushStyle();
  noStroke();
  fill(255);
  for (int i = 0; i < randomLinesEffect_numberOfLines; i++) {
    rect(0,random(height),width,random(randomLinesEffect_minWidth,randomLinesEffect_maxWidth));
  }
  popStyle();
}

public void draw_randomRedLinesEffect() {
  pushStyle();
  colorMode(RGB);
  noStroke();
  fill(255,0,0);
  for (int i = 0; i < randomLinesEffect_numberOfLines; i++) {
    rect(0,random(height),width,random(randomLinesEffect_minWidth,randomLinesEffect_maxWidth));
  }
  popStyle();
}

public void draw_randomBlueLinesEffect() {
  pushStyle();
  colorMode(RGB);
  noStroke();
  for (int i = 0; i < randomLinesEffect_numberOfLines; i++) {
    int randomcol = (int) spotsmulticolor_colorselection[floor(random(spotsmulticolor_colorselection.length))];
    fill(randomcol);
    rect(0,random(height),width,random(randomLinesEffect_minWidth,randomLinesEffect_maxWidth));
  }
  popStyle();
}

public void draw_flickerSinglePanelEffect(int panel) {
  pushStyle();
  noStroke();
  float rand = random(1);
  if (rand > 0.9f) {
    fill(0);
    rect(panel*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height);
  }
  else if (rand > 0.75f) {
    fill(255);
    rect(panel*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height);
  }
  else if (rand > 0.65f) {
    fill(255);
    rect(panel*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height/2);
  }
  else if (rand > 0.55f) {
    fill(255);
    rect(panel*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS, height/2);
  }
  else if (rand > 0.50f) {
    fill(255);
    rect(panel*width/NUMBER_OF_PANELS,0,width/(2*NUMBER_OF_PANELS), height);
  }
  else if (rand > 0.45f) {
    fill(255);
    rect((2*panel+1)*width/(2*NUMBER_OF_PANELS),0,width/(2*NUMBER_OF_PANELS), height);
  }
  popStyle();
}

public void draw_flickerSinglePanelRedEffect(int panel) {
  pushStyle();
  noStroke();
  float rand = random(1);
  if (rand > 0.9f) {
//    fill(0);
//    rect(panel*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height);
  }
  else if (rand > 0.75f) {
    fill(PApplet.parseInt(random(150,255)),0,0);
    rect(panel*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height);
  }
  else if (rand > 0.65f) {
    fill(PApplet.parseInt(random(150,255)),0,0);
    rect(panel*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height/2);
  }
  else if (rand > 0.55f) {
    fill(PApplet.parseInt(random(150,255)),0,0);
    rect(panel*width/NUMBER_OF_PANELS,height/2,width/NUMBER_OF_PANELS, height/2);
  }
  else if (rand > 0.50f) {
    fill(PApplet.parseInt(random(150,255)),0,0);
    rect(panel*width/NUMBER_OF_PANELS,0,width/(2*NUMBER_OF_PANELS), height);
  }
  else if (rand > 0.45f) {
    fill(PApplet.parseInt(random(150,255)),0,0);
    rect((2*panel+1)*width/(2*NUMBER_OF_PANELS),0,width/(2*NUMBER_OF_PANELS), height);
  }
  popStyle();
}

public void draw_randomPanelFlicker() {
  pushMatrix();
  resetMatrix();
  pushStyle();
  for (int panelNb=0; panelNb < NUMBER_OF_PANELS; panelNb++) {
    if (random(1) > 0.8f) {
      draw_flickerSinglePanelEffect(panelNb);
    }
    else if (random(1) > 0.8f) {
      fill(0);
      noStroke();
      rect(panelNb*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height);
    }
  }
  popStyle();
  popMatrix();
}

public void draw_randomRedPanelFlicker() {
  pushMatrix();
  resetMatrix();
  pushStyle();
  for (int panelNb=0; panelNb < NUMBER_OF_PANELS; panelNb++) {
    if (random(1) > 0.8f) {
      draw_flickerSinglePanelRedEffect(panelNb);
    }
    else if (random(1) > 0.8f) {
      fill(0);
      noStroke();
      rect(panelNb*width/NUMBER_OF_PANELS,0,width/NUMBER_OF_PANELS, height);
    }
  }
  popStyle();
  popMatrix();
}

public void draw_flutterEffect() {
  for (int flutter_i=0; flutter_i<flutterEffect_slices; flutter_i++) {
    float flutter_edgeX = map(sin(flutterEffect_theta+flutter_i*(TWO_PI/flutterEffect_slices)), -1, 1, 0, width*.05f);
    float flutter_edgeY = map(sin(flutterEffect_theta+flutter_i*(TWO_PI/flutterEffect_slices)), -1, 1, 0, height*.05f);
    int flutter_y = PApplet.parseInt(flutter_i*flutterEffect_unit);
    blend(0, flutter_y, width, PApplet.parseInt(flutterEffect_unit), PApplet.parseInt(-flutter_edgeX), PApplet.parseInt(flutter_y-flutter_edgeY), PApplet.parseInt(width+flutter_edgeX), PApplet.parseInt(flutterEffect_unit+2*flutter_edgeY), SCREEN);
  }
  flutterEffect_theta += TWO_PI/flutterEffect_slices;
}

public void draw_monochromeFilterEffect() {
  filter(GRAY);
}

public void draw_invertFilterEffect() {
  filter(INVERT);
}

public void draw_onlyLeftEffect() {
  pushStyle();
  noStroke();
  fill(0);
  rect(0,0,(NUMBER_OF_PANELS/2 + 1)*width/NUMBER_OF_PANELS,height);
  popStyle();
}

public void draw_onlyRightEffect() {
  pushStyle();
  noStroke();
  fill(0);
  rect(width - (NUMBER_OF_PANELS/2 + 1)*width/NUMBER_OF_PANELS,0,(NUMBER_OF_PANELS/2 + 1)*width/NUMBER_OF_PANELS,height);
  popStyle();
}

public void draw_rainbowColor() {
  pushStyle();
  noStroke();
  colorMode(HSB);
  fill(frameCount%255, 255, 255, 80);
  rect(0,0,width,height);
  
  popStyle();
}


public void draw_additionalfadeout() {
  pushStyle();
  noStroke();
  fill(0, 0, 0, min(255, fadeout_counter));
  rect(0,0,width,height);
  popStyle();
  
  fadeout_counter += fadeout_speed;
}

public void draw_additionalfadein() {
  pushStyle();
  noStroke();
  fill(0, 0, 0, max(0, 255 - fadein_counter));
  rect(0,0,width,height);
  popStyle();
  
  fadein_counter += fadeout_speed;
}

public void draw_additionalfadeout_red() {
  draw_redocalypseEffect();
  pushStyle();
  noStroke();
  fill(0, 0, 0, min(255, fadeout_counter));
  rect(0,0,width,height);
  popStyle();
  
  fadeout_counter += fadeout_speed;
}

public void draw_additionalfadein_red() {
  draw_redocalypseEffect();
  pushStyle();
  noStroke();
  fill(0, 0, 0, max(0, 255 - fadein_counter));
  rect(0,0,width,height);
  popStyle();
  
  fadein_counter += fadeout_speed;
}

public void draw_additionalwhiteout() {
  pushStyle();
  noStroke();
  fill(255, 255, 255, min(255, fadeout_counter));
  rect(0,0,width,height);
  popStyle();
  
  fadeout_counter += whiteout_speed;
}

public void draw_additionalredout() {
  pushStyle();
  noStroke();
  fill(255, 0, 0, min(255, fadeout_counter));
  rect(0,0,width,height);
  popStyle();
  
  fadeout_counter += whiteout_speed;
}

public void draw_blackWaveCircle() {
  pushStyle();
  pushMatrix();
  resetMatrix();
  noFill();
  stroke(0);
  strokeWeight(32);
  ellipse(width/2, height/2, blackWaveCircle_counter, blackWaveCircle_counter);
  popMatrix(); 
  popStyle();
  blackWaveCircle_counter += blackWaveCircle_speed; 
}


public void draw_windmill() {
  pushStyle();
  colorMode(RGB);
  fill(windmill_intensity);
  noStroke();
  pushMatrix();
  resetMatrix();
  translate(width*0.5f, height*0.5f);
  rotate(frameCount / 100.0f + windmill_randAngle);
  star(0, 0, 8, 2000, 3); 
  popMatrix();
  popStyle();
  windmill_intensity = min(windmill_intensity + windmill_growthSpeed, 255);
}

public void draw_whiteflash() {
  if (whiteflash_cpt < 3) {
    pushStyle(); 
    pushMatrix();
    fill(255);
    noStroke();
    rect(0,0,width,height);
    resetMatrix();
    popStyle();
    popMatrix();
  }
  whiteflash_cpt += 1;
}

public void draw_redflash() {
  if (redflash_cpt < 3) {
    pushStyle(); 
    pushMatrix();
    fill(255,0,0);
    noStroke();
    rect(0,0,width,height);
    resetMatrix();
    popStyle();
    popMatrix();
  }
  redflash_cpt += 1;
}

public void draw_panelsOff() {
  pushStyle(); 
  pushMatrix();
  fill(0);
  noStroke();
  rect(0,0,width,height);
  resetMatrix();
  popStyle();
  popMatrix();
}

//////////////////////////////////////////////////////////////
// Custom exceptions to be raised in case of serious errors //
//////////////////////////////////////////////////////////////

public class SerialPortException extends Exception {

  private static final long serialVersionUID = 3951181732955456485L;

  public SerialPortException(String s) {
    super(s);
  }
}


public class NoSerialPortFoundException extends Exception {

  private static final long serialVersionUID = -6432383124399209942L;
  
  public NoSerialPortFoundException(String s) {
    super(s);
  }
}

public class FixtureDescriptionParseException extends Exception {

  private static final long serialVersionUID = 1432363154395209342L;
  
  public FixtureDescriptionParseException(String s) {
    super(s);
  }
}

public class UndefinedFixtureException extends Exception {

  private static final long serialVersionUID = 1022115134292153760L;
  
  public UndefinedFixtureException(String s) {
    super(s);
  }
}

//////////////////////////////////////////////////////////////
//   DMX Fixture library based on the available XML files   //
//////////////////////////////////////////////////////////////








final String XMLDESC_ROOTNAME                   = "Fixture";

final String XMLDESC_NAME                       = "Name";
final String XMLDESC_MANUFACTURER               = "Manufacturer";
final String XMLDESC_TYPE                       = "Type";
final String XMLDESC_COMMENT                    = "Comment";
final String XMLDESC_NBCHANNELS                 = "NbChannels";
final String XMLDESC_CHANNELTYPE                = "ChannelType";
final String XMLDESC_CHANNELTYPE_INDEX          = "index";
final String XMLDESC_CHANNELTYPE_ATTRIBUTE      = "attribute";
final String XMLDESC_CHANNELTYPE_OPTION         = "option";
final String XMLDESC_CHANNELTYPE_OPTION_ARG     = "option_argument";
final String XMLDESC_CHANNELTYPE_CH_LINK        = "ch_link";
final String XMLDESC_CHANNELSET                 = "ChannelSet";
final String XMLDESC_CHANNELSET_NAME            = "name";
final String XMLDESC_CHANNELSET_FROM_DMX        = "from_dmx";
final String XMLDESC_CHANNELSET_TO_DMX          = "to_dmx";
final String XMLDESC_CHANNELSET_TO_PROPORTIONAL = "proportional";
final String XMLDESC_CHANNELSET_RECOMMENDED     = "recommended";
final String XMLDESC_CHANNELSET_RANGE           = "range";


ArrayList<Fixture> fixtureLibrary;

// Structure description:
// Fixture
//  |  ChannelDesc: big function
//  |   |   ChannelSet: (from/to dmx val: subfunction)
//  |   |   ChannelSet: (from/to dmx val: subfunction)
//  |  ChannelDesc: big function
//  |   |   ChannelSet: (from/to dmx val: subfunction)
//  |   ...



public void readFixtureFiles() {
  
  fixtureLibrary = new ArrayList<Fixture>();
  
  //Parse all data folders, and create Fixture objects
  String[] fixtureTypes   = { "Strobe", "Moving Head", "PAR", "Scanner", "Laser", "Blinder", "LED Strip", "Fog"};
  //String[] fixtureTypes   = { "Strobe"};

    
  for (String directoryToParse: fixtureTypes) {
    try {
      String fullDirectoryPath = dataPath("") + "/Fixtures/" + directoryToParse;

      File dir = new File(fullDirectoryPath);
      String[] children = dir.list();
      
      for (String child : children) {
        // Only check for XML files, disregard OSX's Finder cookie
        if (child.contains(".xml")) {
          println(fullDirectoryPath + "/" + child);
          parseFixtureXML(fullDirectoryPath + "/" + child);
        }
      }
    }
    catch (Exception e) {
      outputLog.println("Exception while parsing fixture XMLs : " + e);
      println("Exception while parsing fixture XMLs : " + e);
    }
  }
}

// Get a fixture from its name
public Fixture getFixtureFromName(String name) {
  for (Fixture fixture: fixtureLibrary) {
    if (name.equals(fixture.getFullName()) || name.equals(fixture.getShortName())) {
      //We've got the right fixture
      return fixture;
    }
  }
  // We couldn't find a corresponding fixture
  Fixture voidFixture = new Fixture();
  return voidFixture;

}

public void parseFixtureXML(String path) {
  
  final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
          
  try {
    
    final DocumentBuilder builder = factory.newDocumentBuilder();
    Document document= builder.parse(new File(path));
    final Element root = document.getDocumentElement();
    String rootName = root.getNodeName();
    
    if (rootName.equals(XMLDESC_ROOTNAME)) {
    
      Fixture newFixture = new Fixture();
    
      final NodeList rootNodes = root.getChildNodes();
      final int nbRootNodes = rootNodes.getLength();
      
      for (int i = 0; i<nbRootNodes; i++) {
        if(rootNodes.item(i).getNodeType() == Node.ELEMENT_NODE) {
          final Element elem = (Element) rootNodes.item(i);

          if (elem.getNodeName().equals(XMLDESC_NAME)) {
            newFixture.setName(elem.getTextContent());
          }
          if (elem.getNodeName().equals(XMLDESC_MANUFACTURER)) {
            newFixture.setManufacturer(elem.getTextContent());
          }
          if (elem.getNodeName().equals(XMLDESC_TYPE)) {
            newFixture.setType(elem.getTextContent());
          }
          if (elem.getNodeName().equals(XMLDESC_NBCHANNELS)) {
            newFixture.setNbChannels(PApplet.parseInt(elem.getTextContent()));
          }
          if (elem.getNodeName().equals(XMLDESC_COMMENT)) {
            newFixture.setComment(elem.getTextContent());
          }
          if (elem.getNodeName().equals(XMLDESC_CHANNELTYPE)) {
            // Basic checks on the channel type declaration
            checkIfAttrDefinedInElementAndThrowException(elem, XMLDESC_CHANNELTYPE_INDEX,     "Bad Fixture XML description - channel type index is not defined");
            checkIfAttrDefinedInElementAndThrowException(elem, XMLDESC_CHANNELTYPE_ATTRIBUTE, "Bad Fixture XML description - channel type attribute is not defined");

            ChannelDesc newChannelDesc = new ChannelDesc( PApplet.parseInt(elem.getAttribute(XMLDESC_CHANNELTYPE_INDEX)), elem.getAttribute(XMLDESC_CHANNELTYPE_ATTRIBUTE) );

            if (checkIfAttrDefinedInElement(elem, XMLDESC_CHANNELTYPE_OPTION)) {
              newChannelDesc.setOption(elem.getAttribute(XMLDESC_CHANNELTYPE_OPTION));

              if (checkIfAttrDefinedInElement(elem, XMLDESC_CHANNELTYPE_OPTION_ARG)) {
                newChannelDesc.setOptionArgument(elem.getAttribute(XMLDESC_CHANNELTYPE_OPTION_ARG));
              }
            }

            if (checkIfAttrDefinedInElement(elem, XMLDESC_CHANNELTYPE_CH_LINK)) {
              newChannelDesc.setChannelLink(PApplet.parseInt(elem.getAttribute(XMLDESC_CHANNELTYPE_CH_LINK)));
            }

            final NodeList channelTypeNodes = elem.getChildNodes();
            final int nbChannelTypeNodes = channelTypeNodes.getLength();
            
            for (int j = 0; j<nbChannelTypeNodes; j++) {
              if(channelTypeNodes.item(j).getNodeType() == Node.ELEMENT_NODE) {
                final Element subElem = (Element) channelTypeNodes.item(j);
                if (subElem.getNodeName().equals(XMLDESC_CHANNELSET)) {
                  
                  checkIfAttrDefinedInElementAndThrowException(subElem, XMLDESC_CHANNELSET_NAME,     "Bad Fixture XML description - channel set name is not defined");
                  checkIfAttrDefinedInElementAndThrowException(subElem, XMLDESC_CHANNELSET_FROM_DMX, "Bad Fixture XML description - channel set from_dmx is not defined");
                  checkIfAttrDefinedInElementAndThrowException(subElem, XMLDESC_CHANNELSET_TO_DMX,   "Bad Fixture XML description - channel set to_dmx is not defined");

                  ChannelSet newChannelSet = new ChannelSet(PApplet.parseInt(subElem.getAttribute(XMLDESC_CHANNELSET_FROM_DMX)), PApplet.parseInt(subElem.getAttribute(XMLDESC_CHANNELSET_TO_DMX)), subElem.getAttribute(XMLDESC_CHANNELSET_NAME));

                  if (checkIfAttrDefinedInElement(subElem, XMLDESC_CHANNELSET_TO_PROPORTIONAL)) {
                    newChannelSet.set_proportional(subElem.getAttribute(XMLDESC_CHANNELSET_TO_PROPORTIONAL));
                  }
                  if (checkIfAttrDefinedInElement(subElem, XMLDESC_CHANNELSET_RECOMMENDED)) {
                    newChannelSet.setRecommended(parseBooleanString(subElem.getAttribute(XMLDESC_CHANNELSET_RECOMMENDED)));
                  }

                  if (checkIfAttrDefinedInElement(subElem, XMLDESC_CHANNELSET_RANGE)) {
                    newChannelSet.setChannelRange(PApplet.parseInt(subElem.getAttribute(XMLDESC_CHANNELSET_RANGE)));
                  }

                  newChannelDesc.addChannelSet(newChannelSet);

                }
              }
            }

            newFixture.addChannelDesc(newChannelDesc);
          }  
        }
      }

      println(newFixture);
      // Very last step : once the file has been parsed, if no exception has been raised up until now, the description is valid
      // Add the new fixture to the library
      fixtureLibrary.add(newFixture);
      println("Added a fixture to the library");
    }


    
  }
  catch (final FixtureDescriptionParseException e) {
      e.printStackTrace();
      println(e);
  }
  catch (final ParserConfigurationException e) {
      e.printStackTrace();
      println(e);
  }
  catch (final SAXException e) {
      e.printStackTrace();
      println(e);
  }
  catch (final IOException e) {
      e.printStackTrace();
      println(e);
  }        
}

public void checkIfAttrDefinedInElementAndThrowException(Element elem, String attribute, String assertion) throws FixtureDescriptionParseException {
  if (elem.getAttribute(attribute).equals("")) {
    throw new FixtureDescriptionParseException(assertion);
  }
}

public boolean checkIfAttrDefinedInElement(Element elem, String attribute) {
  if (elem.getAttribute(attribute).equals("")) {
    return false;
  }
  else {
    return true;
  }
}

public boolean parseBooleanString(String boolString) {
  if (boolString.equals("true")) {
    return true;
  }
  else {
    return false;
  }
}

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////


class Fixture {
  
  String Name;
  String Manufacturer;
  String Type;                          //Family of the fixture: Strobe, Moving Head, PAR, Scanner, Laser, Blinder, LED Strip or Fog Machine
  String Comment;
  int NbChannels;
  ArrayList<ChannelDesc> Channels;
  String[] channelDict;                 //Dictionary of the channels' index/function

  Fixture() {
    this.Name = "";
    this.Manufacturer = "";
    this.Type = "";
    this.Comment = "";
    this.NbChannels = 0;
    this.Channels = new ArrayList<ChannelDesc>();
    this.channelDict = new String[0];
  }

  
  
  public void setName(String name) {
    this.Name = name;
  }

  public void setManufacturer(String manufacturer) {
    this.Manufacturer = manufacturer;
  }

  public void setType(String type) {
    this.Type = type;
  }

  public void setComment(String comment) {
    this.Comment = comment;
  }

  public void setNbChannels(int nbchannels) {
    this.NbChannels = nbchannels;
  }

  public void addChannelDesc(ChannelDesc channel) {
    Channels.add(channel);
    buildChannelIndexDict();
  }

  public String getFullName() {
    return this.Manufacturer + " " + this.Name;
  }

  public String getShortName() {
    return this.Name;
  }

  public int getNbChannels() {
    return this.NbChannels;
  }

  public boolean isValidFixture() {
    if (this.Name.equals("")) {
      return false;
    }
    else if (this.Type.equals("")) {
      return false;
    }
    else if (this.NbChannels == 0) {
      return false;
    }
    else if (this.Channels.size() == 0) {
      return false;
    }
    else {
      return true;
    }
  }
  
  public String toString() {
    //return "DMX Fixture (" + type + ") with " + nbModes + " modes - " + name;
    String description = "DMX Fixture (" + this.Type + ") " + this.Manufacturer + " - " + this.Name + ": \n";
    description += " --- \n";
    for (ChannelDesc channel: this.Channels) {
      description += "\t" + channel.toString();
    }
    description += " --------------------------------------- ";
    return description;
  }

  public void buildChannelIndexDict() {
    this.channelDict = new String[this.NbChannels];

    for (int i=0; i<this.NbChannels; i++) {
      
      // Necessary to do it this way: for some fixtures, some channels might as well not be defined
      String function = "";
      for (ChannelDesc channel: this.Channels) {
        if (channel.getIndex() == i) {
          function = channel.getChannelDescription();
          break;
        }
      }

      this.channelDict[i] = function;
    }
  }

  ///Accessor functions

  // Get the index of the first channel whose name is equal to the specified argument
  public int getChannelIndexCorrespondingToFunction(String function) {
    int ret_val = -1;
    for (ChannelDesc channel: this.Channels) {
      if (channel.getChannelDescription().equals(function)) {
        ret_val = channel.getIndex();
        break;
      }
    }
    return ret_val;
  }

  // Get the indexes of all channels whose name is equal to the specified argument
  public IntList getAllChannelIndexesCorrespondingToFunction(String function) {
    
    IntList ret_val = new IntList();
    for (ChannelDesc channel: this.Channels) {
      if (channel.getChannelDescription().equals(function)) {
        ret_val.append(channel.getIndex());
        break;
      }
    }
    return ret_val;
  }

  public String getOptionCorrespondingToChannelIndex(int index) {
    return getChannelCorrespondingToIndex(index).getOption();
  }

  public ChannelDesc getChannelCorrespondingToIndex(int index) {
    ChannelDesc ret_channel = new ChannelDesc();

    for (ChannelDesc channel: this.Channels) {
      if (channel.getIndex() == index) {
        ret_channel = channel;
        break;
      }
    }

    return ret_channel;
  }

  public int getLinkedChannelIndexCorrespondingToIndex(int index) {
    return getChannelCorrespondingToIndex(index).getChannelLink();
  }

  public ArrayList<ChannelDesc> getAllChannelsWithDefaultVal() {
    ArrayList<ChannelDesc> channels = new ArrayList<ChannelDesc>();

    for (ChannelDesc channel: this.Channels) {
      for (ChannelSet channelSet: channel.channelSets) {
        if (channelSet.isRecommended()) {
          channels.add(channel);
          break;
        }
      }
    }

    return channels;
  }

}


class ChannelDesc {
  
  int index;                                  // Current channel's index -> chaddress = initial device's address + index
  String channelDescription;
  String option;
  String option_argument;
  int ch_link = -1;                           // Used to define an additional "fine" channel - the dmx value is then calculated on 16 bits, MSB go on the first channel, LSB go on the fine channel

  ArrayList<ChannelSet> channelSets;
  
  ChannelDesc() {
    this.index = -1;
    this.channelDescription = "";
    this.channelSets = new ArrayList<ChannelSet>();
    this.option = "";
    this.option_argument = "";
  }

  ChannelDesc(int index, String desc) {
    this.index = index;
    this.channelDescription = desc;
    this.channelSets = new ArrayList<ChannelSet>();
    this.option = "";
    this.option_argument = "";
  }

  ChannelDesc(int index, String desc, String option) {
    this.index = index;
    this.channelDescription = desc;
    this.channelSets = new ArrayList<ChannelSet>();
    this.option = option;
    this.option_argument = "";
  }
  
  public void addChannelSet(ChannelSet set) {
    this.channelSets.add(set);
  }

  public String toString() {
    String description = "Channel index " + this.index + addNecessaryTabs(5, "Channel index " + this.index + "") + "|||" +"\t" + this.channelDescription;
    if (option.equals("") == false) {
      description += "\t" + "(" + option + ")";
    }
    description += "\n";
    for (ChannelSet channelSet: channelSets) {
      description += "\t\t" + channelSet.toString() + "\n";
    }
    return description;
  }

  public int getIndex() {
    return index;
  }

  public String getChannelDescription() {
    return channelDescription;
  }

  public String getOption() {
    return this.option;
  }

  public String getOptionArgument() {
    return this.option_argument;
  }

  public ArrayList<ChannelSet> getAllChannelSets() {
    return channelSets;
   }

  public int getChannelLink() {
    return ch_link;
  }


  public void setOption(String option) {
    this.option = option;
  }

  public void setOptionArgument(String option_arg) {
    this.option_argument = option_arg;
  }  

  public void setChannelLink(int index) {
    ch_link = index;
  }
  
}

class ChannelSet {
  int from_dmx;
  int to_dmx;
  String subfunction;
  boolean proportional = false;
  boolean proportional_increasing = false;    // Not used if proportional is not set to true
  boolean recommended = false;                // This particular channel set is recommended - the set's base value, from_dmx, shall therefore be used as default value for the channel
  int range = -1;                             // Physical range of the parameter - for example, in a moving head, pan=540\u00b0, or tilt=270\u00b0
  
  ChannelSet(int rangeMin, int rangeMax, String subfunction) {
    this.from_dmx = rangeMin;
    this.to_dmx = rangeMax;
    this.subfunction = subfunction;
  }
  
  ChannelSet(int rangeMin, int rangeMax) {
    rangeMin = rangeMin;
    rangeMax = rangeMax;
    subfunction = "";
  }

  public void setRecommended(boolean val) {
    recommended = true;
  }

  public void set_proportional(String prop) {
    if (prop.equals("increasing") || prop.equals("Increasing")) {
      proportional = true;
      proportional_increasing = true;
    }
    else if (prop.equals("decreasing") || prop.equals("Decreasing")) {
      proportional = true;
      proportional_increasing = false;
    }
    else {
      proportional = false;
      proportional_increasing = false;
    }
  }

  public void setChannelRange(int range) {
    this.range = range;
  }

  public String getSubfunction() {
    return subfunction;
  }

  public int getFrom_dmx() {
    return from_dmx;
  }

  public int getTo_dmx() {
    return to_dmx;
  }

  public boolean isProportional() {
    return proportional;
  }

  public boolean isProportional_Increasing() {
    return proportional_increasing;
  }

  public boolean isRecommended() {
    return recommended;
  }

  public int getChannelRange() {
    return range;
  }


  public String toString() {
    String description = "Function:" + "\t" + this.subfunction;
    description += addNecessaryTabs(7, this.subfunction);
    description += "From:\t" + this.from_dmx;
    description += addNecessaryTabs(2, this.from_dmx + "");
    description += "To:\t" + this.to_dmx;
    description += addNecessaryTabs(2, this.to_dmx + "");
    if (this.proportional) {
      description += "\tproportional=";
      if (this.proportional_increasing) {
        description += "increasing";
      }
      else {
        description += "decreasing";
      }
    }
    if (this.recommended == true) {
      description += "\trecommended=true";
    }
    
    return description;
  }


}


// Small tool used to format text
public String addNecessaryTabs(int maxTab, String text) {
  String tabs = "";
  for (int a=0; a<max(0, (maxTab - ( text.length() ) / 4 )); a++) {
    tabs += "\t";
  }
  return tabs;
}

//////////////////////////////////////////////////////////////
// Create a GUI to allow easy management of the application //
//////////////////////////////////////////////////////////////







public ControlP5 cp5;                     //GUI controller
public ControlFrame auxControlFrame;      //Second window to display the GUI into

PFont minimlFont;
PFont minimlFontMedium;
PFont minimlFontBig;

boolean DISPLAY_GUI = true;

boolean gui_activateSimulator = false;
boolean gui_activateAudioMonitoring = false;
boolean gui_initComplete = false;

boolean gui_changePanelMappingActive = false;
int tempLEDPanelMapping_counter = 0;
int[] tempLEDPanelMapping_array;

PImage gui_blackLogo, gui_whiteLogo, gui_glitchWhiteLogo, gui_glitchBlackLogo;
ArrayList<PanelSimulator> gui_panelSimulatorList;
ArrayList<RackLight> gui_rackLightList;
ArrayList<LEDTube> gui_LEDTubeList;

final int gui_width                      = 900;
final int gui_height                     = 750;

int gui_backgroundBrightness             = 45;
final int gui_simulatorPosX              = 10;
final int gui_simulatorPosY              = 80;
final int gui_simulatorWidth             = 576;
final int gui_panelsimuWidth             = 430;
final int gui_simulatorHeight            = 350;
final int gui_informationsAccordionPosY  = 10;
final int gui_spacing                    = 10;
final int gui_simulatorTextCenterX       = 300;
final int gui_simulatorTextMainY         = 170;
final int gui_simulatorTextSubY          = 210;

final int gui_audioMonitoringGroupOffsetX = (gui_simulatorPosX + gui_simulatorWidth + gui_spacing);
final int gui_audioMonitoringGroupWidth   = gui_width - (gui_simulatorPosX + gui_simulatorWidth + 2*gui_spacing);
final int gui_audioMonitoringToggleWidth  = 140;
final int gui_audioMonitoringToggleHeight = 20;    

//Attributes for the LED Panel animations
final int GUI_ATTR_LEDPANEL_GEOMETRIC   = 0;
final int GUI_ATTR_LEDPANEL_ATMOSPHERIC = 1;
final int GUI_ATTR_LEDPANEL_FADE_IN_OUT = 2;
final int GUI_ATTR_LEDPANEL_RANDOM      = 3;
final int GUI_ATTR_LEDPANEL_VERY_BRIGHT = 4;
final int GUI_ATTR_LEDPANEL_VERY_DARK   = 5;
final int GUI_ATTR_LEDPANEL_RED         = 6;
final int GUI_ATTR_LEDPANEL_B_W         = 7;
final int GUI_ATTR_LEDPANEL_BLUE        = 8;
final int GUI_ATTR_LEDPANEL_COLORFUL    = 9;   
final int GUI_ATTR_LEDPANEL_ROTATING    = 10;       
final int GUI_ATTR_LEDPANEL_SIMPLE      = 11;
final int GUI_ATTR_LEDPANEL_COMPLEX     = 12;
final int GUI_ATTR_LEDPANEL_EVOLVING    = 13;
final int GUI_ATTR_LEDPANEL_SMOOTH      = 14;
final int GUI_ATTR_LEDPANEL_VIOLENT     = 15;
final int GUI_ATTR_LEDPANEL_RHYTHMIC    = 16;
final int GUI_ATTR_LEDPANEL_FAST        = 17;
final int GUI_ATTR_LEDPANEL_SLOW        = 18;
final int GUI_ATTR_LEDPANEL_STILL       = 19;
final int GUI_ATTR_LEDPANEL_LINES       = 20;
final int GUI_ATTR_LEDPANEL_CURVES      = 21;
final int GUI_ATTR_LEDPANEL_TRIANGLES   = 22;
final int GUI_ATTR_LEDPANEL_SQUARES     = 23;
final int GUI_ATTR_LEDPANEL_CIRCLES     = 24;
final int GUI_ATTR_LEDPANEL_SPIRAL      = 25;       
final int GUI_ATTR_LEDPANEL_NOISE       = 26;
final int GUI_ATTR_LEDPANEL_OBJECTS     = 27;   
final int GUI_ATTR_LEDPANEL_SPECIAL     = 28;
final int GUI_ATTR_LEDPANEL_AUDIO       = 29;
final int GUI_ATTR_LEDPANEL_GAME        = 30;
final int GUI_ATTR_LEDPANEL_3D          = 31;

//Attributes for the Custom device animations
final int GUI_ATTR_CUSTOMDEV_ALLDEVICES    = 0;
final int GUI_ATTR_CUSTOMDEV_RACKLIGHTS    = 1;
final int GUI_ATTR_CUSTOMDEV_LEDTUBES      = 2;
final int GUI_ATTR_CUSTOMDEV_BLACK         = 3;
final int GUI_ATTR_CUSTOMDEV_WHITE         = 4;
final int GUI_ATTR_CUSTOMDEV_RED           = 5;
final int GUI_ATTR_CUSTOMDEV_BLUE          = 6;
final int GUI_ATTR_CUSTOMDEV_RAINBOW       = 7;
final int GUI_ATTR_CUSTOMDEV_RANDOM        = 8;
final int GUI_ATTR_CUSTOMDEV_FAST          = 9;
final int GUI_ATTR_CUSTOMDEV_MEDUM         = 10;
final int GUI_ATTR_CUSTOMDEV_SLOW          = 11;
final int GUI_ATTR_CUSTOMDEV_VERYSLOW      = 12;
final int GUI_ATTR_CUSTOMDEV_LONG          = 13;
final int GUI_ATTR_CUSTOMDEV_SHORT         = 14;
final int GUI_ATTR_CUSTOMDEV_PLAIN         = 15;
final int GUI_ATTR_CUSTOMDEV_FLASH         = 16;
final int GUI_ATTR_CUSTOMDEV_SMOOTHSINE    = 17;
final int GUI_ATTR_CUSTOMDEV_STROBOSCOPE   = 18;
final int GUI_ATTR_CUSTOMDEV_GROWINGSTROBE = 19;
final int GUI_ATTR_CUSTOMDEV_WAVE          = 20;
final int GUI_ATTR_CUSTOMDEV_BUILDUP       = 21;
final int GUI_ATTR_CUSTOMDEV_NOISE         = 22;
final int GUI_ATTR_CUSTOMDEV_SMOOTHNOISE   = 23;
final int GUI_ATTR_CUSTOMDEV_LEFTSIDE      = 24;
final int GUI_ATTR_CUSTOMDEV_RIGHTSIDE     = 25;

//Attributes for the DMX animations
final int GUI_ATTR_DMX_STROBE_ALL       = 0;
final int GUI_ATTR_DMX_STROBE_RIGHT     = 1;
final int GUI_ATTR_DMX_STROBE_LEFT      = 2;
final int GUI_ATTR_DMX_STROBE_CENTER    = 3;
final int GUI_ATTR_DMX_STROBE_RHYTHMIC  = 4;
final int GUI_ATTR_DMX_STROBE_STROBE    = 5;
final int GUI_ATTR_DMX_STROBE_PAR       = 6;
final int GUI_ATTR_DMX_STROBE_VERYSLOW  = 7;
final int GUI_ATTR_DMX_STROBE_SLOW      = 8;
final int GUI_ATTR_DMX_STROBE_MEDIUM    = 9;
final int GUI_ATTR_DMX_STROBE_FAST      = 10;
final int GUI_ATTR_DMX_STROBE_VERYFAST  = 11;
final int GUI_ATTR_DMX_STROBE_AUDIO     = 12;
final int GUI_ATTR_DMX_STROBE_ATOMIC    = 13;

final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_ALL           = 0;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_LEFT          = 1;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_RIGHT         = 2;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_SIDE          = 3;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_CENTER        = 4;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_UNIFORM       = 5;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_DIVERGENT     = 6;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_CONVERGENT    = 7;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_SYMMETRICAL   = 8;
final int GUI_ATTR_DMX_MOVINGHEAD_MOVE_SUN           = 9;

final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_ALL          = 0;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_LEFT         = 1;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_RIGHT        = 2;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_SIDE         = 3;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_CENTER       = 4;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_WHITE        = 5;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_RED          = 6;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_DEEPRED      = 7;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_BLUE         = 8;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_DEEPBLUE     = 9;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_YELLOW       = 10;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_GREEN        = 11;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_ULTRAVIOLET  = 12;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_ORANGE       = 13;
final int GUI_ATTR_DMX_MOVINGHEAD_COLOR_CTO          = 14;

final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_ALL         = 0;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_LEFT        = 1;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_RIGHT       = 2;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_SIDE        = 3;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_CENTER      = 4;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_NOSYNC      = 5;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_TOGETHER    = 6;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_CLOCK       = 7;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_ANTICLOCK   = 8;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_RANDOM      = 9;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_32ND        = 10;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_16TH        = 11;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_8TH         = 12;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_4TH         = 13;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_2ND         = 14;
final int GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_BAR         = 15;

final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_ALL          = 0;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_LEFT         = 1;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_RIGHT        = 2;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_SIDE         = 3;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_CENTER       = 4;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_STILL        = 5;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_CRESCENDO    = 6;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_FLASH        = 7;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_STROBE       = 8;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_SINE         = 9;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_GLITCH       = 10;
final int GUI_ATTR_DMX_MOVINGHEAD_LIGHT_TIGHT        = 11;


final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_ALL           = 0;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_LEFT          = 1;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_RIGHT         = 2;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_SIDE          = 3;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_CENTER        = 4;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_STILL         = 5;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_FASTMOVE      = 6;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_CONTSWEEP     = 7;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_SINGSWEEP     = 8;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_RANDOM        = 9;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_PARALLEL      = 10;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_DIVERGENT     = 11;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_CONVERGENT    = 12;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_HORIZONTAL    = 13;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_VERTICAL      = 14;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_SLOW          = 15;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_REGULAR       = 16;
final int GUI_ATTR_DMX_MOVINGHEAD_ANIM_FAST          = 17;




final int audioMonitoring_barWidth                 = 90;
final int audioMonitoring_barHeight                = 10;
final float audioMonitoring_maxSignalLevel_Kick    = 1.0f;
final float audioMonitoring_maxSignalLevel_Snare   = 0.3f;
final float audioMonitoring_maxSignalLevel_Cymbals = 0.3f;
final float audioMonitoring_maxSignalLevel_Bass    = 3.0f;
final float audioMonitoring_maxSignalLevel_Keys    = 1.2f;
final float audioMonitoring_maxSignalLevel_Guitar  = 1.2f;

final int FRAMERATE_NOSIMU = 8;
final int FRAMERATE_SIMU   = 24;


public void setup_gui() {
  
  //Initialize images which shall be used by the control frame
  gui_blackLogo  = loadImage("GUI/logo_black.png");
  gui_whiteLogo  = loadImage("GUI/logo_white.png");
  gui_glitchWhiteLogo = loadImage("GUI/logo_glitchwhite.png");
  gui_glitchBlackLogo = loadImage("GUI/logo_glitchblack.png");
  
  //Initialize the font used for text areas
  minimlFont       = loadFont("Miniml-Standard0757-8.vlw");
  minimlFontMedium = loadFont("Miniml-Standard0757-20.vlw");
  minimlFontBig    = loadFont("Miniml-Standard0757-48.vlw");
  
  cp5 = new ControlP5(this);
  // Create a controlFrame by using addControlFrame, this creates a new separate frame
  addControlFrame("Strobot - Controls", gui_width, gui_height);
  
}


public void addControlFrame(String _name, int _width, int _height) {
  Frame auxFrame = new Frame(_name);
  auxControlFrame = new ControlFrame(this, _width, _height);
  auxFrame.add(auxControlFrame);
  auxControlFrame.init();
  auxFrame.setTitle(_name);
  auxFrame.setSize(auxControlFrame.w, auxControlFrame.h);
  auxFrame.setLocation(0, 0);
  auxFrame.setResizable(false);
  auxFrame.setVisible(true);
  auxControlFrame.frameRate(FRAMERATE_NOSIMU);    // Put a limit on the GUI's framerate - very important in order to limit the CPU usage
}


// the ControlFrame class extends PApplet : we are creating a new processing applet inside a new frame with a controlP5 object loaded
public class ControlFrame extends PApplet {

  int w, h;

  ControlP5 cp5;

  Object parent;
  
  
  controlP5.Button gui_mainLogo;
  controlP5.Accordion generalInfoAccordion;
  controlP5.Accordion customDevicesDMXAnimationListsAccordion;
  controlP5.Toggle changeLEDPanelMappingToggle;
  controlP5.Toggle setAutomaticModeToggle;
  controlP5.Toggle setAudioMonitoringToggle;
  ArrayList<Bang> changeLEDPanelMappingBangList;
  
  controlP5.Textlabel resetExpectedTextLabel;
  controlP5.Textlabel inactiveAudioMonitoringTextLabel;
  controlP5.Textlabel audioMonitoringKickTextLabel;
  controlP5.Textlabel audioMonitoringSnareTextLabel;
  controlP5.Textlabel audioMonitoringCymbalsTextLabel;
  controlP5.Textlabel audioMonitoringBassTextLabel;
  controlP5.Textlabel audioMonitoringKeysTextLabel;
  controlP5.Textlabel audioMonitoringGuitarTextLabel;

  //TO BE DELETED
  //controlP5.Button add_FrontLeftStrobo;
  //controlP5.Button add_FrontRightStrobo;
  controlP5.Button add_LEDTube;
  controlP5.Button add_RackLight;
  controlP5.Button add_DMXFixture;
  controlP5.Button remove_DMXFixture;
  //controlP5.Button add_BackStrobo;
 
  controlP5.CheckBox LEDPanelAnimations_animationListCheckBox;
  controlP5.CheckBox CustomDeviceAnimations_animationListCheckBox;
  controlP5.CheckBox DMXStrobeAnimations_animationListCheckBox;
  controlP5.CheckBox DMXMovingHeadAnimations_Movement_animationListCheckBox;
  controlP5.CheckBox DMXMovingHeadAnimations_Color_animationListCheckBox;
  controlP5.CheckBox DMXMovingHeadAnimations_Rhythm_animationListCheckBox;
  controlP5.CheckBox DMXMovingHeadAnimations_LightStyle_animationListCheckBox;
  controlP5.CheckBox DMXMovingHeadAnimations_Animations_animationListCheckBox;
  controlP5.Button LEDPanelAnimations_reinitButton;
  controlP5.Button CustomDeviceAnimations_reinitButton;
  controlP5.Button DMXStrobeAnimations_reinitButton;
  controlP5.Button DMXMovingHeadAnimations_Movement_reinitButton;
  controlP5.Button DMXMovingHeadAnimations_Color_reinitButton;
  controlP5.Button DMXMovingHeadAnimations_Rhythm_reinitButton;
  controlP5.Button DMXMovingHeadAnimations_LightStyle_reinitButton;
  controlP5.Button DMXMovingHeadAnimations_Animations_reinitButton;
  controlP5.ListBox LEDPanelAnimations_animationListBox;
  controlP5.ListBox CustomDeviceAnimations_animationListBox;
  controlP5.ListBox DMXStrobeAnimations_animationListBox;
  controlP5.ListBox DMXMovingHeadAnimations_Movement_animationListBox;
  controlP5.ListBox DMXMovingHeadAnimations_Color_animationListBox;
  controlP5.ListBox DMXMovingHeadAnimations_Rhythm_animationListBox;
  controlP5.ListBox DMXMovingHeadAnimations_LightStyle_animationListBox;
  controlP5.ListBox DMXMovingHeadAnimations_Animations_animationListBox;
  controlP5.Textarea LEDPanelAnimations_currentAnimationDescription;
  controlP5.Textarea CustomDeviceAnimations_currentAnimationDescription;
  controlP5.Textarea DMXStrobeAnimations_currentAnimationDescription;
  controlP5.Textarea DMXMovingHeadAnimations_Movement_currentAnimationDescription;
  controlP5.Textarea DMXMovingHeadAnimations_Color_currentAnimationDescription;
  controlP5.Textarea DMXMovingHeadAnimations_Rhythm_currentAnimationDescription;
  controlP5.Textarea DMXMovingHeadAnimations_LightStyle_currentAnimationDescription;
  controlP5.Textarea DMXMovingHeadAnimations_Animations_currentAnimationDescription;
  
  Group effectsInfo;
  
  ControlGroup GUIMessageBox;
  int GUIMessageBoxResult = -1;
  String GUIMessageBoxString = "";
  
  public ControlFrame(Object theParent, int _width, int _height) {
    parent = theParent;
    w = _width;
    h = _height;
  }


  public ControlP5 control() {
    return cp5;
  }
  
  public void setup() {
    size(w, h);
    frameRate(60);
    
    cp5 = new ControlP5(this);    
    
    createGuiHeaderElements();
    createGeneralInfoAccordion();
    createLEDPanelAnimationListGroup();
    //createCustomDeviceAnimationListGroup();
    
    createCustomDeviceAndDMXAccordion();
    
    createAudioMonitoringGroup();
    
    init_panelSimulatorList();
    init_customDevicesSimulatorList();
    
    gui_initComplete = true;
    
  }

  public void draw() {
    background(color(gui_backgroundBrightness));
    if (gui_activateSimulator) {
      draw_simulator(gui_simulatorPosX,gui_simulatorPosY);
    }
    else {
      fill(255);
      textAlign(CENTER, CENTER);
      textFont(minimlFontBig, 48);
      text("SIMULATOR DEACTIVATED", gui_simulatorTextCenterX, gui_simulatorTextMainY);
      textFont(minimlFontMedium, 20);
      text("ACTIVATE THE SIMULATOR BY CLICKING ON THE XI LOGO", gui_simulatorTextCenterX, gui_simulatorTextSubY);
    }
    
    if (gui_activateAudioMonitoring) {
      draw_audioMonitoring(gui_audioMonitoringGroupOffsetX + gui_spacing, 22*gui_height/30 + 4*gui_spacing, 10);
    }
  }
  

  
  //Add mouse wheel support for all elements on the control panel
  public void mouseWheel(MouseEvent event) {
    cp5.setMouseWheelRotation(event.getCount());
  }
  
  //If an effect is currently active, release it (important for the effect bangs)
  public void mouseReleased() {
    deactivateAdditionalEffect(1);
  }
  
  ////////////////////////////////////////////////////////////////
  // Create the header GUI elements
  //  
  
  public void createGuiHeaderElements() {
    
    int autoModeToggleWidth  = 180;
    int autoModeToggleHeight = 36;
    
    gui_mainLogo = cp5.addButton("Activate Simulator")
                      .setSwitch(true)
                      .setPosition(gui_spacing,gui_spacing)
                      .setImages(gui_whiteLogo, gui_glitchWhiteLogo, gui_glitchBlackLogo, gui_blackLogo)
                      .updateSize();
    
    
    //Add a toggle to set the automatic mode
    setAutomaticModeToggle = cp5.addToggle("Auto Mode")
                                .setValue(0)
                                .setCaptionLabel("Auto Mode")
                                .setPosition(gui_simulatorWidth - autoModeToggleWidth, 15)
                                .setSize(autoModeToggleWidth, autoModeToggleHeight)
                                .setColorBackground(color(100,0,0))
                                .setColorForeground(color(130,0,0))
                                .setColorActive(color(160,0,0))
                                ;
    setAutomaticModeToggle.getCaptionLabel().setFont(minimlFontMedium);
    //setAutomaticModeToggle.getCaptionLabel().setColor(255);
    setAutomaticModeToggle.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
  }

  ////////////////////////////////////////////////////////////////
  // Create the General Informations accordion
  //  


  public Accordion createGeneralInfoAccordion() {

    int textfieldHeight   = 10;
    int textfieldWidth    = 25;
    int bigTextfieldWidth = 100;
    int spacingRow        = 3;
    int leftOffset        = 6;
    int toggleHeight      = 9;
    int toggleWidth       = 100;
    
    
    int accordionWidth    = width - (gui_simulatorPosX + gui_simulatorWidth + 2*gui_spacing);
    int generalInformationsHeight   = 477;
    
    int nbrOfPanelsTextFieldPosY = gui_spacing + 0*spacingRow;
    int DMXTextLabelPosY = 150;
    int CustomDevicesTextLabelPosY = 320; 
    int warningTextLabelPosY = generalInformationsHeight - 2*textfieldHeight - 2*spacingRow;
    int panelConfigBangPosY = nbrOfPanelsTextFieldPosY + toggleHeight + spacingRow;
    int panelConfigBangSize = 15;
    
    
    // group number 1, contains information on the current hardware 
    Group hardwareInfo = cp5.addGroup("Hardware Informations")
                            .setBackgroundColor(color(0, 64))
                            .setBackgroundHeight(generalInformationsHeight)
                            ;
    
    
       
    changeLEDPanelMappingToggle = cp5.addToggle("Change Panel Mapping")
                                         .setValue(0)
                                         .setCaptionLabel("Change Panel Mapping")
                                         .setPosition(leftOffset, nbrOfPanelsTextFieldPosY)
                                         .setSize(toggleWidth, toggleHeight)
                                         .setColorBackground(color(110,0,0))
                                         .setColorForeground(color(150,0,0))
                                         .setColorActive(color(190,0,0))
                                         .moveTo(hardwareInfo)
                                         ;
    changeLEDPanelMappingToggle.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
    
    changeLEDPanelMappingBangList = new ArrayList<Bang>();
    for (int i=0; i<NUMBER_OF_PANELS;i++) {
      Bang temp = cp5.addBang("Mapping Config Bang - Panel " + i)
                                           .setPosition((i+1)*leftOffset + i*panelConfigBangSize,panelConfigBangPosY)
                                           .setSize(panelConfigBangSize,panelConfigBangSize)
                                           .moveTo(hardwareInfo)
                                           //.setColorForeground(color(4,104,154))    //Shall be set to this color once active
                                           //.setColorActive(color(0,180,234))        //Shall be set to this color once active
                                           .setColorForeground(color(150))
                                           .setColorActive(color(150))
                                           .setCaptionLabel(str(i+1));
      temp.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
      changeLEDPanelMappingBangList.add(temp);
    }
    
    cp5.addTextfield("Number Of Panels")
       .setPosition(accordionWidth - textfieldWidth - leftOffset,nbrOfPanelsTextFieldPosY)
       .setSize(textfieldWidth,textfieldHeight)
       .setValue(str(NUMBER_OF_PANELS))
       .setCaptionLabel("Number Of Panels:    ")
       .setAutoClear(false)
       .moveTo(hardwareInfo)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
     
     
    cp5.addTextfield("DMX Microcontroller")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset,nbrOfPanelsTextFieldPosY + 3*spacingRow + 3*textfieldHeight)
       .setSize(bigTextfieldWidth,textfieldHeight)
       .setValue(DMX_MICROCONTROLLER_NAME.substring(5, DMX_MICROCONTROLLER_NAME.length()))
       .setCaptionLabel("DMX Microcontroller:    ")
       .setAutoClear(false)
       .setFont(minimlFont)
       .moveTo(hardwareInfo)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
     
    cp5.addTextfield("Custom Devices Microcontroller")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset,nbrOfPanelsTextFieldPosY + 4*spacingRow + 4*textfieldHeight)
       .setSize(bigTextfieldWidth,textfieldHeight)
       .setValue(CUSTOMDEVICES_MICROCONTROLLER_NAME.substring(5, CUSTOMDEVICES_MICROCONTROLLER_NAME.length()))
       .setCaptionLabel("Custom Devices Microcontroller:    ")
       .setAutoClear(false)
       .setFont(minimlFont)
       .moveTo(hardwareInfo)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
    

    int offsetY_2 = nbrOfPanelsTextFieldPosY + 5*spacingRow + 5*textfieldHeight; 
    for (int i=0; i<NUMBER_OF_PANELS; i++) {
      cp5.addTextfield("LED Panel Microcontroller " + i)
         .setPosition(accordionWidth - bigTextfieldWidth - leftOffset,offsetY_2)
         .setSize(bigTextfieldWidth,textfieldHeight)
         .setValue(devicesToParse[i].substring(5, devicesToParse[i].length()))
         .setCaptionLabel("LED Panel Microcontroller " + (i+1) + ":    ")
         .setAutoClear(false)
         .setFont(minimlFont)
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
         ;
      offsetY_2 += spacingRow + textfieldHeight;
    }
    
    
    int offsetY = DMXTextLabelPosY;
    cp5.addTextlabel("DMX Info")
       .setText("DMX STROBE CHANNELS : (SPD, INTSTY) OR (INTSTY, LNGTH, SPD, SFX)")
       .setPosition(leftOffset,offsetY)
       .setFont(minimlFont)
       .moveTo(hardwareInfo)
       ;
    offsetY += textfieldHeight;
    cp5.addTextlabel("DMX Info 2")
       .setText("REMOVE A DEVICE BY SETTING IT TO (0,0,0,0) or (0,0)")
       .setPosition(leftOffset,offsetY)
       .setFont(minimlFont)
       .moveTo(hardwareInfo)
       ;
    offsetY += textfieldHeight + 2*spacingRow;
    
    for (int i=0; i<DMXList_FrontLeftStroboscopes.size(); i++) {
      DMX_Stroboscope stroboscope = DMXList_FrontLeftStroboscopes.get(i);
      String fieldValue;
      if (stroboscope.numberOfChannels == 2) {
        fieldValue = "(" + stroboscope.DMXAddress_stroboscopeSpeed + "," + stroboscope.DMXAddress_stroboscopeBrightness + ")";
      } 
      else {
        fieldValue = "(" + stroboscope.DMXAddress_stroboscopeBrightness + "," + stroboscope.DMXAddress_stroboscopeFlashLength + "," + stroboscope.DMXAddress_stroboscopeSpeed + "," + stroboscope.DMXAddress_stroboscopeSpecialFX + ")";
      }
      cp5.addTextfield("Left Strobe " + i)
         .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, offsetY)
         .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
         .setValue(fieldValue)
         .setFont(minimlFont)
         .setCaptionLabel("Left Strobe " + (i+1) + " :    ")
         .setAutoClear(false)
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
         ;
      cp5.addToggle("Test FrontLeftStroboscope " + i)
         .setValue(0)
         .setLabelVisible(false)
         .setPosition(accordionWidth - 2*textfieldHeight, offsetY)
         .setSize(2*textfieldHeight - leftOffset, textfieldHeight)
         .setColorForeground(color(4,104,154))
         .setColorActive(color(0,180,234))
         .setColorActive(color(120,0,0))
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER)
         ;
      offsetY += textfieldHeight + spacingRow;
    }
    for (int i=0; i<DMXList_FrontRightStroboscopes.size(); i++) {
      DMX_Stroboscope stroboscope = DMXList_FrontRightStroboscopes.get(i);
      String fieldValue;
      if (stroboscope.numberOfChannels == 2) {
        fieldValue = "(" + stroboscope.DMXAddress_stroboscopeSpeed + "," + stroboscope.DMXAddress_stroboscopeBrightness + ")";
      } 
      else {
        fieldValue = "(" + stroboscope.DMXAddress_stroboscopeBrightness + "," + stroboscope.DMXAddress_stroboscopeFlashLength + "," + stroboscope.DMXAddress_stroboscopeSpeed + "," + stroboscope.DMXAddress_stroboscopeSpecialFX + ")";
      }
      cp5.addTextfield("Right Strobe " + i)
         .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, offsetY)
         .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
         .setValue(fieldValue)
         .setFont(minimlFont)
         .setCaptionLabel("Right Strobe " + (i+1) + " :    ")
         .setAutoClear(false)
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
         ;
      cp5.addToggle("Test FrontRightStroboscope " + i)
         .setValue(0)
         .setLabelVisible(false)
         .setPosition(accordionWidth - 2*textfieldHeight, offsetY)
         .setSize(2*textfieldHeight - leftOffset, textfieldHeight)
         .setColorForeground(color(4,104,154))
         .setColorActive(color(0,180,234))
         .setColorActive(color(120,0,0))
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER)
         ;
      offsetY += textfieldHeight + spacingRow;
    }
    for (int i=0; i<DMXList_BackStroboscopes.size(); i++) {
      DMX_Stroboscope stroboscope = DMXList_BackStroboscopes.get(i);
      String fieldValue;
      if (stroboscope.numberOfChannels == 2) {
        fieldValue = "(" + stroboscope.DMXAddress_stroboscopeSpeed + "," + stroboscope.DMXAddress_stroboscopeBrightness + ")";
      } 
      else {
        fieldValue = "(" + stroboscope.DMXAddress_stroboscopeBrightness + "," + stroboscope.DMXAddress_stroboscopeFlashLength + "," + stroboscope.DMXAddress_stroboscopeSpeed + "," + stroboscope.DMXAddress_stroboscopeSpecialFX + ")";
      }
      cp5.addTextfield("Back Strobe " + i)
         .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, offsetY)
         .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
         .setValue(fieldValue)
         .setFont(minimlFont)
         .setCaptionLabel("Back Strobe " + (i+1) + " :    ")
         .setAutoClear(false)
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
         ;
      cp5.addToggle("Test BackStroboscope " + i)
         .setValue(0)
         .setLabelVisible(false)
         .setPosition(accordionWidth - 2*textfieldHeight, offsetY)
         .setSize(2*textfieldHeight - leftOffset, textfieldHeight)
         .setColorForeground(color(4,104,154))
         .setColorActive(color(0,180,234))
         .setColorActive(color(120,0,0))
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER)
         ;         
      offsetY += textfieldHeight + spacingRow;
    }
    
    
    /*
    add_FrontLeftStrobo = cp5.addButton("Add Front Left Strobe")
                         .setValue(0)
                         .setCaptionLabel("Add Front Left Strobe")
                         .setPosition(leftOffset, DMXTextLabelPosY + 2*textfieldHeight + 2*spacingRow)
                         .setSize(toggleWidth, toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    add_FrontLeftStrobo.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    add_FrontRightStrobo = cp5.addButton("Add Front Right Strobe")
                         .setValue(0)
                         .setCaptionLabel("Add Front Right Strobe")
                         .setPosition(leftOffset, DMXTextLabelPosY + 3*textfieldHeight + 3*spacingRow)
                         .setSize(toggleWidth, toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    add_FrontRightStrobo.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    add_BackStrobo = cp5.addButton("Add Back Strobe")
                         .setValue(0)
                         .setCaptionLabel("Add Back Strobe")
                         .setPosition(leftOffset, DMXTextLabelPosY + 4*textfieldHeight + 4*spacingRow)
                         .setSize(toggleWidth, toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    add_BackStrobo.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    */
    
    add_DMXFixture  = cp5.addButton("Add DMX Fixture")
                         .setValue(0)
                         .setCaptionLabel("\n\nAdd DMX\n\n Fixture")
                         .setPosition(leftOffset, DMXTextLabelPosY + 2*textfieldHeight + 2*spacingRow)
                         .setSize(toggleWidth, 8*toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    add_DMXFixture.getCaptionLabel().align(ControlP5.CENTER, ControlP5.UP)
                                    .setSize(12)
                                    ;
    
    remove_DMXFixture = cp5.addButton("Remove DMX Fixture")
                         .setValue(0)
                         .setCaptionLabel("\nRemove DMX\n\n     Fixture")
                         .setPosition(leftOffset, DMXTextLabelPosY + 2*textfieldHeight + 9*toggleHeight + 3*spacingRow)
                         .setSize(toggleWidth, 5*toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    remove_DMXFixture.getCaptionLabel().align(ControlP5.CENTER, ControlP5.UP)
                                       .setSize(12)
                                       ;
    
    offsetY = CustomDevicesTextLabelPosY;
    cp5.addTextlabel("Custom devices Info")
       .setText("CUSTOM DEVICES : DEVICE NUMBER")
       .setPosition(leftOffset,offsetY)
       .setFont(minimlFont)
       .moveTo(hardwareInfo)
       ;
    offsetY += textfieldHeight;
    cp5.addTextlabel("Custom devices Info 2")
       .setText("REMOVE A DEVICE BY SETTING IT TO -1")
       .setPosition(leftOffset,offsetY)
       .setFont(minimlFont)
       .moveTo(hardwareInfo)
       ;
    offsetY += textfieldHeight + 2*spacingRow;

    for (int i=0; i<CustomDeviceList_LEDTubes.size(); i++) {
      CustomDevice_LEDTube ledTube = CustomDeviceList_LEDTubes.get(i);
      String fieldValue = str(ledTube.CustomDevice_deviceNumber);
      cp5.addTextfield("LED Tube " + i)
         .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, offsetY)
         .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
         .setValue(fieldValue)
         .setFont(minimlFont)
         .setCaptionLabel("LED Tube " + (i+1) + " :    ")
         .setAutoClear(false)
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
         ;
      cp5.addToggle("Test LEDTube " + i)
         .setValue(0)
         .setLabelVisible(false)
         .setPosition(accordionWidth - 2*textfieldHeight, offsetY)
         .setSize(2*textfieldHeight - leftOffset, textfieldHeight)
         .setColorForeground(color(4,104,154))
         .setColorActive(color(0,180,234))
         .setColorActive(color(120,0,0))
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER)
         ;         
      offsetY += textfieldHeight + spacingRow;
    }
    
    for (int i=0; i<CustomDeviceList_RackLights.size(); i++) {
      CustomDevice_RackLight rackLight = CustomDeviceList_RackLights.get(i);
      String fieldValue = str(rackLight.CustomDevice_deviceNumber);
      cp5.addTextfield("Rack Light " + i)
         .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, offsetY)
         .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
         .setValue(fieldValue)
         .setFont(minimlFont)
         .setCaptionLabel("Rack Light " + (i+1) + " :    ")
         .setAutoClear(false)
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
         ;
      cp5.addToggle("Test RackLight " + i)
         .setValue(0)
         .setLabelVisible(false)
         .setPosition(accordionWidth - 2*textfieldHeight, offsetY)
         .setSize(2*textfieldHeight - leftOffset, textfieldHeight)
         .setColorForeground(color(4,104,154))
         .setColorActive(color(0,180,234))
         .setColorActive(color(120,0,0))
         .moveTo(hardwareInfo)
         .getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER)
         ;
      offsetY += textfieldHeight + spacingRow;
    }

    add_LEDTube = cp5.addButton("Add LED Tube")
                         .setValue(0)
                         .setCaptionLabel("Add LED Tube")
                         .setPosition(leftOffset, CustomDevicesTextLabelPosY + 2*textfieldHeight + 2*spacingRow)
                         .setSize(toggleWidth, toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    add_LEDTube.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    add_RackLight = cp5.addButton("Add Rack Light")
                         .setValue(0)
                         .setCaptionLabel("Add Rack Light")
                         .setPosition(leftOffset, CustomDevicesTextLabelPosY + 3*textfieldHeight + 3*spacingRow)
                         .setSize(toggleWidth, toggleHeight)
                         .setColorBackground(color(110,0,0))
                         .setColorForeground(color(150,0,0))
                         .setColorActive(color(190,0,0))
                         .moveTo(hardwareInfo)
                         ;
    add_RackLight.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);

    //Hidden label which appears only when changes requiring a restart are needed
    resetExpectedTextLabel = cp5.addTextlabel("Reset Expected")
                                .setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nCRITICAL PARAMETERS HAVE BEEN CHANGED")
                                .setPosition(leftOffset,warningTextLabelPosY)
                                .setColorValue(color(210,0,0))
                                .moveTo(hardwareInfo)
                                ;
    resetExpectedTextLabel.setVisible(false);
     
     
     
     
    // Group number 2, contains information regarding MIDI input
    Group midiInfo = cp5.addGroup("MIDI Informations")
                        .setBackgroundColor(color(0, 64))
                        .setBackgroundHeight(generalInformationsHeight)
                        ;    
    
    
    Textfield gui_mainInputTextfield = cp5.addTextfield("Main Input")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset,leftOffset)
       .setSize(bigTextfieldWidth,textfieldHeight)
       .setValue(MIDI_BUS_MAIN_INPUT)
       .setFont(minimlFont)
       .setCaptionLabel("Main Input (IAC Bus) :    ")
       .setAutoClear(false)
       .moveTo(midiInfo)
       ;
    
    gui_mainInputTextfield.getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER);
    
    cp5.addTextfield("Keyboard")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset,leftOffset + textfieldHeight + spacingRow)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(MIDI_BUS_KEYBOARD_INPUT)
       .setFont(minimlFont)
       .setCaptionLabel("Keyboard :    ")
       .setAutoClear(false)
       .moveTo(midiInfo)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
   cp5.addTextfield("General FX Controller")
      .setPosition(accordionWidth - bigTextfieldWidth - leftOffset,leftOffset + 2*textfieldHeight + 2*spacingRow)
      .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
      .setValue(MIDI_BUS_CONTROLLER_INPUT)
      .setFont(minimlFont)
      .setCaptionLabel("General FX Controller :    ")
      .setAutoClear(false)
      .moveTo(midiInfo)
      .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
      ;
    
    String gui_incomingMsgList =  "/////////////////////////////\n" +
                                  "// Listening on the Main Input Bus : \n" +
                                  "\n" +
                                  "\n" +
                                  "ACTIVATE AUTOMATIC MODE\n" +
                                  "DISABLE AUTOMATIC MODE\n" +
                                  "\n" +
                                  "PANEL ANIMATION BANK 1\n" +
                                  "PANEL ANIMATION BANK 2\n" +
                                  "PANEL ANIMATION BANK 3\n" +
                                  "PANEL ANIMATION BANK 4\n" +
                                  "PANEL IMAGE BANK 1\n" +
                                  "ACTIVATE PANEL EFFECT\n" +
                                  "DMX ANIMATION BANK 1\n" +
                                  "DMX ANIMATION BANK 2\n" +
                                  "DMX ANIMATION BANK 3\n" +
                                  "CUSTOM DEVICE BANK 1\n" +
                                  "CUSTOM DEVICE BANK 2\n" +
                                  "CUSTOM DEVICE BANK 3\n" +
                                  "\n" +
                                  "START/STOP FRONT RIGHT STROBE\n" +
                                  "START/STOP FRONT LEFT STROBE\n" +
                                  "START/STOP BACK STROBE\n" +
                                  "\n" +
                                  "ENABLE MANUAL INPUT\n" +
                                  "DISABLE MANUAL INPUT\n" +
                                  "ACTIVATE OUTPUT MAPPING CONFIG\n" +
                                  "\n" +
                                  "/////////////////////////////\n" +
                                  "// Listening on the Controller Bus : \n" +
                                  "\n" +
                                  "\n" +
                                  "PAD KILL ALL LIGHTS   \n" + 
                                  "PAD STROBE 4TH        \n" + 
                                  "PAD STROBE 8TH        \n" + 
                                  "PAD STROBE 16TH       \n" + 
                                  "PAD STROBE 32ND       \n" + 
                                  "PAD STROBE 64TH       \n" + 
                                  "KNOB BLACKOUT         \n" + 
                                  "KNOB WHITEOUT         \n" + 
                                  "KNOB SHREDDER         \n" + 
                                  "KNOB AUTO COLOR CHANGE\n" + 
                                  "KNOB WHITE JAMA MONO  \n" +
                                  "\n" +
                                  "/////////////////////////////\n" +
                                  "// Listening on the Keyboard Bus : \n" +
                                  "\n" +
                                  "\n" +
                                  "GAME | P1 - LEFT\n" +
                                  "GAME | P1 - RIGHT\n" + 
                                  "GAME | P2 - LEFT\n" + 
                                  "GAME | P2 - RIGHT"
                                  ;
    
    String gui_incomingMsgValue = "\n" +
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_SET_AUTOMODE_ON             + " | " + getStringFromNoteInt(PITCH_SET_AUTOMODE_ON            ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_SET_AUTOMODE_OFF            + " | " + getStringFromNoteInt(PITCH_SET_AUTOMODE_OFF           ) + "\n" +
                                  
                                  "\n" +
                                  
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_LOAD_ANIMATION_BANK1        + " | " + getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK1       ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_LOAD_ANIMATION_BANK2        + " | " + getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK2       ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_LOAD_ANIMATION_BANK3        + " | " + getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK3       ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_LOAD_ANIMATION_BANK4        + " | " + getStringFromNoteInt(PITCH_LOAD_ANIMATION_BANK4       ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_LOAD_IMAGE_BANK1            + " | " + getStringFromNoteInt(PITCH_LOAD_IMAGE_BANK1           ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DISPLAY_EFFECT              + " | " + getStringFromNoteInt(PITCH_DISPLAY_EFFECT             ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_STROBE        + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_STROBE       ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_PAR           + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_PAR          ) + "\n" +

                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION  + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR       + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR      ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1 + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2 + " | " + getStringFromNoteInt(PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2) + "\n" +

                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_CUSTOM_DEVICE_BANK1         + " | " + getStringFromNoteInt(PITCH_CUSTOM_DEVICE_BANK1        ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_CUSTOM_DEVICE_BANK2         + " | " + getStringFromNoteInt(PITCH_CUSTOM_DEVICE_BANK2        ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_CUSTOM_DEVICE_BANK3         + " | " + getStringFromNoteInt(PITCH_CUSTOM_DEVICE_BANK3        ) + "\n" +
                                  "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_ENABLE_MAN_INPUT            + " | " + getStringFromNoteInt(PITCH_ENABLE_MAN_INPUT           ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_DISABLE_MAN_INPUT           + " | " + getStringFromNoteInt(PITCH_DISABLE_MAN_INPUT          ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_CHANGE_OUTPUTMAPPING        + " | " + getStringFromNoteInt(PITCH_CHANGE_OUTPUTMAPPING       ) + "\n" +
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_PAD_KILL_LED_PANELS        + " | " + getStringFromNoteInt(PITCH_PAD_KILL_LED_PANELS         ) + "\n" + 
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_PAD_STROBE_4TH             + " | " + getStringFromNoteInt(PITCH_PAD_STROBE_4TH              ) + "\n" + 
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_PAD_STROBE_8TH             + " | " + getStringFromNoteInt(PITCH_PAD_STROBE_8TH              ) + "\n" + 
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_PAD_STROBE_16TH            + " | " + getStringFromNoteInt(PITCH_PAD_STROBE_16TH             ) + "\n" + 
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_PAD_STROBE_32ND            + " | " + getStringFromNoteInt(PITCH_PAD_STROBE_32ND             ) + "\n" + 
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_PAD_STROBE_64TH            + " | " + getStringFromNoteInt(PITCH_PAD_STROBE_64TH             ) + "\n" + 
                                  "INPUT MIDI (CC VAL)     : " + PITCH_KNOB_BLACKOUT              + "\n" + 
                                  "INPUT MIDI (CC VAL)     : " + PITCH_KNOB_WHITEOUT              + "\n" + 
                                  "INPUT MIDI (CC VAL)     : " + PITCH_KNOB_SHREDDER              + "\n" + 
                                  "INPUT MIDI (CC VAL)     : " + PITCH_KNOB_COLORCHANGE           + "\n" + 
                                  "INPUT MIDI (CC VAL)     : " + PITCH_KNOB_WHITEJAMAMONO         + "\n" + 
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_P1_LEFT                    + " | " + getStringFromNoteInt(PITCH_P1_LEFT                     ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_P1_RIGHT                   + " | " + getStringFromNoteInt(PITCH_P1_RIGHT                    ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_P2_LEFT                    + " | " + getStringFromNoteInt(PITCH_P2_LEFT                     ) + "\n" +
                                  "INPUT MIDI (VAL | NOTE) : " + PITCH_P2_RIGHT                   + " | " + getStringFromNoteInt(PITCH_P2_RIGHT                    ) + "\n"
                                  ;
                                  
    
    cp5.addTextarea("Accepted incoming messages")
       .setPosition(leftOffset,leftOffset + 4*textfieldHeight + 3*spacingRow)
       .setSize(2*bigTextfieldWidth,generalInformationsHeight - 2*leftOffset - 3*textfieldHeight - 3*spacingRow)
       .setFont(minimlFont)
       .setColor(color(220))
       .setText(gui_incomingMsgList)
       .moveTo(midiInfo)
       ;
    cp5.addTextarea("Accepted incoming value")
       .setPosition(leftOffset + accordionWidth/2,leftOffset + 4*textfieldHeight + 3*spacingRow)
       .setSize(bigTextfieldWidth*2,generalInformationsHeight - 2*leftOffset - 3*textfieldHeight - 3*spacingRow)
       .setFont(minimlFont)
       .setColor(color(220))
       .setText(gui_incomingMsgValue)
       .moveTo(midiInfo)
       ;

                             
    /////////////////////////////////////////////////////////////////////////////////////
    
    effectsInfo = cp5.addGroup("Effects")
                     .setBackgroundColor(color(0, 64))
                     .setBackgroundHeight(generalInformationsHeight)
                     ;

    cp5.addTextarea("Effect List Label")
       .setPosition(leftOffset,leftOffset)
       .setFont(minimlFont)
       .setColor(color(220))
       .setText("List of the available effects :")
       .moveTo(effectsInfo)
       ;
       
    createEffectsBangList();
    
    /////////////////////////////////////////////////////////////////////////////////////
    
    Group audioSignalConfiguration = cp5.addGroup("Audio Signal Configuration")
                                        .setBackgroundColor(color(0, 64))
                                        .setBackgroundHeight(generalInformationsHeight)
                                        ;
    int signalTextFieldOffset = 80;
    int bassThresholdTextFieldOffset = signalTextFieldOffset + 7*spacingRow + 6*textfieldHeight;
    
    cp5.addTextfield("Kick - Audio Signal ID")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, spacingRow + signalTextFieldOffset)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(str(SIGNAL_ID_KICK))
       .setFont(minimlFont)
       .setCaptionLabel("Kick - Audio Signal ID# :    ")
       .setAutoClear(false)
       .moveTo(audioSignalConfiguration)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
    cp5.addTextfield("Snare - Audio Signal ID")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, 2*spacingRow + textfieldHeight + signalTextFieldOffset)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(str(SIGNAL_ID_SNARE))
       .setFont(minimlFont)
       .setCaptionLabel("Snare - Audio Signal ID# :    ")
       .setAutoClear(false)
       .moveTo(audioSignalConfiguration)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
    cp5.addTextfield("Cymbals - Audio Signal ID")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, 3*spacingRow + 2*textfieldHeight + signalTextFieldOffset)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(str(SIGNAL_ID_CYMBALS))
       .setFont(minimlFont)
       .setCaptionLabel("Cymbals - Audio Signal ID# :    ")
       .setAutoClear(false)
       .moveTo(audioSignalConfiguration)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
    cp5.addTextfield("Bass - Audio Signal ID")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, 4*spacingRow + 3*textfieldHeight + signalTextFieldOffset)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(str(SIGNAL_ID_BASS))
       .setFont(minimlFont)
       .setCaptionLabel("Bass - Audio Signal ID# :    ")
       .setAutoClear(false)
       .moveTo(audioSignalConfiguration)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
    cp5.addTextfield("Keys - Audio Signal ID")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, 5*spacingRow + 4*textfieldHeight + signalTextFieldOffset)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(str(SIGNAL_ID_KEYS))
       .setFont(minimlFont)
       .setCaptionLabel("Keys - Audio Signal ID# :    ")
       .setAutoClear(false)
       .moveTo(audioSignalConfiguration)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;
    cp5.addTextfield("Guitar - Audio Signal ID")
       .setPosition(accordionWidth - bigTextfieldWidth - leftOffset, 6*spacingRow + 5*textfieldHeight + signalTextFieldOffset)
       .setSize(bigTextfieldWidth - 2*textfieldHeight - spacingRow,textfieldHeight)
       .setValue(str(SIGNAL_ID_GUITAR))
       .setFont(minimlFont)
       .setCaptionLabel("Guitar - Audio Signal ID# :    ")
       .setAutoClear(false)
       .moveTo(audioSignalConfiguration)
       .getCaptionLabel().align(ControlP5.LEFT_OUTSIDE, ControlP5.CENTER)
       ;


    String idNumberExplanation = "The values set for each function needs to be\n" +
                                 "coherent with the configuration of the Signal\n" +
                                 "Processor plugin instances used inside your DAW\n" +
                                 "\n" +
                                 "Do not forget to also set only one instance to\n" +
                                 "send the transport data (timecode / tempo),\n" +
                                 "more than one could mess up the analysis\n"
                                 ;
    cp5.addTextarea("ID# Explanation 1")
       .setPosition(leftOffset,leftOffset)
       .setFont(minimlFont)
       .setColor(color(220))
       .setText("ID numbers of the incoming signal messages")
       .moveTo(audioSignalConfiguration)
       ;
     cp5.addTextarea("ID# Explanation 2")
       .setPosition(leftOffset,leftOffset + textfieldHeight + spacingRow)
       .setFont(minimlFont)
       .setColor(color(220))
       .setText(idNumberExplanation)
       .moveTo(audioSignalConfiguration)
       ;
       
       
     String bassFilterExplanation = "Set the value for the ratio between the high\n" +
                                    "and the low frequencies after which the bass\n" +
                                    "is considered to be filtered\n" +
                                    "This parameter is used by the auto mode\n" +
                                    "algorithm, to detect when the bass is alone\n" +
                                    "and filtered (special scenario in which the\n" +
                                    "right stroboscope is on, and the panels off)\n"
                                    ;
       
     cp5.addTextarea("Bass Filter Explanation")
       .setPosition(leftOffset,leftOffset + textfieldHeight + spacingRow + bassThresholdTextFieldOffset)
       .setFont(minimlFont)
       .setColor(color(220))
       .setText(bassFilterExplanation)
       .moveTo(audioSignalConfiguration)
       ;
       
     cp5.addSlider("Bass Hi-Lo Ratio Threshold")
        .setPosition(leftOffset, 7*spacingRow + 6*textfieldHeight + bassThresholdTextFieldOffset)
        .setRange(5,200)
        .setValue(HI_LO_RATIO_THRESHOLD)
        .moveTo(audioSignalConfiguration)
        ;

    /////////////////////////////////////////////////////////////////////////////////////
       
    // Create the sidebar accordion, with all the previous subgroups
    generalInfoAccordion = cp5.addAccordion("General Informations")
                              .setPosition(gui_simulatorPosX + gui_simulatorWidth + gui_spacing, gui_informationsAccordionPosY)
                              .setWidth(accordionWidth)
                              .addItem(hardwareInfo)
                              .addItem(midiInfo)
                              .addItem(effectsInfo)
                              .addItem(audioSignalConfiguration)
                              ;
                   
        
    // when in SINGLE mode, only 1 accordion  
    // group can be open at a time.  
    generalInfoAccordion.open(0);
    generalInfoAccordion.setCollapseMode(Accordion.SINGLE);

    return generalInfoAccordion;
    
  }

  
  ////////////////////////////////////////////////////////////////
  // Create the LED Panel filter group
  //  
  
  public Group createLEDPanelAnimationListGroup() {
    int toggleWidth   = 12;
    int toggleHeight  = 9;
    int spacingRow    = 3;
    int spacingColumn = 60;
    int leftOffset    = 6;
    
    int groupWidth    = 576;
    int groupHeight   = 40;
    
    Group LEDPanelAnimations_animListGroup = cp5.addGroup("Animation list - LED panels")
                                                .setPosition(gui_spacing,5*height/10 - 25)
                                                .setWidth(groupWidth)
                                                .activateEvent(true)
                                                .disableCollapse() 
                                                .setBackgroundColor(color(255,80))
                                                .setBackgroundHeight(height/4-35)
                                                .setLabel("Animation list - LED panels")
                                                ;

    LEDPanelAnimations_reinitButton = cp5.addButton("Reinit LED Panel list")
                                         .setValue(0)
                                         .setCaptionLabel("Reinit")
                                         .setPosition(leftOffset + 7*spacingColumn + 7*toggleWidth, 5*toggleHeight + 4*spacingRow)
                                         .setSize(60, toggleHeight)
                                         .setColorBackground(color(110,0,0))
                                         .setColorForeground(color(160,0,0))
                                         .setColorActive(color(255,0,0))
                                         .setGroup(LEDPanelAnimations_animListGroup)
                                         ;
    // Center the label
    LEDPanelAnimations_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
    LEDPanelAnimations_animationListCheckBox = cp5.addCheckBox("Attributes - LED Panel animations")
                                                  .setPosition(leftOffset,toggleHeight)
                                                  .setSize(toggleWidth,toggleHeight)
                                                  .setItemsPerRow(8)
                                                  .setSpacingColumn(spacingColumn)
                                                  .setSpacingRow(spacingRow)
                                                  .setColorForeground(color(120,0,0))
                                                  .setColorActive(color(160,0,0))
                                                  .setColorLabel(color(255))
                                                  .addItem("Geometric",0)
                                                  .addItem("Atmospheric",1)
                                                  .addItem("Fade In/Out",2)
                                                  .addItem("Random",3)
                                                  .addItem("Very Bright",4)
                                                  .addItem("Very Dark",5)
                                                  .addItem("Red",6)
                                                  .addItem("B&W",7)
                                                  .addItem("Blue",8)
                                                  .addItem("Colorful",9)   
                                                  .addItem("Rotating",10)       
                                                  .addItem("Simple",11)
                                                  .addItem("Complex",12)
                                                  .addItem("Evolving",13)
                                                  .addItem("Smooth",14)
                                                  .addItem("Violent",15)
                                                  .addItem("Rhythmic",16)
                                                  .addItem("Fast",17)
                                                  .addItem("Slow",18)
                                                  .addItem("Still",19)
                                                  .addItem("Lines",20)
                                                  .addItem("Curves",21)
                                                  .addItem("Triangles",22)
                                                  .addItem("Squares",23)
                                                  .addItem("Circles",24)
                                                  .addItem("Spiral",25)       
                                                  .addItem("Noise",26)
                                                  .addItem("Objects",27)   
                                                  .addItem("Special",28)
                                                  .addItem("Audio",29)
                                                  .addItem("Game",30)
                                                  .addItem("3D",31)
                                                  .setGroup(LEDPanelAnimations_animListGroup)
                                                  ;
        
    List<String> filteredAnimationsStringList = new ArrayList<String>();
    for (Attribute attr: animationAttributes) {
      filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
    }
    //Initialize the filtered animation list with all the available animations
    LEDPanelAnimations_animationListBox = cp5.addListBox("Filtered LED Panel Animation List")
                                             .setPosition(leftOffset, 5*toggleHeight + 6*spacingRow )
                                             .setSize(3*LEDPanelAnimations_animListGroup.getWidth()/5 - 2*leftOffset, LEDPanelAnimations_animListGroup.getBackgroundHeight() - (6*toggleHeight + 5*spacingRow) + 3)
                                             .addItems(filteredAnimationsStringList)
                                             .hideBar() 
                                             .disableCollapse()
                                             .moveTo(LEDPanelAnimations_animListGroup)
                                             ;
    
    LEDPanelAnimations_currentAnimationDescription = cp5.addTextarea("Current Animation Description - LED Panels")
                                                        .setPosition(3*LEDPanelAnimations_animListGroup.getWidth()/5, 6*toggleHeight + 6*spacingRow)
                                                        .setSize(LEDPanelAnimations_animListGroup.getWidth() - LEDPanelAnimations_animationListBox.getWidth() - 3*leftOffset, LEDPanelAnimations_animListGroup.getBackgroundHeight() - (7*toggleHeight + 6*spacingRow))
                                                        .setColor(color(255))
                                                        //.setFont(createFont("",8,true))
                                                        .setFont(minimlFont)
                                                        .hideScrollbar()
                                                        .setColorBackground(color(255,90))
                                                        .setColorForeground(color(255,90))
                                                        .moveTo(LEDPanelAnimations_animListGroup)
                                                        ;
    String textDescription = "Current animation description \n"
                                      + "Select an animation in the list\n"
                                      + "\n"
                                      + "Animation number : \n"
                                      + "Corresponding note/velocity : \n"
                                      + "Attributes: \n";
    LEDPanelAnimations_currentAnimationDescription.setText(textDescription.toUpperCase());    
        
    return LEDPanelAnimations_animListGroup;
  } 
  
  
  public void createCustomDeviceAndDMXAccordion(){

    int accordionPosX  = gui_spacing;
    int accordionPosY  = 21*height/30 - 18;
    int accordionWidth = 576;
    
    Group CustomDevices = createCustomDeviceAnimationListGroup();
    Group DMXStrobe = createDMXStrobeAnimationListGroup();
    ArrayList<Group> DMXMovingHead = createDMXMovingHeadAnimationListGroup();
    
    customDevicesDMXAnimationListsAccordion = cp5.addAccordion("Animation Lists")
                                                 .setPosition(accordionPosX, accordionPosY)
                                                 .setWidth(accordionWidth)
                                                 .addItem(CustomDevices)
                                                 .addItem(DMXStrobe)
                                                 ;
    for (Group movingHeadGroup: DMXMovingHead) {
      customDevicesDMXAnimationListsAccordion.addItem(movingHeadGroup);
    }
                   
        
    // when in SINGLE mode, only 1 accordion  
    // group can be open at a time.  
    customDevicesDMXAnimationListsAccordion.open(0);
    customDevicesDMXAnimationListsAccordion.setCollapseMode(Accordion.SINGLE);    
  }
  
  ////////////////////////////////////////////////////////////////
  // Create the custom device filter group
  //
  
  public Group createCustomDeviceAnimationListGroup() {
    int toggleWidth   = 12;
    int toggleHeight  = 9;
    int spacingRow    = 3;
    int spacingColumn = 75;
    int leftOffset    = 6;
    
    int groupWidth    = 576;
    int groupHeight   = height/6 + 15;
    
    Group CustomDeviceAnimations_animListGroup = cp5.addGroup("Animation list - Custom Devices")
//                                                    .setPosition(gui_spacing,22*height/30 )
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true)
//                                                    .disableCollapse() 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - Custom devices")
                                                    ;

    CustomDeviceAnimations_reinitButton = cp5.addButton("Reinit CustomDevice list")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(CustomDeviceAnimations_animListGroup)
                                             ;
    // Center the label
    CustomDeviceAnimations_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
    CustomDeviceAnimations_animationListCheckBox = cp5.addCheckBox("Attributes - Custom Device animations")
                                                  .setPosition(leftOffset,toggleHeight)
                                                  .setSize(toggleWidth,toggleHeight)
                                                  .setItemsPerRow(7)
                                                  .setSpacingColumn(spacingColumn)
                                                  .setSpacingRow(spacingRow)
                                                  .setColorForeground(color(120,0,0))
                                                  .setColorActive(color(160,0,0))
                                                  .setColorLabel(color(255))
                                                  .addItem("All Devices",     0)
                                                  .addItem("Rack Lights",     1)
                                                  .addItem("LED Tubes",       2)
                                                  .addItem("black",           3)      //Small trick : controlp5 doesn't allow more than 1 "Black" item,
                                                  .addItem("white",           4)      //work around this by setting some letters to lowercase
                                                  .addItem("red",             5)
                                                  .addItem("blue",            6)
                                                  .addItem("rainbow",         7)
                                                  .addItem("random",          8)
                                                  .addItem("fast",            9)
                                                  .addItem("medium",         10)
                                                  .addItem("slow",           11)
                                                  .addItem("very slow",      12)
                                                  .addItem("long",           13)
                                                  .addItem("short",          14)
                                                  .addItem("plain",          15)
                                                  .addItem("flash",          16)
                                                  .addItem("smooth sine",    17)
                                                  .addItem("stroboscope",    18)
                                                  .addItem("growing strobe", 19)
                                                  .addItem("wave",           20)
                                                  .addItem("buildup",        21)
                                                  .addItem("noise",          22)
                                                  .addItem("smooth noise",   23)
                                                  .addItem("left side",      24)
                                                  .addItem("right side",     25)
                                                  .setGroup(CustomDeviceAnimations_animListGroup)
                                                  ;

    
    List<String> filteredAnimationsStringList = new ArrayList<String>();
    for (Attribute attr: customDevicesAttributes) {
      filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
    }
    //Initialize the filtered animation list with all the available animations
    CustomDeviceAnimations_animationListBox = cp5.addListBox("Filtered Custom Device Animation List")
                                                 .setPosition(leftOffset, 5*toggleHeight + 6*spacingRow)
                                                 .setSize(3*CustomDeviceAnimations_animListGroup.getWidth()/5 - 2*leftOffset, CustomDeviceAnimations_animListGroup.getBackgroundHeight() - (6*toggleHeight + 5*spacingRow) + 1)
                                                 .addItems(filteredAnimationsStringList)
                                                 .hideBar() 
                                                 .disableCollapse()
                                                 .moveTo(CustomDeviceAnimations_animListGroup)
                                                 ;
    
    CustomDeviceAnimations_currentAnimationDescription = cp5.addTextarea("Current Custom Device Animation Description")
                                                            .setPosition(3*CustomDeviceAnimations_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(CustomDeviceAnimations_animListGroup.getWidth() - CustomDeviceAnimations_animationListBox.getWidth() - 3*leftOffset, CustomDeviceAnimations_animationListBox.getBackgroundHeight())
                                                            .setColor(color(255))
                                                            //.setFont(createFont("",8,true))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(CustomDeviceAnimations_animListGroup)
                                                            ;
    String textDescription = "Current animation description \n"
                                      + "Select an animation in the list\n"
                                      + "\n"
                                      + "Animation number : \n"
                                      + "Corresponding note/velocity : \n"
                                      + "Attributes: \n";
    CustomDeviceAnimations_currentAnimationDescription.setText(textDescription.toUpperCase());    
        
    return CustomDeviceAnimations_animListGroup;
  }
  
  
  ////////////////////////////////////////////////////////////////
  // Now do the same for the DMX animations
  //
  
  public Group createDMXStrobeAnimationListGroup() {
    int toggleWidth   = 12;
    int toggleHeight  = 9;
    int spacingRow    = 3;
    int spacingColumn = 75;
    int leftOffset    = 6;
    
    int groupWidth    = 576;
    int groupHeight   = height/6 + 15;
    
    Group DMXAnimations_animListGroup = cp5.addGroup("Animation list - DMX Strobe Devices")
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true) 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - DMX Strobe devices")
                                                    ;

    DMXStrobeAnimations_reinitButton = cp5.addButton("Reinit DMX Strobe list")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(DMXAnimations_animListGroup)
                                             ;
    // Center the label
    DMXStrobeAnimations_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
    DMXStrobeAnimations_animationListCheckBox = cp5.addCheckBox("Attributes - DMX Strobe animations")
                                                  .setPosition(leftOffset,toggleHeight)
                                                  .setSize(toggleWidth,toggleHeight)
                                                  .setItemsPerRow(7)
                                                  .setSpacingColumn(spacingColumn)
                                                  .setSpacingRow(spacingRow)
                                                  .setColorForeground(color(120,0,0))
                                                  .setColorActive(color(160,0,0))
                                                  .setColorLabel(color(255))
                                                  .addItem("All",         0)
                                                  .addItem("Right",       1)
                                                  .addItem("Left",        2)
                                                  .addItem("Center",      3)
                                                  .addItem("rhythmic",    4)
                                                  .addItem("Strobe",      5)
                                                  .addItem("Par",         6)
                                                  .addItem("very slow ",  7)    //Small trick, controlP5 does not allow two elements with the same name
                                                  .addItem("slow ",       8)
                                                  .addItem("medium ",     9)
                                                  .addItem("fast ",       10)
                                                  .addItem("very fast ",  11)
                                                  .addItem("audio",       12)
                                                  .addItem("Atomic",      13)
                                                  .setGroup(DMXAnimations_animListGroup)
                                                  ;

    
    List<String> filteredAnimationsStringList = new ArrayList<String>();
    for (Attribute attr: DMXStrobeAttributes) {
      filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
    }
    //Initialize the filtered animation list with all the available animations
    DMXStrobeAnimations_animationListBox = cp5.addListBox("Filtered DMX Strobe Animation List")
                                                 .setPosition(leftOffset, 3*toggleHeight + 4*spacingRow)
                                                 .setSize(3*DMXAnimations_animListGroup.getWidth()/5 - 2*leftOffset, DMXAnimations_animListGroup.getBackgroundHeight() - (3*toggleHeight + 2*spacingRow) + 1)
                                                 .addItems(filteredAnimationsStringList)
                                                 .hideBar() 
                                                 .disableCollapse()
                                                 .moveTo(DMXAnimations_animListGroup)
                                                 ;
    
    DMXStrobeAnimations_currentAnimationDescription = cp5.addTextarea("Current DMX Strobe Animation Description")
                                                            .setPosition(3*DMXAnimations_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(DMXAnimations_animListGroup.getWidth() - DMXStrobeAnimations_animationListBox.getWidth() - 3*leftOffset, DMXStrobeAnimations_animationListBox.getBackgroundHeight() - toggleHeight - spacingRow)
                                                            .setColor(color(255))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(DMXAnimations_animListGroup)
                                                            ;

    String textDescription = "Current DMX Strobe animation description \n"
                                      + "Select an animation in the list\n"
                                      + "\n"
                                      + "Animation number : \n"
                                      + "Corresponding note/velocity : \n"
                                      + "Attributes: \n";
    DMXStrobeAnimations_currentAnimationDescription.setText(textDescription.toUpperCase());    
        
    return DMXAnimations_animListGroup;
  }

  public ArrayList<Group> createDMXMovingHeadAnimationListGroup() {
    int toggleWidth   = 12;
    int toggleHeight  = 9;
    int spacingRow    = 3;
    int spacingColumn = 75;
    int leftOffset    = 6;
    
    int groupWidth    = 576;
    int groupHeight   = height/6 + 15;
    
    Group DMXAnimations_Movement_animListGroup = cp5.addGroup("Animation list - DMX Moving Head Devices - Prepare Direction")
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true) 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - DMX Moving Head devices - Prepare Direction")
                                                    ;
    Group DMXAnimations_Color_animListGroup = cp5.addGroup("Animation list - DMX Moving Head Devices - Set Color")
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true) 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - DMX Moving Head devices - Set Color")
                                                    ;
    Group DMXAnimations_Rhythm_animListGroup = cp5.addGroup("Animation list - DMX Moving Head Devices - Set Rhythm")
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true) 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - DMX Moving Head devices - Set Rhythm")
                                                    ;
    Group DMXAnimations_LightStyle_animListGroup = cp5.addGroup("Animation list - DMX Moving Head Devices - Set Light Style")
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true) 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - DMX Moving Head devices - Set Light Style")
                                                    ;
    Group DMXAnimations_Animations_animListGroup = cp5.addGroup("Animation list - DMX Moving Head Devices - Perform Animations")
                                                    .setWidth(groupWidth)
                                                    .activateEvent(true) 
                                                    .setBackgroundColor(color(255,80))
                                                    .setBackgroundHeight(groupHeight)
                                                    .setLabel("Animation list - DMX Moving Head devices - Perform Animations")
                                                    ;

    DMXMovingHeadAnimations_Movement_reinitButton = cp5.addButton("Reinit DMX Moving Head list - Prepare Direction")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(DMXAnimations_Movement_animListGroup)
                                             ;
    DMXMovingHeadAnimations_Color_reinitButton = cp5.addButton("Reinit DMX Moving Head list - Set Color")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(DMXAnimations_Color_animListGroup)
                                             ;
    DMXMovingHeadAnimations_Rhythm_reinitButton = cp5.addButton("Reinit DMX Moving Head list - Set Rhythm")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(DMXAnimations_Rhythm_animListGroup)
                                             ;
    DMXMovingHeadAnimations_LightStyle_reinitButton = cp5.addButton("Reinit DMX Moving Head list - Set Light Style")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(DMXAnimations_LightStyle_animListGroup)
                                             ;
    DMXMovingHeadAnimations_Animations_reinitButton = cp5.addButton("Reinit DMX Moving Head list - Perform Animations")
                                             .setValue(0)
                                             .setCaptionLabel("Reinit")
                                             .setPosition(leftOffset + 6*spacingColumn + 6*toggleWidth, 4*toggleHeight + 3*spacingRow)
                                             .setSize(40, toggleHeight)
                                             .setColorBackground(color(110,0,0))
                                             .setColorForeground(color(160,0,0))
                                             .setColorActive(color(255,0,0))
                                             .setGroup(DMXAnimations_Animations_animListGroup)
                                             ;

    // Center the label
    DMXMovingHeadAnimations_Movement_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    DMXMovingHeadAnimations_Color_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    DMXMovingHeadAnimations_LightStyle_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    DMXMovingHeadAnimations_Animations_reinitButton.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
    DMXMovingHeadAnimations_Movement_animationListCheckBox = cp5.addCheckBox("Attributes - DMX Moving Head animations - Prepare Direction")
                                                                .setPosition(leftOffset,toggleHeight)
                                                                .setSize(toggleWidth,toggleHeight)
                                                                .setItemsPerRow(5)
                                                                .setSpacingColumn(spacingColumn + 15)
                                                                .setSpacingRow(spacingRow)
                                                                .setColorForeground(color(120,0,0))
                                                                .setColorActive(color(160,0,0))
                                                                .setColorLabel(color(255))
                                                                .addItem("ALL",          0)  //Small trick, controlP5 does not allow two elements with the same name
                                                                .addItem("LEFT",         1)
                                                                .addItem("RIGHT",        2)
                                                                .addItem("SIDE",         3)
                                                                .addItem("CENTER",       4)
                                                                .addItem("UNIFORM",      5)
                                                                .addItem("DIVERGENT",    6)
                                                                .addItem("CONVERGENT",   7)
                                                                .addItem("SYMMETRICAL",  8)
                                                                .addItem("SUN",          9)
                                                                .setGroup(DMXAnimations_Movement_animListGroup)
                                                                ;

    DMXMovingHeadAnimations_Color_animationListCheckBox = cp5.addCheckBox("Attributes - DMX Moving Head animations - Set Color")
                                                                .setPosition(leftOffset,toggleHeight)
                                                                .setSize(toggleWidth,toggleHeight)
                                                                .setItemsPerRow(8)
                                                                .setSpacingColumn(spacingColumn)
                                                                .setSpacingRow(spacingRow)
                                                                .setColorForeground(color(120,0,0))
                                                                .setColorActive(color(160,0,0))
                                                                .setColorLabel(color(255))
                                                                .addItem("ALL ",           0)  //Small trick, controlP5 does not allow two elements with the same name
                                                                .addItem("LEFT ",          1)
                                                                .addItem("RIGHT ",         2)
                                                                .addItem("SIDE ",          3)
                                                                .addItem("CENTER ",        4)
                                                                .addItem("WHITE ",         5)
                                                                .addItem("RED ",           6)
                                                                .addItem("DEEPRED ",       7)
                                                                .addItem("BLUE ",          8)
                                                                .addItem("DEEPBLUE ",      9)
                                                                .addItem("YELLOW ",        10)
                                                                .addItem("GREEN ",         11)
                                                                .addItem("ULTRAVIOLET ",   12)
                                                                .addItem("ORANGE ",        13)
                                                                .addItem("CTO ",           14)
                                                                .setGroup(DMXAnimations_Color_animListGroup)
                                                                ;
    
    DMXMovingHeadAnimations_Rhythm_animationListCheckBox = cp5.addCheckBox("Attributes - DMX Moving Head animations - Set Rhythm")
                                                                .setPosition(leftOffset,toggleHeight)
                                                                .setSize(toggleWidth,toggleHeight)
                                                                .setItemsPerRow(8)
                                                                .setSpacingColumn(spacingColumn-15)
                                                                .setSpacingRow(spacingRow)
                                                                .setColorForeground(color(120,0,0))
                                                                .setColorActive(color(160,0,0))
                                                                .setColorLabel(color(255))
                                                                .addItem("ALL  ",           0)
                                                                .addItem("LEFT  ",          1)
                                                                .addItem("RIGHT  ",         2)
                                                                .addItem("SIDE  ",          3)
                                                                .addItem("CENTER  ",        4)                                                                
                                                                .addItem("NOSYNC",          5)                                                                
                                                                .addItem("TOGETHER",        6)
                                                                .addItem("CLOCK",           7)
                                                                .addItem("ANTICLOCK",       8)
                                                                .addItem("RANDOm",          9)
                                                                .addItem("32ND  ",          10)
                                                                .addItem("16TH  ",          11)
                                                                .addItem("8TH  ",           12)
                                                                .addItem("4TH  ",           13)
                                                                .addItem("2ND  ",           14)
                                                                .addItem("BAR  ",           15)
                                                                .setGroup(DMXAnimations_Rhythm_animListGroup)
                                                                ;

    DMXMovingHeadAnimations_LightStyle_animationListCheckBox = cp5.addCheckBox("Attributes - DMX Moving Head animations - Set Light Style")
                                                                .setPosition(leftOffset,toggleHeight)
                                                                .setSize(toggleWidth,toggleHeight)
                                                                .setItemsPerRow(6)
                                                                .setSpacingColumn(spacingColumn)
                                                                .setSpacingRow(spacingRow)
                                                                .setColorForeground(color(120,0,0))
                                                                .setColorActive(color(160,0,0))
                                                                .setColorLabel(color(255))
                                                                .addItem("ALl",          0)
                                                                .addItem("LEFt",         1)
                                                                .addItem("RIGHt",        2)
                                                                .addItem("SIDe",         3)
                                                                .addItem("CENTEr",       4)
                                                                .addItem("STILl",        5)
                                                                .addItem("CRESCENDo",    6)
                                                                .addItem("FLASh",        7)
                                                                .addItem("STROBe",       8)
                                                                .addItem("SINe",         9)
                                                                .addItem("GLITCh",       10)
                                                                .addItem("TIGHt",        11)
                                                                .setGroup(DMXAnimations_LightStyle_animListGroup)
                                                                ;



    DMXMovingHeadAnimations_Animations_animationListCheckBox = cp5.addCheckBox("Attributes - DMX Moving Head animations - Perform Animations")
                                                                .setPosition(leftOffset,toggleHeight)
                                                                .setSize(toggleWidth,toggleHeight)
                                                                .setItemsPerRow(6)
                                                                .setSpacingColumn(spacingColumn)
                                                                .setSpacingRow(spacingRow)
                                                                .setColorForeground(color(120,0,0))
                                                                .setColorActive(color(160,0,0))
                                                                .setColorLabel(color(255))
                                                                .addItem("All ",         0)
                                                                .addItem("LEft",         1)
                                                                .addItem("RIGht",        2)
                                                                .addItem("SIde",         3)
                                                                .addItem("CENTer",       4)
                                                                .addItem("STIll",        5)
                                                                .addItem("FASTMOve",     6)
                                                                .addItem("CONTSWEep",    7)
                                                                .addItem("SINGSWEep",    8)
                                                                .addItem("RANDom",       9)
                                                                .addItem("PARALLel",     10)
                                                                .addItem("DIVERGEnt",    11)
                                                                .addItem("CONVERGEnt",   12)
                                                                .addItem("HORIZONTal",   13)
                                                                .addItem("VERTICal",     14)
                                                                .addItem("SLow",         15)
                                                                .addItem("REGULar",      16)
                                                                .addItem("FAst",         17)
                                                                .setGroup(DMXAnimations_Animations_animListGroup)
                                                                ;


    List<String> filteredAnimationsStringList_Movement   = new ArrayList<String>();
    List<String> filteredAnimationsStringList_Color      = new ArrayList<String>();
    List<String> filteredAnimationsStringList_Rhythm      = new ArrayList<String>();
    List<String> filteredAnimationsStringList_LightStyle = new ArrayList<String>();
    List<String> filteredAnimationsStringList_Animations = new ArrayList<String>();

    for (Attribute attr: DMXMovingHead_MovementAttributes) {
      filteredAnimationsStringList_Movement.add(attr.animationNbr + ": " + attr.name);
    }
    for (Attribute attr: DMXMovingHead_ColorAttributes) {
      filteredAnimationsStringList_Color.add(attr.animationNbr + ": " + attr.name);
    }
    for (Attribute attr: DMXMovingHead_RhythmAttributes) {
      filteredAnimationsStringList_Rhythm.add(attr.animationNbr + ": " + attr.name);
    }
    for (Attribute attr: DMXMovingHead_LightStyleAttributes) {
      filteredAnimationsStringList_LightStyle.add(attr.animationNbr + ": " + attr.name);
    }
    for (Attribute attr: DMXMovingHead_AnimationAttributes) {
      filteredAnimationsStringList_Animations.add(attr.animationNbr + ": " + attr.name);
    }

    //Initialize the filtered animation list with all the available animations
    DMXMovingHeadAnimations_Movement_animationListBox = cp5.addListBox("Filtered DMX Moving Head Animation List - Prepare Direction")
                                                           .setPosition(leftOffset, 3*toggleHeight + 4*spacingRow - 2)
                                                           .setSize(3*DMXAnimations_Movement_animListGroup.getWidth()/5 - 2*leftOffset, DMXAnimations_Movement_animListGroup.getBackgroundHeight() - (3*toggleHeight + 2*spacingRow) + 1)
                                                           .addItems(filteredAnimationsStringList_Movement)
                                                           .hideBar() 
                                                           .disableCollapse()
                                                           .moveTo(DMXAnimations_Movement_animListGroup)
                                                           ;
    DMXMovingHeadAnimations_Color_animationListBox = cp5.addListBox("Filtered DMX Moving Head Animation List - Set Color")
                                                           .setPosition(leftOffset, 3*toggleHeight + 4*spacingRow - 2)
                                                           .setSize(3*DMXAnimations_Color_animListGroup.getWidth()/5 - 2*leftOffset, DMXAnimations_Color_animListGroup.getBackgroundHeight() - (3*toggleHeight + 2*spacingRow) + 1)
                                                           .addItems(filteredAnimationsStringList_Color)
                                                           .hideBar() 
                                                           .disableCollapse()
                                                           .moveTo(DMXAnimations_Color_animListGroup)
                                                           ;
    DMXMovingHeadAnimations_Rhythm_animationListBox = cp5.addListBox("Filtered DMX Moving Head Animation List - Set Rhythm")
                                                           .setPosition(leftOffset, 3*toggleHeight + 4*spacingRow - 2)
                                                           .setSize(3*DMXAnimations_Rhythm_animListGroup.getWidth()/5 - 2*leftOffset, DMXAnimations_Rhythm_animListGroup.getBackgroundHeight() - (3*toggleHeight + 2*spacingRow) + 1)
                                                           .addItems(filteredAnimationsStringList_Rhythm)
                                                           .hideBar() 
                                                           .disableCollapse()
                                                           .moveTo(DMXAnimations_Rhythm_animListGroup)
                                                           ;
    DMXMovingHeadAnimations_LightStyle_animationListBox = cp5.addListBox("Filtered DMX Moving Head Animation List - Set Light Style")
                                                           .setPosition(leftOffset, 3*toggleHeight + 4*spacingRow - 2)
                                                           .setSize(3*DMXAnimations_LightStyle_animListGroup.getWidth()/5 - 2*leftOffset, DMXAnimations_LightStyle_animListGroup.getBackgroundHeight() - (3*toggleHeight + 2*spacingRow) + 1)
                                                           .addItems(filteredAnimationsStringList_LightStyle)
                                                           .hideBar() 
                                                           .disableCollapse()
                                                           .moveTo(DMXAnimations_LightStyle_animListGroup)
                                                           ;
    DMXMovingHeadAnimations_Animations_animationListBox = cp5.addListBox("Filtered DMX Moving Head Animation List - Perform Animations")
                                                           .setPosition(leftOffset, 4*toggleHeight + 4*spacingRow)
                                                           .setSize(3*DMXAnimations_Animations_animListGroup.getWidth()/5 - 2*leftOffset, DMXAnimations_Animations_animListGroup.getBackgroundHeight() - (4*toggleHeight + 3*spacingRow) + 1)
                                                           .addItems(filteredAnimationsStringList_Animations)
                                                           .hideBar() 
                                                           .disableCollapse()
                                                           .moveTo(DMXAnimations_Animations_animListGroup)
                                                           ;
    
    DMXMovingHeadAnimations_Movement_currentAnimationDescription = cp5.addTextarea("Current DMX Moving Head Animation Description - Prepare Direction")
                                                            .setPosition(3*DMXAnimations_Movement_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(DMXAnimations_Movement_animListGroup.getWidth() - DMXMovingHeadAnimations_Movement_animationListBox.getWidth() - 3*leftOffset, DMXMovingHeadAnimations_Movement_animationListBox.getBackgroundHeight() - toggleHeight - spacingRow)
                                                            .setColor(color(255))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(DMXAnimations_Movement_animListGroup)
                                                            ;
    DMXMovingHeadAnimations_Color_currentAnimationDescription = cp5.addTextarea("Current DMX Moving Head Animation Description - Set Color")
                                                            .setPosition(3*DMXAnimations_Color_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(DMXAnimations_Color_animListGroup.getWidth() - DMXMovingHeadAnimations_Color_animationListBox.getWidth() - 3*leftOffset, DMXMovingHeadAnimations_Color_animationListBox.getBackgroundHeight() - toggleHeight - spacingRow)
                                                            .setColor(color(255))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(DMXAnimations_Color_animListGroup)
                                                            ;
    DMXMovingHeadAnimations_Rhythm_currentAnimationDescription = cp5.addTextarea("Current DMX Moving Head Animation Description - Set Rhythm")
                                                            .setPosition(3*DMXAnimations_Rhythm_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(DMXAnimations_Rhythm_animListGroup.getWidth() - DMXMovingHeadAnimations_Rhythm_animationListBox.getWidth() - 3*leftOffset, DMXMovingHeadAnimations_Rhythm_animationListBox.getBackgroundHeight() - toggleHeight - spacingRow)
                                                            .setColor(color(255))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(DMXAnimations_Rhythm_animListGroup)
                                                            ;
    DMXMovingHeadAnimations_LightStyle_currentAnimationDescription = cp5.addTextarea("Current DMX Moving Head Animation Description - Set Light Style")
                                                            .setPosition(3*DMXAnimations_LightStyle_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(DMXAnimations_LightStyle_animListGroup.getWidth() - DMXMovingHeadAnimations_LightStyle_animationListBox.getWidth() - 3*leftOffset, DMXMovingHeadAnimations_LightStyle_animationListBox.getBackgroundHeight() - toggleHeight - spacingRow)
                                                            .setColor(color(255))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(DMXAnimations_LightStyle_animListGroup)
                                                            ;
    DMXMovingHeadAnimations_Animations_currentAnimationDescription = cp5.addTextarea("Current DMX Moving Head Animation Description - Perform Animations")
                                                            .setPosition(3*DMXAnimations_Animations_animListGroup.getWidth()/5, 5*toggleHeight + 6*spacingRow)
                                                            .setSize(DMXAnimations_Animations_animListGroup.getWidth() - DMXMovingHeadAnimations_Animations_animationListBox.getWidth() - 3*leftOffset, DMXMovingHeadAnimations_Animations_animationListBox.getBackgroundHeight() - toggleHeight - spacingRow)
                                                            .setColor(color(255))
                                                            .setFont(minimlFont)
                                                            .hideScrollbar()
                                                            .setColorBackground(color(255,90))
                                                            .setColorForeground(color(255,90))
                                                            .moveTo(DMXAnimations_Animations_animListGroup)
                                                            ;

    String textDescription = "Current DMX Moving Head animation description \n"
                                      + "Select an animation in the list\n"
                                      + "\n"
                                      + "Animation number : \n"
                                      + "Corresponding note/velocity : \n"
                                      + "Attributes: \n";
    DMXMovingHeadAnimations_Movement_currentAnimationDescription.setText(textDescription.toUpperCase());
    DMXMovingHeadAnimations_Color_currentAnimationDescription.setText(textDescription.toUpperCase());
    DMXMovingHeadAnimations_Rhythm_currentAnimationDescription.setText(textDescription.toUpperCase());
    DMXMovingHeadAnimations_LightStyle_currentAnimationDescription.setText(textDescription.toUpperCase());
    DMXMovingHeadAnimations_Animations_currentAnimationDescription.setText(textDescription.toUpperCase());
    
    ArrayList<Group> groups = new ArrayList<Group>();
    groups.add(DMXAnimations_Movement_animListGroup);
    groups.add(DMXAnimations_Color_animListGroup);
    groups.add(DMXAnimations_Rhythm_animListGroup);
    groups.add(DMXAnimations_LightStyle_animListGroup);
    groups.add(DMXAnimations_Animations_animListGroup);
    return groups;
  }
  
  public void rebuildFilteredLEDPanelAnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createLEDPanelAnimationListFilter(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = new ArrayList<String>();
    boolean init = false;
    if (wantedAttributes.length == 0) {
      init = true;
    }

    if (init == false) {
      String[] unwantedAttributes = {};
      ArrayList<Attribute> gui_LEDPanelFilteredAttributes = new ArrayList<Attribute>();
      gui_LEDPanelFilteredAttributes = filterAnimationsByAttributes(animationAttributes, wantedAttributes, unwantedAttributes);
      for (Attribute attr: gui_LEDPanelFilteredAttributes) {
        filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
      }
    }
    else {
      for (Attribute attr: animationAttributes) {
        filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
      }
    }

    for (String item[]: LEDPanelAnimations_animationListBox.getListBoxItems()) {
      LEDPanelAnimations_animationListBox.removeItem(item[0]);
    }
    LEDPanelAnimations_animationListBox.addItems(filteredAnimationsStringList);
  }
  
  public void rebuildFilteredCustomDeviceAnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createCustomDeviceAnimationListFilter(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = new ArrayList<String>();
    boolean init = false;
    if (wantedAttributes.length == 0) {
      init = true;
    }

    if (init == false) {
      String[] unwantedAttributes = {};
      ArrayList<Attribute> gui_CustomDeviceFilteredAttributes = new ArrayList<Attribute>();
      gui_CustomDeviceFilteredAttributes = filterAnimationsByAttributes(customDevicesAttributes, wantedAttributes, unwantedAttributes);
      for (Attribute attr: gui_CustomDeviceFilteredAttributes) {
        filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
      }
    }
    else {
      for (Attribute attr: customDevicesAttributes) {
        filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
      }
    }

    for (String item[]: CustomDeviceAnimations_animationListBox.getListBoxItems()) {
      CustomDeviceAnimations_animationListBox.removeItem(item[0]);
    }
    CustomDeviceAnimations_animationListBox.addItems(filteredAnimationsStringList);
  }
  
  
  public void rebuildFilteredDMXStrobeAnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createDMXAnimationListFilter_Strobe(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = getFilteredAnimationsStringList_DMX(checkBoxArrayValue, DMXStrobeAttributes, wantedAttributes);

    for (String item[]: DMXStrobeAnimations_animationListBox.getListBoxItems()) {
      DMXStrobeAnimations_animationListBox.removeItem(item[0]);
    }
    DMXStrobeAnimations_animationListBox.addItems(filteredAnimationsStringList);
  }

  public void rebuildFilteredDMXMovingHead_Movement_AnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createDMXAnimationListFilter_MovingHead_Movement(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = getFilteredAnimationsStringList_DMX(checkBoxArrayValue, DMXMovingHead_MovementAttributes, wantedAttributes);

    for (String item[]: DMXMovingHeadAnimations_Movement_animationListBox.getListBoxItems()) {
      DMXMovingHeadAnimations_Movement_animationListBox.removeItem(item[0]);
    }
    DMXMovingHeadAnimations_Movement_animationListBox.addItems(filteredAnimationsStringList);
  }

  public void rebuildFilteredDMXMovingHead_Color_AnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createDMXAnimationListFilter_MovingHead_Color(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = getFilteredAnimationsStringList_DMX(checkBoxArrayValue, DMXMovingHead_ColorAttributes, wantedAttributes);

    for (String item[]: DMXMovingHeadAnimations_Color_animationListBox.getListBoxItems()) {
      DMXMovingHeadAnimations_Color_animationListBox.removeItem(item[0]);
    }
    DMXMovingHeadAnimations_Color_animationListBox.addItems(filteredAnimationsStringList);
  }

  public void rebuildFilteredDMXMovingHead_Rhythm_AnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createDMXAnimationListFilter_MovingHead_Rhythm(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = getFilteredAnimationsStringList_DMX(checkBoxArrayValue, DMXMovingHead_RhythmAttributes, wantedAttributes);

    for (String item[]: DMXMovingHeadAnimations_Rhythm_animationListBox.getListBoxItems()) {
      DMXMovingHeadAnimations_Rhythm_animationListBox.removeItem(item[0]);
    }
    DMXMovingHeadAnimations_Rhythm_animationListBox.addItems(filteredAnimationsStringList);
  }

  public void rebuildFilteredDMXMovingHead_LightStyle_AnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createDMXAnimationListFilter_MovingHead_Animation(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = getFilteredAnimationsStringList_DMX(checkBoxArrayValue, DMXMovingHead_LightStyleAttributes, wantedAttributes);

    for (String item[]: DMXMovingHeadAnimations_LightStyle_animationListBox.getListBoxItems()) {
      DMXMovingHeadAnimations_LightStyle_animationListBox.removeItem(item[0]);
    }
    DMXMovingHeadAnimations_LightStyle_animationListBox.addItems(filteredAnimationsStringList);
  }

  public void rebuildFilteredDMXMovingHead_Animations_AnimationList(float[] checkBoxArrayValue) {
    String[] wantedAttributes = createDMXAnimationListFilter_MovingHead_Movement(checkBoxArrayValue);
    List<String> filteredAnimationsStringList = getFilteredAnimationsStringList_DMX(checkBoxArrayValue, DMXMovingHead_AnimationAttributes, wantedAttributes);

    for (String item[]: DMXMovingHeadAnimations_Animations_animationListBox.getListBoxItems()) {
      DMXMovingHeadAnimations_Animations_animationListBox.removeItem(item[0]);
    }
    DMXMovingHeadAnimations_Animations_animationListBox.addItems(filteredAnimationsStringList);
  }

  public List<String> getFilteredAnimationsStringList_DMX(float[] checkBoxArrayValue, ArrayList<Attribute> attrList, String[] wantedAttributes) {
    List<String> filteredAnimationsStringList = new ArrayList<String>();
    boolean init = false;
    if (wantedAttributes.length == 0) {
      init = true;
    }
    if (init == false) {
      String[] unwantedAttributes = {};
      ArrayList<Attribute> gui_DMXFilteredAttributes = new ArrayList<Attribute>();
      gui_DMXFilteredAttributes = filterAnimationsByAttributes(attrList, wantedAttributes, unwantedAttributes);
      for (Attribute attr: gui_DMXFilteredAttributes) {
        filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
      }
    }
    else {
      for (Attribute attr: attrList) {
        filteredAnimationsStringList.add(attr.animationNbr + ": " + attr.name);
      }
    }

    return filteredAnimationsStringList;
  }
  
  ////////////////////////////////////////////////////////
  
  public void gui_loadLEDPanelAnimation(int animNbr) {
    setupcomplete = false;
    drawAnimation = 1;
    drawImage = 0;
    animationnumber = animNbr;
    specificActions();
  }
  
  public void gui_loadDMXAnimation_strobe(int animNbr) {
    dmxAutomaticControl = true;
    dmxAnimationNumber_strobe  = animNbr;
    setupDMXAnimation_strobe();
  }

  public void gui_loadDMXAnimation_movingHead_Movement(int animNbr) {
    dmxAutomaticControl = true;
    dmxAnimationNumber_movingHead_initDirection = animNbr;
    setupDMXAnimation_movingHead_initDirection();
  }

  public void gui_loadDMXAnimation_movingHead_Color(int animNbr) {
    dmxAutomaticControl = true;
    dmxAnimationNumber_movingHead_setColor = animNbr;
    setupDMXAnimation_movingHead_setColor();
  }

  public void gui_loadDMXAnimation_movingHead_Rhythm(int animNbr) {
    dmxAutomaticControl = true;
    dmxAnimationNumber_movingHead_setRhythm = animNbr;
    setupDMXAnimation_movingHead_setRhythm();
  }

  public void gui_loadDMXAnimation_movingHead_LightStyle(int animNbr) {
    dmxAutomaticControl = true;
    dmxAnimationNumber_movingHead_setLightStyle = animNbr;
    setupDMXAnimation_movingHead_setLightStyle();
  }

  public void gui_loadDMXAnimation_movingHead(int animNbr) {
    dmxAutomaticControl = true;
    dmxAnimationNumber_movingHead_setAnimation = animNbr;
    setupDMXAnimation_movingHeadAnimation();
  }
  
  ////////////////////////////////////////////////////////
  
  public void gui_activateMappingBangs() {
    for (Bang temp: changeLEDPanelMappingBangList) {
      temp.setColorForeground(color(4,104,154))
          .setColorActive(color(0,180,234));
    }
  }
  
  public void gui_disableMappingBangs() {
    for (Bang temp: changeLEDPanelMappingBangList) {
      temp.setColorForeground(color(150))
          .setColorActive(color(150));
    }
  }
  
  public void initLEDPanelMappingArray() {
    tempLEDPanelMapping_counter = 0;
    tempLEDPanelMapping_array = new int[NUMBER_OF_PANELS];
    for (int i = 0; i<NUMBER_OF_PANELS; i++) {
      tempLEDPanelMapping_array[i] = -1;
    }
    
    //Display an image lighting only the current panel to map to inform the user 
    drawImage = 1;
    drawAnimation = 0;
    imagenumber = -1;
  }
  
  public void registerBangForLEDPanelMapping(int panelNbr) {     
    boolean panelValueInsideMappingArray = false;
    for(int i: tempLEDPanelMapping_array) {
      if (i == panelNbr) {
        panelValueInsideMappingArray = true;
        break;
      }
    }
    if (!panelValueInsideMappingArray) {
      tempLEDPanelMapping_array[tempLEDPanelMapping_counter] = panelNbr;
      tempLEDPanelMapping_counter += 1;
      //Display an image lighting only the current panel to map to inform the user
      imagenumber -=1;
    }

    if (tempLEDPanelMapping_counter == NUMBER_OF_PANELS) {
      gui_disableMappingBangs();
      changeLEDPanelMappingToggle.setState(false);
      
      //Display an image lighting all the panels to map to inform the user that reinit is over
      imagenumber = 0;
      
      gui_updateLEDMapping();
      
      tempLEDPanelMapping_counter = 0;
    }
  }
  
  public void createEffectsBangList() {
    addEffectBang("1 - Classic Glitch", 1);
    addEffectBang("2 - RGB Glitch", 2);
    addEffectBang("3 - 180 Flip", 3);
    addEffectBang("4 - Red Shift", 4);
    addEffectBang("5 - General Flicker", 5);
    addEffectBang("6 - Random White Stripes", 6);
    addEffectBang("7 - Random Red Stripes", 7);
    addEffectBang("8 - Random Blue Stripes", 8);
    addEffectBang("9 - Random White Lines", 9);
    addEffectBang("10 - Random Red Lines", 10);
    addEffectBang("11 - Random Blue Lines", 11);
    addEffectBang("12 - Flicker - Panel 1", 12);
    addEffectBang("13 - Flicker - Panel 2", 13);
    addEffectBang("14 - Flicker - Panel 3", 14);
    addEffectBang("15 - Flicker - Panel 4", 15);
    addEffectBang("16 - Flicker - Panel 5", 16);
    addEffectBang("17 - Flutter", 17);
    addEffectBang("18 - Monochrome Filter", 18);
    addEffectBang("19 - Invert Filter", 19);
    addEffectBang("20 - Only Left", 20);
    addEffectBang("21 - Only Right", 21);
    addEffectBang("22 - General Random Flicker", 22);
    addEffectBang("23 - Rainbow Color", 23);
    addEffectBang("24 - Fadeout", 24);
    addEffectBang("25 - Fadein", 25);
    addEffectBang("26 - Redout", 26);
    addEffectBang("27 - Redin", 27);
    addEffectBang("28 - Whiteout", 28);
    addEffectBang("29 - Redout", 29);
    addEffectBang("30 - BlackWave Circle", 30);
    addEffectBang("31 - Windmill", 31);
    addEffectBang("32 - WhiteFlash", 32);
    addEffectBang("33 - RedFlash", 33);
    addEffectBang("34 - General Red Random Flicker", 34);
    addEffectBang("35 - Light Blue Filter", 35);
    addEffectBang("36 - Panels Off", 36);
  }
  
  public void addEffectBang(String name, int i) {
    
    int toggleWidth   = 12;
    int toggleHeight  = 9;
    int spacingRow    = 3;
    int spacingColumn = 75;
    int leftOffset    = 6;
    int upOffset      = 10;
    
    cp5.addBang("Effect Bang - " + name)
         .setPosition(leftOffset, upOffset + i*(toggleHeight + spacingRow))
         .setSize(toggleWidth, toggleHeight)
         .setCaptionLabel("  " + name)
         .moveTo(effectsInfo)
         .getCaptionLabel().align(ControlP5.RIGHT_OUTSIDE, ControlP5.CENTER)
         ;    
  }
  
  //Note : this function is similar to finalizeLEDPanelRemappingProcedure inside MidiControl,
  //but there is a reason to have two different remapping procedure : the person behind the
  //GUI and the person behind the keyboard could be different people, don't want parasite
  // keyboard input during the GUI remapping
  public void gui_updateLEDMapping() {
    
    // Most critical part : update the panelNumber directly inside the Output objects !
    for (int i=0; i<outputDevices.length; i++) {
      outputDevices[i].panelNumber = tempLEDPanelMapping_array[i];
      screen_order_configuration[i] = tempLEDPanelMapping_array[i];
    }
    
    for (int i=0; i<outputDevices.length; i++) {
      outputLog.println("Microcontroller reconfiguration - device " + outputDevices[i].serialPort + " is now affected to output #" + outputDevices[i].panelNumber);
    }
    
    //Make the configuration change persistant
    writeScreenOrderInConfigurationFile();
  }


  public void createMessageBox(String device, String[] explanationText) {
    // create a group to store the messageBox elements
    int messageBoxWidth = width/2;
    int messageBoxPosX = width/2 - messageBoxWidth/2;
    int messageBoxPosY = height/5;
    int messageBoxInputFieldWidth = 410;
    int messageBoxInputFieldHeight = 14;
    
    GUIMessageBox = cp5.addGroup("messageBox",messageBoxPosX,messageBoxPosY,messageBoxWidth);
    GUIMessageBox.setBackgroundColor(color(0,200));
    GUIMessageBox.hideBar();
    
    // add a TextLabel to the messageBox.
    int nbLines=0;
    for (nbLines=0; nbLines<explanationText.length; nbLines++) {
      Textlabel txt = cp5.addTextlabel("Input label " + nbLines, explanationText[nbLines], 20, 20 + nbLines*10);
      txt.moveTo(GUIMessageBox);
    }
    
    int marginY = (nbLines-1)*10;
    GUIMessageBox.setBackgroundHeight(120 + marginY);
    
    Textfield f = cp5.addTextfield("inputbox_" + device,20,45+marginY,messageBoxInputFieldWidth,messageBoxInputFieldHeight);
    f.captionLabel().setVisible(false);
    f.setFocus(true);
    f.moveTo(GUIMessageBox);
    f.setColorActive(color(100));
    controlP5.Button b1 = cp5.addButton("buttonOK_" + device,0,65,80 + marginY,80,24);
    b1.moveTo(GUIMessageBox);
    b1.setColorBackground(color(40));
    b1.setColorActive(color(20));
    // by default setValue would trigger function buttonOK, 
    // therefore we disable the broadcasting before setting
    // the value and enable broadcasting again afterwards.
    // same applies to the cancel button below.
    b1.setBroadcast(false); 
    b1.setValue(1);
    b1.setBroadcast(true);
    b1.setCaptionLabel("OK");
    // centering of a label needs to be done manually with marginTop and marginLeft
    b1.captionLabel().style().marginTop = 0;
    b1.captionLabel().style().marginLeft = 30;
    
    // add the Cancel button to the messageBox. 
    controlP5.Button b2 = cp5.addButton("buttonCancel_" + device,0,155,80 + marginY,80,24);
    b2.moveTo(GUIMessageBox);
    b2.setBroadcast(false);
    b2.setValue(0);
    b2.setBroadcast(true);
    b2.setCaptionLabel("Cancel");
    b2.setColorBackground(color(40));
    b2.setColorActive(color(20));
    // centering of a label needs to be done manually with marginTop and marginLeft
    b2.captionLabel().style().marginTop = 0;
    b2.captionLabel().style().marginLeft = 22;
  }
  
  // buttonOK will be triggered when pressing the OK button of the messageBox.
  public void buttonOK_FrontLeftStrobe(int theValue) {
    GUIMessageBoxString = ((Textfield)cp5.controller("inputbox_FrontLeftStrobe")).getText();
    GUIMessageBoxResult = theValue;
    gui_parseMessageBoxFrontLeftStrobe(GUIMessageBoxString);
    GUIMessageBox.hide();
  }
  
  public void buttonOK_FrontRightStrobe(int theValue) {
    GUIMessageBoxString = ((Textfield)cp5.controller("inputbox_FrontRightStrobe")).getText();
    GUIMessageBoxResult = theValue;
    gui_parseMessageBoxFrontRightStrobe(GUIMessageBoxString);
    GUIMessageBox.hide();
  }
  
  // function buttonCancel will be triggered when pressing the Cancel button of the messageBox.
  public void buttonCancel_FrontLeftStrobe(int theValue) {
    GUIMessageBoxResult = theValue;
    GUIMessageBox.hide();
  }
  
  public void buttonCancel_FrontRightStrobe(int theValue) {
    GUIMessageBoxResult = theValue;
    GUIMessageBox.hide();
  }
  
  // inputbox is called whenever RETURN has been pressed in textfield-controller inputbox 
  public void inputbox_FrontLeftStrobe(String theString) {
    GUIMessageBoxString = theString;
    gui_parseMessageBoxFrontLeftStrobe(GUIMessageBoxString);    
    GUIMessageBox.hide();
  }
  
  public void inputbox_FrontRightStrobe(String theString) {
    GUIMessageBoxString = theString;
    gui_parseMessageBoxFrontRightStrobe(GUIMessageBoxString);    
    GUIMessageBox.hide();
  }

  public void buttonOK_BackStrobe(int theValue) {
    GUIMessageBoxString = ((Textfield)cp5.controller("inputbox_BackStrobe")).getText();
    GUIMessageBoxResult = theValue;
    gui_parseMessageBoxBackStrobe(GUIMessageBoxString);
    GUIMessageBox.hide();
  }
  public void buttonCancel_BackStrobe(int theValue) {
    GUIMessageBoxResult = theValue;
    GUIMessageBox.hide();
  }
  public void inputbox_BackStrobe(String theString) {
    GUIMessageBoxString = theString;
    gui_parseMessageBoxBackStrobe(GUIMessageBoxString);    
    GUIMessageBox.hide();
  }

  public void buttonOK_LEDTube(int theValue) {
    GUIMessageBoxString = ((Textfield)cp5.controller("inputbox_LEDTube")).getText();
    GUIMessageBoxResult = theValue;
    gui_parseMessageBoxLEDTube(GUIMessageBoxString);
    GUIMessageBox.hide();
  }
  public void buttonCancel_LEDTube(int theValue) {
    GUIMessageBoxResult = theValue;
    GUIMessageBox.hide();
  }
  public void inputbox_LEDTube(String theString) {
    GUIMessageBoxString = theString;
    gui_parseMessageBoxLEDTube(GUIMessageBoxString);    
    GUIMessageBox.hide();
  }
  
  public void buttonOK_RackLight(int theValue) {
    GUIMessageBoxString = ((Textfield)cp5.controller("inputbox_LEDTube")).getText();
    GUIMessageBoxResult = theValue;
    gui_parseMessageBoxRackLight(GUIMessageBoxString);
    GUIMessageBox.hide();
  }
  public void buttonCancel_RackLight(int theValue) {
    GUIMessageBoxResult = theValue;
    GUIMessageBox.hide();
  }
  public void inputbox_RackLight(String theString) {
    GUIMessageBoxString = theString;
    gui_parseMessageBoxRackLight(GUIMessageBoxString);    
    GUIMessageBox.hide();
  }
  
  public void gui_parseMessageBoxFrontLeftStrobe(String result) {
    int[] parsedResult = gui_parseStringGenericDMX(result, 4);
    if (parsedResult[2] < 0) {
      DMXList_FrontLeftStroboscopes.add(new DMX_Stroboscope(parsedResult[0], parsedResult[1]));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : FRONT LEFT STROBOSCOPE ("+parsedResult[0]+" | "+parsedResult[1]+")");
    }
    else {
      DMXList_FrontLeftStroboscopes.add(new DMX_Stroboscope(parsedResult[0], parsedResult[1], parsedResult[2], parsedResult[3]));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : FRONT LEFT STROBOSCOPE ("+parsedResult[0]+" | "+parsedResult[1]+" | "+parsedResult[2]+" | "+parsedResult[3]+")");
    }
    
    resetExpectedTextLabel.setVisible(true);
    createConfigFile();
  }
  public void gui_parseMessageBoxFrontRightStrobe(String result) {
    int[] parsedResult = gui_parseStringGenericDMX(result, 4);
    if (parsedResult[2] < 0) {
      DMXList_FrontRightStroboscopes.add(new DMX_Stroboscope(parsedResult[0], parsedResult[1]));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : FRONT RIGHT STROBOSCOPE ("+parsedResult[0]+" | "+parsedResult[1]+")");
    }
    else {
      DMXList_FrontRightStroboscopes.add(new DMX_Stroboscope(parsedResult[0], parsedResult[1], parsedResult[2], parsedResult[3]));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : FRONT RIGHT STROBOSCOPE ("+parsedResult[0]+" | "+parsedResult[1]+" | "+parsedResult[2]+" | "+parsedResult[3]+")");
    }
    
    resetExpectedTextLabel.setVisible(true);
    createConfigFile();
  }
  public void gui_parseMessageBoxBackStrobe(String result) {
    int[] parsedResult = gui_parseStringGenericDMX(result, 4);
    if (parsedResult[2] < 0) {
      DMXList_BackStroboscopes.add(new DMX_Stroboscope(parsedResult[0], parsedResult[1]));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : BACK STROBOSCOPE ("+parsedResult[0]+" | "+parsedResult[1]+")");
    }
    else {
      DMXList_BackStroboscopes.add(new DMX_Stroboscope(parsedResult[0], parsedResult[1], parsedResult[2], parsedResult[3]));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : BACK STROBOSCOPE ("+parsedResult[0]+" | "+parsedResult[1]+" | "+parsedResult[2]+" | "+parsedResult[3]+")");
    }
    resetExpectedTextLabel.setVisible(true);
    createConfigFile();
  }
  public void gui_parseMessageBoxLEDTube(String result) {
    int parsedResult = -1;
    try {
      parsedResult = Integer.parseInt(result);
    }
    catch (Exception e) {
      outputLog.println("Caught an exception while trying to parse the following string : " + result + " (in order to create a new LED Tube device) : " + e);
    }
    if (parsedResult >= 0) {
      CustomDeviceList_LEDTubes.add(new CustomDevice_LEDTube(parsedResult));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : LED TUBE (ID "+parsedResult+")");
    }    
    resetExpectedTextLabel.setVisible(true);
    createConfigFile();
  }
  public void gui_parseMessageBoxRackLight(String result) {
    int parsedResult = -1;
    try {
      parsedResult = Integer.parseInt(result);
    }
    catch (Exception e) {
      outputLog.println("Caught an exception while trying to parse the following string : " + result + " (in order to create a new Rack Light device) : " + e);
    }
    if (parsedResult >= 0) {
      CustomDeviceList_RackLights.add(new CustomDevice_RackLight(parsedResult));
      resetExpectedTextLabel.setText("PLEASE RESET THE APP BEFORE MAKING FURTHER CHANGES\nNEW DEVICE REGISTERED : RACK LIGHT (ID "+parsedResult+")");
    }    
    resetExpectedTextLabel.setVisible(true);
    createConfigFile();
  }
  
  //Parse strings like "(2,3,5)", to return {2,3,5}
  public int[] gui_parseStringGenericDMX(String string, int numberOfChannels) {
    
    int[] result = new int[numberOfChannels];
    for (int i=0; i<numberOfChannels; i++) {result[i] = -1;}
    
    try {
      boolean rejectLine = false;
      if (string.indexOf("(") != 0) {
        rejectLine = true;
        outputLog.println("Bad string formatting for new DMX device declaration : " + string);
      }
      if (string.indexOf(")") != string.length() - 1) {
        rejectLine = true;
        outputLog.println("Bad string formatting for new DMX device declaration : " + string);
      }
      
      String[] subStringSplit = split(string.substring(1, string.length() - 1), ",");
      
      if (subStringSplit.length != numberOfChannels) {
        rejectLine = true;
        outputLog.println("Bad string formatting for new DMX device declaration : " + string);
      }
      if (rejectLine == false) {
        for (int i=0; i<numberOfChannels; i++) {
          result[i] = Integer.parseInt(subStringSplit[i]);
        }
      }
      return result;
    }
    catch (Exception e) {
      outputLog.println("Caught an exception while trying to parse the following string : " + string + " (in order to create a new DMX device) : " + e);
      return result;
    }
  }


    

  public void controlEvent(ControlEvent theEvent) {
    if (gui_initComplete) {

      if (theEvent.getName() == "Activate Simulator") {
        gui_activateSimulator = !gui_activateSimulator;
        if (gui_activateSimulator) {
          auxControlFrame.frameRate(FRAMERATE_SIMU);
        }
        else {
          auxControlFrame.frameRate(FRAMERATE_NOSIMU);    // Put a limit on the GUI's framerate - very important in order to limit the CPU usage
        }
      }
      else if (theEvent.getName() == "Auto Mode") {
        AUTOMATIC_MODE = setAutomaticModeToggle.getState();
      }
      else if (theEvent.getName() == "Activate audio monitoring") {
        gui_activateAudioMonitoring = setAudioMonitoringToggle.getState();
        inactiveAudioMonitoringTextLabel.setVisible(!(setAudioMonitoringToggle.getState()));
        audioMonitoringKickTextLabel.setVisible((setAudioMonitoringToggle.getState()));
        audioMonitoringSnareTextLabel.setVisible((setAudioMonitoringToggle.getState()));
        audioMonitoringCymbalsTextLabel.setVisible((setAudioMonitoringToggle.getState()));
        audioMonitoringBassTextLabel.setVisible((setAudioMonitoringToggle.getState()));
        audioMonitoringKeysTextLabel.setVisible((setAudioMonitoringToggle.getState()));
        audioMonitoringGuitarTextLabel.setVisible((setAudioMonitoringToggle.getState()));
        
      }
      else if (theEvent.getName() == "Change Panel Mapping") {
        gui_changePanelMappingActive = changeLEDPanelMappingToggle.getState();
        if (gui_changePanelMappingActive) { gui_activateMappingBangs(); initLEDPanelMappingArray(); resetLEDPanelMapping();} 
                                     else { gui_disableMappingBangs();  }
      }
      else if (theEvent.getName().contains("Mapping Config Bang - Panel")) {
        if (gui_changePanelMappingActive) {
          registerBangForLEDPanelMapping(Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length())));
        }
      }
      else if (theEvent.getName() == "Number Of Panels") {
        NUMBER_OF_PANELS = Integer.parseInt(cp5.getController("Number Of Panels").getStringValue());
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
        //Prevent any further frame sending
        debug_without_panels = true;
      }
      else if (theEvent.getName().contains("LED Panel Microcontroller ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        devicesToParse[devNumber] = "/dev/" + cp5.getController(theEvent.getName()).getStringValue();
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
      }
      else if (theEvent.getName() == "DMX Microcontroller") {
        DMX_MICROCONTROLLER_NAME = "/dev/" + cp5.getController("DMX Microcontroller").getStringValue();
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
      }
      else if (theEvent.getName() == "Custom Devices Microcontroller") {
        CUSTOMDEVICES_MICROCONTROLLER_NAME = "/dev/" + cp5.getController("Custom Devices Microcontroller").getStringValue();
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
      }
      
      ////////////////////
      // DMX events
      
      else if (theEvent.getName() == "Add Front Left Strobe") {
        String [] explanation = {"Input new DMX device's channel info using the following syntax : ",
                                 "            For a 2-channel strobe : (Speed, Brightness)",
                                 "            For a 4-channel strobe : (Intensity, Duration, Speed, Special FX)",
                                 "For example, for a 2-channel stroboscope working on channels 4 and 5, input: (4,5)"};
        createMessageBox("FrontLeftStrobe", explanation);
        //The Reset flag is raised in case of successful parsing
      }
      else if (theEvent.getName() == "Add Front Right Strobe") {
        String [] explanation = {"Input new DMX device's channel info using the following syntax : ",
                                 "            For a 2-channel strobe : (Speed, Brightness)",
                                 "            For a 4-channel strobe : (Intensity, Duration, Speed, Special FX)",
                                 "For example, for a 2-channel stroboscope working on channels 4 and 5, input: (4,5)"};
        createMessageBox("FrontRightStrobe", explanation);
        //The Reset flag is raised in case of successful parsing
      }
      else if (theEvent.getName() == "Add Back Strobe") {
        String [] explanation = {"Input new DMX device's channel info using the following syntax : ",
                                 "            For a 2-channel strobe : (Speed, Brightness)",
                                 "            For a 4-channel strobe : (Intensity, Duration, Speed, Special FX)",
                                 "For example, for a 2-channel stroboscope working on channels 4 and 5, input: (4,5)"};
        createMessageBox("BackStrobe", explanation);
        //The Reset flag is raised in case of successful parsing
      }
      
      else if (theEvent.getName().contains("Front Left Strobe ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        //Check if the user wants to delete the device

        if (cp5.getController(theEvent.getName()).getStringValue().equals("(0,0,0,0)") ||
            cp5.getController(theEvent.getName()).getStringValue().equals("(0,0)")) {
          DMXList_FrontLeftStroboscopes.remove(DMXList_FrontLeftStroboscopes.get(devNumber));
          outputLog.println("IMPORTANT : Removed front left stroboscope device #" + devNumber);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
          
          //Rebuild the GUI !
          createGeneralInfoAccordion();
        }
        //The user only wants to change the DMX settings
        else {
          int[] parseResult = gui_parseStringGenericDMX(cp5.getController(theEvent.getName()).getStringValue(), 3);

          //Check if the values returned are coherent - ie do not contain any negative values
          int voidOccurence = 0;
          int posOccurence  = 0;
          for (int i: parseResult) {
            if (i < 0) {voidOccurence += 1;}
                  else {posOccurence  += 1;}
          }
          if (voidOccurence == 0) {
            if (posOccurence == 2) {
              DMXList_FrontLeftStroboscopes.get(devNumber).DMXAddress_stroboscopeSpeed        = parseResult[0];
              DMXList_FrontLeftStroboscopes.get(devNumber).DMXAddress_stroboscopeBrightness   = parseResult[1];

              outputLog.println("IMPORTANT : Modified front left stroboscope device #" + devNumber + " with the values : " + parseResult[0] + "," + parseResult[1] + "," + parseResult[2]);
              resetExpectedTextLabel.setVisible(true);
              createConfigFile();
              
              //Rebuild the GUI !
              createGeneralInfoAccordion();
            }
            else if (posOccurence == 4) {
              DMXList_FrontLeftStroboscopes.get(devNumber).DMXAddress_stroboscopeBrightness   = parseResult[0];
              DMXList_FrontLeftStroboscopes.get(devNumber).DMXAddress_stroboscopeFlashLength  = parseResult[1];
              DMXList_FrontLeftStroboscopes.get(devNumber).DMXAddress_stroboscopeSpeed        = parseResult[2];
              DMXList_FrontLeftStroboscopes.get(devNumber).DMXAddress_stroboscopeSpecialFX    = parseResult[3];
              outputLog.println("IMPORTANT : Modified front left stroboscope device #" + devNumber + " with the values : " + parseResult[0] + "," + parseResult[1] + "," + parseResult[2] + "," + parseResult[3]);
              resetExpectedTextLabel.setVisible(true);
              createConfigFile();
              
              //Rebuild the GUI !
              createGeneralInfoAccordion();
            }
            else {
              outputLog.println("ERROR : Could not parse a modification for a left stroboscope");
            }
          }
        }
      }
      else if (theEvent.getName().contains("Front Right Strobe ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        //Check if the user wants to delete the device

        if (cp5.getController(theEvent.getName()).getStringValue().equals("(0,0,0,0)") ||
            cp5.getController(theEvent.getName()).getStringValue().equals("(0,0)")) {
          DMXList_FrontRightStroboscopes.remove(DMXList_FrontRightStroboscopes.get(devNumber));
          outputLog.println("IMPORTANT : Removed front right stroboscope device #" + devNumber);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
          
          //Rebuild the GUI !
          createGeneralInfoAccordion();
        }
        //The user only wants to change the DMX settings
        else {
          int[] parseResult = gui_parseStringGenericDMX(cp5.getController(theEvent.getName()).getStringValue(), 3);

          //Check if the values returned are coherent - ie do not contain more than once "-1"
          int voidOccurence = 0;
          for (int i: parseResult) {
            if (i == -1) {voidOccurence += 1;}
          }
          if (voidOccurence <= 1) {
            DMXList_FrontRightStroboscopes.get(devNumber).DMXAddress_stroboscopeSpeed        = parseResult[0];
            DMXList_FrontRightStroboscopes.get(devNumber).DMXAddress_stroboscopeBrightness   = parseResult[1];
            DMXList_FrontRightStroboscopes.get(devNumber).DMXAddress_stroboscopeFlashLength  = parseResult[2];
            outputLog.println("IMPORTANT : Modified front left stroboscope device #" + devNumber + " with the values : " + parseResult[0] + "," + parseResult[1] + "," + parseResult[2]);
            resetExpectedTextLabel.setVisible(true);
            createConfigFile();
            
            //Rebuild the GUI !
            createGeneralInfoAccordion();
          }
        }
      }
      else if (theEvent.getName().contains("Back Strobe ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        //Check if the user wants to delete the device

        if (cp5.getController(theEvent.getName()).getStringValue().equals("(0,0,0,0)") ||
            cp5.getController(theEvent.getName()).getStringValue().equals("(0,0)")) {
          DMXList_BackStroboscopes.remove(DMXList_BackStroboscopes.get(devNumber));
          outputLog.println("IMPORTANT : Removed back stroboscope device #" + devNumber);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
          
          //Rebuild the GUI !
          createGeneralInfoAccordion();
        }
        //The user only wants to change the DMX settings
        else {
          int[] parseResult = gui_parseStringGenericDMX(cp5.getController(theEvent.getName()).getStringValue(), 3);

          //Check if the values returned are coherent - ie do not contain more than once "-1"
          int voidOccurence = 0;
          for (int i: parseResult) {
            if (i == -1) {voidOccurence += 1;}
          }
          if (voidOccurence <= 1) {
            DMXList_BackStroboscopes.get(devNumber).DMXAddress_stroboscopeSpeed        = parseResult[0];
            DMXList_BackStroboscopes.get(devNumber).DMXAddress_stroboscopeBrightness   = parseResult[1];
            DMXList_BackStroboscopes.get(devNumber).DMXAddress_stroboscopeFlashLength  = parseResult[2];
            outputLog.println("IMPORTANT : Modified back stroboscope device #" + devNumber + " with the values : " + parseResult[0] + "," + parseResult[1] + "," + parseResult[2]);
            resetExpectedTextLabel.setVisible(true);
            createConfigFile();
            
            //Rebuild the GUI !
            createGeneralInfoAccordion();
          }
        }
      }
      
      
      /////////////////////////
      // Custom devices
      
      else if (theEvent.getName() == "Add LED Tube") {
        String [] explanation = {"Input new LED Tube's ID info using the following syntax : ID",
                                 "For example, for a led tube defined with an ID equal to 3, input: 3"};
        createMessageBox("LEDTube", explanation);
        //The Reset flag is raised in case of successful parsing
      }
      else if (theEvent.getName() == "Add Rack Light") {
        String [] explanation = {"Input new Rack Light's ID info using the following syntax : ID",
                                 "For example, for a rack light defined with an ID equal to 3, input: 3"};
        createMessageBox("RackLight", explanation);
        //The Reset flag is raised in case of successful parsing
      }
      else if (theEvent.getName().contains("LED Tube ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        //Check if the user wants to delete the device
        int parsedResult = -1;
        try {
          parsedResult = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        }
        catch (Exception e) {
          outputLog.println("Caught an exception while trying to parse the following string : " + cp5.getController(theEvent.getName()).getStringValue() + " (in order to parse a LED Tube device modification) : " + e);
        }
        //Valid modification
        if (parsedResult >= 0) {
          CustomDeviceList_LEDTubes.get(devNumber).CustomDevice_deviceNumber  = parsedResult;
          outputLog.println("IMPORTANT : Modified LED Tube device #" + devNumber + " with the value : " + parsedResult);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
        }
        //Delete the device
        else {
          CustomDeviceList_LEDTubes.remove(CustomDeviceList_LEDTubes.get(devNumber));
          outputLog.println("IMPORTANT : Removed LED tube device #" + devNumber);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
          
          //Rebuild the GUI !
          createGeneralInfoAccordion();
        }
      }
      else if (theEvent.getName().contains("Rack Light ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        //Check if the user wants to delete the device
        int parsedResult = -1;
        try {
          parsedResult = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        }
        catch (Exception e) {
          outputLog.println("Caught an exception while trying to parse the following string : " + cp5.getController(theEvent.getName()).getStringValue() + " (in order to parse a Rack Light device modification) : " + e);
        }
        //Valid modification
        if (parsedResult >= 0) {
          CustomDeviceList_RackLights.get(devNumber).CustomDevice_deviceNumber  = parsedResult;
          outputLog.println("IMPORTANT : Modified Rack Light device #" + devNumber + " with the value : " + parsedResult);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
        }
        //Delete the device
        else {
          CustomDeviceList_RackLights.remove(CustomDeviceList_RackLights.get(devNumber));
          outputLog.println("IMPORTANT : Removed Rack Light device #" + devNumber);
          resetExpectedTextLabel.setVisible(true);
          createConfigFile();
          
          //Rebuild the GUI !
          createGeneralInfoAccordion();
        }
      }
      
      /////////////////////////
      // MIDI Configuration
      
      else if (theEvent.getName() == "Main Input") {
        MIDI_BUS_MAIN_INPUT = cp5.getController("Main Input").getStringValue();
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
      }
      else if (theEvent.getName() == "Keyboard") {
        MIDI_BUS_KEYBOARD_INPUT = cp5.getController("Keyboard").getStringValue();
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
      }
      else if (theEvent.getName() == "General FX Controller") {
        MIDI_BUS_CONTROLLER_INPUT = cp5.getController("DMX Microcontroller").getStringValue();
        resetExpectedTextLabel.setVisible(true);
        createConfigFile();
      }
      
      
      /////////////////////////
      // Audio input configuration
      
      else if (theEvent.getName() == "Kick - Audio Signal ID") {
        SIGNAL_ID_KICK = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      else if (theEvent.getName() == "Snare - Audio Signal ID") {
        SIGNAL_ID_SNARE = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      else if (theEvent.getName() == "Cymbals - Audio Signal ID") {
        SIGNAL_ID_CYMBALS = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      else if (theEvent.getName() == "Bass - Audio Signal ID") {
        SIGNAL_ID_BASS = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      else if (theEvent.getName() == "Keys - Audio Signal ID") {
        SIGNAL_ID_KEYS = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      else if (theEvent.getName() == "Guitar - Audio Signal ID") {
        SIGNAL_ID_GUITAR = Integer.parseInt(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      else if (theEvent.getName() == "Bass Hi-Lo Ratio Threshold") {
        HI_LO_RATIO_THRESHOLD = Float.parseFloat(cp5.getController(theEvent.getName()).getStringValue());
        createConfigFile();
      }
      
      
      
      
      /////////////////////////
      // Device test : using the corresponding buttons, light up the devices to check proper connection
      // For DMX devices, it's normal the simulator won't light up
      
      // TBIL - needs to be redone after the proper DMX implementation
      // VERY important function !!! Do not forget to do it !!
      
//      else if (theEvent.getName().contains("Test FrontLeftStroboscope ")) {
//        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
//        float toggleValue =  cp5.getController(theEvent.getName()).getValue();
//        if (toggleValue == 1.0) {
//          //Start the corresponding stroboscope, full power
//          DMXList_FrontLeftStroboscopes.get(devNumber).startDMX(100);
//        }
//        else {
//          //Stop it once we're done
//          DMXList_FrontLeftStroboscopes.get(devNumber).stopDMX();
//        }
//      }
//      else if (theEvent.getName().contains("Test FrontRightStroboscope ")) {
//        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
//        float toggleValue =  cp5.getController(theEvent.getName()).getValue();
//        if (toggleValue == 1.0) {
//          //Start the corresponding stroboscope, full power
//          DMXList_FrontRightStroboscopes.get(devNumber).startDMX(100);
//        }
//        else {
//          //Stop it once we're done
//          DMXList_FrontRightStroboscopes.get(devNumber).stopDMX();
//        }
//      }
//      else if (theEvent.getName().contains("Test BackStroboscope ")) {
//        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
//        float toggleValue =  cp5.getController(theEvent.getName()).getValue();
//        if (toggleValue == 1.0) {
//          //Start the corresponding stroboscope, full power
//          DMXList_BackStroboscopes.get(devNumber).startDMX(100);
//        }
//        else {
//          //Stop it once we're done
//          DMXList_BackStroboscopes.get(devNumber).stopDMX();
//        }
//      }
      if (theEvent.getName().contains("Test LEDTube ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        float toggleValue =  cp5.getController(theEvent.getName()).getValue();
        if (toggleValue == 1.0f) {
          //Light up the corresponding LED Tube
          CustomDeviceList_LEDTubes.get(devNumber).setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
        }
        else {
          //Stop it once we're done
          CustomDeviceList_LEDTubes.get(devNumber).setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
        }
      }
      else if (theEvent.getName().contains("Test RackLight ")) {
        int devNumber = Integer.parseInt(theEvent.getName().substring(theEvent.getName().length() - 1, theEvent.getName().length()));
        float toggleValue =  cp5.getController(theEvent.getName()).getValue();
        if (toggleValue == 1.0f) {
          //Light up the corresponding Rack light
          CustomDeviceList_RackLights.get(devNumber).setDeviceAnimation(CUSTOMDEV_ANIM_WHITEOUT);
        }
        else {
          //Stop it once we're done
          CustomDeviceList_RackLights.get(devNumber).setDeviceAnimation(CUSTOMDEV_ANIM_BLACKOUT);
        }
      }
       
      
      /////////////////////////
      // Animation control
      
      else if (theEvent.getName() == "Reinit LED Panel list") {
        LEDPanelAnimations_animationListCheckBox.deactivateAll();
      }
      else if (theEvent.getName() == "Reinit CustomDevice list") {
        CustomDeviceAnimations_animationListCheckBox.deactivateAll();
      }
      else if (theEvent.getName() == "Reinit DMX list") {
        DMXStrobeAnimations_animationListCheckBox.deactivateAll();
      }
      else if (theEvent.getName() == "Attributes - LED Panel animations") {
        rebuildFilteredLEDPanelAnimationList(LEDPanelAnimations_animationListCheckBox.getArrayValue());        
      }
      else if (theEvent.getName() == "Attributes - Custom Device animations") {
        rebuildFilteredCustomDeviceAnimationList(CustomDeviceAnimations_animationListCheckBox.getArrayValue());        
      }
      else if (theEvent.getName() == "Attributes - DMX Strobe animations") {
        rebuildFilteredDMXStrobeAnimationList(DMXStrobeAnimations_animationListCheckBox.getArrayValue());        
      }
      else if (theEvent.getName() == "Attributes - DMX Moving Head animations - Prepare Direction") {
        rebuildFilteredDMXMovingHead_Movement_AnimationList(DMXMovingHeadAnimations_Movement_animationListCheckBox.getArrayValue());
      }
      else if (theEvent.getName() == "Attributes - DMX Moving Head animations - Set Color") {
        rebuildFilteredDMXMovingHead_Color_AnimationList(DMXMovingHeadAnimations_Color_animationListCheckBox.getArrayValue());
      }
      else if (theEvent.getName() == "Attributes - DMX Moving Head animations - Set Light Style") {
        rebuildFilteredDMXMovingHead_LightStyle_AnimationList(DMXMovingHeadAnimations_LightStyle_animationListCheckBox.getArrayValue());
      }
      else if (theEvent.getName() == "Attributes - DMX Moving Head animations - Perform Animations") {
        rebuildFilteredDMXMovingHead_Animations_AnimationList(DMXMovingHeadAnimations_Animations_animationListCheckBox.getArrayValue());
      }
      //With listBoxes, it is necessary to also check if theEvent.isGroup()
      else if (theEvent.getName() == "Filtered LED Panel Animation List" && theEvent.isGroup()) {
        int selectedVal = PApplet.parseInt(LEDPanelAnimations_animationListBox.getValue());
        String selectedItem =  LEDPanelAnimations_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);
        
        
        //Update the description
        String textDescription = "Current animation description \n"
                                      + animationAttributes.get(animNbr).name + "\n"
                                      + "\n"
                                      + "Animation number : " + animationAttributes.get(animNbr).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromAnimationNumber(animationAttributes.get(animNbr).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + animationAttributes.get(animNbr).attributes;
        LEDPanelAnimations_currentAnimationDescription.setText(textDescription);
        
        gui_loadLEDPanelAnimation(animNbr);
      }
      else if (theEvent.getName() == "Filtered Custom Device Animation List") {
        int selectedVal = PApplet.parseInt(CustomDeviceAnimations_animationListBox.getValue());
        String selectedItem =  CustomDeviceAnimations_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);
        
        
        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current animation description \n"
                                      + customDevicesAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + customDevicesAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromCustomDeviceAnimationNumber(customDevicesAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + customDevicesAttributes.get(animNbr - 1).attributes;
        CustomDeviceAnimations_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        customDeviceAnimation(animNbr);

      }
      else if (theEvent.getName() == "Filtered DMX Strobe Animation List") {
        int selectedVal = PApplet.parseInt(DMXStrobeAnimations_animationListBox.getValue());
        String selectedItem =  DMXStrobeAnimations_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);
        
        
        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current strobe animation description \n"
                                      + DMXStrobeAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + DMXStrobeAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromDMXAnimationNumber_strobe(DMXStrobeAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + DMXStrobeAttributes.get(animNbr - 1).attributes;
        DMXStrobeAnimations_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        gui_loadDMXAnimation_strobe(animNbr);

      }
      else if (theEvent.getName() == "Filtered DMX Moving Head Animation List - Prepare Direction") {
        int selectedVal = PApplet.parseInt(DMXMovingHeadAnimations_Movement_animationListBox.getValue());
        String selectedItem =  DMXMovingHeadAnimations_Movement_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);

        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current moving head animation description \n"
                                      + DMXMovingHead_MovementAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + DMXMovingHead_MovementAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromDMXAnimationNumber_movingHead_Movement(DMXMovingHead_MovementAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + DMXMovingHead_MovementAttributes.get(animNbr - 1).attributes;

        DMXMovingHeadAnimations_Movement_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        gui_loadDMXAnimation_movingHead_Movement(animNbr);

      }
      else if (theEvent.getName() == "Filtered DMX Moving Head Animation List - Set Color") {
        int selectedVal = PApplet.parseInt(DMXMovingHeadAnimations_Color_animationListBox.getValue());
        String selectedItem =  DMXMovingHeadAnimations_Color_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);

        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current moving head animation description \n"
                                      + DMXMovingHead_ColorAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + DMXMovingHead_ColorAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromDMXAnimationNumber_movingHead_Color(DMXMovingHead_ColorAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + DMXMovingHead_ColorAttributes.get(animNbr - 1).attributes;
        DMXMovingHeadAnimations_Color_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        gui_loadDMXAnimation_movingHead_Color(animNbr);

      }
      else if (theEvent.getName() == "Filtered DMX Moving Head Animation List - Set Rhythm") {
        int selectedVal = PApplet.parseInt(DMXMovingHeadAnimations_Rhythm_animationListBox.getValue());
        String selectedItem =  DMXMovingHeadAnimations_Rhythm_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);

        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current moving head animation description \n"
                                      + DMXMovingHead_RhythmAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + DMXMovingHead_RhythmAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromDMXAnimationNumber_movingHead_Rhythm(DMXMovingHead_RhythmAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + DMXMovingHead_RhythmAttributes.get(animNbr - 1).attributes;
        DMXMovingHeadAnimations_Rhythm_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        gui_loadDMXAnimation_movingHead_Rhythm(animNbr);

      }
      else if (theEvent.getName() == "Filtered DMX Moving Head Animation List - Set Light Style") {
        int selectedVal = PApplet.parseInt(DMXMovingHeadAnimations_LightStyle_animationListBox.getValue());
        String selectedItem =  DMXMovingHeadAnimations_LightStyle_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);

        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current moving head animation description \n"
                                      + DMXMovingHead_LightStyleAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + DMXMovingHead_LightStyleAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromDMXAnimationNumber_movingHead_LightStyle(DMXMovingHead_LightStyleAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + DMXMovingHead_LightStyleAttributes.get(animNbr - 1).attributes;
        DMXMovingHeadAnimations_LightStyle_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        gui_loadDMXAnimation_movingHead_LightStyle(animNbr);

      }
      else if (theEvent.getName() == "Filtered DMX Moving Head Animation List - Perform Animations") {
        int selectedVal = PApplet.parseInt(DMXMovingHeadAnimations_Animations_animationListBox.getValue());
        String selectedItem =  DMXMovingHeadAnimations_Animations_animationListBox.getListBoxItems()[selectedVal][0];
        String[] selectedItemSplit = split(selectedItem, ":");
        int animNbr = Integer.parseInt(selectedItemSplit[0]);

        //Update the description
        //Note : get animNbr - 1, because unlike for the LED Panel animations, there is no 0
        String textDescription = "Current moving head animation description \n"
                                      + DMXMovingHead_AnimationAttributes.get(animNbr - 1).name + "\n"
                                      + "\n"
                                      + "Animation number : " + DMXMovingHead_AnimationAttributes.get(animNbr - 1).animationNbr + "\n"
                                      + "Corresponding note/velocity : " + getStringFromDMXAnimationNumber_movingHead_Animation(DMXMovingHead_AnimationAttributes.get(animNbr - 1).animationNbr) + "\n"
                                      + "Attributes:\n"
                                      + DMXMovingHead_AnimationAttributes.get(animNbr - 1).attributes;
        DMXMovingHeadAnimations_Animations_currentAnimationDescription.setText(textDescription);
        
        //Load the animation
        gui_loadDMXAnimation_movingHead(animNbr);

      }
      else if (theEvent.getName().contains("Effect Bang")) {
        String[] eventNameSplit = split(theEvent.getName(), " ");
        int effectNumber = PApplet.parseInt(eventNameSplit[3]);
        activateAdditionalEffect(effectNumber);
      }
    }
  }
  
  //////////////////////////////////////////
  // Create a small interface to monitor the incoming audio
  
  public void createAudioMonitoringGroup() {
        
    Group AudioMonitoringGroup = cp5.addGroup("Audio monitoring")
                                    .setPosition(gui_audioMonitoringGroupOffsetX,22*height/30 )
                                    .setWidth(gui_audioMonitoringGroupWidth)
                                    .activateEvent(true)
                                    .disableCollapse() 
                                    .setBackgroundColor(color(255,40))
                                    .setBackgroundHeight(height/4-20)
                                    .setLabel("Audio monitoring")
                                    ;
    
    setAudioMonitoringToggle = cp5.addToggle("Activate audio monitoring")
                                  .setValue(0)
                                  .setCaptionLabel("Activate Audio Monitoring")
                                  .setPosition(gui_spacing, gui_spacing)
                                  .setSize(gui_audioMonitoringToggleWidth, gui_audioMonitoringToggleHeight)
                                  .setColorBackground(color(100,0,0))
                                  .setColorForeground(color(130,0,0))
                                  .setColorActive(color(160,0,0))
                                  .setGroup(AudioMonitoringGroup)
                                  ;
    setAudioMonitoringToggle.getCaptionLabel().align(ControlP5.CENTER, ControlP5.CENTER);
    
    //Label which gets hidden when audio monitoring is activated
    inactiveAudioMonitoringTextLabel = cp5.addTextlabel("Inactive Audio Monitoring")
                                          .setText("AUDIO MONITORING IS CURRENTLY INACTIVE\nACTIVATE ONLY IF YOU NEED TO CHECK CORRECT INPUT \nROUTING THROUGH THE GUI AS ALL INCOMING AUDIO DATA \nWILL BE PROCESSED, REGARDLESS THIS TOGGLE")
                                          .setPosition(gui_spacing, gui_spacing*5)
                                          .setColorValue(color(255))
                                          .moveTo(AudioMonitoringGroup)
                                          ;
    inactiveAudioMonitoringTextLabel.setVisible(true);
    
    //Labels which gets hidden when audio monitoring is deactivated
    audioMonitoringKickTextLabel = cp5.addTextlabel("Audio Monitoring - Kick")
                                      .setText("KICK")
                                      .setPosition(2*gui_spacing + audioMonitoring_barWidth, 4*gui_spacing + 0*(10 + audioMonitoring_barHeight))
                                      .setColorValue(color(255))
                                      .moveTo(AudioMonitoringGroup)
                                      ;
    audioMonitoringSnareTextLabel = cp5.addTextlabel("Audio Monitoring - Snare")
                                      .setText("SNARE")
                                      .setPosition(2*gui_spacing + audioMonitoring_barWidth, 4*gui_spacing + 1*(10 + audioMonitoring_barHeight))
                                      .setColorValue(color(255))
                                      .moveTo(AudioMonitoringGroup)
                                      ;
    audioMonitoringCymbalsTextLabel = cp5.addTextlabel("Audio Monitoring - Cymbals")
                                      .setText("CYMBALS")
                                      .setPosition(2*gui_spacing + audioMonitoring_barWidth, 4*gui_spacing + 2*(10 + audioMonitoring_barHeight))
                                      .setColorValue(color(255))
                                      .moveTo(AudioMonitoringGroup)
                                      ;
    audioMonitoringBassTextLabel = cp5.addTextlabel("Audio Monitoring - Bass")
                                      .setText("BASS")
                                      .setPosition(2*gui_spacing + audioMonitoring_barWidth, 4*gui_spacing + 3*(10 + audioMonitoring_barHeight))
                                      .setColorValue(color(255))
                                      .moveTo(AudioMonitoringGroup)
                                      ;
    audioMonitoringKeysTextLabel = cp5.addTextlabel("Audio Monitoring - Keys")
                                      .setText("KEYS")
                                      .setPosition(2*gui_spacing + audioMonitoring_barWidth, 4*gui_spacing + 4*(10 + audioMonitoring_barHeight))
                                      .setColorValue(color(255))
                                      .moveTo(AudioMonitoringGroup)
                                      ;
    audioMonitoringGuitarTextLabel = cp5.addTextlabel("Audio Monitoring - Guitar")
                                      .setText("GUITAR")
                                      .setPosition(2*gui_spacing + audioMonitoring_barWidth, 4*gui_spacing + 5*(10 + audioMonitoring_barHeight))
                                      .setColorValue(color(255))
                                      .moveTo(AudioMonitoringGroup)
                                      ;
    audioMonitoringKickTextLabel.setVisible(false);
    audioMonitoringSnareTextLabel.setVisible(false);
    audioMonitoringCymbalsTextLabel.setVisible(false);
    audioMonitoringBassTextLabel.setVisible(false);
    audioMonitoringKeysTextLabel.setVisible(false);
    audioMonitoringGuitarTextLabel.setVisible(false);
    
  }
  
  // Draw the actual audio info
  public void draw_audioMonitoring(int offsetX, int offsetY, int spacing) {
    draw_singleAudioBar(offsetX, offsetY + 0*(spacing + audioMonitoring_barHeight), automaticSequencer.globalIntensity_Kick,    audioMonitoring_maxSignalLevel_Kick);
    draw_singleAudioBar(offsetX, offsetY + 1*(spacing + audioMonitoring_barHeight), automaticSequencer.globalIntensity_Snare,   audioMonitoring_maxSignalLevel_Snare);
    draw_singleAudioBar(offsetX, offsetY + 2*(spacing + audioMonitoring_barHeight), automaticSequencer.globalIntensity_Cymbals, audioMonitoring_maxSignalLevel_Cymbals);
    draw_singleAudioBar(offsetX, offsetY + 3*(spacing + audioMonitoring_barHeight), automaticSequencer.globalIntensity_Bass,    audioMonitoring_maxSignalLevel_Bass);
    draw_singleAudioBar(offsetX, offsetY + 4*(spacing + audioMonitoring_barHeight), automaticSequencer.globalIntensity_Keys,    audioMonitoring_maxSignalLevel_Keys);
    draw_singleAudioBar(offsetX, offsetY + 5*(spacing + audioMonitoring_barHeight), automaticSequencer.globalIntensity_Guitar,  audioMonitoring_maxSignalLevel_Guitar);
    
    draw_timeInfoText();
    draw_autoModeInfo();
  }

  public void draw_singleAudioBar(int x, int y, float val, float maxVal) {
    noStroke();
    fill(80);
    rect(x, y, audioMonitoring_barWidth, audioMonitoring_barHeight);
    fill(160);
    rect(x, y, map(constrain(val,0,maxVal),0,maxVal, 0, audioMonitoring_barWidth), audioMonitoring_barHeight);
  }  
  
  public void draw_timeInfoText() {
    textFont(minimlFont, 8);
    textAlign(LEFT, TOP);
    fill(255);
    text(formatTimeInfoPositionText(), gui_audioMonitoringGroupOffsetX + 175,22*gui_height/30 + 4*gui_spacing + 0);
    text(formatTimeInfoBPMText(),      gui_audioMonitoringGroupOffsetX + 175,22*gui_height/30 + 4*gui_spacing + 13);
    text(formatTimeInfoPlayingText(),  gui_audioMonitoringGroupOffsetX + 175,22*gui_height/30 + 4*gui_spacing + 26);
    
  }
  
  public String formatTimeInfoPositionText() {
    int bar    = (((int) automaticSequencer.currentPosition) / 4) + 1;
    int beat   = ((int) (automaticSequencer.currentPosition % 4.0f)) + 1;
    int ticks  = ((int) ( (automaticSequencer.currentPosition % 1.0f) * 960.0f + 0.5f));
    return "POSITION: " + bar + "|" + beat + "|" + ticks;
  }
  
  public String formatTimeInfoBPMText() {
    return "TEMPO: " + automaticSequencer.currentBPM + " BPM";
  }
  
  public String formatTimeInfoPlayingText() {
    
    if (automaticSequencer.isPlaying) {
      return "PLAYBACK: ON";
    }
    else {
      return "PLAYBACK: OFF";
    }
  }
  
  public void draw_autoModeInfo() {
    textFont(minimlFont, 8);
    textAlign(LEFT, TOP);
    fill(255);
    text(formatCurrentIntensityText(),  gui_audioMonitoringGroupOffsetX + 175,22*gui_height/30 + 4*gui_spacing + 39);
  }
  
  public String formatCurrentIntensityText() {
    if (automaticSequencer.onlyGuitarIsPlaying) {
      return "INTENSITY: SOLO GUITAR";
    }
    else if (automaticSequencer.onlyFilteredBassIsPlaying) {
      return "INTENSITY: SOLO HPF BASS";
    }
    else if (automaticSequencer.currentIntensity == INTENSITY_DEFAULT) {
      return "INTENSITY: DEFAULT";
    }
    else if (automaticSequencer.currentIntensity == INTENSITY_LOW) {
      return "INTENSITY: LOW";
    }
    else if (automaticSequencer.currentIntensity == INTENSITY_MEDIUM) {
      return "INTENSITY: MEDIUM";
    }
    else if (automaticSequencer.currentIntensity == INTENSITY_HIGH) {
      return "INTENSITY: HIGH";
    }
    else if (automaticSequencer.currentIntensity == INTENSITY_MAX) {
      return "INTENSITY: MAX";
    }
    return "INTENSITY: ";
  }
}



public String[] createLEDPanelAnimationListFilter(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_LEDPANEL_GEOMETRIC   : temp.append("Geometric"  );break;
        case GUI_ATTR_LEDPANEL_ATMOSPHERIC : temp.append("Atmospheric");break;
        case GUI_ATTR_LEDPANEL_FADE_IN_OUT : temp.append("Fade In/Out");break;
        case GUI_ATTR_LEDPANEL_RANDOM      : temp.append("Random"     );break;
        case GUI_ATTR_LEDPANEL_VERY_BRIGHT : temp.append("Very Bright");break;
        case GUI_ATTR_LEDPANEL_VERY_DARK   : temp.append("Very Dark"  );break;
        case GUI_ATTR_LEDPANEL_RED         : temp.append("Red"        );break;
        case GUI_ATTR_LEDPANEL_B_W         : temp.append("B&W"        );break;
        case GUI_ATTR_LEDPANEL_BLUE        : temp.append("Blue"       );break;
        case GUI_ATTR_LEDPANEL_COLORFUL    : temp.append("Colorful"   );break;
        case GUI_ATTR_LEDPANEL_ROTATING    : temp.append("Rotating"   );break;
        case GUI_ATTR_LEDPANEL_SIMPLE      : temp.append("Simple"     );break;
        case GUI_ATTR_LEDPANEL_COMPLEX     : temp.append("Complex"    );break;
        case GUI_ATTR_LEDPANEL_EVOLVING    : temp.append("Evolving"   );break;
        case GUI_ATTR_LEDPANEL_SMOOTH      : temp.append("Smooth"     );break;
        case GUI_ATTR_LEDPANEL_VIOLENT     : temp.append("Violent"    );break;
        case GUI_ATTR_LEDPANEL_RHYTHMIC    : temp.append("Rhythmic"   );break;
        case GUI_ATTR_LEDPANEL_FAST        : temp.append("Fast"       );break;
        case GUI_ATTR_LEDPANEL_SLOW        : temp.append("Slow"       );break;
        case GUI_ATTR_LEDPANEL_STILL       : temp.append("Still"      );break;
        case GUI_ATTR_LEDPANEL_LINES       : temp.append("Lines"      );break;
        case GUI_ATTR_LEDPANEL_CURVES      : temp.append("Curves"     );break;
        case GUI_ATTR_LEDPANEL_TRIANGLES   : temp.append("Triangles"  );break;
        case GUI_ATTR_LEDPANEL_SQUARES     : temp.append("Squares"    );break;
        case GUI_ATTR_LEDPANEL_CIRCLES     : temp.append("Circles"    );break;
        case GUI_ATTR_LEDPANEL_SPIRAL      : temp.append("Spiral"     );break;
        case GUI_ATTR_LEDPANEL_NOISE       : temp.append("Noise"      );break;
        case GUI_ATTR_LEDPANEL_OBJECTS     : temp.append("Objects"    );break;
        case GUI_ATTR_LEDPANEL_SPECIAL     : temp.append("Special"    );break;
        case GUI_ATTR_LEDPANEL_AUDIO       : temp.append("AudioInput" );break;
        case GUI_ATTR_LEDPANEL_GAME        : temp.append("Game"       );break;
        case GUI_ATTR_LEDPANEL_3D          : temp.append("3D"         );break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;
}


public String[] createCustomDeviceAnimationListFilter(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_CUSTOMDEV_ALLDEVICES    : temp.append("All Devices");break;
        case GUI_ATTR_CUSTOMDEV_RACKLIGHTS    : temp.append("Rack Lights");break;
        case GUI_ATTR_CUSTOMDEV_LEDTUBES      : temp.append("LED Tubes");break;
        case GUI_ATTR_CUSTOMDEV_BLACK         : temp.append("Black");break;
        case GUI_ATTR_CUSTOMDEV_WHITE         : temp.append("White");break;
        case GUI_ATTR_CUSTOMDEV_RED           : temp.append("Red");break;
        case GUI_ATTR_CUSTOMDEV_BLUE          : temp.append("Blue");break;
        case GUI_ATTR_CUSTOMDEV_RAINBOW       : temp.append("Rainbow");break;
        case GUI_ATTR_CUSTOMDEV_RANDOM        : temp.append("Random");break;
        case GUI_ATTR_CUSTOMDEV_FAST          : temp.append("Fast");break;
        case GUI_ATTR_CUSTOMDEV_MEDUM         : temp.append("Medium");break;
        case GUI_ATTR_CUSTOMDEV_SLOW          : temp.append("Slow");break;
        case GUI_ATTR_CUSTOMDEV_VERYSLOW      : temp.append("Very Slow");break;
        case GUI_ATTR_CUSTOMDEV_LONG          : temp.append("Long");break;
        case GUI_ATTR_CUSTOMDEV_SHORT         : temp.append("Short");break;
        case GUI_ATTR_CUSTOMDEV_PLAIN         : temp.append("Plain");break;
        case GUI_ATTR_CUSTOMDEV_FLASH         : temp.append("Flash");break;
        case GUI_ATTR_CUSTOMDEV_SMOOTHSINE    : temp.append("Smooth Sine");break;
        case GUI_ATTR_CUSTOMDEV_STROBOSCOPE   : temp.append("Stroboscope");break;
        case GUI_ATTR_CUSTOMDEV_GROWINGSTROBE : temp.append("Growing Strobe");break;
        case GUI_ATTR_CUSTOMDEV_WAVE          : temp.append("Wave");break;
        case GUI_ATTR_CUSTOMDEV_BUILDUP       : temp.append("BuildUp");break;
        case GUI_ATTR_CUSTOMDEV_NOISE         : temp.append("Noise");break;
        case GUI_ATTR_CUSTOMDEV_SMOOTHNOISE   : temp.append("Smooth Noise");break;
        case GUI_ATTR_CUSTOMDEV_LEFTSIDE      : temp.append("Left");break;
        case GUI_ATTR_CUSTOMDEV_RIGHTSIDE     : temp.append("Right");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;
}

public String[] createDMXAnimationListFilter_Strobe(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_DMX_STROBE_ALL       : temp.append("All");break;
        case GUI_ATTR_DMX_STROBE_LEFT      : temp.append("Left");break;
        case GUI_ATTR_DMX_STROBE_RIGHT     : temp.append("Right");break;
        case GUI_ATTR_DMX_STROBE_CENTER    : temp.append("Center");break;
        case GUI_ATTR_DMX_STROBE_RHYTHMIC  : temp.append("Rhythmic");break;
        case GUI_ATTR_DMX_STROBE_STROBE    : temp.append("Strobe");break;
        case GUI_ATTR_DMX_STROBE_PAR       : temp.append("PAR");break;
        case GUI_ATTR_DMX_STROBE_VERYSLOW  : temp.append("Very Slow");break;
        case GUI_ATTR_DMX_STROBE_SLOW      : temp.append("Slow");break;
        case GUI_ATTR_DMX_STROBE_MEDIUM    : temp.append("Medium");break;
        case GUI_ATTR_DMX_STROBE_FAST      : temp.append("Fast");break;
        case GUI_ATTR_DMX_STROBE_VERYFAST  : temp.append("Very Fast");break;
        case GUI_ATTR_DMX_STROBE_AUDIO     : temp.append("AudioInput");break;
        case GUI_ATTR_DMX_STROBE_ATOMIC    : temp.append("Atomic");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;
}



public String[] createDMXAnimationListFilter_MovingHead_Movement(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_ALL        : temp.append("MovingHead-SetDirection-All");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_LEFT       : temp.append("MovingHead-SetDirection-Left");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_RIGHT      : temp.append("MovingHead-SetDirection-Right");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_SIDE       : temp.append("MovingHead-SetDirection-Side");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_CENTER     : temp.append("MovingHead-SetDirection-Center");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_UNIFORM    : temp.append("MovingHead-Uniform");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_DIVERGENT  : temp.append("MovingHead-Divergent");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_CONVERGENT : temp.append("MovingHead-Convergent");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_SYMMETRICAL: temp.append("MovingHead-Symmetrical");break;
        case GUI_ATTR_DMX_MOVINGHEAD_MOVE_SUN        : temp.append("MovingHead-Sun");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;
}

public String[] createDMXAnimationListFilter_MovingHead_Light(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_ALL       : temp.append("MovingHead-SetLight-All");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_LEFT      : temp.append("MovingHead-SetLight-Left");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_RIGHT     : temp.append("MovingHead-SetLight-Right");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_SIDE      : temp.append("MovingHead-SetLight-Side");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_CENTER    : temp.append("MovingHead-SetLight-Center");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_STILL     : temp.append("MovingHead-Still");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_CRESCENDO : temp.append("MovingHead-Crescendo");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_FLASH     : temp.append("MovingHead-Flash");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_STROBE    : temp.append("MovingHead-Strobe");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_SINE      : temp.append("MovingHead-Sine");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_GLITCH    : temp.append("MovingHead-Glitch");break;
        case GUI_ATTR_DMX_MOVINGHEAD_LIGHT_TIGHT     : temp.append("MovingHead-Tight");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;

}

public String[] createDMXAnimationListFilter_MovingHead_Color(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_ALL        : temp.append("MovingHead-SetColor-All");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_LEFT       : temp.append("MovingHead-SetColor-Left");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_RIGHT      : temp.append("MovingHead-SetColor-Right");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_SIDE       : temp.append("MovingHead-SetColor-Side");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_CENTER     : temp.append("MovingHead-SetColor-Center");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_WHITE      : temp.append("MovingHead-White");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_RED        : temp.append("MovingHead-Red");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_DEEPRED    : temp.append("MovingHead-Deep Red");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_BLUE       : temp.append("MovingHead-Blue");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_DEEPBLUE   : temp.append("MovingHead-Deep Blue");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_YELLOW     : temp.append("MovingHead-Yellow");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_GREEN      : temp.append("MovingHead-Green");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_ULTRAVIOLET: temp.append("MovingHead-Ultraviolet");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_ORANGE     : temp.append("MovingHead-Orange");break;
        case GUI_ATTR_DMX_MOVINGHEAD_COLOR_CTO        : temp.append("MovingHead-CTO");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;
}

public String[] createDMXAnimationListFilter_MovingHead_Rhythm(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_ALL      : temp.append("MovingHead-SetRhythm-All");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_LEFT     : temp.append("MovingHead-SetRhythm-Center");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_RIGHT    : temp.append("MovingHead-SetRhythm-Side");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_SIDE     : temp.append("MovingHead-SetRhythm-Left");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_CENTER   : temp.append("MovingHead-SetRhythm-Right");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_NOSYNC   : temp.append("MovingHead-No Sync");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_TOGETHER : temp.append("MovingHead-Together");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_CLOCK    : temp.append("MovingHead-Clockwise");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_ANTICLOCK: temp.append("MovingHead-AntiClockwise");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_RANDOM   : temp.append("MovingHead-Random");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_32ND     : temp.append("MovingHead-32nd");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_16TH     : temp.append("MovingHead-16th");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_8TH      : temp.append("MovingHead-8th");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_4TH      : temp.append("MovingHead-4th");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_2ND      : temp.append("MovingHead-2nd");break;
        case GUI_ATTR_DMX_MOVINGHEAD_RHYTHM_BAR      : temp.append("MovingHead-Bar");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;

}

public String[] createDMXAnimationListFilter_MovingHead_Animation(float[] checkBoxArrayvalue) {
  StringList temp = new StringList();
  for (int i = 0; i<checkBoxArrayvalue.length; i++) {
    if (checkBoxArrayvalue[i] == 1.0f) {
      switch(i) {

        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_ALL           : temp.append("MovingHead-Anim-All");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_LEFT          : temp.append("MovingHead-Anim-Center");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_RIGHT         : temp.append("MovingHead-Anim-Side");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_SIDE          : temp.append("MovingHead-Anim-Left");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_CENTER        : temp.append("MovingHead-Anim-Right");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_STILL         : temp.append("MovingHead-Anim-Still");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_FASTMOVE      : temp.append("MovingHead-Anim-FastMove");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_CONTSWEEP     : temp.append("MovingHead-Anim-ContinuousSweep");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_SINGSWEEP     : temp.append("MovingHead-Anim-SingleSweep");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_RANDOM        : temp.append("MovingHead-Anim-Random");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_PARALLEL      : temp.append("MovingHead-Anim-Parallel");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_DIVERGENT     : temp.append("MovingHead-Anim-Divergent");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_CONVERGENT    : temp.append("MovingHead-Anim-Convergent");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_HORIZONTAL    : temp.append("MovingHead-Anim-Horizontal");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_VERTICAL      : temp.append("MovingHead-Anim-Vertical");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_SLOW          : temp.append("MovingHead-Anim-Slow");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_REGULAR       : temp.append("MovingHead-Anim-Regular");break;
        case GUI_ATTR_DMX_MOVINGHEAD_ANIM_FAST          : temp.append("MovingHead-Anim-Fast");break;
        default: break;
      }
    }
  }
  
  String[] filter = new String[temp.size()];
  for (int i = 0; i<temp.size(); i++) {
    filter[i] = temp.get(i);
  }
  return filter;
}

///////////////////////////////////////////////////////////////
/// Create pre-calculated gamma tables for color correction ///
///////////////////////////////////////////////////////////////

String NONE = "";
String GAMMA_20 = "gamma_20";
String GAMMA_22 = "gamma_22";
String GAMMA_25 = "gamma_25";
String SPECIAL1 = "special1";

//use it for lpd6803 based led devices
int[] gamma20 = generateGammaTab(2.0f);

int[] gamma22 = generateGammaTab(2.2f);

//use it for ws2801 based led devices
int[] gamma25 = generateGammaTab(2.5f);

//gamma correction found in ledstyles.de forum 
private final int[] apecialGammaTab1 = {
    0,   0,   1,   1,   1,   1,   1,   2,
    2,   2,   2,   3,   3,   3,   4,   4,
    4,   5,   5,   5,   6,   6,   7,   7,
    8,   8,   9,   9,  10,  10,  11,  11,
   12,  12,  13,  13,  14,  14,  15,  15,
   16,  16,  17,  17,  18,  18,  19,  19,
   20,  20,  21,  21,  22,  22,  23,  23,
   24,  24,  25,  25,  26,  27,  28,  29,
   30,  30,  31,  32,  33,  34,  35,  36,
   36,  37,  38,  39,  40,  41,  42,  43,
   43,  44,  45,  46,  47,  48,  49,  50,
   51,  52,  52,  53,  54,  55,  56,  57,
   58,  59,  60,  61,  62,  63,  64,  65,
   66,  67,  68,  69,  70,  71,  72,  73,
   74,  75,  76,  77,  78,  79,  80,  81,
   82,  83,  84,  85,  86,  88,  89,  90,
   91,  92,  93,  94,  95,  96,  97,  98,
   99, 100, 102, 103, 104, 105, 106, 107,
  108, 109, 110, 112, 113, 114, 115, 116,
  117, 119, 120, 121, 122, 123, 124, 126,
  127, 128, 129, 130, 132, 133, 134, 135,
  136, 138, 139, 140, 141, 142, 144, 145,
  146, 147, 149, 150, 151, 152, 154, 155,
  156, 158, 159, 160, 161, 162, 164, 165,
  167, 168, 169, 171, 172, 173, 174, 176,
  177, 178, 180, 181, 182, 184, 185, 187,
  188, 189, 191, 192, 193, 195, 196, 197,
  199, 200, 202, 203, 204, 206, 207, 208,
  210, 211, 213, 214, 216, 217, 218, 220,
  221, 223, 224, 226, 227, 228, 230, 231,
  233, 234, 236, 237, 239, 240, 242, 243,
  245, 246, 248, 249, 251, 252, 254, 255
};


// Create a pre-calculated gamma table
// Best for WS2801 LED : Gamma_25
private int[] generateGammaTab(float gamma) {
        int[] ret = new int[256];

        for (int i=0; i<256; i++) {
                ret[i] = (int)(Math.pow ((float)(i)/255.0f, gamma)*255.0f+0.5f);
        }

        return ret;
}

    
// apply brightness level and gamma correction
 public int[] applyBrightnessAndGammaTab(int[] buffer, String type, float brightness) {
    int ret[] = new int[buffer.length];
    int ofs=0;
    int r,g,b;

    for (int n=0; n<buffer.length; n++) {
      int tmp = buffer[ofs];        
      r = (int) ((tmp>>16) & 255);
      g = (int) ((tmp>>8)  & 255);
      b = (int) ( tmp      & 255);                       
      
      //apply brightness
      r = (int)(r*brightness);
      g = (int)(g*brightness);
      b = (int)(b*brightness);
      //apply gamma
      if (type == GAMMA_20) {
        r = gamma20[r];
        g = gamma20[g];
        b = gamma20[b];
        ret[ofs] = (r<<16)|(g<<8)|b;
        ofs++;          
      }
      else if (type == GAMMA_22) {
        r = gamma22[r];
        g = gamma22[g];
        b = gamma22[b];
        ret[ofs] = (r<<16)|(g<<8)|b;
        ofs++;
      }
      else if (type == GAMMA_25) {
        r = gamma25[r];
        g = gamma25[g];
        b = gamma25[b];
        ret[ofs] = (r<<16)|(g<<8)|b;
        ofs++;
      }            
      else if (type == SPECIAL1) {
        r = apecialGammaTab1[r];
        g = apecialGammaTab1[g];
        b = apecialGammaTab1[b];
        ret[ofs] = (r<<16)|(g<<8)|b;
        ofs++;
      }
    }
    return ret;
}




public class RGBAdjust {

    private int r,g,b;
    
    public RGBAdjust(int r, int g, int b) {
            this.r = r;
            this.g = g;
            this.b = b;
    }
  
    public int getR() {
            return r;
    }
  
    public int getG() {
            return g;
    }
  
    public int getB() {
            return b;
    }
  
    @Override
    public String toString() {
            return "[r=" + r + ", g=" + g + ", b=" + b + "]";
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create an automatic PHP site in order to browse the available animations without looking at the code  //
///////////////////////////////////////////////////////////////////////////////////////////////////////////


//Create a php outputfile, which shall contain the filtering web page
static PrintWriter phpOutputFile;

public void create_PHP_output() {
  phpOutputFile = createWriter("HTML/Strobot_AnimationViewer.php");
  print_playmeHeader();
  print_htmlHeader();
  print_htmlBody();
  print_filterForm();
  print_attributes();
  print_htmlFooter();

  print_phpFunctions();
  
  phpOutputFile.flush(); // Writes the remaining data to the file
  phpOutputFile.close(); // Finishes the file
}

public void print_playmeHeader() {
  phpOutputFile.println("<!--/////////////////////////////////////////-->");
  phpOutputFile.println("<!--//Xi Light Setup - Animation Viewer//-->");
  phpOutputFile.println("<!--/////////////////////////////////////////-->");
  phpOutputFile.println("");
  phpOutputFile.println(""); 
}

public void print_htmlHeader() {
  phpOutputFile.println("<!doctype html>                                                                                   ");
  phpOutputFile.println("                                                                                                  ");
  phpOutputFile.println("<html>                                                                                            ");
  phpOutputFile.println("  <head>                                                                                          ");
  phpOutputFile.println("    <meta charset=\"UTF-8\">                                                                      ");
  phpOutputFile.println("    <title>Xi Live Setup - Animation List</title>                                             ");
  phpOutputFile.println("    <link rel=\"icon\"                                                                            ");
  phpOutputFile.println("      type=\"image/png\"                                                                          ");
  phpOutputFile.println("      href=\"img/favicon.png\">                                                                   ");
  phpOutputFile.println("    <link rel=\"stylesheet\" type=\"text/css\" href=\"Strobot_AnimationViewer.css\" />   ");
  phpOutputFile.println("    <link href='http://fonts.googleapis.com/css?family=Exo+2' rel='stylesheet' type='text/css'>   ");
  phpOutputFile.println("    <script src=\"js/processing-1.4.1.min.js\"></script>                                          ");
  phpOutputFile.println("  </head>                                                                                         ");
}

public void print_htmlBody() {

  phpOutputFile.println("                                                                                                                                                                                      ");
  phpOutputFile.println("  <body>                                                                                                                                                                              ");
  //phpOutputFile.println("    <div class=\"backgrounddiv\">                                                                                                                                                     ");
  //phpOutputFile.println("      <canvas id=\"background\" data-processing-sources=\"background/background.pde\"></canvas>                                                                                       ");
  //phpOutputFile.println("    </div>                                                                                                                                                                            ");
  phpOutputFile.println("                                                                                                                                                                                      ");
  phpOutputFile.println("    <div class=\"content\">                                                                                                                                                           ");
  phpOutputFile.println("                                                                                                                                                                                      ");
  phpOutputFile.println("      <div class=\"full_description\">                                                                                                                                                ");
  phpOutputFile.println("        <h1><img src=\"../data/PlayMe.png\" height=\"90px\" width=\"90px\" class=\"floatingimage\" alt=\"Hell yeah\" /> Live Setup - Animation helper tool</h1>                       ");
  phpOutputFile.println("        <p>This PHP application is to be used along with a PHP server<br/>If not already installed, download MAMP (OSX) or WAMP (Windows), and run your own local Apache server.</p>  ");
  phpOutputFile.println("        <p></p>                                                                                                                                                                       ");
  
}

public void print_filterForm() {
  print_formHeader();
  /*  
  //The following function is useful and elegant because all attributes are automatically printed... but organization in the HTML file is a mess
  //It is better to print individual groups and associate them together
  for (String attribute: registeredAttributes) {
    print_attributeform(attribute);
  }
  */

  phpOutputFile.println("                <fieldset><legend>Genre : </legend>");
  print_attributeform("Geometric");
  print_attributeform("Atmospheric");
  print_attributeform("Fade In/Out");
  print_attributeform("Random");
  phpOutputFile.println("                </fieldset>");
  
  phpOutputFile.println("                <fieldset><legend>Colors : </legend>");
  print_attributeform("Red");
  print_attributeform("B&W");
  print_attributeform("Blue");
  print_attributeform("Colorful");
  print_attributeform("Very Dark");
  print_attributeform("Very Bright");
  phpOutputFile.println("                </fieldset>");
  
  phpOutputFile.println("                <fieldset><legend>Animation : </legend>");
  print_attributeform("Rotating");
  print_attributeform("Simple");
  print_attributeform("Complex");
  print_attributeform("Evolving");
  print_attributeform("Smooth");
  print_attributeform("Violent");
  phpOutputFile.println("                </fieldset>");

  phpOutputFile.println("                <fieldset><legend>Speed : </legend>");
  print_attributeform("Rhythmic");
  print_attributeform("Fast");
  print_attributeform("Slow");
  print_attributeform("Still");
  phpOutputFile.println("                </fieldset>");

  phpOutputFile.println("                <fieldset><legend>Geometry : </legend>");
  print_attributeform("Lines");
  print_attributeform("Curves");
  print_attributeform("Triangles");
  print_attributeform("Squares");
  print_attributeform("Circles");
  print_attributeform("Spiral");
  print_attributeform("Noise");
  print_attributeform("Objects");
  phpOutputFile.println("                </fieldset>");

  phpOutputFile.println("                <fieldset><legend>Other attributes : </legend>");
  print_attributeform("Special");
  print_attributeform("Video");
  print_attributeform("Game");
  print_attributeform("3D");
  print_attributeform("TO BE DELETED");
  phpOutputFile.println("                </fieldset>");

  phpOutputFile.println("                <div style=\"clear:both;\"></div>");

  print_formFooter();
}

public void print_attributeform(String attribute) {
    phpOutputFile.println("                <?php if (isset($_POST['" + attribute + "']) == 1)                                                                                   ");
    phpOutputFile.println("                { echo '<input type=\"checkbox\" class=\"css-checkbox\" id=\"" + attribute + "\" checked=\"checked\" /> <label for=\"" + attribute + "\" name=\"" + attribute + "\"  class=\"css-label\">" + attribute + "</label><br />'; ");
    phpOutputFile.println("                  $SelectedAttributeList[] = '" + attribute + "';                                                                                    ");
    phpOutputFile.println("                  }                                                                                                                    ");
    phpOutputFile.println("                else                                                                                                                   ");
    phpOutputFile.println("                { echo '<input type=\"checkbox\" class=\"css-checkbox\" name=\"" + attribute + "\" id=\"" + attribute + "\" /> <label for=\"" + attribute + "\" class=\"css-label\">" + attribute + "</label><br />';} ?>                 ");

}

public void print_formHeader() {
  phpOutputFile.println("        <form action=\"Strobot_AnimationViewer.php\" method=\"post\">   ");
  phpOutputFile.println("            Filter animations according to the following tags :<br />            ");
  phpOutputFile.println("                                                                                 ");
  phpOutputFile.println("            <p>                                                                  ");
}

public void print_formFooter() {
  phpOutputFile.println("            <input type=\"submit\" value=\"Filter\" />");
  phpOutputFile.println("            <input type=\"reset\" value=\"Reset\" />  ");
  phpOutputFile.println("                                                      ");
  phpOutputFile.println("        </form>                                       ");
}

public void print_htmlFooter() {
  phpOutputFile.println("      </div>");
  phpOutputFile.println("    </div>");
  phpOutputFile.println("  </body>");
  phpOutputFile.println("</html>"); 
}

public void print_attributes() {
  phpOutputFile.println("        <?php                                                                              ");
  for (Attribute attribute: animationAttributes) {
    phpOutputFile.println("        $animationName[] = \'" + attribute.name + "\';                                   ");
    phpOutputFile.println(attribute.printAttributePHP());
  }  
  phpOutputFile.println("        echo filterAllAttributes($attributeList, $SelectedAttributeList, $animationName);  ");
  phpOutputFile.println("        ?>                                                                                 "); 
  
}

public void print_phpFunctions() {
  phpOutputFile.println("<?php                                                                                           ");
  phpOutputFile.println("function printIfAttributeIsRegistered($List, $animationNbr, $attributeStringArray, $animName) { ");
  phpOutputFile.println("  $numberOfMatchingAttributes = 0;                                                              ");
  phpOutputFile.println("                                                                                                ");
  phpOutputFile.println("  foreach($List[$animationNbr] as $element) {                                                   ");
  phpOutputFile.println("    if (in_array($element, $attributeStringArray)) {                                            ");
  phpOutputFile.println("    $numberOfMatchingAttributes += 1;                                                           ");
  phpOutputFile.println("    }                                                                                           ");
  phpOutputFile.println("  }                                                                                             ");
  phpOutputFile.println("                                                                                                ");
  phpOutputFile.println("                                                                                                ");
  phpOutputFile.println("  if ($numberOfMatchingAttributes == count($attributeStringArray)) {                            ");
  phpOutputFile.println("    echo '<p>       ';                                                                          ");
  phpOutputFile.println("    echo '<img src=\"../GIF/PlayMeLightSetup';                                                  ");
  phpOutputFile.println("    echo $animationNbr;                                                                         ");
  phpOutputFile.println("    echo '.gif\"  class=\"floatingimage\" alt=\"Animation number = ';                           ");
  phpOutputFile.println("    echo $animationNbr;                                                                         ");
  phpOutputFile.println("    echo '\" /> </br>    Animation Number ';                                                    ");
  phpOutputFile.println("    echo $animationNbr;                                                                         ");
  phpOutputFile.println("    echo ' - MIDI note : ';                                                                     ");
  phpOutputFile.println("    echo getMidiNote($animationNbr);                                                            ");
  phpOutputFile.println("    echo ' </br>';                                                                              ");
  phpOutputFile.println("    echo $animName[$animationNbr];                                                              ");
  phpOutputFile.println("    echo ' </br>';                                                                              ");
  phpOutputFile.println("    echo 'Related attributes : [';                                                              ");
  phpOutputFile.println("    foreach($List[$animationNbr] as $attr) {                                                    ");
  phpOutputFile.println("      echo '  ';                                                                                ");
  phpOutputFile.println("      echo $attr;                                                                               ");
  phpOutputFile.println("      echo '  ';                                                                                ");
  phpOutputFile.println("    }                                                                                           ");
  phpOutputFile.println("    echo ']';                                                                                   ");
  phpOutputFile.println("    echo '</p> </br>';                                                                          ");
  phpOutputFile.println("  }                                                                                             ");
  phpOutputFile.println("}                                                                                               ");
  phpOutputFile.println("                                                                                                ");
  phpOutputFile.println("function filterAllAttributes($List, $attributeString, $animName) {                              ");
  phpOutputFile.println("  for ($numero = 0; $numero < count($List); $numero++) {                                        ");
  phpOutputFile.println("    printIfAttributeIsRegistered($List, $numero, $attributeString, $animName);                  ");
  phpOutputFile.println("  }                                                                                             ");
  phpOutputFile.println("}                                                                                               ");
  phpOutputFile.println("                                                                                                ");
  phpOutputFile.println("function getMidiNote($animationNbr) {                                                           ");
  phpOutputFile.println("  if ($animationNbr <= 127) {                                                                   ");
  phpOutputFile.println("    echo 'D#8 / Velocity = ';                                                                    ");
  phpOutputFile.println("    $tempNote = $animationNbr;                                                                   ");
  phpOutputFile.println("    echo $tempNote;                                                                              ");
  phpOutputFile.println("  }                                                                                              ");
  phpOutputFile.println("  else if ($animationNbr <= 254) {                                                               ");
  phpOutputFile.println("    echo 'E8 / Velocity = ';                                                                     ");
  phpOutputFile.println("    $tempNote = $animationNbr - 127;                                                             ");
  phpOutputFile.println("    echo $tempNote;                                                                              ");
  phpOutputFile.println("  }                                                                                              ");
  phpOutputFile.println("  else if ($animationNbr <= 381) {                                                               ");
  phpOutputFile.println("    echo 'F8 / Velocity = ';                                                                     ");
  phpOutputFile.println("    $tempNote = $animationNbr - 254;                                                             ");
  phpOutputFile.println("    echo $tempNote;                                                                              ");
  phpOutputFile.println("  }                                                                                              ");
  phpOutputFile.println("}                                                                                               ");
  phpOutputFile.println("?>                                                                                              ");
}
///////////////////////////////////////////////////////////////
// Configure the mapping for the manual animation selection  //
///////////////////////////////////////////////////////////////

/*
Define groups of 16 animations by assigning them to close MIDI notes
Structure of a group, using a Maschine or a similar MPC-controller :
If 1 is the base note, in the lower left section, the following pads send MIDI messages
whose notes are mapped in the following way
    13 14 15 16
     9 10 11 12
     5  6  7  8
     1  2  3  4
Each group if defined through a ManualGroup object
*/

//Booleans used to determine whether the animation is to be released upon Note Off event 
final int LATCH = 0;
final int RELEASE = 1; 

//Special actions : kill all animations, or change the configuration
final int MANINPUT_ON  = -124;    //Activate special manual inputs (ie stroboscope using pads from an additional keyboard)
final int MANINPUT_OFF = -125;    //Disable special manual inputs (ie stroboscope using pads from an additional keyboard)
final int CONFCHANGE   = -126;    //Change the panel output configuration (ie switch panels)
final int PADKILLER    = -127;    //Kill panel output by switching to an all-black animation
final int REINIT       = -128;    //Reinit - nothing to be done here, as the application will be killed and reinitialised by the external Python

//Accessors for DMX actions, 1 is weak, 4 is strong
final int STROBO_SLOW_1 = -1;
final int STROBO_SLOW_2 = -2;
final int STROBO_SLOW_3 = -3;
final int STROBO_SLOW_4 = -4;
final int STROBO_MED_1  = -5;
final int STROBO_MED_2  = -6;
final int STROBO_MED_3  = -7;
final int STROBO_MED_4  = -8;
final int STROBO_FAST_1 = -9;
final int STROBO_FAST_2 = -10;
final int STROBO_FAST_3 = -11;
final int STROBO_FAST_4 = -12;
final int STROBO_MAX_1  = -13;
final int STROBO_MAX_2  = -14;
final int STROBO_MAX_3  = -15;
final int STROBO_MAX_4  = -16;

//Info contained inside these int[] : MIDI channel, note, requested animation, behaviour upon Note-Off
ArrayList<int[]> manualMode_InputTranslationList;

boolean animationToBeReleased          = false;    //Will the previousAnimationNumber be set when receiving the corresponding NoteOff message ?
boolean expectingNoteOffForRelease     = false;    //Is a NoteOff currently being expected ?
int noteOffToResetAnimation            = 1;        //Which NoteOff pitch will reset the animation ?
int previousAnimationNumber            = 1;        //In case of an on-off animation, the visuals must switch back to the previous animation upon receiving the Note-Off
int noteOffToResetDMX                  = 1;        //Which NoteOff pitch will reset the DMX equipments ?

//Parameters used to blend manual keyboard input with the regular semi-auto mode
int previousFrontLeftStrobeState   = 0;
int previousFrontLeftStrobePreset  = 0;
int previousFrontRightStrobeState  = 0;
int previousFrontRightStrobePreset = 0;
int previousBackStrobeState        = 0;
int previousBackStrobePreset       = 0;

//initialise the translation list, by moving all the info inside the different ManualGroup objects (easier for configuration definition) into the int[] arraylist (faster implementation)
public void init_ManualMode() {
  
  ////////////////////////////////////////////////////////////////////
  ////////////////////--- START OF USER CONFIG ---////////////////////  
  ////////////////////////////////////////////////////////////////////
  
  //Each pad must be configured either to have its animation released or not upon Note Off
  // -- LATCH : the animation will stay after Note Off
  // -- RELEASE : the animation will revert to the previous latch animation
  
  //Note : MIDI note 0 corresponds to C-2
  
  //Group H1 : Patatap
  ManualGroup H1 = new ManualGroup(CHANNEL_MANUALMODE_1, 12,
                                  new Pad(349, LATCH)            , new Pad(357, LATCH)             , new Pad(359, LATCH)             , new Pad(360, LATCH),
                                  new Pad(348, LATCH)            , new Pad(352, LATCH)             , new Pad(353, LATCH)             , new Pad(356, LATCH),
                                  new Pad(345, LATCH)            , new Pad(350, LATCH)             , new Pad(351, LATCH)             , new Pad(358, LATCH),
                                  new Pad(346, LATCH)            , new Pad(354, LATCH)             , new Pad(355, LATCH)             , new Pad(347, LATCH));

  //Group A2 : DMX Stroboscope, with different speed settings
  ManualGroup A2 = new ManualGroup(CHANNEL_MANUALMODE_1, 28,
                                  new Pad(STROBO_MAX_1, RELEASE) , new Pad(STROBO_MAX_2, RELEASE)  , new Pad(STROBO_MAX_3, RELEASE)  , new Pad(STROBO_MAX_4, RELEASE) ,
                                  new Pad(STROBO_FAST_1, RELEASE), new Pad(STROBO_FAST_2, RELEASE) , new Pad(STROBO_FAST_3, RELEASE) , new Pad(STROBO_FAST_4, RELEASE),
                                  new Pad(STROBO_MED_1, RELEASE) , new Pad(STROBO_MED_2, RELEASE)  , new Pad(STROBO_MED_3, RELEASE)  , new Pad(STROBO_MED_4, RELEASE) ,
                                  new Pad(STROBO_SLOW_1, RELEASE), new Pad(STROBO_SLOW_2, RELEASE) , new Pad(STROBO_SLOW_3, RELEASE) , new Pad(STROBO_SLOW_4, RELEASE));
  
  //Group B2 : Simple B&W animations 1
  ManualGroup B2 = new ManualGroup(CHANNEL_MANUALMODE_1, 44,
                                  new Pad(140, LATCH)            , new Pad(141, LATCH)             , new Pad(142, LATCH)             , new Pad(143, LATCH),
                                  new Pad(41, LATCH)             , new Pad(54, LATCH)              , new Pad(55, LATCH)              , new Pad(56, LATCH),
                                  new Pad(29, LATCH)             , new Pad(30, LATCH)              , new Pad(86, LATCH)              , new Pad(87, LATCH),
                                  new Pad(24, LATCH)             , new Pad(25, LATCH)              , new Pad(26, LATCH)              , new Pad(88, LATCH));
                                  
  //Group C2 : Simple B&W animations 2
  ManualGroup C2 = new ManualGroup(CHANNEL_MANUALMODE_1, 60,
                                  new Pad(250, LATCH)            , new Pad(251, LATCH)             , new Pad(252, LATCH)             , new Pad(253, LATCH),
                                  new Pad(76, LATCH)             , new Pad(128, LATCH)             , new Pad(145, LATCH)             , new Pad(146, LATCH),
                                  new Pad(48, LATCH)             , new Pad(49, LATCH)              , new Pad(50, LATCH)              , new Pad(53, LATCH),
                                  new Pad(44, LATCH)             , new Pad(45, LATCH)              , new Pad(46, LATCH)              , new Pad(47, LATCH));

  //Group D2 : Simple B&W animations 3
  ManualGroup D2 = new ManualGroup(CHANNEL_MANUALMODE_1, 76,
                                  new Pad(72, LATCH)             , new Pad(73, LATCH)              , new Pad(148, LATCH)             , new Pad(161, LATCH),
                                  new Pad(68, LATCH)             , new Pad(69, LATCH)              , new Pad(70, LATCH)              , new Pad(71, LATCH),
                                  new Pad(64, LATCH)             , new Pad(65, LATCH)              , new Pad(66, LATCH)              , new Pad(67, LATCH),
                                  new Pad(60, LATCH)             , new Pad(61, LATCH)              , new Pad(62, LATCH)              , new Pad(63, LATCH));

  //Group E2 : Simple B&W animations 4
  ManualGroup E2 = new ManualGroup(CHANNEL_MANUALMODE_1, 92,
                                  new Pad(331, LATCH)            , new Pad(334, LATCH)             , new Pad(335, LATCH)             , new Pad(339, LATCH),
                                  new Pad(340, LATCH)            , new Pad(341, LATCH)             , new Pad(342, LATCH)             , new Pad(343, LATCH),
                                  new Pad(171, LATCH)            , new Pad(189, LATCH)             , new Pad(207, LATCH)             , new Pad(237, LATCH),
                                  new Pad(181, LATCH)            , new Pad(182, LATCH)             , new Pad(240, LATCH)             , new Pad(241, LATCH));

  //Group F2 : Simple B&W animations 5
  ManualGroup F2 = new ManualGroup(CHANNEL_MANUALMODE_2, 12,
                                  new Pad(107, LATCH)            , new Pad(108, RELEASE)           , new Pad(109, LATCH)             , new Pad(110, LATCH),
                                  new Pad(103, RELEASE)          , new Pad(104, RELEASE)           , new Pad(105, RELEASE)           , new Pad(106, RELEASE),
                                  new Pad(338, LATCH)            , new Pad(109, LATCH)             , new Pad(124, LATCH)             , new Pad(111, LATCH),
                                  new Pad(332, LATCH)            , new Pad(333, LATCH)             , new Pad(336, LATCH)             , new Pad(337, LATCH));

  //Group G2 : Violent / Strobo animations
  ManualGroup G2 = new ManualGroup(CHANNEL_MANUALMODE_2, 28,
                                  new Pad(258, LATCH)            , new Pad(260, LATCH)             , new Pad(102, RELEASE)           , new Pad(21, RELEASE),
                                  new Pad(224, LATCH)            , new Pad(284, RELEASE)           , new Pad(29, LATCH)              , new Pad(30, LATCH),
                                  new Pad(85, LATCH)             , new Pad(162, LATCH)             , new Pad(286, RELEASE)           , new Pad(322, LATCH),
                                  new Pad(75, RELEASE)           , new Pad(283, RELEASE)           , new Pad(83, LATCH)              , new Pad(84, LATCH));

  //Group H2 : Transitions
  ManualGroup H2 = new ManualGroup(CHANNEL_MANUALMODE_2, 44,
                                  new Pad(312, RELEASE)          , new Pad(313, RELEASE)           , new Pad(314, RELEASE)           , new Pad(315, RELEASE),
                                  new Pad(263, LATCH)            , new Pad(264, LATCH)             , new Pad(265, LATCH)             , new Pad(266, LATCH),
                                  new Pad(81, LATCH)             , new Pad(82, LATCH)              , new Pad(261, LATCH)             , new Pad(262, LATCH),
                                  new Pad(77, LATCH)             , new Pad(78, LATCH)              , new Pad(79, LATCH)              , new Pad(80, LATCH));

  //Group A3 : Complex B&W animations 1
  ManualGroup A3 = new ManualGroup(CHANNEL_MANUALMODE_2, 60,
                                  new Pad(187, LATCH)            , new Pad(189, LATCH)             , new Pad(199, LATCH)             , new Pad(205, LATCH),
                                  new Pad(172, LATCH)            , new Pad(173, LATCH)             , new Pad(177, LATCH)             , new Pad(178, LATCH),
                                  new Pad(230, LATCH)            , new Pad(43, LATCH)              , new Pad(92, LATCH)              , new Pad(125, LATCH),
                                  new Pad(2, LATCH)              , new Pad(36, LATCH)              , new Pad(37, LATCH)              , new Pad(38, LATCH));
  
  //Group B3 : Complex B&W animations 2
  ManualGroup B3 = new ManualGroup(CHANNEL_MANUALMODE_2, 76,
                                  new Pad(287, LATCH)            , new Pad(288, LATCH)             , new Pad(301, LATCH)             , new Pad(302, LATCH),
                                  new Pad(316, LATCH)            , new Pad(244, LATCH)             , new Pad(245, LATCH)             , new Pad(183, LATCH),
                                  new Pad(233, LATCH)            , new Pad(234, LATCH)             , new Pad(235, LATCH)             , new Pad(236, LATCH),
                                  new Pad(202, LATCH)            , new Pad(203, LATCH)             , new Pad(219, LATCH)             , new Pad(223, LATCH));

  //Group C3 : Color animations 1
  ManualGroup C3 = new ManualGroup(CHANNEL_MANUALMODE_2, 92,
                                  new Pad(169, LATCH)            , new Pad(170, LATCH)             , new Pad(246, LATCH)             , new Pad(247, LATCH),
                                  new Pad(323, LATCH)            , new Pad(324, LATCH)             , new Pad(344, LATCH)             , new Pad(195, LATCH),
                                  new Pad(165, LATCH)            , new Pad(166, LATCH)             , new Pad(167, LATCH)             , new Pad(168, LATCH),
                                  new Pad(159, LATCH)            , new Pad(160, LATCH)             , new Pad(163, LATCH)             , new Pad(164, LATCH));

  //Group D3 : Color animations 2
  ManualGroup D3 = new ManualGroup(CHANNEL_MANUALMODE_3, 12,
                                  new Pad(190, LATCH)            , new Pad(191, LATCH)             , new Pad(192, LATCH)             , new Pad(194, LATCH),
                                  new Pad(133, LATCH)            , new Pad(174, LATCH)             , new Pad(175, LATCH)             , new Pad(179, LATCH),
                                  new Pad(18, LATCH)             , new Pad(28, LATCH)              , new Pad(39, LATCH)              , new Pad(40, LATCH),
                                  new Pad(325, LATCH)            , new Pad(326, LATCH)             , new Pad(129, LATCH)             , new Pad(130, LATCH));

  //Group E3 : Color animations 3
  ManualGroup E3 = new ManualGroup(CHANNEL_MANUALMODE_3, 28,
                                  new Pad(221, LATCH)            , new Pad(222, LATCH)             , new Pad(231, LATCH)             , new Pad(280, LATCH),
                                  new Pad(134, LATCH)            , new Pad(184, LATCH)             , new Pad(185, LATCH)             , new Pad(186, LATCH),
                                  new Pad(12, LATCH)             , new Pad(23, LATCH)              , new Pad(132, LATCH)             , new Pad(279, LATCH),
                                  new Pad(197, LATCH)            , new Pad(232, LATCH)             , new Pad(321, LATCH)             , new Pad(91, LATCH));

  //Group E3 : Color animations 4
  ManualGroup F3 = new ManualGroup(CHANNEL_MANUALMODE_3, 44,
                                  new Pad(90, LATCH)             , new Pad(188, LATCH)             , new Pad(126, LATCH)             , new Pad(127, LATCH),
                                  new Pad(328, LATCH)            , new Pad(330, LATCH)             , new Pad(138, LATCH)             , new Pad(158, LATCH),
                                  new Pad(299, LATCH)            , new Pad(303, LATCH)             , new Pad(319, LATCH)             , new Pad(325, LATCH),
                                  new Pad(295, LATCH)            , new Pad(296, LATCH)             , new Pad(297, LATCH)             , new Pad(298, LATCH));
                                  
  //Group G3 : Simple Red animations 1
  ManualGroup G3 = new ManualGroup(CHANNEL_MANUALMODE_3, 60,
                                  new Pad(289, LATCH)            , new Pad(290, LATCH)             , new Pad(291, LATCH)             , new Pad(292, LATCH),
                                  new Pad(212, LATCH)            , new Pad(213, LATCH)             , new Pad(214, LATCH)             , new Pad(215, LATCH),
                                  new Pad(208, LATCH)            , new Pad(209, LATCH)             , new Pad(210, LATCH)             , new Pad(211, LATCH),
                                  new Pad(136, LATCH)            , new Pad(137, LATCH)             , new Pad(225, LATCH)             , new Pad(226, LATCH));
  
  //Group H3 : Simple Red animations 2
  ManualGroup H3 = new ManualGroup(CHANNEL_MANUALMODE_3, 76,
                                  new Pad(267, LATCH)            , new Pad(294, LATCH)             , new Pad(204, LATCH)             , new Pad(20, LATCH),
                                  new Pad(131, LATCH)            , new Pad(220, LATCH)             , new Pad(256, LATCH)             , new Pad(257, LATCH),
                                  new Pad(153, LATCH)            , new Pad(154, LATCH)             , new Pad(155, LATCH)             , new Pad(156, LATCH),
                                  new Pad(22, LATCH)             , new Pad(57, LATCH)              , new Pad(58, LATCH)              , new Pad(59, LATCH));
                                  
  //Group A4 : Simple Red animations 3 + Complex Red animations 1
  ManualGroup A4 = new ManualGroup(CHANNEL_MANUALMODE_3, 92,
                                  new Pad(149, LATCH)            , new Pad(150, LATCH)             , new Pad(151, LATCH)             , new Pad(152, LATCH),
                                  new Pad(95, LATCH)             , new Pad(96, LATCH)              , new Pad(97, LATCH)              , new Pad(98, LATCH),
                                  new Pad(285, LATCH)            , new Pad(286, LATCH)             , new Pad(89, LATCH)              , new Pad(139, LATCH),
                                  new Pad(281, LATCH)            , new Pad(282, LATCH)             , new Pad(283, LATCH)             , new Pad(284, LATCH));
                                  
  //Group B4 : Complex Red animations 2
  ManualGroup B4 = new ManualGroup(CHANNEL_MANUALMODE_4, 12,
                                  new Pad(278, LATCH)            , new Pad(300, LATCH)             , new Pad(317, LATCH)             , new Pad(318, LATCH),
                                  new Pad(249, LATCH)            , new Pad(254, LATCH)             , new Pad(255, LATCH)             , new Pad(268, LATCH),
                                  new Pad(206, LATCH)            , new Pad(216, LATCH)             , new Pad(217, LATCH)             , new Pad(218, LATCH),
                                  new Pad(198, LATCH)            , new Pad(200, LATCH)             , new Pad(238, LATCH)             , new Pad(239, LATCH));


  //Group C4 : Complex Red animations 2
  ManualGroup C4 = new ManualGroup(CHANNEL_MANUALMODE_4, 28,
                                  new Pad(8, LATCH)              , new Pad(9, LATCH)               , new Pad(33, LATCH)              , new Pad(34, LATCH),
                                  new Pad(293, LATCH)            , new Pad(320, LATCH)             , new Pad(327, LATCH)             , new Pad(329, LATCH),
                                  new Pad(273, LATCH)            , new Pad(274, LATCH)             , new Pad(276, LATCH)             , new Pad(277, LATCH),
                                  new Pad(269, LATCH)            , new Pad(270, LATCH)             , new Pad(271, LATCH)             , new Pad(272, LATCH));

  //Last group : Special actions
  ManualGroup SpecialGroup = new ManualGroup(CHANNEL_MANUALMODE_4, 44,
                                  new Pad(CONFCHANGE, LATCH)     , new Pad(CONFCHANGE, LATCH)      , new Pad(MANINPUT_OFF, LATCH)    , new Pad(MANINPUT_ON, LATCH),
                                  new Pad(PADKILLER, LATCH)      , new Pad(PADKILLER, LATCH)       , new Pad(PADKILLER, LATCH)       , new Pad(PADKILLER, LATCH),
                                  new Pad(PADKILLER, LATCH)      , new Pad(PADKILLER, LATCH)       , new Pad(PADKILLER, LATCH)       , new Pad(PADKILLER, LATCH),
                                  new Pad(REINIT, LATCH)         , new Pad(REINIT, LATCH)          , new Pad(REINIT, LATCH)          , new Pad(REINIT, LATCH));



  ////////////////////////////////////////////////////////////////////
  ////////////////////---  END OF USER CONFIG  ---////////////////////
  //////////////////////////////////////////////////////////////////// 

  //Using the defined ManualGroup objects, build the translation list which shall be really used
  manualMode_InputTranslationList = new ArrayList<int[]>();
  buildIntputTranslationList(H1);
  buildIntputTranslationList(A2);
  buildIntputTranslationList(B2);
  buildIntputTranslationList(C2);
  buildIntputTranslationList(D2);
  buildIntputTranslationList(E2);
  buildIntputTranslationList(F2);
  buildIntputTranslationList(G2);
  buildIntputTranslationList(H2);
  buildIntputTranslationList(A3);
  buildIntputTranslationList(B3);
  buildIntputTranslationList(C3);
  buildIntputTranslationList(D3);
  buildIntputTranslationList(E3);
  buildIntputTranslationList(F3);
  buildIntputTranslationList(G3);
  buildIntputTranslationList(H3);
  buildIntputTranslationList(A4);
  buildIntputTranslationList(B4);
  buildIntputTranslationList(C4);
  buildIntputTranslationList(SpecialGroup);

}


//Do the necessary actions upon receiving an explicit manual input
public void setManualAnimation(int channel, int pitch) {
  
    drawImage = 0;
    drawAnimation = 1;

  int animationToBePlayed = 1;
  int behaviour = 1;
  for (int[] pad: manualMode_InputTranslationList) {
    if (pad[0] == channel && pad[1] == pitch) {
      animationToBePlayed = pad[2];
      behaviour = pad[3];
      break;
    }
  }
   
  //Animation found is >0 : it is an animation for the LED panels
  if (animationToBePlayed > 0) {
    
    //Reset the flag to prevent any nullpointer exception
    setupcomplete = false;
    
    if (behaviour == RELEASE) {
      noteOffToResetAnimation = pitch;
      if (expectingNoteOffForRelease == false) {
        expectingNoteOffForRelease = true;
        previousAnimationNumber = animationnumber;
      }
    }
    else if (behaviour == LATCH) {
      expectingNoteOffForRelease = false;
    }
    animationnumber = animationToBePlayed;
    specificActions();
  }
  //Animation found is <0 : it is either a special command, or a command for DMX equipments
  else {
    if (animationToBePlayed == CONFCHANGE) {
      activateKeyboardLEDPanelMapping();
      //Make it persistant
      writeScreenOrderInConfigurationFile();
    }
    else if (animationToBePlayed == PADKILLER) {
      setupcomplete = false;
      animationnumber = 110;
      specificActions();
    }
    else if (animationToBePlayed == MANINPUT_OFF) {
      disableManualInput();
    }
    else if (animationToBePlayed == MANINPUT_ON) {
      enableManualInput();
    }
    else {
      //Stroboscope actions are always in RELEASE mode
      noteOffToResetDMX = pitch;
      // TBIL - needs to be remade with the new DMX functions
      //setManualFrontStroboscope(animationToBePlayed);    
    }
  }
}

//Called if a noteOff corresponding to noteOffToResetAnimation AND expectingNoteOffForRelease == true
public void noteOffRevertToPreviousAnimation() {
  expectingNoteOffForRelease = false;
  animationnumber = previousAnimationNumber;
  
  specificActions();
}


//Add to manualMode_InputTranslationList the configuration for a MPC group
public void buildIntputTranslationList(ManualGroup group) {
  for (int[] padInfo: group.getGroupMIDIInfo()) {
    manualMode_InputTranslationList.add(padInfo);
  }
}


class Pad {
 
  int animation;
  int setup; 
  
  Pad (int _animation, int _setup) {
    animation = _animation;
    setup = _setup;
  }
  
}

class ManualGroup {
  
  int midiChannel;
  int baseNote;
  ArrayList<int[]> listPerPad;          //Array of MIDI note / corresponding animation combinations
  
  ManualGroup(int midiCh, int note,
              Pad pad13, Pad pad14, Pad pad15, Pad pad16,
              Pad pad9,  Pad pad10, Pad pad11, Pad pad12,
              Pad pad5,  Pad pad6,  Pad pad7,  Pad pad8,
              Pad pad1,  Pad pad2,  Pad pad3,  Pad pad4) {
   
    midiChannel = midiCh;
    baseNote = note;
    listPerPad = new ArrayList<int[]>();
    int[] notePad1  = {midiChannel, baseNote, pad1.animation, pad1.setup};
    int[] notePad2  = {midiChannel, baseNote + 1, pad2.animation, pad2.setup};
    int[] notePad3  = {midiChannel, baseNote + 2, pad3.animation, pad3.setup};
    int[] notePad4  = {midiChannel, baseNote + 3, pad4.animation, pad4.setup};
    int[] notePad5  = {midiChannel, baseNote + 4, pad5.animation, pad5.setup};
    int[] notePad6  = {midiChannel, baseNote + 5, pad6.animation, pad6.setup};
    int[] notePad7  = {midiChannel, baseNote + 6, pad7.animation, pad7.setup};
    int[] notePad8  = {midiChannel, baseNote + 7, pad8.animation, pad8.setup};
    int[] notePad9  = {midiChannel, baseNote + 8, pad9.animation, pad9.setup};
    int[] notePad10 = {midiChannel, baseNote + 9, pad10.animation, pad10.setup};
    int[] notePad11 = {midiChannel, baseNote + 10, pad11.animation, pad11.setup};
    int[] notePad12 = {midiChannel, baseNote + 11, pad12.animation, pad12.setup};
    int[] notePad13 = {midiChannel, baseNote + 12, pad13.animation, pad13.setup};
    int[] notePad14 = {midiChannel, baseNote + 13, pad14.animation, pad14.setup};
    int[] notePad15 = {midiChannel, baseNote + 14, pad15.animation, pad15.setup};
    int[] notePad16 = {midiChannel, baseNote + 15, pad16.animation, pad16.setup};
    
    listPerPad.add(notePad1);
    listPerPad.add(notePad2);
    listPerPad.add(notePad3);
    listPerPad.add(notePad4);
    listPerPad.add(notePad5);
    listPerPad.add(notePad6);
    listPerPad.add(notePad7);
    listPerPad.add(notePad8);
    listPerPad.add(notePad9);
    listPerPad.add(notePad10);
    listPerPad.add(notePad11);
    listPerPad.add(notePad12);
    listPerPad.add(notePad13);
    listPerPad.add(notePad14);
    listPerPad.add(notePad15);
    listPerPad.add(notePad16);
  }
  
  public ArrayList<int[]> getGroupMIDIInfo() {
    return listPerPad;
  }
  
  
}

///////////////////////////////////////////////////////////////
/// Allow the Processing sketch to be controlled using MIDI ///
///////////////////////////////////////////////////////////////

         //Import MIDI library

//MIDI configuration :
final int CHANNEL_KEYBOARD           = 0;      //MIDI Channel 1
final int CHANNEL_SEMIAUTOMODE       = 1;      //MIDI Channel 2
final int CHANNEL_AUTOMODE           = 2;      //MIDI Channel 3
final int CHANNEL_MANUALMODE_1       = 3;      //MIDI Channel 4
final int CHANNEL_MANUALMODE_2       = 4;      //MIDI Channel 5
final int CHANNEL_MANUALMODE_3       = 5;      //MIDI Channel 6
final int CHANNEL_MANUALMODE_4       = 6;      //MIDI Channel 7

//Pitches for messages coming from the keyboard
final int PITCH_P1_LEFT              = 0;
final int PITCH_P1_RIGHT             = 2;
final int PITCH_P2_LEFT              = 22;
final int PITCH_P2_RIGHT             = 23;

//Pitches for messages coming from the pads + knobs
//These parameters must not be declared as final : they may be reconfigured later on 
int PITCH_PAD_KILL_LED_PANELS  = 40;
int PITCH_PAD_STROBE_4TH       = 36;
int PITCH_PAD_STROBE_8TH       = 37;
int PITCH_PAD_STROBE_16TH      = 41;
int PITCH_PAD_STROBE_32ND      = 42;
int PITCH_PAD_STROBE_64TH      = 38;
int PITCH_KNOB_BRIGHTNESS      = 11;
int PITCH_KNOB_BLACKOUT        = 1;
int PITCH_KNOB_WHITEOUT        = 2;
int PITCH_KNOB_SHREDDER        = 5;
int PITCH_KNOB_COLORCHANGE     = 3;
int PITCH_KNOB_WHITEJAMAMONO   = -1;      //Not very fun as an animation, don't use it
int PITCH_KNOB_WHITENOISE      = 7;


//Pitches for messages coming from the DAW - Manual mode
final int PITCH_SET_AUTOMODE_OFF                          = 90;
final int PITCH_SET_AUTOMODE_ON                           = 91;

final int PITCH_LOAD_ANIMATION_BANK1_TEMP                 = 96;
final int PITCH_LOAD_ANIMATION_BANK2_TEMP                 = 97;
final int PITCH_LOAD_ANIMATION_BANK3_TEMP                 = 98;
final int PITCH_LOAD_ANIMATION_BANK4_TEMP                 = 99;

final int PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION  = 100;
final int PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR       = 101;
final int PITCH_DMX_ANIMATION_MOVING_HEAD_SET_RHYTHM      = 102;
final int PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE = 103;
final int PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1 = 104;
final int PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2 = 105;
final int PITCH_DMX_ANIMATION_STROBE                      = 106;    //DMX bank used for the strobes
final int PITCH_DMX_ANIMATION_PAR                         = 107;    //DMX bank used for the PAR effects

final int PITCH_ENABLE_MAN_INPUT                          = 110;
final int PITCH_DISABLE_MAN_INPUT                         = 111;
final int PITCH_CUSTOM_DEVICE_BANK1                       = 118;
final int PITCH_CUSTOM_DEVICE_BANK2                       = 119;
final int PITCH_CUSTOM_DEVICE_BANK3                       = 120;
final int PITCH_DISPLAY_EFFECT                            = 121;
final int PITCH_LOAD_ANIMATION_BANK1                      = 123;
final int PITCH_LOAD_ANIMATION_BANK2                      = 124;
final int PITCH_LOAD_ANIMATION_BANK3                      = 125;
final int PITCH_LOAD_ANIMATION_BANK4                      = 122;
final int PITCH_LOAD_IMAGE_BANK1                          = 126;
final int PITCH_CHANGE_OUTPUTMAPPING                      = 127;

//The RMX has a pretty specific MIDI implementation - only one knob to control a range of effects
//When activating the effect, a specific note on 127 is sent, afterwards the activated effect is controlled with a single MIDI CC (the same for all effects)
final int CC_RMX_RHYTHM_1 = 20;
final int CC_RMX_RHYTHM_2 = 21;
final int CC_RMX_SCENE_1 = 22;
final int CC_RMX_SCENE_2 = 23;
final int PITCH_RMX_SCENE_HPF = 26;
final int PITCH_RMX_SCENE_LPF = 27;
final int PITCH_RMX_SCENE_ZIP = 28;
final int PITCH_RMX_SCENE_SPIRALDOWN = 29;
final int PITCH_RMX_SCENE_REVERBDOWN = 30;
final int PITCH_RMX_SCENE_MOD = 21;
final int PITCH_RMX_SCENE_ECHO = 22;
final int PITCH_RMX_SCENE_NOISE = 23;
final int PITCH_RMX_SCENE_SPIRALUP = 24;
final int PITCH_RMX_SCENE_REVERBUP = 25;
final int PITCH_RMX_RHYTHM_ROLL = 6;
final int PITCH_RMX_RHYTHM_TRANS = 7;
final int PITCH_RMX_RHYTHM_ADD = 8;
final int PITCH_RMX_RHYTHM_REVDELAY = 9;
final int PITCH_RMX_RHYTHM_OFFSET = 10;
final int PITCH_RMX_RHYTHM_KICK = 11;
final int PITCH_RMX_RHYTHM_SNARE = 12;
final int PITCH_RMX_RHYTHM_CLAP = 13;
final int PITCH_RMX_RHYTHM_HIHAT = 14;
final int PITCH_RMX_RHYTHM_CYMBAL = 15;
final int PITCH_RMX_RELEASE_FX  = 37;
final int[] PIONEER_RMX_SCENEFX_temp = {PITCH_RMX_SCENE_HPF, PITCH_RMX_SCENE_LPF, PITCH_RMX_SCENE_ZIP, PITCH_RMX_SCENE_SPIRALDOWN, PITCH_RMX_SCENE_REVERBDOWN, PITCH_RMX_SCENE_MOD, PITCH_RMX_SCENE_ECHO, PITCH_RMX_SCENE_NOISE, PITCH_RMX_SCENE_SPIRALUP, PITCH_RMX_SCENE_REVERBUP};
final int[] PIONEER_RMX_RHYTHMFX_temp = {PITCH_RMX_RHYTHM_ROLL, PITCH_RMX_RHYTHM_TRANS, PITCH_RMX_RHYTHM_ADD, PITCH_RMX_RHYTHM_REVDELAY, PITCH_RMX_RHYTHM_OFFSET, PITCH_RMX_RHYTHM_KICK, PITCH_RMX_RHYTHM_SNARE, PITCH_RMX_RHYTHM_CLAP, PITCH_RMX_RHYTHM_HIHAT, PITCH_RMX_RHYTHM_CYMBAL};
IntList PIONEER_RMX_SCENEFX = new IntList();    //IntList are easier to use for some specific functions they have
IntList PIONEER_RMX_RHYTHMFX = new IntList();

// Special CC values used for the RMX effects
final int RMX_CC_VAL_THR_1 = 22;
final int RMX_CC_VAL_THR_2 = 77;
final int RMX_CC_VAL_THR_3 = 126;
final int RMX_CC_VAL_THR_4 = 127;

boolean pionnerRMX_SceneFxOn = false;           // is an effect currently applied at the moment ?
boolean pionnerRMX_RhythmFxOn = false;          // is an effect currently applied at the moment ?
int pionnerRMX_LastSeenScenePitch = -1;         // variable used to store the last MIDI message sent by the RMX
int pionnerRMX_LastSeenRhythmPitch = -1;        // variable used to store the last MIDI message sent by the RMX
int pionnerRMX_CurrentSceneFxCCVal = -1;        // value of the current SceneFX knob #1
int pionnerRMX_CurrentSceneFxCCVal2 = -1;       // value of the current SceneFX knob #2
int pionnerRMX_CurrentRhythmFxCCVal = -1;       // value of the current RhythmFX knob #1
int pionnerRMX_CurrentRhythmFxCCVal2 = -1;      // value of the current RhythmFX knob #2


// Allow LED Panel remapping using the keyboard
// Use case : this boolean is set to true using the Maschine
// Once it is on, listen to the keyboard input : record NUMBER_OF_PANELS notes (with a different pitch)
// The mapping is then set using the input order and the pitch of the notes
// Ex : keyboard [ C5 E5 G#5 D5 F5 ] -> panel mapping [1 3 5 2 4]
boolean authorizePanelRemappingUsingKeyboard = false;
int[] manualLEDPanelRemappingNoteArray;
int manualLEDPanelRemappingNoteCounter = 0;

// Buffer variable used to serve as a memory for temporary panel animations
int previousLEDPanelAnimation = 0;

public void midiInit() {
  //Initialize some Pioneer RMX-specific stuff
  PIONEER_RMX_SCENEFX.append(PIONEER_RMX_SCENEFX_temp);
  PIONEER_RMX_RHYTHMFX.append(PIONEER_RMX_RHYTHMFX_temp);
  
  outputLog.println("--- Initializing MIDI Control ---");
  MidiBus.list(); 
  //Arguments to create the MidiBus : Parent Class, IN device, OUT device, NAME
  myMainBus = new MidiBus(this, MIDI_BUS_MAIN_INPUT, MIDI_BUS_MAIN_INPUT, MIDI_BUS_MAIN_INPUT);
  outputLog.println("Configuration --- Main Input MIDI device : " + MIDI_BUS_MAIN_INPUT);
  
  boolean controllerConnected = true, pioneerConnected = true, keyboardConnected = true;
  try {myControllerBus = new MidiBus(this, MIDI_BUS_CONTROLLER_INPUT, MIDI_BUS_CONTROLLER_INPUT, MIDI_BUS_CONTROLLER_INPUT);}
    catch (Exception e) {println("Problem during initialization of controller MIDI input port : " + e); controllerConnected = false;}
  try {myPioneerControllerBus = new MidiBus(this, MIDI_BUS_PIONEER_CONTROLLER_INPUT, MIDI_BUS_PIONEER_CONTROLLER_INPUT, MIDI_BUS_PIONEER_CONTROLLER_INPUT);}
    catch (Exception e) {println("Problem during initialization of the Pioneer controller MIDI input port : " + e); pioneerConnected = false;}
  try {myKeyboardBus = new MidiBus(this, MIDI_BUS_KEYBOARD_INPUT, MIDI_BUS_KEYBOARD_INPUT, MIDI_BUS_KEYBOARD_INPUT);}
    catch (Exception e) {println("Problem during initialization of controller MIDI input port : " + e); keyboardConnected = false;}
    
  if (pioneerConnected) { outputLog.println("Device configurated --- Pioneer Controller device : " + MIDI_BUS_PIONEER_CONTROLLER_INPUT); }
  if (controllerConnected) { outputLog.println("Device configurated --- Controller Input MIDI device : " + MIDI_BUS_CONTROLLER_INPUT); }
  if (keyboardConnected) { outputLog.println("Configuration --- Keyboard Input MIDI device : " + MIDI_BUS_KEYBOARD_INPUT); }

  outputLog.println("--- MIDI initialization over ---");

}

// May be used in the future
//void rawMidi() {
//  println("TEST");
//}

/////////////////////////////////////////////////
//////////////       NOTE ON       //////////////
/////////////////////////////////////////////////

// Receive a noteOn
public void noteOn(int channel, int pitch, int velocity, long timestamp, String bus_name) {
  if (initComplete == true) {
    
    if (bus_name == myControllerBus.getBusName() || bus_name == myKeyboardBus.getBusName()) {
      processMidiInfo_standardControllers(channel, pitch, velocity);
    }
    
    else if (bus_name == myPioneerControllerBus.getBusName()) {
      processMidiInfo_pioneerControllerNoteOn(pitch, velocity);
    }
    
    else if (channel == CHANNEL_MANUALMODE_1 || channel == CHANNEL_MANUALMODE_2 || channel == CHANNEL_MANUALMODE_3 || channel == CHANNEL_MANUALMODE_4) {
      //Release automatic mode in case of explicit input
      //This mode corresponds to a MPC-like controller selecting manually animations
      AUTOMATIC_MODE = false;
      setManualAnimation(channel, pitch);
    }
    
    else if (channel == CHANNEL_SEMIAUTOMODE) {
      //Release automatic mode in case of explicit input
      //This mode corresponds to a DAW sending MIDI commands, for example through the use of clips (Ableton Live), scenes (Maschine), or plain old MIDI tracks (Logic)
      AUTOMATIC_MODE = false;
      processMidiInfo_semiAutoMode(pitch, velocity);
    }
    
    else if (channel == CHANNEL_KEYBOARD) {
      processMidiInfo_keyboard(pitch, velocity);
    }
  }
}


public void processMidiInfo_semiAutoMode(int pitch, int velocity) {
  switch (pitch) {
    //Standard mode, MIDI incoming from Ableton
    case PITCH_SET_AUTOMODE_OFF:                            setAutomaticModeOff();break;                                             //F#5   - Disable the automatic mode
    case PITCH_SET_AUTOMODE_ON:                             setAutomaticModeOn();break;                                              //G5    - Enable the automatic mode
    case PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION:    loadDMXAnimation_movingHead_initDirection(velocity); break;              //E7
    case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR:         loadDMXAnimation_movingHead_setColor(velocity); break;                   //F7
    case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_RHYTHM:        loadDMXAnimation_movingHead_setRhythm(velocity); break;                  //F#7
    case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE:   loadDMXAnimation_movingHead_setLightStyle(velocity); break;              //G7
    case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1:   loadDMXAnimation_movingHead_setAnimation1(velocity); break;              //G#7
    case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2:   loadDMXAnimation_movingHead_setAnimation2(velocity); break;              //A7
    case PITCH_DMX_ANIMATION_STROBE:                        loadDMXAnimation_strobe(velocity); break;                                //A#7   - Load an animation using DMX devices - Strobe bank
    case PITCH_DMX_ANIMATION_PAR:                           loadDMXAnimation_par(velocity); break;                                   //B7
    case PITCH_ENABLE_MAN_INPUT:                            enableManualInput();break;                                               //D8
    case PITCH_DISABLE_MAN_INPUT:                           disableManualInput();break;                                              //D#8
    case PITCH_CUSTOM_DEVICE_BANK1:                         loadCustomDeviceAnimation1(velocity);break;                              //A#8   - Load an animation for the custom devices
    case PITCH_CUSTOM_DEVICE_BANK2:                         loadCustomDeviceAnimation2(velocity);break;                              //B8
    case PITCH_CUSTOM_DEVICE_BANK3:                         loadCustomDeviceAnimation3(velocity);break;                              //C9
    case PITCH_DISPLAY_EFFECT:                              activateAdditionalEffect(velocity);break;                                //C#9
    case PITCH_LOAD_ANIMATION_BANK1_TEMP:                   loadTempAnimation1(velocity);break;                                      //C7    - Load a temporary animation using the LED panels
    case PITCH_LOAD_ANIMATION_BANK2_TEMP:                   loadTempAnimation2(velocity);break;                                      //C#7
    case PITCH_LOAD_ANIMATION_BANK3_TEMP:                   loadTempAnimation3(velocity);break;                                      //D7
    case PITCH_LOAD_ANIMATION_BANK4_TEMP:                   loadTempAnimation4(velocity);break;                                      //D#7
    case PITCH_LOAD_ANIMATION_BANK1:                        loadAnimation1(velocity);break;                                          //D#9   - Load an animation using the LED panels
    case PITCH_LOAD_ANIMATION_BANK2:                        loadAnimation2(velocity);break;                                          //E9
    case PITCH_LOAD_ANIMATION_BANK3:                        loadAnimation3(velocity);break;                                          //F9
    case PITCH_LOAD_ANIMATION_BANK4:                        loadAnimation4(velocity);break;                                          //D9
    case PITCH_LOAD_IMAGE_BANK1:                            loadImage1(velocity);break;                                              //F#9
    case PITCH_CHANGE_OUTPUTMAPPING:                        activateKeyboardLEDPanelMapping();break;                                 //G9    - Activate the remapping procedure
    default: break;
  }
}

public void processMidiInfo_keyboard(int pitch, int velocity) {
  //Custom function : Remapping using the keyboard, record the input notes 
  if (authorizePanelRemappingUsingKeyboard == true) {
            
    //Do not allow the same panel to be mapped to two different outputs
    boolean pitchAlreadyInArray = false;
    for (int element: manualLEDPanelRemappingNoteArray) {
      if (pitch == element) {
        pitchAlreadyInArray = true;
      }
    }
    
    if (manualLEDPanelRemappingNoteCounter == 0) {
      manualLEDPanelRemappingNoteArray[manualLEDPanelRemappingNoteCounter] = pitch;
      manualLEDPanelRemappingNoteCounter += 1;
      imagenumber = 0 - manualLEDPanelRemappingNoteCounter - 1;
    }
    else if (pitchAlreadyInArray == false) {
      manualLEDPanelRemappingNoteArray[manualLEDPanelRemappingNoteCounter] = pitch;
      manualLEDPanelRemappingNoteCounter += 1;
      imagenumber = 0 - manualLEDPanelRemappingNoteCounter - 1;
    }
    
    if (manualLEDPanelRemappingNoteCounter == NUMBER_OF_PANELS) {
      finalizeLEDPanelRemappingProcedure();
      imagenumber = 0;
    }
    
  }
}

public void processMidiInfo_standardControllers(int channel, int pitch, int velocity) {
    //Drumpad sub-keyboard - couldn't use a switch here because the pitches are not declared as finals 
    if (pitch == PITCH_P1_LEFT)                  {p1Left(channel, pitch, velocity);}
    else if (pitch == PITCH_P1_RIGHT)            {p1Right(channel, pitch, velocity);}
    else if (pitch == PITCH_P2_LEFT)             {p2Left(channel, pitch, velocity);}
    else if (pitch == PITCH_P2_RIGHT)            {p2Right(channel, pitch, velocity);}
    else if (pitch == PITCH_PAD_KILL_LED_PANELS) {activateKillLedPanel(channel, pitch, velocity);}
    else if (pitch == PITCH_PAD_STROBE_4TH)      {activatePadStrobe4th(channel, pitch, velocity);}
    else if (pitch == PITCH_PAD_STROBE_8TH)      {activatePadStrobe8th(channel, pitch, velocity);}
    else if (pitch == PITCH_PAD_STROBE_16TH)     {activatePadStrobe16th(channel, pitch, velocity);}
    else if (pitch == PITCH_PAD_STROBE_32ND)     {activatePadStrobe32nd(channel, pitch, velocity);}
    else if (pitch == PITCH_PAD_STROBE_64TH)     {activatePadStrobe64th(channel, pitch, velocity);}
}

public void processMidiInfo_pioneerControllerNoteOn(int pitch, int velocity) {
  //In the case of a Pioneer RMX-like controller, the pitches are defined as final values (impossible to remap the controller)
  if (PIONEER_RMX_RHYTHMFX.hasValue(pitch)) {
    if (pitch == pionnerRMX_LastSeenRhythmPitch) {
      pionnerRMX_RhythmFxOn = !pionnerRMX_RhythmFxOn;
    }
    else {
      pionnerRMX_RhythmFxOn = true;
    }
    pionnerRMX_LastSeenRhythmPitch = pitch;

  }
  else if (PIONEER_RMX_SCENEFX.hasValue(pitch)) {
    if (pitch == pionnerRMX_LastSeenScenePitch) {
      pionnerRMX_SceneFxOn = !pionnerRMX_SceneFxOn;
    }
    else {
      pionnerRMX_SceneFxOn = true;
    }
    pionnerRMX_LastSeenScenePitch = pitch;
  }
  else if (pitch == PITCH_RMX_RELEASE_FX) {
    //Release all FX -> release all visual effects
    pionnerRMX_RhythmFxOn = false;
    pionnerRMX_SceneFxOn = false;
  }
  
  //A Pong game is actually going on - the FX knobs hold different meanings here
  if (animationnumber == 394) {
    if (pitch == PITCH_RMX_RELEASE_FX) {
      pong_gameRestart();
    }
  }

}

//////////////////////////////////////////////////////
// Specific functions


// Specific actions 
public void executeRMXSpecificAnimations() {
  if (pionnerRMX_RhythmFxOn) {
    switch (pionnerRMX_LastSeenRhythmPitch) {
      case PITCH_RMX_RHYTHM_ROLL:           draw_AutoModeDMXStrobe(pionnerRMX_CurrentRhythmFxCCVal, pionnerRMX_CurrentRhythmFxCCVal2); break;
      case PITCH_RMX_RHYTHM_TRANS:          break;
      case PITCH_RMX_RHYTHM_ADD:            break;
      case PITCH_RMX_RHYTHM_REVDELAY:       break;
      case PITCH_RMX_RHYTHM_OFFSET:         break;
      default: break;
    }
  }

  if (pionnerRMX_SceneFxOn) {
    switch (pionnerRMX_LastSeenScenePitch) {
      case PITCH_RMX_SCENE_HPF:             draw_AutoModeWhiteOut(pionnerRMX_CurrentSceneFxCCVal, pionnerRMX_CurrentSceneFxCCVal2); break;
      case PITCH_RMX_SCENE_LPF:             draw_AutoModeBlackOut(pionnerRMX_CurrentSceneFxCCVal, pionnerRMX_CurrentSceneFxCCVal2); break;
      case PITCH_RMX_SCENE_ZIP:             break;
      case PITCH_RMX_SCENE_SPIRALDOWN:      break;
      case PITCH_RMX_SCENE_REVERBDOWN:      break;
      case PITCH_RMX_SCENE_MOD:             break;
      case PITCH_RMX_SCENE_ECHO:            break;
      case PITCH_RMX_SCENE_NOISE:           break;
      case PITCH_RMX_SCENE_SPIRALUP:        draw_AutoModeRedOut(pionnerRMX_CurrentSceneFxCCVal, pionnerRMX_CurrentSceneFxCCVal2); break;
      case PITCH_RMX_SCENE_REVERBUP:        draw_AutoModeWhiteOut(pionnerRMX_CurrentSceneFxCCVal, pionnerRMX_CurrentSceneFxCCVal2); break;
      default: break;
    }  
  }
}


// Actions related to the integrated games
public void p1KnobControl(int value) {
  command_p1_left = false;
  command_p1_right = false;
  if (gamestart) {
    bottom.x = PApplet.parseInt((width - bottom.paddle_width) * (value/127.0f));
  }
}

public void p2KnobControl(int value) {
  command_p2_left = false;
  command_p2_right = false;
  if (gamestart) {
    top.x = PApplet.parseInt((width - top.paddle_width) * (value/127.0f));
  }
}

public void p1Left(int channel, int pitch, int velocity) {
  //P1_LEFT 
  command_p1_left = true;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P1_LEFT");
}

public void p1Right(int channel, int pitch, int velocity) {
  //P1_RIGHT
  command_p1_right = true;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P1_RIGHT");
}

public void p2Left(int channel, int pitch, int velocity) {
  //P2_LEFT
  command_p2_left = true;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P2_LEFT");
}

public void p2Right(int channel, int pitch, int velocity) {
  //P2_RIGHT
  command_p2_right = true; 
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P2_RIGHT");
}

public void activateKillLedPanel(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : ACTIVATE_KILL_LEDPANEL");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setKillLedPanel = true;
  }
  if (authorizeKillLedPanelManualMode == true) {
    //TBIL - needs to be redone with the new DMX functions
//    setKillLedPanelManualMode = true;
//    if (authorizeDMXStrobe == true) {
//      strobepreset_frontleft = 0;
//      strobepreset_frontright = 0;
//      stopStrobe_FrontLeft();
//      stopStrobe_FrontRight();
//    }
  }
}

public void activatePadStrobe4th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : ACTIVATE_PAD_STROBE_4TH");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode4th = true;
    registeredTempo = frameRate;
  }
  if (authorizeStrobeManualMode4th == true) {
    //TBIL - needs to be redone with the new DMX functions
//    if (authorizePanelStrobe == true) {
//      setStrobeManualMode4th = true;
//    }
//    if (authorizeDMXStrobe == true) {
//      if ((setStrobeManualMode4th == true || setStrobeManualMode8th == true || setStrobeManualMode32nd == true || setStrobeManualMode64th == true) == false) {
//        previousFrontLeftStrobeState = drawStrobe_FrontLeft;
//        previousFrontLeftStrobePreset = strobepreset_frontleft;
//        previousFrontRightStrobeState = drawStrobe_FrontRight;
//        previousFrontRightStrobePreset = strobepreset_frontright;
//      }
//      strobepreset_frontleft = 40;
//      strobepreset_frontright = 40;
//      //Only need to call this function once
//      startStrobe(strobepreset_frontleft);
//    }
//    registeredTempo = frameRate;
  }
}

public void activatePadStrobe8th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : ACTIVATE_PAD_STROBE_8TH");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode8th = true;
    registeredTempo = frameRate;
  }
  if (authorizeStrobeManualMode8th == true) {
    //TBIL - needs to be redone with the new DMX functions
//    if (authorizePanelStrobe == true) {
//      registeredTempo = frameRate;
//    }
//    if (authorizeDMXStrobe == true) {
//      if ((setStrobeManualMode4th == true || setStrobeManualMode16th == true || setStrobeManualMode32nd == true || setStrobeManualMode64th == true) == false) {
//        previousFrontLeftStrobeState = drawStrobe_FrontLeft;
//        previousFrontLeftStrobePreset = strobepreset_frontleft;
//        previousFrontRightStrobeState = drawStrobe_FrontRight;
//        previousFrontRightStrobePreset = strobepreset_frontright;
//      }
//      strobepreset_frontleft = 60;
//      strobepreset_frontright = 60;
//      startStrobe(strobepreset_frontleft);
//    }
//    setStrobeManualMode8th = true;
  }
}

public void activatePadStrobe16th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : ACTIVATE_PAD_STROBE_16TH");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode16th = true;
    registeredTempo = frameRate;
  }
  if (authorizeStrobeManualMode16th == true) {
    //TBIL - needs to be redone with the new DMX functions
//    if (authorizePanelStrobe == true) {
//      registeredTempo = frameRate;
//    }
//    if (authorizeDMXStrobe == true) {
//      if ((setStrobeManualMode4th == true || setStrobeManualMode8th == true || setStrobeManualMode32nd == true || setStrobeManualMode64th == true) == false) {
//        previousFrontLeftStrobeState = drawStrobe_FrontLeft;
//        previousFrontLeftStrobePreset = strobepreset_frontleft;
//        previousFrontRightStrobeState = drawStrobe_FrontRight;
//        previousFrontRightStrobePreset = strobepreset_frontright;
//      }
//      strobepreset_frontleft = 80;
//      strobepreset_frontright = 80;
//      startStrobe(strobepreset_frontleft);
//    }
//    setStrobeManualMode16th = true;
  }
}

public void activatePadStrobe32nd(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : ACTIVATE_PAD_STROBE_32ND");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode32nd = true;
    registeredTempo = frameRate;
  }
  if (authorizeStrobeManualMode32nd == true) {
    //TBIL - needs to be redone with the new DMX functions
//    if (authorizePanelStrobe == true) {
//      registeredTempo = frameRate;
//    }
//    if (authorizeDMXStrobe == true) {
//      if ((setStrobeManualMode4th == true || setStrobeManualMode8th == true || setStrobeManualMode16th == true || setStrobeManualMode64th == true) == false) {
//        previousFrontLeftStrobeState = drawStrobe_FrontLeft;
//        previousFrontLeftStrobePreset = strobepreset_frontleft;
//        previousFrontRightStrobeState = drawStrobe_FrontRight;
//        previousFrontRightStrobePreset = strobepreset_frontright;
//      }
//      strobepreset_frontleft = 100;
//      strobepreset_frontright = 100;
//      startStrobe(strobepreset_frontleft);
//    }
//    setStrobeManualMode32nd = true;
  }
}

public void activatePadStrobe64th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : ACTIVATE_PAD_STROBE_64TH");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode64th = true;
    registeredTempo = frameRate;
  }
  if (authorizeStrobeManualMode64th == true) {
    //TBIL - needs to be redone with the new DMX functions
//    if (authorizePanelStrobe == true) {
//      registeredTempo = frameRate;
//    }
//    if (authorizeDMXStrobe == true) {
//      if ((setStrobeManualMode4th == true || setStrobeManualMode8th == true || setStrobeManualMode16th == true || setStrobeManualMode32nd == true) == false) {
//        previousFrontLeftStrobeState = drawStrobe_FrontLeft;
//        previousFrontLeftStrobePreset = strobepreset_frontleft;
//        previousFrontRightStrobeState = drawStrobe_FrontRight;
//        previousFrontRightStrobePreset = strobepreset_frontright;
//        previousBackStrobeState = drawStrobe_Back;
//        previousBackStrobePreset = strobepreset_back;
//      }
//      strobepreset_frontleft = 100;
//      strobepreset_frontright = 100;
//      strobepreset_back = 100;
//      startStrobe(strobepreset_frontleft);
//      startStrobe_Back(strobepreset_back);
//    }
//    setStrobeManualMode64th = true;
  }
}


public void setAutomaticModeOff() {
  //outputLog.println("Action received: Set Automatic Mode OFF");
  AUTOMATIC_MODE = false;
  // Update the GUI's Auto Mode toggle
  auxControlFrame.setAutomaticModeToggle.setValue(false);
}
  
public void setAutomaticModeOn() {  
  //outputLog.println("Action received: Set Automatic Mode ON");
  AUTOMATIC_MODE = true;
  auxControlFrame.setAutomaticModeToggle.setValue(true);
}


public void activateAdditionalEffect(int velocity) {
  effectToBeDrawn = true;
  currentEffectNumber = velocity;
  initSpecificEffectParams();
  effectNumberToDeactivateEffects = velocity;
}

public void deactivateAdditionalEffect(int velocity) {
  effectToBeDrawn = false;
}


public void loadDMXAnimation_movingHead_initDirection(int velocity) {
  dmxAnimationNumber_movingHead_initDirection = velocity;
  setupDMXAnimation_movingHead_initDirection();
}

public void loadDMXAnimation_movingHead_setColor(int velocity) {
  dmxAnimationNumber_movingHead_setColor = velocity;
  setupDMXAnimation_movingHead_setColor();
}

public void loadDMXAnimation_movingHead_setRhythm(int velocity) {
  dmxAnimationNumber_movingHead_setRhythm = velocity;
  setupDMXAnimation_movingHead_setRhythm();
}

public void loadDMXAnimation_movingHead_setLightStyle(int velocity) {
  dmxAnimationNumber_movingHead_setLightStyle = velocity;
  setupDMXAnimation_movingHead_setLightStyle();
}

public void loadDMXAnimation_movingHead_setAnimation1(int velocity) {
  loadDMXAnimation_movingHead_setAnimation(velocity);
}

public void loadDMXAnimation_movingHead_setAnimation2(int velocity) {
  loadDMXAnimation_movingHead_setAnimation(velocity + 127);
}


public void loadDMXAnimation_movingHead_setAnimation(int dmxAnimNumber) {
  //When such a command is received, and while the note continues, the DMX control is up to Strobot
  dmxAutomaticControl = true;
  dmxAnimationNumber_movingHead_setAnimation = dmxAnimNumber;
  setupDMXAnimation_movingHeadAnimation();
}

public void loadDMXAnimation_strobe(int dmxAnimNumber) {
  //When such a command is received, and while the note continues, the DMX control is up to Strobot
  dmxAutomaticControl = true;
  dmxAnimationNumber_strobe = dmxAnimNumber;
  setupDMXAnimation_strobe();
}

public void loadDMXAnimation_par(int dmxAnimNumber) {
  //When such a command is received, and while the note continues, the DMX control is up to Strobot
  dmxAutomaticControl = true;
  dmxAnimationNumber_par = dmxAnimNumber;
  setupDMXAnimation_par();
}

public void loadCustomDeviceAnimation1(int velocity) {
  customDeviceAnimation(velocity);
}

public void loadCustomDeviceAnimation2(int velocity) {
  customDeviceAnimation(velocity + 127);
}

public void loadCustomDeviceAnimation3(int velocity) {
  customDeviceAnimation(velocity + 254);
}


public void loadAnimation1(int velocity) {
  //Update the animation number
  loadAnimation(velocity);
}

public void loadAnimation2(int velocity) {
  //Update the animation number
  loadAnimation(velocity + 127);
}

public void loadAnimation3(int velocity) {
  //Update the animation number
  loadAnimation(velocity + 254);
}

public void loadAnimation4(int velocity) {  
  //Update the animation number
  loadAnimation(velocity + 381);
}

public void loadAnimation (int number) {
  drawImage = 0;
  drawAnimation = 1;
  
  //Reset the flag to prevent any nullpointer exception
  setupcomplete = false;
  
  //Update the memory of the previous animation
  previousLEDPanelAnimation = animationnumber;
  
  //Update the animation number
  animationnumber = number;
  
  //Kept for debug, not necessary in the release version
  //outputLog.println("Semi-auto action : Change current animation to " + animationnumber);
  
  //Execute specific actions related to this particular animation
  specificActions();  
}

public void loadTempAnimation1(int velocity) {
  //Update the animation number
  loadTempAnimation(velocity);
}

public void loadTempAnimation2(int velocity) {
  //Update the animation number
  loadTempAnimation(velocity + 127);
}

public void loadTempAnimation3(int velocity) {
  //Update the animation number
  loadTempAnimation(velocity + 254);
}

public void loadTempAnimation4(int velocity) {  
  //Update the animation number
  loadTempAnimation(velocity + 381);
}

public void loadTempAnimation (int number) {
  drawImage = 0;
  drawAnimation = 1;
  
  //Reset the flag to prevent any nullpointer exception
  setupcomplete = false; 
  
  //Update the animation number
  animationnumber = number;
  
  //Kept for debug, not necessary in the release version
  //outputLog.println("Semi-auto action : Change current animation to " + animationnumber);
  
  //Execute specific actions related to this particular animation
  specificActions();  
}

// Reinitialize the LED Panel animation in case of a temporary command
public void unloadAnimation() {
  drawImage = 0;
  drawAnimation = 1;
  
  //Reset the flag to prevent any nullpointer exception
  setupcomplete = false;
  
  //Reset the animation number
  animationnumber = previousLEDPanelAnimation;
  
  //Execute specific actions related to this particular animation
  specificActions();  
}

public void loadImage1(int velocity) {
  //LOAD_IMAGE_BANK1
  drawImage = 1;
  drawAnimation = 0;

  //No need to reset the flag
  setupcomplete = true;

  //Get the first value as an string
  imagenumber = velocity;
  
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note On received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : Load image number " + imagenumber);      
}

public void activateKeyboardLEDPanelMapping() {
  //Without this reset, no common base exists to say "this is the nth panel"
  resetLEDPanelMapping();
  
  manualLEDPanelRemappingNoteArray = new int[NUMBER_OF_PANELS];
  for (int i=0;i<NUMBER_OF_PANELS;i++) { manualLEDPanelRemappingNoteArray[i] = -1; }
    
  manualLEDPanelRemappingNoteCounter = 0;
  authorizePanelRemappingUsingKeyboard = true;
  
  //Display an image lighting only the current panel to map to inform the user 
  drawImage = 1;
  drawAnimation = 0;
  imagenumber = -1;
}

public void finalizeLEDPanelRemappingProcedure() {
  
  int[] sortedNoteList = sort(manualLEDPanelRemappingNoteArray);
  int[] sortedArray = new int[sortedNoteList.length];
    
  for (int i=0; i<sortedNoteList.length; i++) {
    for (int panelNb=0; panelNb<manualLEDPanelRemappingNoteArray.length; panelNb++) {
      if (sortedNoteList[i] == manualLEDPanelRemappingNoteArray[panelNb]) {
        sortedArray[panelNb] = i;
      }
    }
  }
      
  // Most critical part : update the panelNumber directly inside the Output objects !
  for (int i=0; i<outputDevices.length; i++) {
    outputDevices[i].panelNumber = sortedArray[i];
    screen_order_configuration[i] = sortedArray[i];
  }
  
  manualLEDPanelRemappingNoteCounter = 0;
  authorizePanelRemappingUsingKeyboard = false;
  
  for (int i=0; i<outputDevices.length; i++) {
    outputLog.println("Microcontroller reconfiguration - device " + outputDevices[i].serialPort + " is now affected to output #" + outputDevices[i].panelNumber);
  }
  
  //Make the configuration change persistant
  writeScreenOrderInConfigurationFile();
}

//Reset the output order of the panels back to their original pre-conf value
public void resetLEDPanelMapping() {
  //Reset the display in addition to this
  for (int i=0; i<outputDevices.length; i++) {
    outputDevices[i].panelNumber = i;
    screen_order_configuration[i] = i;
  }
}


//////////////////////////////////////////////////
//////////////       NOTE OFF       //////////////
//////////////////////////////////////////////////


public void noteOff(int channel, int pitch, int velocity, long timestamp, String bus_name) {
    
  // Receive a noteOff
  if (initComplete == true) {
    if (bus_name == myControllerBus.getBusName() || bus_name == myKeyboardBus.getBusName()) {
      if (pitch == PITCH_P1_LEFT)                  {p1LeftStop(channel, pitch, velocity);}
      else if (pitch == PITCH_P1_RIGHT)            {p1RightStop(channel, pitch, velocity);}
      else if (pitch == PITCH_P2_LEFT)             {p2LeftStop(channel, pitch, velocity);}
      else if (pitch == PITCH_P2_RIGHT)            {p2RightStop(channel, pitch, velocity);}
      else if (pitch == PITCH_PAD_KILL_LED_PANELS) {deactivateKillLedPanel(channel, pitch, velocity);}
      else if (pitch == PITCH_PAD_STROBE_4TH)      {deactivatePadStrobe4th(channel, pitch, velocity);}
      else if (pitch == PITCH_PAD_STROBE_8TH)      {deactivatePadStrobe8th(channel, pitch, velocity);}
      else if (pitch == PITCH_PAD_STROBE_16TH)     {deactivatePadStrobe16th(channel, pitch, velocity);}
      else if (pitch == PITCH_PAD_STROBE_32ND)     {deactivatePadStrobe32nd(channel, pitch, velocity);}
      else if (pitch == PITCH_PAD_STROBE_64TH)     {deactivatePadStrobe64th(channel, pitch, velocity);}
    }
    
    //Semi-automatic mode - Release for DMX actions, or for effects
    if (channel == CHANNEL_SEMIAUTOMODE) {
      //Do not release automatic mode : only Note On events have this right
      //AUTOMATIC_MODE = false;
      switch (pitch) {
        case PITCH_DMX_ANIMATION_STROBE:                        unloadDMXAnimation_strobe(); break;                         //A#7   - Unload an animation using DMX devices : noteOff releases DMX
        case PITCH_DMX_ANIMATION_PAR:                           unloadDMXAnimation_par(); break;                            //B7

        case PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION:    break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_RHYTHM:        break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR:         break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE:   break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1:   unloadDMXAnimation_movingHead(); break;
        case PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2:   unloadDMXAnimation_movingHead(); break;

        case PITCH_LOAD_ANIMATION_BANK1_TEMP:                   unloadAnimation();break;                                    //C7    - Unload a temporary animation using the LED panels
        case PITCH_LOAD_ANIMATION_BANK2_TEMP:                   unloadAnimation();break;                                    //C#7
        case PITCH_LOAD_ANIMATION_BANK3_TEMP:                   unloadAnimation();break;                                    //D7
        case PITCH_LOAD_ANIMATION_BANK4_TEMP:                   unloadAnimation();break;                                    //D#7
        
        case PITCH_DISPLAY_EFFECT:                              deactivateAdditionalEffect(velocity);break;                 //C9    - Reset the effect
        default: break;
      }
    }
    
    //Manual mode : release the animation in case of momentary animations
    if (channel == CHANNEL_MANUALMODE_1 || channel == CHANNEL_MANUALMODE_2 || channel == CHANNEL_MANUALMODE_3 || channel == CHANNEL_MANUALMODE_4) {
      
      int animationToBePlayed = 1;
      int behaviour = 1;
      for (int[] pad: manualMode_InputTranslationList) {
        if (pad[0] == channel && pad[1] == pitch) {
          animationToBePlayed = pad[2];
          behaviour = pad[3];
          break;
        }
      }
      
      //The command aims to change the LED panels
      if (animationToBePlayed >0) {
        if (expectingNoteOffForRelease == true) {
          if (noteOffToResetAnimation == pitch) {
            noteOffRevertToPreviousAnimation();
          }
        }        
      }
      //TBIL - needs to be redone once the new DMX implementation is complete
//      //The command is an order for DMX devices
//      else {
//        if (pitch == noteOffToResetDMX) {
//          strobepreset_frontleft = 0;
//          myDMX.stopStrobe_FrontLeft();
//          strobepreset_frontright = 0;
//          myDMX.stopStrobe_FrontRight();
//          strobepreset_back = 0;
//          myDMX.stopStrobe_Back();
//        }
//      }
    }
  }
}

public void unloadDMXAnimation_strobe() {
  //Note off for the DMX animation, kill the DMX animation by switching everything back to a blackout
  dmxAutomaticControl = false;
  dmxAnimationNumber_strobe = 1;
  dmxAnim_strobe_blackout();
}

public void unloadDMXAnimation_par() {
  //Note off for the DMX animation, kill the DMX animation by switching everything back to a blackout
  dmxAutomaticControl = false;
  dmxAnimationNumber_par = 1;
  dmxAnim_par_blackout();
}

public void unloadDMXAnimation_movingHead() {
  //Note off for the DMX animation, kill the DMX animation by switching everything back to a blackout
  dmxAutomaticControl = false;
  dmxAnimationNumber_movingHead_setAnimation = 0;
  dmxAnim_movingHead_blackout();
}

public void p1LeftStop(int channel, int pitch, int velocity) {          //Pitch == 0
  command_p1_left = false;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P1_LEFT_STOP");
}

public void p1RightStop(int channel, int pitch, int velocity) {         //Pitch == 2
  command_p1_right = false;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P1_RIGHT_STOP");
}

public void p2LeftStop(int channel, int pitch, int velocity) {          //Pitch == 23
  command_p2_left = false;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P2_LEFT_STOP");
}

public void p2RightStop(int channel, int pitch, int velocity) {         //Pitch == 24
  command_p2_right = false;
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : P2_RIGHT_STOP");
}


public void deactivateKillLedPanel(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : DEACTIVATE_KILL_LEDPANEL");
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setKillLedPanel = false;
  }
  if (authorizeKillLedPanelManualMode == true) {
    setKillLedPanelManualMode = false;
  }
}


public void deactivatePadStrobe4th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : DEACTIVATE_PAD_STROBE_4TH");
  
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode4th = false;
    frameRate(registeredTempo);
    stroboAutoPadNoteOff = false;
  }
  if (authorizeStrobeManualMode4th == true) {
    if (authorizePanelStrobe == true) {
      frameRate(registeredTempo);
    }
    if (authorizeDMXStrobe == true) {
      //TBIL - needs to be redone once the new DMX implementation is complete
//      if ((setStrobeManualMode8th == true || setStrobeManualMode16th == true || setStrobeManualMode32nd == true || setStrobeManualMode64th == true) == false) {
//        drawStrobe_FrontLeft = previousFrontLeftStrobeState;
//        strobepreset_frontleft = previousFrontLeftStrobePreset;
//        drawStrobe_FrontRight = previousFrontRightStrobeState;
//        strobepreset_frontright = previousFrontRightStrobePreset;
//        
//        if (drawStrobe_FrontLeft == 0 || drawStrobe_FrontRight == 0) {
//          drawStrobe_FrontLeft  = 0;
//          drawStrobe_FrontRight = 0;
//          stopStrobe_FrontLeft();
//          stopStrobe_FrontRight();
//        }
//        else {
//          startStrobe_FrontRight(strobepreset_frontright);
//          startStrobe_FrontLeft(strobepreset_frontleft);
//        }
//      }
    }
    setStrobeManualMode4th = false;
  }
}

public void deactivatePadStrobe8th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : DEACTIVATE_PAD_STROBE_8TH");
  
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode8th = false;
    frameRate(registeredTempo);
    stroboAutoPadNoteOff = false;
  }
  if (authorizeStrobeManualMode8th == true) {
    if (authorizePanelStrobe == true) {
      frameRate(registeredTempo);
    }
    if (authorizeDMXStrobe == true) {
      //TBIL - needs to be redone once the new DMX implementation is complete
//      if ((setStrobeManualMode4th == true || setStrobeManualMode16th == true || setStrobeManualMode32nd == true || setStrobeManualMode64th == true) == false) {
//        drawStrobe_FrontRight = previousFrontRightStrobeState;
//        strobepreset_frontright = previousFrontRightStrobePreset;
//        drawStrobe_FrontLeft = previousFrontLeftStrobeState;
//        strobepreset_frontleft = previousFrontLeftStrobePreset;
//        
//        if (drawStrobe_FrontLeft == 0 || drawStrobe_FrontRight == 0) {
//          drawStrobe_FrontLeft  = 0;
//          drawStrobe_FrontRight = 0;
//          stopStrobe_FrontLeft();
//          stopStrobe_FrontRight();
//        }
//        else {
//          startStrobe_FrontRight(strobepreset_frontright);
//          startStrobe_FrontLeft(strobepreset_frontleft);
//        }
//      }
    }
    setStrobeManualMode8th = false;
  }
}

public void deactivatePadStrobe16th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : DEACTIVATE_PAD_STROBE_16TH");
  
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode16th = false;
    frameRate(registeredTempo);
    stroboAutoPadNoteOff = false;
  }
  if (authorizeStrobeManualMode16th == true) {
    if (authorizePanelStrobe == true) {
      frameRate(registeredTempo);
    }
    if (authorizeDMXStrobe == true) {
      //TBIL - needs to be redone once the new DMX implementation is complete
//      if ((setStrobeManualMode4th == true || setStrobeManualMode8th == true || setStrobeManualMode32nd == true || setStrobeManualMode64th == true) == false) {
//        drawStrobe_FrontLeft = previousFrontLeftStrobeState;
//        strobepreset_frontleft = previousFrontLeftStrobePreset;
//        drawStrobe_FrontRight = previousFrontRightStrobeState;
//        strobepreset_frontright = previousFrontRightStrobePreset;
//        
//        if (drawStrobe_FrontLeft == 0 || drawStrobe_FrontRight == 0) {
//          drawStrobe_FrontLeft  = 0;
//          drawStrobe_FrontRight = 0;
//          stopStrobe_FrontLeft();
//          stopStrobe_FrontRight();
//        }
//        else {
//          startStrobe_FrontRight(strobepreset_frontright);
//          startStrobe_FrontLeft(strobepreset_frontleft);
//        }
//      }
    }
    setStrobeManualMode16th = false;
  }
}

public void deactivatePadStrobe32nd(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : DEACTIVATE_PAD_STROBE_32ND");
  
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode32nd = false;
    frameRate(registeredTempo);
    stroboAutoPadNoteOff = false;
  }
  if (authorizeStrobeManualMode32nd == true) {
    if (authorizePanelStrobe == true) {
      frameRate(registeredTempo);
    }
    if (authorizeDMXStrobe == true) {
      //TBIL - needs to be redone once the new DMX implementation is complete
//      if ((setStrobeManualMode8th == true || setStrobeManualMode16th == true || setStrobeManualMode4th == true || setStrobeManualMode64th == true) == false) {
//        drawStrobe_FrontLeft = previousFrontLeftStrobeState;
//        strobepreset_frontleft = previousFrontLeftStrobePreset;
//        drawStrobe_FrontRight = previousFrontRightStrobeState;
//        strobepreset_frontright = previousFrontRightStrobePreset;
//        
//        if (drawStrobe_FrontLeft == 0 || drawStrobe_FrontRight == 0) {
//          drawStrobe_FrontLeft  = 0;
//          drawStrobe_FrontRight = 0;
//          stopStrobe_FrontLeft();
//          stopStrobe_FrontRight();
//        }
//        else {
//          startStrobe_FrontRight(strobepreset_frontright);
//          startStrobe_FrontLeft(strobepreset_frontleft);
//        }
//      }
    }
    setStrobeManualMode32nd = false;
  }
}

public void deactivatePadStrobe64th(int channel, int pitch, int velocity) {
  //Kept for debug, not necessary in the release version
  //outputLog.println("Note Off received: (Channel, Pitch, Velocity = (" + channel + ", " + pitch + ", " + velocity + ")    -> Corresponding message : DEACTIVATE_PAD_STROBE_64TH");
  
  if (AUTOMATIC_MODE == true) {
    automaticSequencer.setStrobeAutoMode64th = false;
    frameRate(registeredTempo);
    stroboAutoPadNoteOff = false;
  }
  if (authorizeStrobeManualMode32nd == true) {
    if (authorizePanelStrobe == true) {
      frameRate(registeredTempo);
    }
    if (authorizeDMXStrobe == true) {
      //TBIL - needs to be redone once the new DMX implementation is complete
//      if ((setStrobeManualMode8th == true || setStrobeManualMode16th == true || setStrobeManualMode4th == true || setStrobeManualMode32nd == true) == false) {
//        drawStrobe_FrontLeft = previousFrontLeftStrobeState;
//        strobepreset_frontleft = previousFrontLeftStrobePreset;
//        drawStrobe_FrontRight = previousFrontRightStrobeState;
//        strobepreset_frontright = previousFrontRightStrobePreset;
//        drawStrobe_Back = previousBackStrobeState;
//        strobepreset_back = previousBackStrobePreset;
//        
//        if (drawStrobe_FrontLeft == 0 || drawStrobe_FrontRight == 0) {
//          drawStrobe_FrontLeft  = 0;
//          drawStrobe_FrontRight = 0;
//          stopStrobe_FrontLeft();
//          stopStrobe_FrontRight();
//        }
//        else {
//          startStrobe_FrontRight(strobepreset_frontright);
//          startStrobe_FrontLeft(strobepreset_frontleft);
//        }
//        
//        if (drawStrobe_Back == 0) {
//          stopStrobe_Back();
//        }
//        else {
//          startStrobe_Back(strobepreset_back);
//        }
//      }
    }
    setStrobeManualMode64th = false;
  }
}

/////////////////////////////////////////////////
//////////////  CONTROLLER CHANGE  //////////////
/////////////////////////////////////////////////

// Filter CC messages : do not take in more than 1 message every 40 ms
final int DELTA_FILTER_MS = 40;
long lastMillisecond_cc_in = 0;

// Receive a controllerChange  
public void controllerChange(int channel, int number, int value, long timestamp, String bus_name) {
  
  //Special case: a Pong game is currently going on, ignore the time filter, we need to be fast here
  //Also, do not use any effects for this animation
  if (animationnumber == 394) {
    //Player 1 is using the rhythm knob, Player 2 the scene knob
    if (number == CC_RMX_RHYTHM_1) {
        p1KnobControl(value);
      }
      else if (number == CC_RMX_SCENE_1) {
        p2KnobControl(value);
      }
  } 
  
  else if (filterTimeElapsed(lastMillisecond_cc_in) || value == 0 || value == 127) {
    
    lastMillisecond_cc_in = System.currentTimeMillis();
    
    if (bus_name == myPioneerControllerBus.getBusName()) {
      processCCInfo_RMX500(channel, number, value);
    }
    
    if (bus_name == myControllerBus.getBusName() || bus_name == myKeyboardBus.getBusName() || bus_name == myMainBus.getBusName()) {    //Filter the panic all-notes-off messages sent by non-related devices
      processCCInfo_standardControllers(channel, number, value);
    }
  }
}

public void processCCInfo_RMX500(int channel, int number, int value) {
  switch(number) {
    case CC_RMX_RHYTHM_1:  pionnerRMX_CurrentRhythmFxCCVal = value; break;
    case CC_RMX_RHYTHM_2:  pionnerRMX_CurrentRhythmFxCCVal2 = value; break;
    case CC_RMX_SCENE_1:   pionnerRMX_CurrentSceneFxCCVal = value; break;
    case CC_RMX_SCENE_2:   pionnerRMX_CurrentSceneFxCCVal2 = value; break;
    default:               break;
  }
  if (pionnerRMX_SceneFxOn || pionnerRMX_RhythmFxOn) {
    executeRMXSpecificAnimations();
  }
}

public void processCCInfo_standardControllers(int channel, int number, int value) {
  if (number == PITCH_KNOB_BRIGHTNESS)         {changeBrightness(channel, number, value);}          //Modulation wheel : change global brightness
  else if (number == PITCH_KNOB_BLACKOUT)      {setBlackOutAutoMode(channel, number, value);}       //Low-pass filter knob : blackout
  else if (number == PITCH_KNOB_WHITEOUT)      {setWhiteOutAutoMode(channel, number, value);}       //Hi-pass filter knob : whiteout
  else if (number == PITCH_KNOB_SHREDDER)      {setShredderAutoMode(channel, number, value);}       //Repeat knob : depending on the value, set splitter or shredder on
  else if (number == PITCH_KNOB_COLORCHANGE)   {setColorChangeAutoMode(channel, number, value);}    //Color change : when the phaser is set, tint the screen with a cycling color
  else if (number == PITCH_KNOB_WHITEJAMAMONO) {setWhiteJamaMonoAutoMode(channel, number, value);}  //WhiteJamaMono : when the pitch shift is set, a white rectangle enters the screen
  else if (number == PITCH_KNOB_WHITENOISE)    {setWhiteNoiseAutoMode(channel, number, value);}     //White noise : pixelize the output accordingly to the input value 
}

public void changeBrightness(int channel, int number, int value) {
  //CHANGE_BRIGHTNESS
  //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : CHANGE_BRIGHTNESS");
  brightness = value / 127.0f;
}

public void setBlackOutAutoMode(int channel, int number, int value) {
  if (AUTOMATIC_MODE == true) {
    if (value == 0) {
      automaticSequencer.setBlackOutAutomode = false;
      automaticSequencer.blackoutPower = 0;
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_BLACKOUT_OFF");
    }
    else {
      automaticSequencer.setBlackOutAutomode = true;
      automaticSequencer.blackoutPower = value;
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_BLACKOUT_ON");
    }
  }
  else {
    if (authorizeBlackOutManualMode == true) {
      if (value == 0) {
        setBlackOutManualMode = false;
        blackoutPowerManualMode = 0;
      }
      else {
        setBlackOutManualMode = true;
        blackoutPowerManualMode = value;
      }
    }
  }
}

public void setWhiteOutAutoMode(int channel, int number, int value) {
  if (AUTOMATIC_MODE == true) {
    if (value == 0) {
      automaticSequencer.setWhiteOutAutomode = false;
      automaticSequencer.whiteoutPower = 0;
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_WHITEOUT_OFF");
    }
    else {
      automaticSequencer.setWhiteOutAutomode = true;
      automaticSequencer.whiteoutPower = value;
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_WHITEOUT_ON");
    }
  }
  else {
    if (authorizeWhiteOutManualMode == true) {
      if (value == 0) {
        setWhiteOutManualMode = false;
        whiteoutPowerManualMode = 0;
      }
      else {
        setWhiteOutManualMode = true;
        whiteoutPowerManualMode = value;
      }
    }
  }
}

public void setShredderAutoMode(int channel, int number, int value) {
  if (AUTOMATIC_MODE == true) {
    if (value == 0) {
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_SHREDDER_OFF");
      
      //The shredder was active : the animation needs to be reinitialised
      if (automaticSequencer.setShredderAutoMode == true) {
        specificActions();
      }
      
      automaticSequencer.setShredderAutoMode = false; 
      automaticSequencer.shredderPower = 0;
    }
    else {
      automaticSequencer.setShredderAutoMode = true; 
      automaticSequencer.shredderPower = value;
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_SHREDDER_ON");
    }
  }
  else {
    if (authorizeShredderManualMode == true) {
      if (value == 0) {
        setShredderManualMode = false;
        shredderPowerManualMode = 0;
        //Reinit
        specificActions();
      }
      else {
        setShredderManualMode = true;
        shredderPowerManualMode = value;
      }
    }
  }
}


public void setColorChangeAutoMode(int channel, int number, int value) {
  if (AUTOMATIC_MODE == true) {
    if (value == 0) {
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_COLORCHANGE_OFF");
      automaticSequencer.setColorChangeAutoMode = false;
      automaticSequencer.colorChangePower = 0;
    }
    else {
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_COLORCHANGE_ON");
      automaticSequencer.setColorChangeAutoMode = true;
      automaticSequencer.colorChangePower = value;
    }
  }
  else {
    if (authorizeColorChangeManualMode == true) {
      if (value == 0) {
        setColorChangeManualMode = false;
        colorChangePowerManualMode = 0;
      }
      else {
        setColorChangeManualMode = true;
        colorChangePowerManualMode = value;
      }
    }
  }
}

public void setWhiteJamaMonoAutoMode(int channel, int number, int value) {
  if (AUTOMATIC_MODE == true) {
    if (value == 0) {
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_WHITEJAMAMONO_OFF");
      automaticSequencer.setWhiteJamaMonoAutoMode = false;
      automaticSequencer.whiteJamaMonoPower = 0;
    }
    else {
      //outputLog.println("Note On received: (Channel, Number, Value = (" + channel + ", " + number + ", " + value + ")    -> Corresponding message : SET_WHITEJAMAMONO_ON");
      automaticSequencer.setWhiteJamaMonoAutoMode = true;
      automaticSequencer.whiteJamaMonoPower = value;
    }
  }
  else {
    if (authorizeWhiteJamaMonoManualMode == true) {
      if (value == 0) {
        setWhiteJamaMonoManualMode = false;
        whiteJamaMonoPowerManualMode = 0;
      }
      else {
        setWhiteJamaMonoManualMode = true;
        whiteJamaMonoPowerManualMode = value;
      }
    }
  }
}

public void setWhiteNoiseAutoMode(int channel, int number, int value) {
  if (authorizeWhiteNoiseManualMode == true) {
    if (value == 0) {
      setWhiteNoiseManualMode = false;
      whiteNoisePowerManualMode = 0;
    }
    else {
      setWhiteNoiseManualMode = true;
      whiteNoisePowerManualMode = value;
    }
  }

}


/////////////////////////////////////////////////
/////////////  FILTER TOOL FUNCTION  ////////////
/////////////////////////////////////////////////

public boolean filterTimeElapsed(long lastTimeStamp) {
  long delta = System.currentTimeMillis() - lastTimeStamp;
  if (delta > DELTA_FILTER_MS) {
    return true;
  }
  else {
    return false;
  }
}


////////////////////////////////////////////
// ENABLE / DISABLE ADDITIONAL MIDI INPUT //
////////////////////////////////////////////

public void disableManualInput(){
  authorizeStrobeManualMode4th     = false;
  authorizeStrobeManualMode8th     = false;
  authorizeStrobeManualMode16th    = false;
  authorizeStrobeManualMode32nd    = false;
  authorizeStrobeManualMode64th    = false;
  authorizeColorChangeManualMode   = false;
  authorizeWhiteJamaMonoManualMode = false;
  authorizeWhiteNoiseManualMode    = true;
  authorizeRMXControl              = false;
}

public void enableManualInput(){
  authorizeStrobeManualMode4th     = true;
  authorizeStrobeManualMode8th     = true;
  authorizeStrobeManualMode16th    = true;
  authorizeStrobeManualMode32nd    = true;
  authorizeStrobeManualMode64th    = true;
  authorizeColorChangeManualMode   = true;
  authorizeWhiteJamaMonoManualMode = false;
  authorizeWhiteNoiseManualMode    = true;
  authorizeRMXControl              = true;
}

///////////////////////////////////////////////////////////////////////
/// Read MIDI files at startup, and build a base of auto animations ///
///////////////////////////////////////////////////////////////////////








//java.io.File is needed by these functions, but it's already imported in Configuration

final int NOTE_ON = 0x90;
final int NOTE_OFF = 0x80;
final float ONE_BAR_LENGTH = 384.0f;      //Length of 1 bar, in MIDI ticks - in float, as this is often used as a division denominator
//For the following note off events, an action is allowed
final int[] AVAILABLE_NOTE_OFF = {PITCH_DMX_ANIMATION_STROBE, PITCH_DMX_ANIMATION_PAR, 
                                  PITCH_DMX_ANIMATION_MOVING_HEAD_INIT_DIRECTION, PITCH_DMX_ANIMATION_MOVING_HEAD_SET_COLOR, PITCH_DMX_ANIMATION_MOVING_HEAD_SET_LIGHT_STYLE, 
                                  PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_1, PITCH_DMX_ANIMATION_MOVING_HEAD_SET_ANIMATION_2,
                                  PITCH_DISPLAY_EFFECT};


ArrayList<MidiSequence> MidiSequences_White_DefaultIntensity;
ArrayList<MidiSequence> MidiSequences_White_LowIntensity;
ArrayList<MidiSequence> MidiSequences_White_MediumIntensity;
ArrayList<MidiSequence> MidiSequences_White_HighIntensity;
ArrayList<MidiSequence> MidiSequences_White_MaxIntensity;

ArrayList<MidiSequence> MidiSequences_Red_DefaultIntensity;
ArrayList<MidiSequence> MidiSequences_Red_LowIntensity;
ArrayList<MidiSequence> MidiSequences_Red_MediumIntensity;
ArrayList<MidiSequence> MidiSequences_Red_HighIntensity;
ArrayList<MidiSequence> MidiSequences_Red_MaxIntensity;

ArrayList<MidiSequence> MidiSequences_Colorful_DefaultIntensity;
ArrayList<MidiSequence> MidiSequences_Colorful_LowIntensity;
ArrayList<MidiSequence> MidiSequences_Colorful_MediumIntensity;
ArrayList<MidiSequence> MidiSequences_Colorful_HighIntensity;
ArrayList<MidiSequence> MidiSequences_Colorful_MaxIntensity;

ArrayList<MidiSequence> MidiSequences_Devices_DefaultIntensity;
ArrayList<MidiSequence> MidiSequences_Devices_LowIntensity;
ArrayList<MidiSequence> MidiSequences_Devices_MediumIntensity;
ArrayList<MidiSequence> MidiSequences_Devices_HighIntensity;
ArrayList<MidiSequence> MidiSequences_Devices_MaxIntensity;

// Check in the data folder all the MIDI files available, and parse them
public void parseAllAvailableMidiClips() {
  
  String[] colorDirectories   = { "Panels/White", "Panels/Red", "Panels/Colorful", "DMX & Custom Devices"};
  String[] directoriesToParse = { "Default Intensity", "Low Intensity", "Medium Intensity", "High Intensity", "Max Intensity" };
  
  MidiSequences_White_DefaultIntensity    = new ArrayList<MidiSequence>();
  MidiSequences_White_LowIntensity        = new ArrayList<MidiSequence>();
  MidiSequences_White_MediumIntensity     = new ArrayList<MidiSequence>();
  MidiSequences_White_HighIntensity       = new ArrayList<MidiSequence>();
  MidiSequences_White_MaxIntensity        = new ArrayList<MidiSequence>();
  MidiSequences_Red_DefaultIntensity      = new ArrayList<MidiSequence>();
  MidiSequences_Red_LowIntensity          = new ArrayList<MidiSequence>();
  MidiSequences_Red_MediumIntensity       = new ArrayList<MidiSequence>();
  MidiSequences_Red_HighIntensity         = new ArrayList<MidiSequence>();
  MidiSequences_Red_MaxIntensity          = new ArrayList<MidiSequence>();
  MidiSequences_Colorful_DefaultIntensity = new ArrayList<MidiSequence>();
  MidiSequences_Colorful_LowIntensity     = new ArrayList<MidiSequence>();
  MidiSequences_Colorful_MediumIntensity  = new ArrayList<MidiSequence>();
  MidiSequences_Colorful_HighIntensity    = new ArrayList<MidiSequence>();
  MidiSequences_Colorful_MaxIntensity     = new ArrayList<MidiSequence>();
  MidiSequences_Devices_DefaultIntensity  = new ArrayList<MidiSequence>();
  MidiSequences_Devices_LowIntensity      = new ArrayList<MidiSequence>();
  MidiSequences_Devices_MediumIntensity   = new ArrayList<MidiSequence>();
  MidiSequences_Devices_HighIntensity     = new ArrayList<MidiSequence>();
  MidiSequences_Devices_MaxIntensity      = new ArrayList<MidiSequence>();
  
  //Parse all data folders, and create MidiSequence objects
  
  for (String colorDirectory: colorDirectories) {
    for (String directoryToParse: directoriesToParse) {
      
      try {
        String fullDirectoryPath = dataPath("") + "/MIDI/" + colorDirectory + "/" + directoryToParse;
        File dir = new File(fullDirectoryPath);
        String[] children = dir.list();
        for (String child : children) {
          // Only check for MIDI files, disregard OSX's Finder cookie
          if (child.contains(".mid")) {
            parseMIDISequence(fullDirectoryPath + "/" + child);
          }
        }
      }
      catch (Exception e) {
        outputLog.println("Exception while parsing MIDI clip directories : " + e);
      }
    }
  }
}

public void parseMIDISequence(String filepath) {
    
  try {
    Sequence sequence = MidiSystem.getSequence(new File(filepath));
    int trackNumber = 0;
    for (Track track :  sequence.getTracks()) {
      int endOfTrackTickNumber = 1;
      ArrayList<MidiAction> actionList = new ArrayList<MidiAction>();
      trackNumber++;
      for (int i=0; i < track.size(); i++) {
        MidiEvent event = track.get(i);
        MidiMessage message = event.getMessage();
        
        if (message instanceof ShortMessage) {
          ShortMessage sm = (ShortMessage) message;
          int channel = sm.getChannel();

          if (sm.getCommand() == NOTE_ON) {
            int notePitch = sm.getData1();
            int noteVelocity = sm.getData2();
            MidiAction newEvent = new MidiAction(event.getTick()*4/ONE_BAR_LENGTH, NOTE_ON, notePitch, noteVelocity);        //  Timestamp in pulses-per-quarter-note | Event Type | Action Type | Action Parameter
            actionList.add(newEvent);
          }
          else if (sm.getCommand() == NOTE_OFF) {
            int notePitch = sm.getData1();
            boolean addNoteToActionList = false;
            for (int allowedNote: AVAILABLE_NOTE_OFF) {
              if (notePitch == allowedNote) {
                addNoteToActionList = true;
                break;
              }
            }
            if (addNoteToActionList) {
              int noteVelocity = sm.getData2();
              MidiAction newEvent = new MidiAction(event.getTick()*4/ONE_BAR_LENGTH, NOTE_OFF, notePitch, noteVelocity);      //  Timestamp in pulses-per-quarter-note | Event Type | Action Type | Action Parameter
              actionList.add(newEvent);
            }
          } 
          else { }    //The controller change commands could be used
        }
        else {
          String className = "" + message.getClass();
          if (className.contains("ImmutableEndOfTrack")) {
            endOfTrackTickNumber = (int) event.getTick();
          }          
        }
      }
      
      //Create the MidiSequence object. Length of the animation : MidiSequence's constructor shall round the value to the upper int, all animations should be whole bars
      MidiSequence newSeq = new MidiSequence(endOfTrackTickNumber/ONE_BAR_LENGTH, actionList);
      
      //Add the MidiSequence to the correct list, regarding the MIDI clip's filepath
      //Black and white animations
      if (filepath.contains("Panels/White/")) {
        if (filepath.contains("Default")) {
          MidiSequences_White_DefaultIntensity.add(newSeq);
        }
        else if (filepath.contains("Low")) {
          MidiSequences_White_LowIntensity.add(newSeq);
        }
        else if (filepath.contains("Medium")) {
          MidiSequences_White_MediumIntensity.add(newSeq);
        }
        else if (filepath.contains("High")) {
          MidiSequences_White_HighIntensity.add(newSeq);
        }
        else if (filepath.contains("Max")) {
          MidiSequences_White_MaxIntensity.add(newSeq);
        }
      }
      
      //Red animations (some white can be allowed)
      else if (filepath.contains("Panels/Red/")) {
        if (filepath.contains("Default")) {
          MidiSequences_Red_DefaultIntensity.add(newSeq);
        }
        else if (filepath.contains("Low")) {
          MidiSequences_Red_LowIntensity.add(newSeq);
        }
        else if (filepath.contains("Medium")) {
          MidiSequences_Red_MediumIntensity.add(newSeq);
        }
        else if (filepath.contains("High")) {
          MidiSequences_Red_HighIntensity.add(newSeq);
        }
        else if (filepath.contains("Max")) {
          MidiSequences_Red_MaxIntensity.add(newSeq);
        }
      }
      
      //Colorful animations
      else if (filepath.contains("Panels/Colorful/")) {
        if (filepath.contains("Default")) {
          MidiSequences_Colorful_DefaultIntensity.add(newSeq);
        }
        else if (filepath.contains("Low")) {
          MidiSequences_Colorful_LowIntensity.add(newSeq);
        }
        else if (filepath.contains("Medium")) {
          MidiSequences_Colorful_MediumIntensity.add(newSeq);
        }
        else if (filepath.contains("High")) {
          MidiSequences_Colorful_HighIntensity.add(newSeq);
        }
        else if (filepath.contains("Max")) {
          MidiSequences_Colorful_MaxIntensity.add(newSeq);
        }
      }
      
      //DMX & Custom Devices animations
      else if (filepath.contains("DMX & Custom Devices")) {
        if (filepath.contains("Default")) {
          MidiSequences_Devices_DefaultIntensity.add(newSeq);
        }
        else if (filepath.contains("Low")) {
          MidiSequences_Devices_LowIntensity.add(newSeq);
        }
        else if (filepath.contains("Medium")) {
          MidiSequences_Devices_MediumIntensity.add(newSeq);
        }
        else if (filepath.contains("High")) {
          MidiSequences_Devices_HighIntensity.add(newSeq);
        }
        else if (filepath.contains("Max")) {
          MidiSequences_Devices_MaxIntensity.add(newSeq);
        }
      }
    }
  }
  catch (Exception e) 
  {
    outputLog.println("Exception when parsing AutoMode MIDI file " + filepath + " : " + e);
  }
}

//Sequence created by a single MIDI clip
class MidiSequence {
  float lengthInBars;                 //Number of bars the sequence will last, in bars - rounded to the nearest upper value, all sequences are full bars
  ArrayList<MidiAction> actionBank;   //List of the actions contained in this clip, organized in [MIDI Tick #, Action, Argument], ID card of this sequence
  ArrayList<MidiAction> actionQueue;  //List of the actions consumed by the sequencer, updated either when the sequence is read, or when an action is executed 
  
  MidiSequence(float _length, ArrayList<MidiAction> _actions) {
    lengthInBars = ceil(_length);
    actionBank   = _actions;
    initActions();
    outputLog.println(this.toString());
  }
  
  public void initActions() {
    actionQueue = (ArrayList<MidiAction>) actionBank.clone();
  }
  
  //Non-javadoc toString method for MidiSequence objects
  public String toString() {
    String temp = "";
    for (MidiAction action: actionBank) {
      temp += action.timestamp + "->" + action.actionType + "|" + action.actionVal + ", ";
    }
    //Remove the useless ", " at the end of the temp string
    if (temp.length() > 2) {
      temp = temp.substring(0, temp.length()-2);
    }
    return "Registered MIDI clip : Animation length =" + lengthInBars + " bars ||| Sequenced actions : " + temp;
  }
}

//Single MIDI action
class MidiAction {
  
  float timestamp;    //In pulses per quarter note, the MIDI timestamp when the action should be executed
  int eventType;      //Note on, or Note off
  int actionType;     //Which action should be executed ("load animation bank 1", "display an image", ...)
  int actionVal;      //The argument to feed the action function
  
  //Timestamp in pulses-per-quarter-note | Action Type | Action Parameter
  MidiAction(float _timestamp, int _eventType, int _actionType, int _actionVal) {
    timestamp  = _timestamp;
    eventType  = _eventType;
    actionType = _actionType;
    actionVal  = _actionVal;
  }
  
}

//////////////////////////////////////////////////////////////////
// Output - this file contains all the different output objects //
// The only ones which can be instanciated are currently TPM2 & //
// Null, a future update will include DMX and ArtNet protocols  //
//////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// Parent output class - abstract, shall not be instanciated //
///////////////////////////////////////////////////////////////


//Supported devices :
//TODO : add more devices
String TPM2 = "TPM2";
String NULL = "NULL";

public abstract class Output {

  // The outputDevice - as a string, for example "TPM2"
  public String outputDevice;
          
  //Bits per pixel
  protected int bpp;
                  
  //Gamma configuration for color correction
  public String gammaType;  
  
  //Snake cabling : is each line to be flipped or not
  public boolean snakeCabling;
  
  //Is the device initialized ?
  public boolean initialized = false;
  
  //Constructor : instanciate a new output
  public Output(String outputDevice, int bpp) {
      this.outputDevice = outputDevice;                
      this.bpp = bpp;
      this.gammaType = panelGamma;
      this.snakeCabling = false;
  }
  

  
  //Update the output device - specific for each device, to be overridden
  public abstract void update();

  //Close to output device
  public abstract void close(); 

  //Non-javadoc toString method for Output objects
  public String toString() {
          return outputDevice;
  }

  
  //If the specific device supports a connection status, overwrite me.
  //Examples: connected to /dev/aaa or IP Adress: 1.2.3.4
  public String getConnectionStatus() {
      return "";
  }

  //Return BPP (bits per pixel)
  public int getBpp() {
          return bpp;
  }
  
  // Get the type : TPM2, DMX...
  public String getType() {
          return outputDevice;
  }

  // Return the gammaType
  public String getGammaType() {
      return gammaType;
  }                
}


/////////////////////////////////////////////////////////
// Pixel buffering functions - used for the LED panels //
/////////////////////////////////////////////////////////

public int[] getpartialscreenbuffer(int stringnumber) {
  return pixelsPanels[stringnumber];
}

public void update_buffer() {
  
  //loadPixels allows to fill the pixels buffer with the contents of the frame currently displayed
  //Trying to access the pixels array without calling loadPixels will result in a NullPointerException !
  loadPixels();  
  
  
  //TODO : optimize the memory accesses by not using these temporary variables to fill the buffers 

  int[] device_i = new int[NUMBER_OF_PANELS];
  for (int o=0; o<NUMBER_OF_PANELS; o++) {
    device_i[o] = 0;
  }
  
  for (int i = 0; i < (width*height); i++) {
    for (int threshold = 0; threshold<NUMBER_OF_PANELS; threshold++) {
      if ((i%width)<(threshold+1)*width/NUMBER_OF_PANELS){
        pixelsPanels[threshold][device_i[threshold]++] = pixels[i];
        break;
      }
    }      
  }
}

//Get the actual data buffer for a specific panel (still as an int[], array of
//all the pixels for this device), and apply brightness and gamma correction
public int[] getBufferForScreen(int screenNr, boolean applyGamma) {
  
  //gamma/brightness correct buffer
  int[] buffer = getpartialscreenbuffer(screenNr);
  
  //Resize buffer - using the resize object created during setup()
  if (RESIZE_OPTION == QUALITY) { 
    buffer = qualityResize.getBuffer(buffer, PANEL_RESOLUTION_X, PANEL_RESOLUTION_Y, PIXELS_X/NUMBER_OF_PANELS, PIXELS_Y);
  }
  else if (RESIZE_OPTION == SPEED) {
    buffer = pixelResize.getBuffer(buffer, PANEL_RESOLUTION_X, PANEL_RESOLUTION_Y, PIXELS_X/NUMBER_OF_PANELS, PIXELS_Y);
  }
  
  //return buffer;
  return applyBrightnessAndGammaTab(buffer, panelGamma, brightness);
}

public void getNewTransformedBuffersLEDPanels() {
  for (int i= 0; i<transformedBuffersLEDPanels.length;i++) {
    transformedBuffersLEDPanels[i] = transformImage(getBufferForScreen(i, true), "NO_ROTATE", PANEL_RESOLUTION_X, PANEL_RESOLUTION_Y);
  } 
}




////////////////////////////////////////////////////////////////////
/// Create a custom (different from 8x8) resolution panel output ///
/// Abstract class : shall not be instanciated, is used only as  ///
///  a father class to more specific devices (ie, TPM2 or DMX )  ///
////////////////////////////////////////////////////////////////////

public abstract class OnePanelResolutionAwareOutput extends Output {

    protected int xResolution;
    protected int yResolution;
    protected String colorFormat;   //Color format : RGB, BGR, RBG...
    protected int[] mapping;        //Manual mapping for the device

    // Constructor
    // Parameters : Outputdevice (for TPM2, "TPM2"), bpp (bits per pixel, 8 in most cases)
    public OnePanelResolutionAwareOutput(String outputDevice, int bpp) {
      super(outputDevice, bpp);
            
      this.xResolution = PANEL_RESOLUTION_X;
      this.yResolution = PANEL_RESOLUTION_Y;
      this.mapping = getOutputMappingValues();       
      this.colorFormat = LED_COLOR_FORMAT;
      this.snakeCabling = false;
    }
}

//Get the manual mapping (global variable declared in Strobot.pde)
//Warn in case of invalid manual mapping
public int[] getOutputMappingValues() {            

  if (MANUAL_MAPPING.length != PANEL_RESOLUTION_X * PANEL_RESOLUTION_Y) {
    outputLog.println("!!!!!!!-----------------------------------------!!!!!!");
    outputLog.println("!!!Possible error on the manual mapping parameter : table size != PANEL_RESOLUTION_X * PANEL_RESOLUTION_Y!!!");
    outputLog.println("!!!Manual mapping table size : " + MANUAL_MAPPING.length + "!!!");
    outputLog.println("!!!PANEL_RESOLUTION_X * PANEL_RESOLUTION_Y : " + str(PANEL_RESOLUTION_X * PANEL_RESOLUTION_Y) + "!!!"); 
    outputLog.println("!!!!!!!-----------------------------------------!!!!!!");
  }
  return MANUAL_MAPPING;
}



/////////////////////////////////////////////////////////////////////////////////////////
/// TPM2 Output Class - Send data to a TPM2 device (protocol created by ledstyles.de) ///
/////////////////////////////////////////////////////////////////////////////////////////


public class Tpm2 extends OnePanelResolutionAwareOutput {
                        
    private static final String VERSION = "1.1";

    private Tpm2Serial tpm2;
    
    private int panelNumber;
    private String serialPort;
    
    //The panel device will actually output
    public int mappingPanel;
    
    public Tpm2(int panelnumber) {
            super(TPM2, 8);

            int baud = COM_BAUD_RATE;
            this.snakeCabling = false;
            this.panelNumber = panelnumber;
            
            //HINT: on windows you need to (for example) use COM1, com1 will not work! (case sensitive)
            //String serialPort = OutputHelper.getSerialPortName(ph.getTpm2Device().toUpperCase());
            serialPort = getSerialPortName(TEENSY_SERIAL_PORT_LIST_5[panelnumber]);      //Initialize it to a possible value
            if (NUMBER_OF_PANELS == 3) {
              serialPort = getSerialPortName(TEENSY_SERIAL_PORT_LIST_3[panelnumber]);
            }
            else if (NUMBER_OF_PANELS == 5) {
              serialPort = getSerialPortName(TEENSY_SERIAL_PORT_LIST_5[panelnumber]);
            }
            //outputLog.println("--------DEBUG ! Checking serialPort : " + serialPort); 
            this.initialized = false;
            try {
                    tpm2 = new Tpm2Serial(serialPort, PANEL_RESOLUTION_X*PANEL_RESOLUTION_Y, baud);
                    this.initialized = true;
                    outputLog.println("Initialized TPM2 serial device v" + VERSION + " , target port: " + serialPort + ", Resolution: " + PANEL_RESOLUTION_X + "/" + PANEL_RESOLUTION_Y);
                    
            } catch (NoSerialPortFoundException e) {
                    outputLog.println("Error !!! Failed to initialize serial port! " + e);
            }
    }
    

    //Non Javadoc update
    //Send data to the TPM2 device
    public void update() {                
      if (initialized) {                                        
        byte[] rgbBuffer = convertBufferTo24bit(getTransformedBuffer(), colorFormat);
        //outputLog.println(rgbBuffer);
        if (rgbBuffer.length < 511) {
            //small frame, fit in one packed
            //this will always be the case with our 128 LED panels : a single packet can fit 512 bytes, amounting to 170 LED.
            tpm2.sendFrame(createImagePayload(0,1,rgbBuffer));                                
        } else {
            //need to splitup buffers                                
            int bytesToSend = rgbBuffer.length;
            int currentUniverse = 0;
            int totalUniverse = (int)((bytesToSend/510f))+1;
            while (currentUniverse < totalUniverse) 
            { 
                int l = bytesToSend - 510*currentUniverse;
                if (l>510) l=510;
                byte[] tmp = new byte[l];
                
                System.arraycopy(rgbBuffer, 510*currentUniverse, tmp, 0, l);
                tpm2.sendFrame(createImagePayload(currentUniverse, totalUniverse, tmp));
                                                        
                currentUniverse++;
            }
        }
      }
    }
    

    
    //Transform the buffer (get a resized buffer, if necessary rotated, if necessary with a flipped 2nd scanline)
    public int[] getTransformedBuffer() {

          int[] transformedBuffer = transformedBuffersLEDPanels[this.panelNumber];
                    
          if (this.snakeCabling) {
              //flip each 2nd scanline
              transformedBuffer = flipSecondScanline(transformedBuffer, xResolution, yResolution);
          } else if (this.mapping.length>0) {
              //do manual mapping
              transformedBuffer = manualMapping(transformedBuffer, this.mapping, xResolution, yResolution);
          }
          return transformedBuffer;
    }
            
    //Non-Javadoc close
    @Override
    public void close() {
      if (initialized) {
          tpm2.dispose();
      }
    }



    //Convert internal buffer to 24bit byte buffer, using color format
    public byte[] convertBufferTo24bit(int[] data, String colorFormat) throws IllegalArgumentException {
      int targetBuffersize = data.length;
      
      int[] r = new int[targetBuffersize];
      int[] g = new int[targetBuffersize];
      int[] b = new int[targetBuffersize];
  
      splitUpBuffers(targetBuffersize, data, colorFormat, r, g, b);
  
      int ofs=0;
      byte[] buffer = new byte[targetBuffersize*3];
      for (int i=0; i<targetBuffersize; i++) {
        buffer[ofs] = (byte)r[i];
        ofs++;
        buffer[ofs] = (byte)g[i];
        ofs++;
        buffer[ofs] = (byte)b[i];
        ofs++;
      }
      
      return buffer;
    }

    //Read data sent by the microcontroller - usually for debug only
    public void readDebugData() {
      while (tpm2.port.available() > 0) {
        String inBuffer = tpm2.port.readString();   
        if (inBuffer != null) {
          println(inBuffer);
        }
      }      
    }

}

//////////////////////////////////////////////////////////////
//No device configured : useful for debugging the animations//
//or executing the Processing without the microcontrollers  //
//////////////////////////////////////////////////////////////

public class NullDevice extends Output {

    /**
     * init the null devices.
     *
     * @param controller the controller
     */
    public NullDevice() {
        super(NULL, 8);
    }


    public void update() {
        //nothing todo
    }


    @Override
    public void close() {
        //nothing todo
    }

    @Override
    public String getConnectionStatus(){
        return "Connected on port NULL";            
    }

}

//////////////////////////////////////////////////////////////////////////////////////////
// Output Helper Class - Contains some common helper methods used by the output devices //
//////////////////////////////////////////////////////////////////////////////////////////


//import processing.serial.Serial;

//Cannot name the regular RGB as RGB : Processing already uses a global variable called RGB
String Regular_RGB = "RGB";
String RBG = "RBG";
String BRG = "BRG";
String BGR = "BGR";
String GBR = "GBR";
String GRB = "GRB";
 

//this function feeds the framebufferdata (32 pixels a 2bytes (aka 16bit)
//to the send array. each second scanline gets inverted
public int[] flipSecondScanline(int buffer[], int xResolution, int yResolution) {
    int bufferTwo[] = buffer.clone();

    for (int y=0; y<yResolution; y++) {
            if (y%2==1) {
                    int ofs = y*xResolution;
                    for (int x=0; x<xResolution; x++) {
                            bufferTwo[ofs+x] = buffer[xResolution+ofs-x-1];
                    }
            }
    }                
    return bufferTwo;
}

//Reorder the buffer according to the manual mapping, this is used to support more exotic device configurations
public int[] manualMapping(int src[], int mapping[], int xResolution, int yResolution) {
    int bufferTwo[] = src.clone();
    int lenght = src.length;
    int ofs=0;
    for (int i: mapping) {
            if (i+1>lenght) {
                    outputLog.println("Your manual mapping is wrong,the first index is 0! Invalid entry index: " + i);
            } else {
                    bufferTwo[ofs++] = src[i];                                 
            }
    }
    return bufferTwo;
}



// Convert buffer to 15bit - used for some particular LED IC chips
public byte[] convertBufferTo15bit(int[] data, String colorFormat) throws IllegalArgumentException {
    int targetBuffersize = data.length;

    int[] r = new int[targetBuffersize];
    int[] g = new int[targetBuffersize];
    int[] b = new int[targetBuffersize];

    splitUpBuffers(targetBuffersize, data, colorFormat, r, g, b);

    int ofs=0;
    byte[] converted = new byte[targetBuffersize*2];

    //convert to 24bpp to 15(16)bpp output format: RRRRRGGG GGGBBBBB (64x)
    for (int i=0; i<targetBuffersize;i++) {
      byte b1 = (byte)(r[i]>>3);
      byte b2 = (byte)(g[i]>>3);
      byte b3 = (byte)(b[i]>>3);

      converted[ofs] = (byte)((b1<<2) | (b2>>3));
      ofs++;
      converted[ofs] = (byte)(((b2&7)<<5) | b3);
      ofs++;
    }

    return converted;                
}

        

// convert the int buffer in byte buffers, respecting the color order
private void splitUpBuffers(int targetBuffersize, int[] data, String colorFormat, int[] r, int[] g, int[] b) {
    int ofs = 0;
    int tmp;
    
    for (int n=0; n<targetBuffersize; n++) {
        //one int contains the rgb color
        tmp = data[ofs];

        if (colorFormat == Regular_RGB) {
            r[ofs] = (int) ((tmp>>16) & 255);
            g[ofs] = (int) ((tmp>>8)  & 255);
            b[ofs] = (int) ( tmp      & 255);                       
        }
        else if (colorFormat == RBG) {
            r[ofs] = (int) ((tmp>>16) & 255);
            b[ofs] = (int) ((tmp>>8)  & 255);
            g[ofs] = (int) ( tmp      & 255);                       
        }
        else if (colorFormat == BRG) {
            b[ofs] = (int) ((tmp>>16) & 255);
            r[ofs] = (int) ((tmp>>8)  & 255);
            g[ofs] = (int) ( tmp      & 255);
        }
        else if (colorFormat == BGR) {
            b[ofs] = (int) ((tmp>>16) & 255);
            g[ofs] = (int) ((tmp>>8)  & 255);
            r[ofs] = (int) ( tmp      & 255);
        }
        else if (colorFormat == GBR) {
            g[ofs] = (int) ((tmp>>16) & 255);
            b[ofs] = (int) ((tmp>>8)  & 255);
            r[ofs] = (int) ( tmp      & 255);
        }
        else if (colorFormat == GRB) {
            g[ofs] = (int) ((tmp>>16) & 255);
            r[ofs] = (int) ((tmp>>8)  & 255);
            b[ofs] = (int) ( tmp      & 255);
        }
        ofs++;
    }       
}
    

//Get the serial port name - try to find it inside the Serial.list() to be sure
//Important : serial port names are CASE SENSITIVE. On Windows, all names need to be uppercase (ex : COM1)
public String getSerialPortName(String configuredName) {
    for (String portName: Serial.list()) {
        if (portName.toUpperCase().equals(configuredName.toUpperCase())) {
            outputLog.println(portName + " - Device detected correctly");
            return portName;
        }
    }
    
    //we didn't find the port, hope that the provided name will work...
    outputLog.println(configuredName + " - Device was not detected in the serial devices list, the output might not work correctly !");
    return configuredName;
}



/**
 * Rotate90.
 *
 * @param buffer the buffer
 * @param deviceXSize the device x size
 * @param deviceYSize the device y size
 * @return the int[]
 */
private static int[] rotate90(int[] buffer, int deviceXSize, int deviceYSize) {
  int[] ret = new int[deviceXSize*deviceYSize];
  int ofs=0;
  for (int x=0; x<deviceXSize; x++) {      
    for (int y=0; y<deviceYSize; y++) {
      //TODO missing y size?
      ret[deviceXSize*y+deviceXSize-1-x] = buffer[ofs++];
    }
  }
  return ret;
}

/**
 * Flip y.
 *
 * @param buffer the buffer
 * @param deviceXSize the device x size
 * @param deviceYSize the device y size
 * @return the int[]
 */
private static int[] flipY(int[] buffer, int deviceXSize, int deviceYSize) {
  int[] ret = new int[deviceXSize*deviceYSize];
  for (int y=0; y<deviceYSize; y++) {
    int ofsSrc=y*deviceXSize;
    int ofsDst=(deviceYSize-1-y)*deviceXSize;
    for (int x=0; x<deviceXSize; x++) {              
      ret[x+ofsDst] = buffer[x+ofsSrc];
    }
  }
  return ret;
}

/**
 * Rotate180.
 *
 * @param buffer the buffer
 * @param deviceXSize the device x size
 * @param deviceYSize the device y size
 * @return the int[]
 */
private static int[] rotate180(int[] buffer, int deviceXSize, int deviceYSize) {
  int[] ret = new int[deviceXSize*deviceYSize];
  int ofs=0;
  int dst=deviceXSize*deviceYSize-1;
  for (int x=0; x<deviceXSize; x++) {      
    for (int y=0; y<deviceYSize; y++) {
      ret[dst--] = buffer[ofs++];
    }
  }
  return ret;
}

//Rotate by 270\u00b0 the int[] pixel buffer
private static int[] rotate270(int[] buffer, int deviceXSize, int deviceYSize) {

  return rotate180(
      rotate90(buffer, deviceXSize, deviceYSize),
      deviceXSize, deviceYSize);
}

/**
 *
 * @param buffer the buffer
 * @param deviceConfig the device config
 * @param deviceXSize the device size of the matrix
 * @param deviceYSize the device y size
 * @return the int[]
 */
public static int[] transformImage(int[] buffer, String deviceConfig, int deviceXSize, int deviceYSize) {
  if (deviceXSize==0) {
    deviceXSize = PANEL_RESOLUTION_X;
  }
  
  if (deviceConfig == "NO_ROTATE"){
    return buffer;}

  else if (deviceConfig == "ROTATE_90"){
    return rotate90(buffer, deviceXSize, deviceYSize);}  

  else if (deviceConfig == "ROTATE_90_FLIPPEDY"){
    return flipY(
        rotate90(buffer, deviceXSize, deviceYSize), 
        deviceXSize, deviceYSize
    );}

  else if (deviceConfig == "ROTATE_180"){
    return rotate180(buffer, deviceXSize, deviceYSize);}

  else if (deviceConfig == "ROTATE_180_FLIPPEDY"){
    return flipY( 
        rotate180(buffer, deviceXSize, deviceYSize),
        deviceXSize, deviceYSize
    );}

  else if (deviceConfig == "ROTATE_270"){
    return rotate270(buffer, deviceXSize, deviceYSize);}

  else {
    outputLog.println("Error : invalid deviceConfig (rotatedevice)");      
    return null;
    }
  
}

// Set the default screen mapping
public void setDefaultScreenOrderConfiguration() {
  screen_order_configuration = new int[NUMBER_OF_PANELS];
  for (int i=0; i<NUMBER_OF_PANELS; i++) {
    screen_order_configuration[i] = i;
  }
}

///////////////////////////////////////////////////
/// Resize a larger buffer for a smaller buffer ///
///////////////////////////////////////////////////









final String QUALITY = "QUALITY";
final String SPEED = "SPEED";

public static abstract class Resize {
                                      
        public Resize() {
          //No need to do anything in particular to create the object
        }
        
        /**
         * Gets the buffer.
         *
         * @param buffer the buffer
         * @param deviceXSize the device x size
         * @param deviceYSize the device y size
         * @param currentXSize the current x size
         * @param currentYSize the current y size
         * @return the buffer
         */
        public abstract int[] getBuffer(int[] buffer, int deviceXSize, int deviceYSize, int currentXSize, int currentYSize);
        
        /**
         * internal use - get buffer from image.
         *
         * @param scaledImage the scaled image
         * @param deviceXSize the device x size
         * @param deviceYSize the device y size
         * @return the pixels from image
         */
        public int[] getPixelsFromImage(BufferedImage scaledImage, int deviceXSize, int deviceYSize) {
                //painfully slow!
                //return scaledImage.getRGB(0, 0, deviceXSize, deviceYSize, null, 0, deviceXSize);
                DataBufferInt buf = (DataBufferInt) scaledImage.getRaster().getDataBuffer();
                return buf.getData();
        }

        /**
         * Creates the image.
         *
         * @param buffer the buffer
         * @param currentXSize the current x size
         * @param currentYSize the current y size
         * @return the buffered image
         */
        public BufferedImage createImage(int[] buffer, int currentXSize, int currentYSize) {
                BufferedImage bi = new BufferedImage(currentXSize, currentYSize, BufferedImage.TYPE_INT_RGB);
                //bi.setRGB(0, 0, currentXSize, currentYSize, buffer, 0, currentXSize);
                WritableRaster newRaster = bi.getRaster();
                newRaster.setDataElements(0, 0, currentXSize, currentYSize, buffer);
                bi.setData(newRaster);

                return bi;
        }

}




//This resize function is optimized for PixelArt oriented images
public class PixelResize extends Resize {

    //Instantiates a new pixel resize
    public PixelResize() {
            super();
    }
    

    //Get an image buffer (int[]), create a temp image, scale it with by prioritizing speed, and return the scaled pixel int[] buffer
    public int[] getBuffer(int[] buffer, int deviceXSize, int deviceYSize, int currentXSize, int currentYSize) {
        BufferedImage bi = createImage(buffer, currentXSize, currentYSize);
        
        bi = ScalrOld.resize(bi, ScalrOld.SPEED, deviceXSize, deviceYSize);
  
        int[] ret = getPixelsFromImage(bi, deviceXSize, deviceYSize);
        
        //Destroy image
        bi.flush();
        
        return ret;
    }
}

//This resize function works more like an area average filter

public class QualityResize extends Resize {

    /**
     * Instantiates a new quality resize.
     *
     * @param controller the controller
     */
    public QualityResize() {
            super();
    }
    
    /* (non-Javadoc)
     * @see com.neophob.sematrix.resize.Resize#getBuffer(int[], int, int, int, int)
     */
    public int[] getBuffer(int[] buffer, int deviceXSize, int deviceYSize, int currentXSize, int currentYSize) {
        BufferedImage bi = createImage(buffer, currentXSize, currentYSize);
       
        bi = ScalrOld.resize(bi, ScalrOld.QUALITY, deviceXSize, deviceYSize);

        int[] ret = getPixelsFromImage(bi, deviceXSize, deviceYSize);

        //Destroy image
        bi.flush();
        
        return ret;
    }
}




public static class ScalrOld {
        
        private ScalrOld() {
                //no instance allowed 
        }
        
        /**
         * Used to define the different scaling hints that the algorithm can prefer.
         */

        /**  ----> Automatic scaling
         * Used to indicate that the scaling implementation should decide which
         * method to use in order to get the best looking scaled image in the
         * least amount of time. When scaling an image down in size, this method
         * takes advantage of the fact that scaling an image to 800px or bigger
         * looks roughly the same whether the SPEED or QUALITY method are used
         * while scaling an image smaller than that needs to be scaled using the
         * QUALITY method in order to keep it looking good. Most users simply
         * looking for a "good" result are meant to use this method.
         */
        static String AUTOMATIC = "AUTOMATIC";
         

        /** ----> Fast scaling
         * Used to indicate that the scaling implementation should scale as fast
         * as possible and return a result. For smaller images (below 800px in
         * size) this can result in noticeable aliasing but it can be a few
         * magnitudes times faster than using the QUALITY method.
         */        
        static String SPEED = "SPEED";


        /** ----> Quality scaling
         * Used to indicate that the scaling implementation should do everything
         * it can to create as nice of a result as possible. This approach is
         * most important for smaller pictures (800px or smaller) and less
         * important for larger pictures as the difference between this method
         * and the SPEED method become less and less noticeable as the
         * source-image size increases. Using the AUTOMATIC method will
         * automatically prefer the QUALITY method when scaling an image down
         * below 800px in size.
         */        
        static String QUALITY = "QUALITY";        

        /**
         * Threshold in pixels (width or height) at which point a scaling operation
         * using the "AUTOMATIC" method will use to decide if an image should use
         * the SPEED method (if bigger than threshold) or the QUALITY method (if
         * smaller than threshold). This was based on A/B testing with images
         * processed with the two algorithms and noticing right around an image size
         * of 800x600 or larger where the difference in quality is negligible when
         * using the more expensive QUALITY method. While this is a relatively
         * arbitrary number (no mathematics to back it up) it should provide a good
         * default in most use-cases. Users that are not seeing the results they
         * need can perform their own pre-calculation and then request either a
         * SPEED or QUALITY scaling approach.
         */
        public static final int AUTOMATIC_THRESHOLD_PX = 800;

        /**
         * Resize a given image (maintaining its proportion) to a width and height
         * of the given target size using the scaling method of
         * {@link Method#AUTOMATIC}.
         * 
         * @param src
         *            The image that will be scaled.
         * @param targetSize
         *            The target width and height (square) that you wish the image
         *            to fit within.
         * 
         * @return the proportionally scaled image with either a width or height of
         *         the given target size.
         * 
         * @throws IllegalArgumentException
         *             if <code>targetSize</code> is &lt; 0.
         */
        public static BufferedImage resize(BufferedImage src, int targetSize)
                        throws IllegalArgumentException {
                return resize(src, AUTOMATIC, targetSize, targetSize);
        }

        /**
         * Resize a given image (maintaining its proportion) to a width and height
         * of the given target size using the given scaling method.
         * 
         * @param src
         *            The image that will be scaled.
         * @param scalingMethod
         *            The method used for scaling the image; preferring speed to
         *            quality or a balance of both.
         * @param targetSize
         *            The target width and height (square) that you wish the image
         *            to fit within.
         * 
         * @return the proportionally scaled image with either a width or height of
         *         the given target size.
         * 
         * @throws IllegalArgumentException
         *             if <code>scalingMethod</code> is <code>null</code> or if
         *             <code>targetSize</code> is &lt; 0.
         */
        public static BufferedImage resize(BufferedImage src, String scalingMethod,
                        int targetSize) throws IllegalArgumentException {
                return resize(src, scalingMethod, targetSize, targetSize);
        }



        /**
         * Resize a given image (maintaining its proportion) to the target width and
         * height using the given scaling method and optionally print out
         * performance and debugging information while doing it.
         * 
         * @param src
         *            The image that will be scaled.
         * @param scalingMethod
         *            The method used for scaling the image; preferring speed to
         *            quality or a balance of both.
         * @param targetWidth
         *            The target width that you wish the image to have.
         * @param targetHeight
         *            The target height that you wish the image to have.
         * @param printDebugInfo
         *            Used to indicate if debugging information should be printed
         *            out during the scaling operation. Can be useful for
         *            troubleshooting.
         * @param printElapseTimes
         *            Used to indicate if performance metrics (elapse times) should
         *            be printed out during the scaling operation.
         * 
         * @return the proportionally scaled image no bigger than the given width
         *         and height.
         * 
         * @throws IllegalArgumentException
         *             if <code>scalingMethod</code> is <code>null</code>, if
         *             <code>targetWidth</code> is &lt; 0 or if
         *             <code>targetHeight</code> is &lt; 0.
         */
        public static BufferedImage resize(BufferedImage src, String scalingMethod,
                        int targetWidth, int targetHeight) throws IllegalArgumentException {
                if (scalingMethod == null)
                        throw new IllegalArgumentException("scalingMethod cannot be null");
                if (targetWidth < 0)
                        throw new IllegalArgumentException("targetWidth must be >= 0");
                if (targetHeight < 0)
                        throw new IllegalArgumentException("targetHeight must be >= 0");

                BufferedImage result = null;

                if (src != null) {
                        int currentWidth = src.getWidth();
                        int currentHeight = src.getHeight();

                        /*
                         * The resize operation has to be constrained by the smallest
                         * dimension (width or height) in order to keep the image
                         * proportional even if the caller passes in bogus w/h values. For
                         * example, trying to scale an image from 1600x1200 to 1600x20. In
                         * order to maintain the correct proportion of the image, the width
                         * of 1600 will have to be corrected for and the height of 20 used
                         * as the primary constraint.
                         */
/*                        

                        I DONT WANT TO USE THAT CODE - the resize does not work as expected.

                         if (targetHeight <= targetWidth) {
                                // Height is smaller or equal to width, so calculate a new width
                                // using the height, maintaining the known ratio.
                                targetWidth = Math.round((float) targetHeight / ratio);

                                if (printDebugInfo)
                                        System.out.println("\tAdjusted targetWidth to "
                                                        + targetWidth
                                                        + " in order to maintain image proportions");
                        } else {
                                // Width is smaller than height, so calculate a new height using
                                // the width, maintaining the known ratio.
                                targetHeight = Math.round((float) targetWidth * ratio);

                                if (printDebugInfo)
                                        System.out.println("\tAdjusted targetHeight to "
                                                        + targetHeight
                                                        + " in order to maintain image proportions");
                        }
*/
                        /*
                         * Using an AUTOMATIC method we look at the image and see if either
                         * of its dimensions are larger than our threshold value we
                         * determined is the cutoff point where the visual difference
                         * between the SPEED method and QUALITY method are negligible at
                         * which point we use the SPEED method instead to save time. If the
                         * width and height are smaller than that value, then we use the
                         * QUALITY method to ensure a good looking picture. In the case of
                         * scaling-up, we never use the Campbell algorithm even if we are
                         * doing a QUALITY scale operation and will instead use a single
                         * BICUBIC interpolation which is much faster than multiple scale
                         * iterations up-wards.
                         */
                        if (scalingMethod == AUTOMATIC) {
                                if (targetWidth < AUTOMATIC_THRESHOLD_PX && targetHeight < AUTOMATIC_THRESHOLD_PX)
                                        scalingMethod = QUALITY;
                                else
                                        scalingMethod = SPEED;
                        }

                        // Now we scale the image
                        if (scalingMethod == SPEED) {
                                result = new BufferedImage(targetWidth, targetHeight,
                                                src.getType());
                                Graphics2D resultGraphics = result.createGraphics();

                                resultGraphics.setRenderingHint(
                                                RenderingHints.KEY_INTERPOLATION,
                                                RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
                                resultGraphics.drawImage(src, 0, 0, targetWidth, targetHeight,
                                                null);
                        } else if (scalingMethod == QUALITY) {
                                /*
                                 * If we are scaling up, directly using a single BICUBIC will
                                 * give us better results then using Chris Campbell's
                                 * incremental scaling operation. If we are scaling down, we
                                 * must use the incremental scaling algorithm for the best
                                 * result.
                                 */
                                if (targetWidth > currentWidth && targetHeight > currentHeight) {
                                        result = new BufferedImage(targetWidth, targetHeight,
                                                        src.getType());
                                        Graphics2D resultGraphics = result.createGraphics();

                                        // BICUBIC gives us the best results when scaling up in a
                                        // single operation.
                                        resultGraphics.setRenderingHint(
                                                        RenderingHints.KEY_INTERPOLATION,
                                                        RenderingHints.VALUE_INTERPOLATION_BICUBIC);
                                        resultGraphics.drawImage(src, 0, 0, targetWidth,
                                                        targetHeight, null);
                                } else {
                                        boolean hasReassignedSrc = false;

                                        /*
                                         * Using Chris Campbell's incremental scaling algorithm:
                                         * http://today.java.net/pub/a/today/2007/04/03/perils
                                         * -of-image-getscaledinstance.html
                                         * 
                                         * NOTE: Modifications to the original algorithm are
                                         * variable names and comments added for clarity and the
                                         * hard-coding of using BICUBIC interpolation as well as the
                                         * explicit "flush()" operation on the interim BufferedImage
                                         * instances to avoid resource leaking.
                                         */
                                        do {
                                                // If the current width is bigger than our target, cut
                                                // it in half and sample again.
                                                if (currentWidth > targetWidth) {
                                                        currentWidth /= 2;

                                                        // If we cut the width too far it means we are on
                                                        // our last sampling step. Just set
                                                        // it to the target width and finish up.
                                                        if (currentWidth < targetWidth)
                                                                currentWidth = targetWidth;
                                                }

                                                // If the current height is bigger than our target, cut
                                                // it in half and sample again.
                                                if (currentHeight > targetHeight) {
                                                        currentHeight /= 2;

                                                        // If we cut the height too far it means we are on
                                                        // our last sampling step. Just set
                                                        // it to the target height and finish up.
                                                        if (currentHeight < targetHeight)
                                                                currentHeight = targetHeight;
                                                }

                                                BufferedImage incrementalImage = new BufferedImage(
                                                                currentWidth, currentHeight, src.getType());
                                                Graphics2D incrementalGraphics = incrementalImage
                                                                .createGraphics();

                                                /*
                                                 * Originally we wanted to use BILINEAR interpolation
                                                 * here because it takes 1/3rd the time that the BICUBIC
                                                 * interpolation does, however, when scaling large
                                                 * images down to most sizes bigger than a thumbnail we
                                                 * witnessed Noticeable "softening" in the resultant
                                                 * image with BILINEAR that would be unexpectedly
                                                 * annoying to a user expecting a "QUALITY" scale of
                                                 * their original image. Instead BICUBIC was chosen to
                                                 * honor the contract of a QUALITY scale of the original
                                                 * image.
                                                 */
                                                incrementalGraphics.setRenderingHint(
                                                                RenderingHints.KEY_INTERPOLATION,
                                                                RenderingHints.VALUE_INTERPOLATION_BICUBIC);
                                                incrementalGraphics.drawImage(src, 0, 0, currentWidth,
                                                                currentHeight, null);
                                                incrementalGraphics.dispose();

                                                /*
                                                 * Before re-assigning our interim (partially scaled)
                                                 * incrementalImage to be the new src image, we want to
                                                 * flush() the previous src image IF (and only IF) it
                                                 * was one of our own temporary BufferedImages created
                                                 * during this incremental down-sampling cycle. If it
                                                 * wasn't one of ours, then it was the caller-supplied
                                                 * BufferedImage in which case we don't want to flush()
                                                 * it.
                                                 */
                                                if (hasReassignedSrc)
                                                        src.flush();

                                                // Now treat our incremental partially scaled image as
                                                // the src image and cycle through our loop again to do
                                                // another incremental scaling of it (if necessary).
                                                src = incrementalImage;

                                                // Keep track of us re-assigning the original
                                                // caller-supplied source image with one of our interim
                                                // BufferedImages.
                                                if (!hasReassignedSrc)
                                                        hasReassignedSrc = true;
                                        } while (currentWidth != targetWidth
                                                        || currentHeight != targetHeight);

                                        // Once the loop has exited, the source image argument is
                                        // now our scaled result image that we want to return.
                                        result = src;
                                }
                        }

                }

                return result;
        }
}
/////////////////////////////////////////////////////////
// Define simulator devices to mock up the real render //
/////////////////////////////////////////////////////////


int SIMU_COLOR_BLACK                     = color(0);
int SIMU_COLOR_WHITE                     = color(255);
int SIMU_COLOR_RED                       = color(255,0,0);
int SIMU_COLOR_BLUE                      = color(0,0,255);

int   RAINBOW_FACTOR                       = 2;
int   SIMU_FAST_FLASH_FACTOR               = 25;
int   SIMU_SLOW_FLASH_FACTOR               = 5;
int   SIMU_FAST_STROBE_PERIOD              = 2;
int   SIMU_MEDIUM_STROBE_PERIOD            = 4;
int   SIMU_SLOW_STROBE_PERIOD              = 8;
int   SIMU_VERYSLOW_STROBE_PERIOD          = 12;
int   SIMU_FAST_GROWINGSTROBE_FACTOR       = 8;
int   SIMU_MEDIUM_GROWINGSTROBE_FACTOR     = 4;
int   SIMU_SLOW_GROWINGSTROBE_FACTOR       = 2;
int   SIMU_VERYSLOW_GROWINGSTROBE_FACTOR   = 1;
float SIMU_RACK_SLOW_SMOOTHSINE_FACTOR     = 0.1f;
float SIMU_RACK_FAST_SMOOTHSINE_FACTOR     = 0.5f;
float SIMU_RACK_SHORT_WAVE_LENGTH          = 25;
float SIMU_RACK_LONG_WAVE_LENGTH           = 100;
int   SIMU_RACK_FAST_WAVE_SPEED            = 16;

float SIMU_RACK_FAST_BUILDUP_SPEED         = 6;
float SIMU_RACK_MEDIUM_BUILDUP_SPEED       = 3;
float SIMU_RACK_SLOW_BUILDUP_SPEED         = 1.5f;
float SIMU_RACK_VERYSLOW_BUILDUP_SPEED     = 0.3f;
float SIMU_RACK_SLOW_SMOOTHNOISE_SPEED     = 0.1f;
float SIMU_RACK_FAST_SMOOTHNOISE_SPEED     = 0.5f;


int   panel_pixelSize = 3;        //Size (1 cm = 1 px) of a LED module
int   panel_pixelDistance = 8;    //Distance between pixels (counting from the center)
int   panel_borderSize = 8;       //Distance between the panel's border and the first pixel
int   panel_lowerBoardSize = 30;  //Size of the lower board, raising the panel's size
int   gui_distanceBetweenPanels;

int strobe_sizeX = 60;
int strobe_sizeY = 30;
int strobe_borderSize = 4;
int gui_frontStrobePositionY = 260;

int gui_ledTubePositionY = 30;
int gui_rackLightPositionY = 160;
int gui_rackLightSpacing = 5;

int gui_movingHeadsPositionY = 310;

// TO BE DELETED
// //Define more positions than needed, when the time comes just fill in the new values
// int[] gui_rackLight1Position = {60,30,gui_simulatorPosX - 3*gui_rackLightSpacing,gui_rackLightPositionY};
// int[] gui_rackLight2Position = {60,50,gui_simulatorPosX - 3*gui_rackLightSpacing,gui_rackLightPositionY - gui_rackLightSpacing - 50};
// int[] gui_rackLight3Position = {60,30,gui_simulatorWidth - 55, gui_rackLightPositionY};
// int[] gui_rackLight4Position = {60,30,0,0};
// int[] gui_rackLight5Position = {60,30,0,0};
// int[] gui_rackLight6Position = {60,30,0,0};
// int[] gui_rackLight7Position = {60,30,0,0};
// int[] gui_rackLight8Position = {60,30,0,0};
// int[][] gui_rackLightsPosition = {gui_rackLight1Position, gui_rackLight2Position, gui_rackLight3Position, gui_rackLight4Position, gui_rackLight5Position, gui_rackLight6Position, gui_rackLight7Position, gui_rackLight8Position};

int[] gui_LEDTube1Position = {6,180,62,gui_ledTubePositionY};
int[] gui_LEDTube2Position = {6,180,151,gui_ledTubePositionY+30};
int[] gui_LEDTube3Position = {6,180,418,gui_ledTubePositionY+30};
int[] gui_LEDTube4Position = {6,180,508,gui_ledTubePositionY};
//int[] gui_LEDTube5Position = {6,180,0,gui_ledTubePositionY};
//int[] gui_LEDTube6Position = {6,180,0,gui_ledTubePositionY};
//int[] gui_LEDTube7Position = {6,180,0,gui_ledTubePositionY};
//int[] gui_LEDTube8Position = {6,180,0,gui_ledTubePositionY};
//int[][] gui_LEDTubesPosition = {gui_LEDTube1Position, gui_LEDTube2Position, gui_LEDTube3Position, gui_LEDTube4Position, gui_LEDTube5Position, gui_LEDTube6Position, gui_LEDTube7Position, gui_LEDTube8Position};
int[][] gui_LEDTubesPosition = {gui_LEDTube1Position, gui_LEDTube2Position, gui_LEDTube3Position, gui_LEDTube4Position};


//Variables used by the GUI to simulate special animated FX, which cannot be purely deduced using the DMX channels' value
int atomicStrobe_animCpt = 0;
final int ATOMICSTROBE_ANIMCPT_SINGLEFLASH = 10;

public void init_panelSimulatorList() {
  //Initialize parameters will shall be used to display the simulator
  gui_panelSimulatorList = new ArrayList<PanelSimulator>();
  
  for (int i=0; i<NUMBER_OF_PANELS; i++) {
    gui_panelSimulatorList.add(new PanelSimulator(i, PANEL_RESOLUTION_X, PANEL_RESOLUTION_Y));
  }
  
  //Define the distance between the panels for the GUI
  gui_distanceBetweenPanels = (gui_panelsimuWidth - NUMBER_OF_PANELS*(panel_pixelDistance*(PANEL_RESOLUTION_X - 1) + 2*panel_borderSize))/(NUMBER_OF_PANELS-1);
}

public void init_customDevicesSimulatorList() {
  //Initialize parameters will shall be used to display the simulator
  gui_rackLightList = new ArrayList<RackLight>();
  gui_LEDTubeList = new ArrayList<LEDTube>();
  
  //RackLight constructor : ID, sizeX, sizeY, posX, posY
  // for (int i=0; i<CustomDeviceList_RackLights.size(); i++) {
  //   gui_rackLightList.add(new RackLight(i, gui_rackLightsPosition[i][0], gui_rackLightsPosition[i][1],gui_rackLightsPosition[i][2], gui_rackLightsPosition[i][3]));
  // }
  
  //LEDTube constructor : ID, sizeX, sizeY, posX, posY
  for (int i=0; i<CustomDeviceList_LEDTubes.size(); i++) {
    gui_LEDTubeList.add(new LEDTube(i, gui_LEDTubesPosition[i][0], gui_LEDTubesPosition[i][1],gui_LEDTubesPosition[i][2], gui_LEDTubesPosition[i][3]));
  }
}

public void draw_simulator(int x, int y) {
  
  //LED Panels
  int offset = (gui_simulatorWidth - gui_panelsimuWidth)/2;
  for (int i=0; i<gui_panelSimulatorList.size(); i++) {
    gui_panelSimulatorList.get(i).drawBasePanelOutline(offset + x,y);
    offset += gui_panelSimulatorList.get(i).totalWidth + gui_distanceBetweenPanels;
  }
  offset = (gui_simulatorWidth - gui_panelsimuWidth)/2;
  auxControlFrame.loadPixels();
  loadPixels();  
  for (int i=0; i<gui_panelSimulatorList.size(); i++) {
    gui_panelSimulatorList.get(i).drawPanelSimulator(offset + x,y);
    offset += gui_panelSimulatorList.get(i).totalWidth + gui_distanceBetweenPanels;
  }
  auxControlFrame.updatePixels();
  
  
  // //Rack lights
  // for (int i=0; i<gui_rackLightList.size(); i++) {
  //   gui_rackLightList.get(i).drawFullRackLight(CustomDeviceList_RackLights.get(i).lastAnimationExecuted, x, y);
  // }

  
  //LED tubes
  for (int i=0; i<CustomDeviceList_LEDTubes.size(); i++) {
    gui_LEDTubeList.get(i).drawFullLEDTube(CustomDeviceList_LEDTubes.get(i).lastAnimationExecuted, x, y);
  }

  //stroboscopes
  drawSimuFrontLeftStroboscope(gui_simulatorWidth/5 + 5, gui_frontStrobePositionY);
  drawSimuFrontRightStroboscope(4*gui_simulatorWidth/5 + 16, gui_frontStrobePositionY);
  drawSimuBackStroboscope(gui_simulatorWidth/2 + 10, gui_frontStrobePositionY);

  //Moving heads
  drawMovingHeads(gui_simulatorWidth, gui_movingHeadsPositionY);
  
}

public void simuResetAnimCpt_AtomicStrobe() {
  atomicStrobe_animCpt = 0;
}

class PanelSimulator {
  
  int panelNumber;                //ID of the panel
  int widthPixels;                //Number of pixels in a row
  int heightPixels;               //Number of pixels in a column
  
  //Parameters to define the size of the actual panel
  int totalHeight;
  int totalWidth;
  
  PGraphics panelImage;
  
  int panelColor       = color(0);
  int lowerBoardColor  = color(70);
  
  PanelSimulator(int _panelNumber, int _widthPixels, int _heightPixels) {
    panelNumber  = _panelNumber;
    widthPixels  = _widthPixels;
    heightPixels = _heightPixels;
    totalHeight  = panel_borderSize*2 + (heightPixels-1)*panel_pixelDistance + panel_lowerBoardSize;
    totalWidth   = panel_borderSize*2 + (widthPixels-1)*panel_pixelDistance;
    panelImage = createGraphics(widthPixels, heightPixels);
  }
  
  public void drawBasePanelOutline(int offsetX, int offsetY) {
    auxControlFrame.fill(panelColor);
    auxControlFrame.rect(offsetX, offsetY, totalWidth, totalHeight);
    auxControlFrame.fill(lowerBoardColor);
    auxControlFrame.rect(offsetX, offsetY+totalWidth + 2*panel_lowerBoardSize + panel_borderSize*2, totalWidth, panel_lowerBoardSize);    
  }
  
  //Must be called as part of the greater draw_simulator() ! To optimize performance, the pixels are loaded/updated in the higher level function  
  public void drawPanelSimulator(int offsetX, int offsetY) {
    
    //int baseOffset = this.panelNumber*widthPixels + offsetX + auxControlFrame.height*offsetY;
    int baseOffset = (offsetX + panel_borderSize) + auxControlFrame.width*(offsetY + panel_borderSize);
    for (int i = 0; i < heightPixels; i++) {
      for (int j = 0; j < widthPixels; j++) {
        
        int pixelCoordinates =  baseOffset + (i*panel_pixelDistance)*auxControlFrame.width + (j*panel_pixelDistance);
        
        for (int k=0; k<panel_pixelSize;k++) {
          for (int l=0; l<panel_pixelSize;l++) {
            auxControlFrame.pixels[pixelCoordinates + k + auxControlFrame.width*l] = transformedBuffersLEDPanels[this.panelNumber][i*widthPixels + j];
          }
        }

      }
    }
    
  }
  
  public void drawSpecificPanel(int[] array) {
    for (int i = 0; i < heightPixels; i++) {
      for (int j = 0; j < widthPixels; j++) {
        auxControlFrame.stroke(array[i*widthPixels + j]);
        auxControlFrame.point(panel_borderSize + j*panel_pixelDistance, panel_borderSize + i*panel_pixelDistance);
      }
    }
  }
  
  
}


// DMX equipments - simulator functions

public void drawSimuFrontLeftStroboscope(int positionX, int positionY) {
  auxControlFrame.fill(100);
  auxControlFrame.rect(positionX - strobe_sizeX/2,positionY,strobe_sizeX,strobe_sizeY);
  
  boolean drawStrobe = false;
  for (DMX_Stroboscope stroboscope: DMXList_FrontLeftStroboscopes) {
    if (stroboscope.isActive != false) {
      drawStrobe = true;
      break;
    }
  }
    
  if (drawStrobe == true) {
    int simuSpeed = 0;
    int simuBrightness = 0;
    int simuFlashLength = 0;
    int simuSpecialFx = 0;
    //Get the maximum speed/brightness of this strobe group
    for (DMX_Stroboscope stroboscope : DMXList_FrontLeftStroboscopes) {
      simuSpeed       = max(simuSpeed, stroboscope.currentSpeed);
      simuBrightness  = max(simuBrightness, stroboscope.currentBrightness);
      simuFlashLength = max(simuFlashLength, stroboscope.currentFlashLength);
      simuSpecialFx   = max(simuSpecialFx, stroboscope.currentSpecialFX);
    }
    
    simu_computeStrobeColor(simuSpeed, simuBrightness, simuFlashLength, simuSpecialFx);
  }
  else {
    auxControlFrame.fill(0);
  }
  auxControlFrame.rect(positionX - strobe_sizeX/2 + strobe_borderSize,positionY + strobe_borderSize,strobe_sizeX - strobe_borderSize*2,strobe_sizeY - strobe_borderSize*2);
}

public void drawSimuFrontRightStroboscope(int positionX, int positionY) {
  auxControlFrame.fill(100);
  auxControlFrame.rect(positionX - strobe_sizeX/2,positionY,strobe_sizeX,strobe_sizeY);
  
  boolean drawStrobe = false;
  for (DMX_Stroboscope stroboscope: DMXList_FrontRightStroboscopes) {
    if (stroboscope.isActive != false) {
      drawStrobe = true;
      break;
    }
  }
    
  if (drawStrobe == true) {
    int simuSpeed = 0;
    int simuBrightness = 0;
    int simuFlashLength = 0;
    int simuSpecialFx = 0;
    //Get the maximum speed/brightness of this strobe group
    for (DMX_Stroboscope stroboscope : DMXList_FrontRightStroboscopes) {
      simuSpeed       = max(simuSpeed, stroboscope.currentSpeed);
      simuBrightness  = max(simuBrightness, stroboscope.currentBrightness);
      simuFlashLength = max(simuFlashLength, stroboscope.currentFlashLength);
      simuSpecialFx   = max(simuSpecialFx, stroboscope.currentSpecialFX);
    }
    
    simu_computeStrobeColor(simuSpeed, simuBrightness, simuFlashLength, simuSpecialFx);
  }
  else {
    auxControlFrame.fill(0);
  }
  auxControlFrame.rect(positionX - strobe_sizeX/2 + strobe_borderSize,positionY + strobe_borderSize,strobe_sizeX - strobe_borderSize*2,strobe_sizeY - strobe_borderSize*2);
}

public void drawSimuBackStroboscope(int positionX, int positionY) {
  auxControlFrame.fill(100);
  auxControlFrame.rect(positionX - strobe_sizeX/2,positionY,strobe_sizeX,strobe_sizeY);
  
  boolean drawStrobe = false;
  for (DMX_Stroboscope stroboscope: DMXList_BackStroboscopes) {
    if (stroboscope.isActive != false) {
      drawStrobe = true;
      break;
    }
  }
  
  if (drawStrobe == true) {
    int simuSpeed = 0;
    int simuBrightness = 0;
    int simuFlashLength = 0;
    int simuSpecialFx = 0;
    //Get the maximum speed/brightness of this strobe group
    for (DMX_Stroboscope stroboscope : DMXList_BackStroboscopes) {
      simuSpeed       = max(simuSpeed, stroboscope.currentSpeed);
      simuBrightness  = max(simuBrightness, stroboscope.currentBrightness);
      simuFlashLength = max(simuFlashLength, stroboscope.currentFlashLength);
      simuSpecialFx   = max(simuSpecialFx, stroboscope.currentSpecialFX);
    }
    
    simu_computeStrobeColor(simuSpeed, simuBrightness, simuFlashLength, simuSpecialFx);
  }
  else {
    auxControlFrame.fill(0);
  }
  auxControlFrame.rect(positionX - strobe_sizeX/2 + strobe_borderSize,positionY + strobe_borderSize,strobe_sizeX - strobe_borderSize*2,strobe_sizeY - strobe_borderSize*2);
}

public void simu_computeStrobeColor(int simuSpeed, int simuBrightness, int simuFlashLength, int simuSpecialFx) {
  // The device is set to active, but with a null speed -> special case : single flash
  if (simuSpeed == 0) {
    if (atomicStrobe_animCpt < ATOMICSTROBE_ANIMCPT_SINGLEFLASH) {
      auxControlFrame.fill(simuBrightness);
      atomicStrobe_animCpt += 1;
    }
    else {
      auxControlFrame.fill(0);
    }
  }
  // No effect is currently active, normal strobe
  else if (simuSpecialFx == DMXStroboscope_defaultSpecialFXValue) {
    //Map simuSpeed to a more usable value
    simuSpeed = PApplet.parseInt(map(simuSpeed, 0, 255, 12, 2));
    
    if (auxControlFrame.frameCount%simuSpeed == 0) {
      auxControlFrame.fill(simuBrightness);
    }
    else {
      auxControlFrame.fill(0);
    }
  }
  // A special effect is being played using the Atomic strobes
  else {
    switch(simuSpecialFx) {
      case ATOMICFX_BLINDER:    simu_drawAtomicStroboFX_blinder(); break;
      case ATOMICFX_RAMPUP:     simu_drawAtomicStroboFX_rampUp(); break;
      case ATOMICFX_RAMPDOWN:   simu_drawAtomicStroboFX_rampDown(); break;
      case ATOMICFX_RAMPUPDOWN: simu_drawAtomicStroboFX_rampUpDown(); break;
      case ATOMICFX_RANDOM:     simu_drawAtomicStroboFX_random(); break;
      case ATOMICFX_LIGHTNING:  simu_drawAtomicStroboFX_lightning(); break;
      case ATOMICFX_SPIKES:     simu_drawAtomicStroboFX_spikes(simuSpeed, simuBrightness); break;
      default:                  auxControlFrame.fill(0); break;
    }
    atomicStrobe_animCpt += 1;
  }
}

public void simu_drawAtomicStroboFX_blinder() {
  auxControlFrame.fill(255);
}

public void simu_drawAtomicStroboFX_rampUp() {
  auxControlFrame.fill(min(atomicStrobe_animCpt*10, 255));
}

public void simu_drawAtomicStroboFX_rampDown() {
  auxControlFrame.fill(max(255 - atomicStrobe_animCpt*10, 0));
}

public void simu_drawAtomicStroboFX_rampUpDown() {
  if (dmxAnimationNumber_strobe >= 68 && dmxAnimationNumber_strobe <= 70) {
    if (auxControlFrame.frameCount%4 == 0 || auxControlFrame.frameCount%4 == 1) {
      auxControlFrame.fill(255*(sin(atomicStrobe_animCpt*(dmxAnimationNumber_strobe-67)) + 1) * 0.5f);
    }
    else {
      auxControlFrame.fill(0);
    }
  }
  else {
    auxControlFrame.fill(abs(255*((sin(atomicStrobe_animCpt*3*(dmxAnimationNumber_strobe-70)*TWO_PI/360)))));
  }
}

public void simu_drawAtomicStroboFX_random() {
  if (auxControlFrame.frameCount%4 == 0 || auxControlFrame.frameCount%4 == 1) {
    auxControlFrame.fill(random(255));
  }
  else {
    auxControlFrame.fill(0);
  }
}

public void simu_drawAtomicStroboFX_lightning() {
  if (auxControlFrame.frameCount%4 == 0 || auxControlFrame.frameCount%4 == 1) {
    auxControlFrame.fill(max(0,random(255 - atomicStrobe_animCpt*3)));
  }
  else {
    auxControlFrame.fill(0);
  }
}

public void simu_drawAtomicStroboFX_spikes(int simuSpeed, int simuBrightness) {
  //Map simuSpeed to a more usable value
  simuSpeed = PApplet.parseInt(map(simuSpeed, 0, 255, 20, 6));
  
  if (auxControlFrame.frameCount%simuSpeed == 0) {
    auxControlFrame.fill(simuBrightness);
  }
  else if (auxControlFrame.frameCount%2 == 0) {
    auxControlFrame.fill(80);
  }
  else {
    auxControlFrame.fill(0);
  }  
}


////////////////////////////////////////////////
// Moving Heads

public void drawMovingHeads(int simulatorWidth, int positionY) {
  
  if (DMXList_MovingHeads.size() > 0) {
    int nbMovingHeads = DMXList_MovingHeads.size();
    int centerX = simulatorWidth/2;
    int maxWidth = (80 - 6*nbMovingHeads) * nbMovingHeads;
    //int spacing = maxWidth / nbMovingHeads;

    for (int i = 0; i<nbMovingHeads; i++) {

      //centerX - maxWidth/2 + i*maxWidth/(nbMovingHeads-2);


      DMX_MovingHead movingHead = DMXList_MovingHeads.get(i);
      auxControlFrame.pushMatrix();
      int posX;
      if (nbMovingHeads%2 == 0) {
        posX = centerX-maxWidth/2+(i+1)*maxWidth/(nbMovingHeads+1);
        posX = centerX -  PApplet.parseInt((5.0f/3.0f) * (maxWidth/2-(i+1)*maxWidth/(nbMovingHeads+1)));        
      }
      else {
        posX = centerX - ((nbMovingHeads/2) - i)*maxWidth/nbMovingHeads;
        
      }
      
      auxControlFrame.translate(posX + 10,positionY);

      //External circle
      auxControlFrame.fill(0);
      auxControlFrame.stroke(255);
      auxControlFrame.ellipse(0, 0, 18, 18);
      auxControlFrame.noStroke();

      //Internal color light
      if (movingHead.getSimulatorShutterMode() == DMX_MOVINGHEAD_SHUTTERMODE_STROBE) {
        if (auxControlFrame.frameCount % PApplet.parseInt(map(movingHead.getSimulatorShutter(), 0, 255, 7, 2)) == 0) {
          auxControlFrame.fill(movingHead.getSimulatorColor()[0], movingHead.getSimulatorColor()[1], movingHead.getSimulatorColor()[2], movingHead.getSimulatorDimmer());  
        }
        else {
          auxControlFrame.fill(0);
        }
      }
      else {
        auxControlFrame.fill(movingHead.getSimulatorColor()[0], movingHead.getSimulatorColor()[1], movingHead.getSimulatorColor()[2], movingHead.getSimulatorDimmer());  
      }
      auxControlFrame.ellipse(0, 0, 10,10);

      //Tilt meter
      auxControlFrame.stroke(255);
      auxControlFrame.fill(0);
      auxControlFrame.rect(-26,-16,5,28);
      auxControlFrame.fill(movingHead.getSimulatorColor()[0], movingHead.getSimulatorColor()[1], movingHead.getSimulatorColor()[2]);
      auxControlFrame.rect(-26,16 - movingHead.getSimulatorTilt()*28/255.0f, 5, movingHead.getSimulatorTilt()*28/255.0f);
      //Pan meter 
      auxControlFrame.fill(0);
      auxControlFrame.rect(-16,20,32,3);
      auxControlFrame.fill(movingHead.getSimulatorColor()[0], movingHead.getSimulatorColor()[1], movingHead.getSimulatorColor()[2]);
      auxControlFrame.rect(-16,20,movingHead.getSimulatorPan()*32/255.0f,3);
      
      auxControlFrame.line(-26,1,-21,1);  //Center position for the tilt meter
      auxControlFrame.line(0,20,0,23);  //Center position for the pan meter

      //Pan arrow
      //auxControlFrame.rotate(frameCount / 50.0);
      auxControlFrame.rotate(PI/2 - PApplet.parseInt(map(movingHead.getSimulatorPan(),0,255,-3*PI/2,3*PI/2) * 1000)/1000.0f);
      auxControlFrame.translate(10,0);
      auxControlFrame.stroke(255);
      //auxControlFrame.fill(255,0,0);
      auxControlFrame.triangle(0,4,0,-4,7,0);

      auxControlFrame.popMatrix();
    }
    auxControlFrame.noStroke();
  }

}

////////////////////////////////////////////////
// Rack Lights

class RackLight {
  
  int rackLightNumber;                //ID of the device
  int rackWidth;
  int rackHeight;
  int positionX;
  int positionY;
  
  int animProgress = 0;
  int executionCount = 0;
  int currentAnim = -1;
  
  //int strokePixelWeight = 6;
  int rackLight_borderSize = 4;
  
  PGraphics rackLightImage;
  PGraphics sidebarUp;
  PGraphics sidebarDown;
  PGraphics sidebarLeft;
  PGraphics sidebarRight;
  
  
  RackLight(int _rackLightNumber, int _rackWidth, int _rackHeight, int _positionX, int _positionY) {
    this.rackLightNumber = _rackLightNumber;
    this.rackWidth       = _rackWidth;
    this.rackHeight      = _rackHeight;
    this.positionX       = _positionX;
    this.positionY       = _positionY;
    
    this.rackLightImage = createGraphics(rackWidth, rackHeight);
    this.sidebarUp = createGraphics(rackWidth,rackLight_borderSize);
    this.sidebarDown = createGraphics(rackWidth,rackLight_borderSize);
    this.sidebarLeft = createGraphics(rackLight_borderSize,rackHeight);
    this.sidebarRight = createGraphics(rackLight_borderSize,rackHeight);
    
  }
  
  public void drawFullRackLight(int rackLightAnimNbr, int additionalX, int additionalY) {
    if (currentAnim != rackLightAnimNbr) {
      this.animProgress = 0;
      this.currentAnim = rackLightAnimNbr;
    }
    else {
      this.animProgress += 1;
    }
    if (CustomDeviceList_RackLights.get(rackLightNumber).executionCount != this.executionCount) {
      this.executionCount = CustomDeviceList_RackLights.get(rackLightNumber).executionCount;
      this.animProgress = 0;
    }
    
    //Draw the blackish rack structure (just a rectangle actually
    computeBaseRackLightOutline();
    //Draw the individual sidebars
    drawSpecificRackLight(rackLightAnimNbr);
    


    //Draw the strips of LED on the side of the rack
    this.rackLightImage.beginDraw();
    this.rackLightImage.image(sidebarUp, 0, 0);
    this.rackLightImage.image(sidebarLeft, 0, 0);
    this.rackLightImage.image(sidebarDown, 0, this.rackLightImage.height - rackLight_borderSize);
    this.rackLightImage.image(sidebarRight, this.rackLightImage.width - rackLight_borderSize, 0);
    this.rackLightImage.endDraw();
    
    auxControlFrame.image(this.rackLightImage, this.positionX + additionalX, this.positionY + additionalY); 
  }
  
  public void computeBaseRackLightOutline() {
    this.rackLightImage.loadPixels();
    for (int i=0; i<this.rackLightImage.pixels.length; i++) {
      this.rackLightImage.pixels[i] = SIMU_COLOR_BLACK;
    }
    this.rackLightImage.updatePixels();
  }
  
  public void drawSpecificRackLight(int rackLightAnimNbr) {
    
    this.sidebarUp.loadPixels();
    this.sidebarDown.loadPixels();
    this.sidebarLeft.loadPixels();
    this.sidebarRight.loadPixels();

    switch (this.currentAnim) {
      case CUSTOMDEV_ANIM_BLACKOUT                           : simuDraw_rackLight_plainColor(SIMU_COLOR_BLACK);break;
      case CUSTOMDEV_ANIM_WHITEOUT                           : simuDraw_rackLight_plainColor(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_REDOUT                             : simuDraw_rackLight_plainColor(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_BLUEOUT                            : simuDraw_rackLight_plainColor(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_RAINBOWOUT                         : simuDraw_rackLight_plainColor(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_FASTWHITEFLASH                     : simuDraw_rackLight_fastFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTWHITEFLASH_2                   : simuDraw_rackLight_fastFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDFLASH                       : simuDraw_rackLight_fastFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTREDFLASH_2                     : simuDraw_rackLight_fastFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUEFLASH                      : simuDraw_rackLight_fastFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTBLUEFLASH_2                    : simuDraw_rackLight_fastFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWFLASH                   : simuDraw_rackLight_fastFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2                 : simuDraw_rackLight_fastFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWWHITEFLASH                     : simuDraw_rackLight_slowFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWWHITEFLASH_2                   : simuDraw_rackLight_slowFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDFLASH                       : simuDraw_rackLight_slowFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWREDFLASH_2                     : simuDraw_rackLight_slowFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUEFLASH                      : simuDraw_rackLight_slowFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWBLUEFLASH_2                    : simuDraw_rackLight_slowFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWFLASH                   : simuDraw_rackLight_slowFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2                 : simuDraw_rackLight_slowFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE                : simuDraw_rackLight_slowSmoothSine(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE                  : simuDraw_rackLight_slowSmoothSine(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE                 : simuDraw_rackLight_slowSmoothSine(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE              : simuDraw_rackLight_fastSmoothSine(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE                : simuDraw_rackLight_fastSmoothSine(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDSMOOTHSINE                  : simuDraw_rackLight_fastSmoothSine(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE                 : simuDraw_rackLight_fastSmoothSine(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE              : simuDraw_rackLight_fastSmoothSine(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE               : simuDraw_rackLight_fastStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE                 : simuDraw_rackLight_fastStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE                : simuDraw_rackLight_fastStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE              : simuDraw_rackLight_fastStrobo(color(random(255),255,255));break;
      case CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE        : simuDraw_rackLight_fastGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2      : simuDraw_rackLight_fastGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE          : simuDraw_rackLight_fastGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2        : simuDraw_rackLight_fastGrowingStrobo(SIMU_COLOR_RED);break;
      
      case CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE             : simuDraw_rackLight_mediumStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE               : simuDraw_rackLight_mediumStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE              : simuDraw_rackLight_mediumStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE            : simuDraw_rackLight_mediumStrobo(Color.HSBtoRGB(random(1),1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE      : simuDraw_rackLight_mediumGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2    : simuDraw_rackLight_mediumGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE        : simuDraw_rackLight_mediumGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2      : simuDraw_rackLight_mediumGrowingStrobo(SIMU_COLOR_RED);break;
      
      case CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE               : simuDraw_rackLight_slowStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE                 : simuDraw_rackLight_slowStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE                : simuDraw_rackLight_slowStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE              : simuDraw_rackLight_slowStrobo(Color.HSBtoRGB(random(1),1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE        : simuDraw_rackLight_slowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2      : simuDraw_rackLight_slowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE          : simuDraw_rackLight_slowGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2        : simuDraw_rackLight_slowGrowingStrobo(SIMU_COLOR_RED);break;  
      
      case CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE           : simuDraw_rackLight_verySlowStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE             : simuDraw_rackLight_verySlowStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE            : simuDraw_rackLight_verySlowStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE          : simuDraw_rackLight_verySlowStrobo(Color.HSBtoRGB(random(1),1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE    : simuDraw_rackLight_verySlowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2  : simuDraw_rackLight_verySlowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE      : simuDraw_rackLight_verySlowGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2    : simuDraw_rackLight_verySlowGrowingStrobo(SIMU_COLOR_RED);break;
      
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE         : simuDraw_rackLight_singleShortUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2       : simuDraw_rackLight_singleShortUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE           : simuDraw_rackLight_singleShortUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2         : simuDraw_rackLight_singleShortUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE          : simuDraw_rackLight_singleShortUpwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2        : simuDraw_rackLight_singleShortUpwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE          : simuDraw_rackLight_singleLongUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2        : simuDraw_rackLight_singleLongUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE            : simuDraw_rackLight_singleLongUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2          : simuDraw_rackLight_singleLongUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE           : simuDraw_rackLight_singleLongUpwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2         : simuDraw_rackLight_singleLongUpwardWave(SIMU_COLOR_BLUE);break;
      
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE       : simuDraw_rackLight_singleShortDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2     : simuDraw_rackLight_singleShortDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE         : simuDraw_rackLight_singleShortDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2       : simuDraw_rackLight_singleShortDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE        : simuDraw_rackLight_singleShortDownwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2      : simuDraw_rackLight_singleShortDownwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE        : simuDraw_rackLight_singleLongDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2      : simuDraw_rackLight_singleLongDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE          : simuDraw_rackLight_singleLongDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2        : simuDraw_rackLight_singleLongDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE         : simuDraw_rackLight_singleLongDownwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2       : simuDraw_rackLight_singleLongDownwardWave(SIMU_COLOR_BLUE);break;
      
      case CUSTOMDEV_ANIM_FASTWHITEBUILDUP                   : simuDraw_rackLight_fastBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2                 : simuDraw_rackLight_fastBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDBUILDUP                     : simuDraw_rackLight_fastBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTREDBUILDUP_2                   : simuDraw_rackLight_fastBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUEBUILDUP                    : simuDraw_rackLight_fastBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2                  : simuDraw_rackLight_fastBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP                 : simuDraw_rackLight_fastBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2               : simuDraw_rackLight_fastBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP                 : simuDraw_rackLight_mediumBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2               : simuDraw_rackLight_mediumBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMREDBUILDUP                   : simuDraw_rackLight_mediumBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2                 : simuDraw_rackLight_mediumBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP                  : simuDraw_rackLight_mediumBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2                : simuDraw_rackLight_mediumBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP               : simuDraw_rackLight_mediumBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2             : simuDraw_rackLight_mediumBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_SLOWWHITEBUILDUP                   : simuDraw_rackLight_slowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2                 : simuDraw_rackLight_slowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDBUILDUP                     : simuDraw_rackLight_slowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWREDBUILDUP_2                   : simuDraw_rackLight_slowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUEBUILDUP                    : simuDraw_rackLight_slowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2                  : simuDraw_rackLight_slowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP                 : simuDraw_rackLight_slowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2               : simuDraw_rackLight_slowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP               : simuDraw_rackLight_verySlowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2             : simuDraw_rackLight_verySlowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP                 : simuDraw_rackLight_verySlowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2               : simuDraw_rackLight_verySlowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP                : simuDraw_rackLight_verySlowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2              : simuDraw_rackLight_verySlowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP             : simuDraw_rackLight_verySlowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2           : simuDraw_rackLight_verySlowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_WHITENOISE                         : simuDraw_rackLight_noise(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_REDNOISE                           : simuDraw_rackLight_noise(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_BLUENOISE                          : simuDraw_rackLight_noise(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_RAINBOWNOISE                       : simuDraw_rackLight_noise(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE               : simuDraw_rackLight_slowSmoothNoise(SIMU_COLOR_WHITE);break;     
      case CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE                 : simuDraw_rackLight_slowSmoothNoise(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE                : simuDraw_rackLight_slowSmoothNoise(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE             : simuDraw_rackLight_slowSmoothNoise(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE               : simuDraw_rackLight_fastSmoothNoise(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE                 : simuDraw_rackLight_fastSmoothNoise(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE                : simuDraw_rackLight_fastSmoothNoise(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE             : simuDraw_rackLight_fastSmoothNoise(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
    }
    
    this.sidebarUp.updatePixels();
    this.sidebarDown.updatePixels();
    this.sidebarLeft.updatePixels();
    this.sidebarRight.updatePixels();

  }
  
  public void simuDraw_rackLight_plainColor(int col) {
    for (int i=0; i<this.sidebarUp.pixels.length;i++) {
      this.sidebarUp.pixels[i] = col;
    }
    for (int i=0; i<this.sidebarRight.pixels.length;i++) {
      this.sidebarRight.pixels[i] = col;
    }
    for (int i=0; i<this.sidebarDown.pixels.length;i++) {
      this.sidebarDown.pixels[i] = col;
    }
    for (int i=0; i<this.sidebarLeft.pixels.length;i++) {
      this.sidebarLeft.pixels[i] = col;
    }
  }
  
  public void simuDraw_rackLight_fastFlash(int col) {
    simuDraw_rackLight_flash(col, SIMU_FAST_FLASH_FACTOR);
  }
  public void simuDraw_rackLight_slowFlash(int col) {
    simuDraw_rackLight_flash(col, SIMU_SLOW_FLASH_FACTOR);
  }
    
  public void simuDraw_rackLight_flash(int col, int factor) {
    int newCol = Color.HSBtoRGB(hue(col)/255.0f,saturation(col)/255.0f,max(PApplet.parseInt(brightness(col)-this.animProgress*factor), 0)/255.0f);
    simuDraw_rackLight_plainColor(newCol);
  }
  
  public void simuDraw_rackLight_slowSmoothSine(int col) {
    simuDraw_rackLight_SmoothSine(col, SIMU_RACK_SLOW_SMOOTHSINE_FACTOR);
  }
  public void simuDraw_rackLight_fastSmoothSine(int col) {
    simuDraw_rackLight_SmoothSine(col, SIMU_RACK_FAST_SMOOTHSINE_FACTOR);
  }
  
  public void simuDraw_rackLight_SmoothSine(int col, float factor) {
    for (int i=0; i<this.sidebarUp.width;i++) {
      float intensity = (0.5f + sin(factor*(i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarUp.height;j++) {
        this.sidebarUp.pixels[i+j*this.sidebarUp.width] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarRight.height;i++) {
      float intensity = (0.5f + sin(factor*((this.sidebarUp.width + i)+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarRight.width;j++) {
        this.sidebarRight.pixels[(this.sidebarRight.height - 1 - i)*this.sidebarRight.width+j] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarDown.width;i++) {
      float intensity = (0.5f + sin(factor*((this.sidebarUp.width + this.sidebarRight.height + i)+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarDown.height;j++) {
        this.sidebarDown.pixels[((this.sidebarDown.width - 1 - i)+j*this.sidebarDown.width)] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarLeft.height;i++) {
      float intensity = (0.5f + sin(factor*((this.sidebarUp.width + this.sidebarRight.height + this.sidebarDown.width + i)+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarLeft.width;j++) {
        this.sidebarLeft.pixels[i*this.sidebarLeft.width+j] = newCol;
      }
    }
    
  }
  
  public void simuDraw_rackLight_fastStrobo(int col) {
    simuDraw_rackLight_strobo(col, SIMU_FAST_STROBE_PERIOD);
  }
  public void simuDraw_rackLight_mediumStrobo(int col) {
    simuDraw_rackLight_strobo(col, SIMU_MEDIUM_STROBE_PERIOD);
  }
  public void simuDraw_rackLight_slowStrobo(int col) {
    simuDraw_rackLight_strobo(col, SIMU_SLOW_STROBE_PERIOD);
  }
  public void simuDraw_rackLight_verySlowStrobo(int col) {
    simuDraw_rackLight_strobo(col, SIMU_VERYSLOW_STROBE_PERIOD);
  }
  public void simuDraw_rackLight_fastGrowingStrobo(int col) {
    simuDraw_rackLight_growingStrobo(col, SIMU_FAST_GROWINGSTROBE_FACTOR);
  }
  public void simuDraw_rackLight_mediumGrowingStrobo(int col) {
    simuDraw_rackLight_growingStrobo(col, SIMU_MEDIUM_GROWINGSTROBE_FACTOR);
  }
  public void simuDraw_rackLight_slowGrowingStrobo(int col) {
    simuDraw_rackLight_growingStrobo(col, SIMU_SLOW_GROWINGSTROBE_FACTOR);
  }
  public void simuDraw_rackLight_verySlowGrowingStrobo(int col) {
    simuDraw_rackLight_growingStrobo(col, SIMU_VERYSLOW_GROWINGSTROBE_FACTOR);
  }

  
  public void simuDraw_rackLight_strobo(int col, int flashPeriod) {
    if (auxControlFrame.frameCount % flashPeriod == 0) {
      simuDraw_rackLight_plainColor(col);
    }
    else {
      simuDraw_rackLight_plainColor(SIMU_COLOR_BLACK);
    }
  }
  
  public void simuDraw_rackLight_growingStrobo(int col, int factor) {
    int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, min(this.animProgress*factor, 255)/255.0f);
    if (auxControlFrame.frameCount % 2 == 0) {
      simuDraw_rackLight_plainColor(newCol);
    }
    else {
      simuDraw_rackLight_plainColor(SIMU_COLOR_BLACK);
    }
  }

  public void simuDraw_rackLight_singleShortUpwardWave(int col) {
    simuDraw_rackLight_singleUpwardWave(col, SIMU_RACK_SHORT_WAVE_LENGTH);
  }
  public void simuDraw_rackLight_singleLongUpwardWave(int col) {
    simuDraw_rackLight_singleUpwardWave(col, SIMU_RACK_LONG_WAVE_LENGTH);
  }
  public void simuDraw_rackLight_singleUpwardWave(int col, float waveLength) {
    for (int i=0; i<this.sidebarUp.width*this.sidebarUp.height; i++) {
      this.sidebarUp.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarRight.width*this.sidebarRight.height; i++) {
      this.sidebarRight.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarDown.width*this.sidebarDown.height; i++) {
      this.sidebarDown.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarLeft.width*this.sidebarLeft.height; i++) {
      this.sidebarLeft.pixels[i] = 0;
    }
    
    int currentPos = this.animProgress*SIMU_RACK_FAST_WAVE_SPEED;
    //Don't even check the pixels if currentPos is too far ahead
    if (currentPos < (this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width+this.sidebarLeft.height+100)) {
      for (int i=0; i<waveLength; i++) {
        float intensity = (1- i/waveLength);   
        int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
  
        if ((currentPos - i) > 0 && (currentPos - i) < this.sidebarUp.width) {
          for (int j=0; j<this.sidebarUp.height; j++) {
            this.sidebarUp.pixels[(currentPos - i)+this.sidebarUp.width*j] = newCol;
          }
        }
        
        if ((currentPos - (i+this.sidebarUp.width)) > 0 && (currentPos - (i+this.sidebarUp.width)) < this.sidebarRight.height) {
          for (int j=0; j<this.sidebarRight.width; j++) {
            this.sidebarRight.pixels[(currentPos - (i+this.sidebarUp.width))*this.sidebarRight.width+j] = newCol;
          }
        }
      
        if ((currentPos - (i+this.sidebarUp.width+this.sidebarRight.height)) > 0 && (currentPos - (i+this.sidebarUp.width+this.sidebarRight.height)) < this.sidebarDown.width) {
          for (int j=0; j<this.sidebarDown.height; j++) {
            this.sidebarDown.pixels[this.sidebarDown.pixels.length - ((currentPos - (i+this.sidebarUp.width+this.sidebarRight.height))+this.sidebarDown.width*j)] = newCol;
          }
        }
      
        if ((currentPos - (i+this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width)) > 0 && (currentPos - (i+this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width)) < this.sidebarLeft.height) {
          for (int j=0; j<this.sidebarLeft.width; j++) {
            this.sidebarLeft.pixels[this.sidebarLeft.pixels.length - ((currentPos - (i+this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width))*this.sidebarLeft.width+j)] = newCol;
          }
        }
      }
    }
  }
  
  public void simuDraw_rackLight_singleShortDownwardWave(int col) {
    simuDraw_rackLight_singleDownwardWave(col, SIMU_RACK_SHORT_WAVE_LENGTH);
  }
  public void simuDraw_rackLight_singleLongDownwardWave(int col) {
    simuDraw_rackLight_singleDownwardWave(col, SIMU_RACK_LONG_WAVE_LENGTH);
  }
  public void simuDraw_rackLight_singleDownwardWave(int col, float waveLength) {
    for (int i=0; i<this.sidebarUp.width*this.sidebarUp.height; i++) {
      this.sidebarUp.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarRight.width*this.sidebarRight.height; i++) {
      this.sidebarRight.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarDown.width*this.sidebarDown.height; i++) {
      this.sidebarDown.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarLeft.width*this.sidebarLeft.height; i++) {
      this.sidebarLeft.pixels[i] = 0;
    }
    
    int currentPos = this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width+this.sidebarLeft.height - this.animProgress*SIMU_RACK_FAST_WAVE_SPEED;
    //Don't even check the pixels if currentPos is too far ahead
    if (currentPos < (this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width+this.sidebarLeft.height+100)) {
      for (int i=0; i<waveLength; i++) {
        float intensity = (1- i/waveLength);   
        int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
  
        if ((currentPos + i) > 0 && (currentPos + i) < this.sidebarUp.width) {
          for (int j=0; j<this.sidebarUp.height; j++) {
            this.sidebarUp.pixels[(currentPos + i)+this.sidebarUp.width*j] = newCol;
          }
        }
        
        if ((currentPos + i-this.sidebarUp.width) > 0 && (currentPos + i - (this.sidebarUp.width)) < this.sidebarRight.height) {
          for (int j=0; j<this.sidebarRight.width; j++) {
            this.sidebarRight.pixels[(currentPos + i - (this.sidebarUp.width))*this.sidebarRight.width+j] = newCol;
          }
        }
      
        if ((currentPos + i - (this.sidebarUp.width+this.sidebarRight.height)) > 0 && (currentPos + i - (this.sidebarUp.width+this.sidebarRight.height)) < this.sidebarDown.width) {
          for (int j=0; j<this.sidebarDown.height; j++) {
            this.sidebarDown.pixels[this.sidebarDown.pixels.length - ((currentPos + i - (this.sidebarUp.width+this.sidebarRight.height))+this.sidebarDown.width*j)] = newCol;
          }
        }
      
        if ((currentPos + i - (this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width)) > 0 && (currentPos + i - (this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width)) < this.sidebarLeft.height) {
          for (int j=0; j<this.sidebarLeft.width; j++) {
            this.sidebarLeft.pixels[this.sidebarLeft.pixels.length - ((currentPos + i - (this.sidebarUp.width+this.sidebarRight.height+this.sidebarDown.width))*this.sidebarLeft.width+j)] = newCol;
          }
        }
      }
    }
  }
  
  public void simuDraw_rackLight_fastBuildup(int col) {
    simuDraw_rackLight_Buildup(col, SIMU_RACK_FAST_BUILDUP_SPEED);
  }
  public void simuDraw_rackLight_mediumBuildup(int col) {
    simuDraw_rackLight_Buildup(col, SIMU_RACK_MEDIUM_BUILDUP_SPEED);
  }
  public void simuDraw_rackLight_slowBuildup(int col) {
    simuDraw_rackLight_Buildup(col, SIMU_RACK_SLOW_BUILDUP_SPEED);
  }
  public void simuDraw_rackLight_verySlowBuildup(int col) {
    simuDraw_rackLight_Buildup(col, SIMU_RACK_VERYSLOW_BUILDUP_SPEED);
  }
  public void simuDraw_rackLight_Buildup(int col, float speed) {
    for (int i=0; i<this.sidebarUp.width*this.sidebarUp.height; i++) {
      this.sidebarUp.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarRight.width*this.sidebarRight.height; i++) {
      this.sidebarRight.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarDown.width*this.sidebarDown.height; i++) {
      this.sidebarDown.pixels[i] = 0;
    }
    for (int i=0; i<this.sidebarLeft.width*this.sidebarLeft.height; i++) {
      this.sidebarLeft.pixels[i] = 0;
    }

    int maxBuildupProgress = PApplet.parseInt(min(this.animProgress*speed,this.sidebarUp.width - 1)); 
    for (int i=0; i<maxBuildupProgress; i++) {
      for (int j=0; j<this.sidebarUp.height; j++) {
        this.sidebarUp.pixels[(i + j*this.sidebarUp.width)] = col;
      }
    }

    maxBuildupProgress = PApplet.parseInt(min(this.animProgress*speed - this.sidebarUp.width,this.sidebarRight.height - 1));
    for (int i=0; i<maxBuildupProgress; i++) {
      for (int j=0; j<this.sidebarRight.width; j++) {
        this.sidebarRight.pixels[(i*this.sidebarRight.width + j)] = col;
      }
    }
    
    maxBuildupProgress = PApplet.parseInt(min(this.animProgress*speed - this.sidebarUp.width - this.sidebarRight.height,this.sidebarDown.width - 1)); 
    for (int i=0; i<maxBuildupProgress; i++) {
      for (int j=0; j<this.sidebarDown.height; j++) {
        this.sidebarDown.pixels[this.sidebarDown.pixels.length - 1 - (i + j*this.sidebarDown.width)] = col;
      }
    }
    
    maxBuildupProgress = PApplet.parseInt(min(this.animProgress*speed - this.sidebarUp.width - this.sidebarRight.height - this.sidebarDown.width,this.sidebarRight.height - 1)); 
    for (int i=0; i<maxBuildupProgress; i++) {
      for (int j=0; j<this.sidebarLeft.width; j++) {
        this.sidebarLeft.pixels[this.sidebarLeft.pixels.length - 1 - (i*this.sidebarLeft.width + j)] = col;
      }
    }
  }
  
  
  public void simuDraw_rackLight_noise(int col) {
    for (int i=0; i<this.sidebarUp.width;i++) {
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, random(1));
      for (int j=0; j<this.sidebarUp.height;j++) {
        this.sidebarUp.pixels[i+j*this.sidebarUp.width] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarRight.height;i++) {
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, random(1));
      for (int j=0; j<this.sidebarRight.width;j++) {
        this.sidebarRight.pixels[(this.sidebarRight.height - 1 - i)*this.sidebarRight.width+j] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarDown.width;i++) {
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, random(1));
      for (int j=0; j<this.sidebarDown.height;j++) {
        this.sidebarDown.pixels[((this.sidebarDown.width - 1 - i)+j*this.sidebarDown.width)] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarLeft.height;i++) {
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, random(1));
      for (int j=0; j<this.sidebarLeft.width;j++) {
        this.sidebarLeft.pixels[i*this.sidebarLeft.width+j] = newCol;
      }
    }
  }
  
  

  public void simuDraw_rackLight_fastSmoothNoise(int col) {
    simuDraw_rackLight_SmoothNoise(col, SIMU_RACK_FAST_SMOOTHNOISE_SPEED);
  }
  public void simuDraw_rackLight_slowSmoothNoise(int col) {
    simuDraw_rackLight_SmoothNoise(col, SIMU_RACK_SLOW_SMOOTHNOISE_SPEED); 
  }
  public void simuDraw_rackLight_SmoothNoise(int col, float factor) {
    for (int i=0; i<this.sidebarUp.width;i++) {
      float intensity = (0.5f + sin(factor*(i*i*i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarUp.height;j++) {
        this.sidebarUp.pixels[i+j*this.sidebarUp.width] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarRight.height;i++) {
      float intensity = (0.5f + sin(factor*((this.sidebarUp.width + i)*i*i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarRight.width;j++) {
        this.sidebarRight.pixels[(this.sidebarRight.height - 1 - i)*this.sidebarRight.width+j] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarDown.width;i++) {
      float intensity = (0.5f + sin(factor*((this.sidebarUp.width + this.sidebarRight.height + i)*i*i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarDown.height;j++) {
        this.sidebarDown.pixels[((this.sidebarDown.width - 1 - i)+j*this.sidebarDown.width)] = newCol;
      }
    }
        
    for (int i=0; i<this.sidebarLeft.height;i++) {
      float intensity = (0.5f + sin(factor*((this.sidebarUp.width + this.sidebarRight.height + this.sidebarDown.width + i)*i*i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.sidebarLeft.width;j++) {
        this.sidebarLeft.pixels[i*this.sidebarLeft.width+j] = newCol;
      }
    }
  }
}




////////////////////////////////////////////////
// LED Tubes

class LEDTube {
  
  int LEDTubeNumber;                //ID of the device
  int tubeWidth;
  int tubeHeight;
  int positionX;
  int positionY;
  
  int animProgress = 0;
  int executionCount = 0;
  int currentAnim = -1;
  
    
  PGraphics LEDTubeImage;
  PGraphics tubebarUp;
  
  
  LEDTube(int _LEDTubeNumber, int _tubeWidth, int _tubeHeight, int _positionX, int _positionY) {
    this.LEDTubeNumber = _LEDTubeNumber;
    this.tubeWidth       = _tubeWidth;
    this.tubeHeight      = _tubeHeight;
    this.positionX       = _positionX;
    this.positionY       = _positionY;
    
    this.LEDTubeImage = createGraphics(tubeWidth, tubeHeight);
    this.tubebarUp = createGraphics(tubeWidth,tubeHeight);
    
  }
  
  public void drawFullLEDTube(int LEDTubeAnimNbr, int additionalX, int additionalY) {
    if (currentAnim != LEDTubeAnimNbr) {
      this.animProgress = 0;
      this.currentAnim = LEDTubeAnimNbr;
    }
    else {
      this.animProgress += 1;
    }
    if (CustomDeviceList_LEDTubes.get(LEDTubeNumber).executionCount != this.executionCount) {
      this.executionCount = CustomDeviceList_LEDTubes.get(LEDTubeNumber).executionCount;
      this.animProgress = 0;
    }
    
    //Draw the foot of the LED tube
    computeBaseLEDTubeOutline();
    //Draw the big tube
    drawSpecificLEDTube(LEDTubeAnimNbr);
    

    //Draw the strips of LED on the side of the rack
    this.LEDTubeImage.beginDraw();
    this.LEDTubeImage.image(tubebarUp, 0, 0);
    this.LEDTubeImage.endDraw();
    
    auxControlFrame.image(this.LEDTubeImage, this.positionX + additionalX, this.positionY + additionalY);
  }
  
  public void computeBaseLEDTubeOutline() {
    this.LEDTubeImage.loadPixels();
    for (int i=0; i<this.LEDTubeImage.pixels.length; i++) {
      this.LEDTubeImage.pixels[i] = SIMU_COLOR_BLACK;
    }
    this.LEDTubeImage.updatePixels();
  }
  
  public void drawSpecificLEDTube(int rackLightAnimNbr) {
    
    this.tubebarUp.loadPixels();

    switch (this.currentAnim) {
      case CUSTOMDEV_ANIM_BLACKOUT                           : simuDraw_LEDTube_plainColor(SIMU_COLOR_BLACK);break;
      case CUSTOMDEV_ANIM_WHITEOUT                           : simuDraw_LEDTube_plainColor(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_REDOUT                             : simuDraw_LEDTube_plainColor(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_BLUEOUT                            : simuDraw_LEDTube_plainColor(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_RAINBOWOUT                         : simuDraw_LEDTube_plainColor(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_FASTWHITEFLASH                     : simuDraw_LEDTube_fastFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTWHITEFLASH_2                   : simuDraw_LEDTube_fastFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDFLASH                       : simuDraw_LEDTube_fastFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTREDFLASH_2                     : simuDraw_LEDTube_fastFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUEFLASH                      : simuDraw_LEDTube_fastFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTBLUEFLASH_2                    : simuDraw_LEDTube_fastFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWFLASH                   : simuDraw_LEDTube_fastFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTRAINBOWFLASH_2                 : simuDraw_LEDTube_fastFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWWHITEFLASH                     : simuDraw_LEDTube_slowFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWWHITEFLASH_2                   : simuDraw_LEDTube_slowFlash(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDFLASH                       : simuDraw_LEDTube_slowFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWREDFLASH_2                     : simuDraw_LEDTube_slowFlash(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUEFLASH                      : simuDraw_LEDTube_slowFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWBLUEFLASH_2                    : simuDraw_LEDTube_slowFlash(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWFLASH                   : simuDraw_LEDTube_slowFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWFLASH_2                 : simuDraw_LEDTube_slowFlash(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_SLOWWHITESMOOTHSINE                : simuDraw_LEDTube_slowSmoothSine(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDSMOOTHSINE                  : simuDraw_LEDTube_slowSmoothSine(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUESMOOTHSINE                 : simuDraw_LEDTube_slowSmoothSine(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHSINE              : simuDraw_LEDTube_fastSmoothSine(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTWHITESMOOTHSINE                : simuDraw_LEDTube_fastSmoothSine(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDSMOOTHSINE                  : simuDraw_LEDTube_fastSmoothSine(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUESMOOTHSINE                 : simuDraw_LEDTube_fastSmoothSine(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHSINE              : simuDraw_LEDTube_fastSmoothSine(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_FASTWHITESTROBOSCOPE               : simuDraw_LEDTube_fastStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDSTROBOSCOPE                 : simuDraw_LEDTube_fastStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUESTROBOSCOPE                : simuDraw_LEDTube_fastStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRANDOMSTROBOSCOPE              : simuDraw_LEDTube_fastStrobo(color(random(255),255,255));break;
      case CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE        : simuDraw_LEDTube_fastGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTGROWINGWHITESTROBOSCOPE_2      : simuDraw_LEDTube_fastGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE          : simuDraw_LEDTube_fastGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTGROWINGREDSTROBOSCOPE_2        : simuDraw_LEDTube_fastGrowingStrobo(SIMU_COLOR_RED);break;
      
      case CUSTOMDEV_ANIM_MEDIUMWHITESTROBOSCOPE             : simuDraw_LEDTube_mediumStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMREDSTROBOSCOPE               : simuDraw_LEDTube_mediumStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMBLUESTROBOSCOPE              : simuDraw_LEDTube_mediumStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_MEDIUMRANDOMSTROBOSCOPE            : simuDraw_LEDTube_mediumStrobo(Color.HSBtoRGB(random(1),1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE      : simuDraw_LEDTube_mediumGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGWHITESTROBOSCOPE_2    : simuDraw_LEDTube_mediumGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE        : simuDraw_LEDTube_mediumGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMGROWINGREDSTROBOSCOPE_2      : simuDraw_LEDTube_mediumGrowingStrobo(SIMU_COLOR_RED);break;
      
      case CUSTOMDEV_ANIM_SLOWWHITESTROBOSCOPE               : simuDraw_LEDTube_slowStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDSTROBOSCOPE                 : simuDraw_LEDTube_slowStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUESTROBOSCOPE                : simuDraw_LEDTube_slowStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRANDOMSTROBOSCOPE              : simuDraw_LEDTube_slowStrobo(Color.HSBtoRGB(random(1),1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE        : simuDraw_LEDTube_slowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWGROWINGWHITESTROBOSCOPE_2      : simuDraw_LEDTube_slowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE          : simuDraw_LEDTube_slowGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWGROWINGREDSTROBOSCOPE_2        : simuDraw_LEDTube_slowGrowingStrobo(SIMU_COLOR_RED);break;  
      
      case CUSTOMDEV_ANIM_VERYSLOWWHITESTROBOSCOPE           : simuDraw_LEDTube_verySlowStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWREDSTROBOSCOPE             : simuDraw_LEDTube_verySlowStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWBLUESTROBOSCOPE            : simuDraw_LEDTube_verySlowStrobo(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_VERYSLOWRANDOMSTROBOSCOPE          : simuDraw_LEDTube_verySlowStrobo(Color.HSBtoRGB(random(1),1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE    : simuDraw_LEDTube_verySlowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGWHITESTROBOSCOPE_2  : simuDraw_LEDTube_verySlowGrowingStrobo(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE      : simuDraw_LEDTube_verySlowGrowingStrobo(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWGROWINGREDSTROBOSCOPE_2    : simuDraw_LEDTube_verySlowGrowingStrobo(SIMU_COLOR_RED);break;
      
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE         : simuDraw_LEDTube_singleShortUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTUPWARDWAVE_2       : simuDraw_LEDTube_singleShortUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE           : simuDraw_LEDTube_singleShortUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTUPWARDWAVE_2         : simuDraw_LEDTube_singleShortUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE          : simuDraw_LEDTube_singleShortUpwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTUPWARDWAVE_2        : simuDraw_LEDTube_singleShortUpwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE          : simuDraw_LEDTube_singleLongUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGUPWARDWAVE_2        : simuDraw_LEDTube_singleLongUpwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE            : simuDraw_LEDTube_singleLongUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGUPWARDWAVE_2          : simuDraw_LEDTube_singleLongUpwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE           : simuDraw_LEDTube_singleLongUpwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGUPWARDWAVE_2         : simuDraw_LEDTube_singleLongUpwardWave(SIMU_COLOR_BLUE);break;
      
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE       : simuDraw_LEDTube_singleShortDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITESHORTDOWNWARDWAVE_2     : simuDraw_LEDTube_singleShortDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE         : simuDraw_LEDTube_singleShortDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDSHORTDOWNWARDWAVE_2       : simuDraw_LEDTube_singleShortDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE        : simuDraw_LEDTube_singleShortDownwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUESHORTDOWNWARDWAVE_2      : simuDraw_LEDTube_singleShortDownwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE        : simuDraw_LEDTube_singleLongDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEWHITELONGDOWNWARDWAVE_2      : simuDraw_LEDTube_singleLongDownwardWave(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE          : simuDraw_LEDTube_singleLongDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEREDLONGDOWNWARDWAVE_2        : simuDraw_LEDTube_singleLongDownwardWave(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE         : simuDraw_LEDTube_singleLongDownwardWave(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SINGLEBLUELONGDOWNWARDWAVE_2       : simuDraw_LEDTube_singleLongDownwardWave(SIMU_COLOR_BLUE);break;
      
      case CUSTOMDEV_ANIM_FASTWHITEBUILDUP                   : simuDraw_LEDTube_fastBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTWHITEBUILDUP_2                 : simuDraw_LEDTube_fastBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDBUILDUP                     : simuDraw_LEDTube_fastBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTREDBUILDUP_2                   : simuDraw_LEDTube_fastBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUEBUILDUP                    : simuDraw_LEDTube_fastBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTBLUEBUILDUP_2                  : simuDraw_LEDTube_fastBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP                 : simuDraw_LEDTube_fastBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTRAINBOWBUILDUP_2               : simuDraw_LEDTube_fastBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP                 : simuDraw_LEDTube_mediumBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMWHITEBUILDUP_2               : simuDraw_LEDTube_mediumBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_MEDIUMREDBUILDUP                   : simuDraw_LEDTube_mediumBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMREDBUILDUP_2                 : simuDraw_LEDTube_mediumBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP                  : simuDraw_LEDTube_mediumBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_MEDIUMBLUEBUILDUP_2                : simuDraw_LEDTube_mediumBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP               : simuDraw_LEDTube_mediumBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_MEDIUMRAINBOWBUILDUP_2             : simuDraw_LEDTube_mediumBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_SLOWWHITEBUILDUP                   : simuDraw_LEDTube_slowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWWHITEBUILDUP_2                 : simuDraw_LEDTube_slowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_SLOWREDBUILDUP                     : simuDraw_LEDTube_slowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWREDBUILDUP_2                   : simuDraw_LEDTube_slowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUEBUILDUP                    : simuDraw_LEDTube_slowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWBLUEBUILDUP_2                  : simuDraw_LEDTube_slowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP                 : simuDraw_LEDTube_slowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWBUILDUP_2               : simuDraw_LEDTube_slowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP               : simuDraw_LEDTube_verySlowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWWHITEBUILDUP_2             : simuDraw_LEDTube_verySlowBuildup(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP                 : simuDraw_LEDTube_verySlowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWREDBUILDUP_2               : simuDraw_LEDTube_verySlowBuildup(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP                : simuDraw_LEDTube_verySlowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_VERYSLOWBLUEBUILDUP_2              : simuDraw_LEDTube_verySlowBuildup(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP             : simuDraw_LEDTube_verySlowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_VERYSLOWRAINBOWBUILDUP_2           : simuDraw_LEDTube_verySlowBuildup(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_WHITENOISE                         : simuDraw_LEDTube_noise(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_REDNOISE                           : simuDraw_LEDTube_noise(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_BLUENOISE                          : simuDraw_LEDTube_noise(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_RAINBOWNOISE                       : simuDraw_LEDTube_noise(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      
      case CUSTOMDEV_ANIM_SLOWWHITESMOOTHNOISE               : simuDraw_LEDTube_slowSmoothNoise(SIMU_COLOR_WHITE);break;     
      case CUSTOMDEV_ANIM_SLOWREDSMOOTHNOISE                 : simuDraw_LEDTube_slowSmoothNoise(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_SLOWBLUESMOOTHNOISE                : simuDraw_LEDTube_slowSmoothNoise(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_SLOWRAINBOWSMOOTHNOISE             : simuDraw_LEDTube_slowSmoothNoise(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
      case CUSTOMDEV_ANIM_FASTWHITESMOOTHNOISE               : simuDraw_LEDTube_fastSmoothNoise(SIMU_COLOR_WHITE);break;
      case CUSTOMDEV_ANIM_FASTREDSMOOTHNOISE                 : simuDraw_LEDTube_fastSmoothNoise(SIMU_COLOR_RED);break;
      case CUSTOMDEV_ANIM_FASTBLUESMOOTHNOISE                : simuDraw_LEDTube_fastSmoothNoise(SIMU_COLOR_BLUE);break;
      case CUSTOMDEV_ANIM_FASTRAINBOWSMOOTHNOISE             : simuDraw_LEDTube_fastSmoothNoise(Color.HSBtoRGB(((auxControlFrame.frameCount/RAINBOW_FACTOR)%255)/255.0f,1.0f,1.0f));break;
    }
    
    this.tubebarUp.updatePixels();
  }
  
  public void simuDraw_LEDTube_plainColor(int col) {
    for (int i=0; i<this.tubebarUp.pixels.length;i++) {
      this.tubebarUp.pixels[i] = col;
    }
  }
  
  public void simuDraw_LEDTube_fastFlash(int col) {
    simuDraw_LEDTube_flash(col, SIMU_FAST_FLASH_FACTOR);
  }
  public void simuDraw_LEDTube_slowFlash(int col) {
    simuDraw_LEDTube_flash(col, SIMU_SLOW_FLASH_FACTOR);
  }
    
  public void simuDraw_LEDTube_flash(int col, int factor) {
    int newCol = Color.HSBtoRGB(hue(col)/255.0f,saturation(col)/255.0f,max(PApplet.parseInt(brightness(col)-this.animProgress*factor), 0)/255.0f);
    simuDraw_LEDTube_plainColor(newCol);
  }
  
  public void simuDraw_LEDTube_slowSmoothSine(int col) {
    simuDraw_LEDTube_SmoothSine(col, SIMU_RACK_SLOW_SMOOTHSINE_FACTOR);
  }
  public void simuDraw_LEDTube_fastSmoothSine(int col) {
    simuDraw_LEDTube_SmoothSine(col, SIMU_RACK_FAST_SMOOTHSINE_FACTOR);
  }
  
  public void simuDraw_LEDTube_SmoothSine(int col, float factor) {    
    for (int i=0; i<this.tubebarUp.height;i++) {
      float intensity = (0.5f + sin(factor*(i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.tubebarUp.width;j++) {
        this.tubebarUp.pixels[i*this.tubebarUp.width+j] = newCol;
      }
    }    
  }
  
  public void simuDraw_LEDTube_fastStrobo(int col) {
    simuDraw_LEDTube_strobo(col, SIMU_FAST_STROBE_PERIOD);
  }
  public void simuDraw_LEDTube_mediumStrobo(int col) {
    simuDraw_LEDTube_strobo(col, SIMU_MEDIUM_STROBE_PERIOD);
  }
  public void simuDraw_LEDTube_slowStrobo(int col) {
    simuDraw_LEDTube_strobo(col, SIMU_SLOW_STROBE_PERIOD);
  }
  public void simuDraw_LEDTube_verySlowStrobo(int col) {
    simuDraw_LEDTube_strobo(col, SIMU_VERYSLOW_STROBE_PERIOD);
  }
  public void simuDraw_LEDTube_fastGrowingStrobo(int col) {
    simuDraw_LEDTube_growingStrobo(col, SIMU_FAST_GROWINGSTROBE_FACTOR);
  }
  public void simuDraw_LEDTube_mediumGrowingStrobo(int col) {
    simuDraw_LEDTube_growingStrobo(col, SIMU_MEDIUM_GROWINGSTROBE_FACTOR);
  }
  public void simuDraw_LEDTube_slowGrowingStrobo(int col) {
    simuDraw_LEDTube_growingStrobo(col, SIMU_SLOW_GROWINGSTROBE_FACTOR);
  }
  public void simuDraw_LEDTube_verySlowGrowingStrobo(int col) {
    simuDraw_LEDTube_growingStrobo(col, SIMU_VERYSLOW_GROWINGSTROBE_FACTOR);
  }

  
  public void simuDraw_LEDTube_strobo(int col, int flashPeriod) {
    if (auxControlFrame.frameCount % flashPeriod == 0) {
      simuDraw_LEDTube_plainColor(col);
    }
    else {
      simuDraw_LEDTube_plainColor(SIMU_COLOR_BLACK);
    }
  }
  
  public void simuDraw_LEDTube_growingStrobo(int col, int factor) {
    int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, min(this.animProgress*factor, 255)/255.0f);
    if (auxControlFrame.frameCount % 2 == 0) {
      simuDraw_LEDTube_plainColor(newCol);
    }
    else {
      simuDraw_LEDTube_plainColor(SIMU_COLOR_BLACK);
    }
  }

  public void simuDraw_LEDTube_singleShortUpwardWave(int col) {
    simuDraw_LEDTube_singleUpwardWave(col, SIMU_RACK_SHORT_WAVE_LENGTH);
  }
  public void simuDraw_LEDTube_singleLongUpwardWave(int col) {
    simuDraw_LEDTube_singleUpwardWave(col, SIMU_RACK_LONG_WAVE_LENGTH);
  }
  public void simuDraw_LEDTube_singleUpwardWave(int col, float waveLength) {
    for (int i=0; i<this.tubebarUp.width*this.tubebarUp.height; i++) {
      this.tubebarUp.pixels[i] = 0;
    }
    
    int currentPos = this.animProgress*SIMU_RACK_FAST_WAVE_SPEED;
    //Don't even check the pixels if currentPos is too far ahead
    if (currentPos < (this.tubebarUp.height+100)) {
      for (int i=0; i<waveLength; i++) {
        float intensity = (1- i/waveLength);   
        int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
  
        if ((currentPos - i) > 0 && (currentPos - i) < this.tubebarUp.height) {
          for (int j=0; j<this.tubebarUp.width; j++) {
            this.tubebarUp.pixels[this.tubebarUp.pixels.length - ((currentPos - i)*this.tubebarUp.width+j)] = newCol;
          }
        }
      }
    }
  }
  
  public void simuDraw_LEDTube_singleShortDownwardWave(int col) {
    simuDraw_LEDTube_singleDownwardWave(col, SIMU_RACK_SHORT_WAVE_LENGTH);
  }
  public void simuDraw_LEDTube_singleLongDownwardWave(int col) {
    simuDraw_LEDTube_singleDownwardWave(col, SIMU_RACK_LONG_WAVE_LENGTH);
  }
  public void simuDraw_LEDTube_singleDownwardWave(int col, float waveLength) {
    for (int i=0; i<this.tubebarUp.width*this.tubebarUp.height; i++) {
      this.tubebarUp.pixels[i] = 0;
    }
    
    int currentPos = this.tubebarUp.height - this.animProgress*SIMU_RACK_FAST_WAVE_SPEED;
    //Don't even check the pixels if currentPos is too far ahead
    if (currentPos < (this.tubebarUp.height+100)) {
      for (int i=0; i<waveLength; i++) {
        float intensity = (1- i/waveLength);   
        int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
  
      
        if ((currentPos + i) > 0 && (currentPos + i) < this.tubebarUp.height) {
          for (int j=0; j<this.tubebarUp.width; j++) {
            this.tubebarUp.pixels[this.tubebarUp.pixels.length - ((currentPos + i)*this.tubebarUp.width+j)] = newCol;
          }
        }
      }
    }
  }
  
  public void simuDraw_LEDTube_fastBuildup(int col) {
    simuDraw_LEDTube_Buildup(col, SIMU_RACK_FAST_BUILDUP_SPEED);
  }
  public void simuDraw_LEDTube_mediumBuildup(int col) {
    simuDraw_LEDTube_Buildup(col, SIMU_RACK_MEDIUM_BUILDUP_SPEED);
  }
  public void simuDraw_LEDTube_slowBuildup(int col) {
    simuDraw_LEDTube_Buildup(col, SIMU_RACK_SLOW_BUILDUP_SPEED);
  }
  public void simuDraw_LEDTube_verySlowBuildup(int col) {
    simuDraw_LEDTube_Buildup(col, SIMU_RACK_VERYSLOW_BUILDUP_SPEED);
  }
  public void simuDraw_LEDTube_Buildup(int col, float speed) {
    for (int i=0; i<this.tubebarUp.width*this.tubebarUp.height; i++) {
      this.tubebarUp.pixels[i] = 0;
    }
        
    int maxBuildupProgress = PApplet.parseInt(min(this.animProgress*speed,this.tubebarUp.height - 1)); 
    for (int i=0; i<maxBuildupProgress; i++) {
      for (int j=0; j<this.tubebarUp.width; j++) {
        this.tubebarUp.pixels[this.tubebarUp.pixels.length - 1 - (i*this.tubebarUp.width + j)] = col;
      }
    }
    
  }
  
  public void simuDraw_LEDTube_noise(int col) {
    for (int i=0; i<this.tubebarUp.height;i++) {
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, random(1));
      for (int j=0; j<this.tubebarUp.width;j++) {
        this.tubebarUp.pixels[i*this.tubebarUp.width+j] = newCol;
      }
    }
  }

  public void simuDraw_LEDTube_fastSmoothNoise(int col) {
    simuDraw_LEDTube_SmoothNoise(col, SIMU_RACK_FAST_SMOOTHNOISE_SPEED);
  }
  public void simuDraw_LEDTube_slowSmoothNoise(int col) {
    simuDraw_LEDTube_SmoothNoise(col, SIMU_RACK_SLOW_SMOOTHNOISE_SPEED); 
  }
  public void simuDraw_LEDTube_SmoothNoise(int col, float factor) {
    
    for (int i=0; i<this.tubebarUp.height;i++) {
      float intensity = (0.5f + sin(factor*(i*i*i+this.animProgress))/2);
      int newCol = Color.HSBtoRGB(hue(col)/255.0f, saturation(col)/255.0f, intensity);
      for (int j=0; j<this.tubebarUp.width;j++) {
        this.tubebarUp.pixels[i*this.tubebarUp.width+j] = newCol;
      }
    }
  }
}
///////////////////////////////////////
///Execute the requested animation ///
///////////////////////////////////////

//Parameters used for manual animations (similar to the ones used in auto mode, but individually switchable using the configuration file)
boolean authorizeGeneralManualMode       = true;
boolean authorizeStrobeManualMode4th     = true;
boolean authorizeStrobeManualMode8th     = true;
boolean authorizeStrobeManualMode16th    = true;
boolean authorizeStrobeManualMode32nd    = true;
boolean authorizeStrobeManualMode64th    = true;
boolean authorizeKillLedPanelManualMode  = true;
boolean authorizeBlackOutManualMode      = true;
boolean authorizeWhiteOutManualMode      = true;
boolean authorizeShredderManualMode      = true; 
boolean authorizeWhiteJamaMonoManualMode = false;
boolean authorizeColorChangeManualMode   = true;
boolean authorizeWhiteNoiseManualMode    = true;
boolean authorizeDMXStrobe               = true;
boolean authorizePanelStrobe             = true;
boolean authorizeRMXControl              = false;

boolean setStrobeManualMode4th           = false;
boolean setStrobeManualMode8th           = false;
boolean setStrobeManualMode16th          = false;
boolean setStrobeManualMode32nd          = false;
boolean setStrobeManualMode64th          = false;
boolean setKillLedPanelManualMode        = false;
boolean setBlackOutManualMode            = false;
int blackoutPowerManualMode              = 0;
boolean setWhiteOutManualMode            = false;
int whiteoutPowerManualMode              = 0;
boolean setShredderManualMode            = false; 
int shredderPowerManualMode              = 0;
boolean setWhiteJamaMonoManualMode       = false;
int whiteJamaMonoPowerManualMode         = 0;
boolean setColorChangeManualMode         = false;
int colorChangePowerManualMode           = 0;
boolean setWhiteNoiseManualMode          = false;
int whiteNoisePowerManualMode            = 0;

//Boolean set when an effect is to be drawn (as part of the classic manual mode)
boolean effectToBeDrawn = false;
int currentEffectNumber = -1;
int effectNumberToDeactivateEffects = -1;

public void actionControlled_preSpecificDraw() {
  if (authorizeGeneralManualMode == true) {
    if (setShredderManualMode == true) {
      draw_AutoModeShredder(shredderPowerManualMode);
    }
  }
}

public void actionControlled_postSpecificDraw() {
  if (authorizeStrobeManualMode4th == true) {
    if (setStrobeManualMode4th == true) {
      draw_stroboAutoPad(COLORSET_WHITE, 120, 1);
    }
  }
  if (authorizeStrobeManualMode8th == true) {
    if (setStrobeManualMode8th == true) {
      draw_stroboAutoPad(COLORSET_WHITE, 120, 2);
    }
  }
  if (authorizeStrobeManualMode16th == true) {
    if (setStrobeManualMode16th == true) {
      draw_stroboAutoPad(COLORSET_WHITE, 120, 4);        
    }
  }
  if (authorizeStrobeManualMode32nd == true) {
    if (setStrobeManualMode32nd == true) {
      draw_stroboAutoPad(COLORSET_WHITE, 120, 8);
    }
  }
  if (authorizeStrobeManualMode64th == true) {
    if (setStrobeManualMode64th == true) {
      draw_stroboAutoPad(COLORSET_WHITE, 120, 8);
    }
  }
    
  if (authorizeBlackOutManualMode == true) {
    if (setBlackOutManualMode == true) {
      draw_AutoModeBlackOut(blackoutPowerManualMode);
    }
  }
  if (authorizeWhiteOutManualMode == true) {
    if (setWhiteOutManualMode == true) {
      draw_AutoModeWhiteOut(whiteoutPowerManualMode);
    }
  }
  if (authorizeColorChangeManualMode == true) {  
    if (setColorChangeManualMode == true) {
      draw_AutoModeColorChange();
    }
  }
  if (authorizeWhiteJamaMonoManualMode == true) {
    if (setWhiteJamaMonoManualMode == true) {
      draw_whiteJamaMono(whiteJamaMonoPowerManualMode);
    }
  }
  if (authorizeWhiteNoiseManualMode == true) {
    if (setWhiteNoiseManualMode == true) {
      draw_whiteNoiseEffect(whiteNoisePowerManualMode);
    }
  }
  //Effects controlled by the RMX
  if (authorizeRMXControl == true) {
    //A Pong game is actually going on - the FX knobs hold different meanings here
    if (animationnumber == 394) {
    }
    //We're not playing a game, do the regular stuff
    else {  
      executeRMXSpecificAnimations();
    }
  }
  if (authorizeKillLedPanelManualMode == true) {
    if (setKillLedPanelManualMode == true) {
      draw_killLedPanels();
    }
  }
  
}

public void specific_draw() {
  
  if (drawImage == 1)                     //Draw the image whose filename is specified by imagenumber
  {
    draw_image();
  }
    
  if (drawAnimation == 1) 
  {
    switch(animationnumber) {
      case   1: draw_blackout();break;                             //BlackOut
      case   2: draw_whiteout();break;                             //WhiteOut
      case   3: draw_wideflash();break;                            //WideFlash
      case   4: draw_longwideflash();break;                        //LongWideFlash
      case   5: draw_flashextremeleft();break;                     //FlashExtremeLeft
      case   6: draw_flashleft();break;                            //FlashLeft
      case   7: draw_flashcenter();break;                          //FlashCenter
      case   8: draw_flashright();break;                           //FlashRight
      case   9: draw_flashextremeright();break;                    //FlashExtremeRight
      case  10: draw_wideflashred();break;                         //WideFlashRed
      case  11: draw_flashextremeleftred();break;                  //FlashExtremeLeftRed
      case  12: draw_flashleftred();break;                         //FlashLeftRed
      case  13: draw_flashcenterred();break;                       //FlashCenterRed
      case  14: draw_flashrightred();break;                        //FlashRightRed
      case  15: draw_flashextremerightred();break;                 //FlashExtremeRightRed
      case  16: draw_fadeoutextremeleft();break;                   //FadeoutExtremeLeft
      case  17: draw_fadeoutleft();break;                          //FadeoutLeft
      case  18: draw_fadeoutcenter();break;                        //FadeoutCenter
      case  19: draw_fadeoutright();break;                         //FadeoutRight
      case  20: draw_fadeoutextremeright();break;                  //FadeoutExtremeRight
      case  21: draw_fadeout();break;                              //Fadeout
      case  22: draw_fadein();break;                               //Fadein
      case  23: draw_fillextremelowleft();break;                   //ExtremeLowLeft
      case  24: draw_fillextremehileft();break;                    //ExtremeHiLeft
      case  25: draw_filllowleft();break;                          //LowLeft
      case  26: draw_fillhileft();break;                           //HiLeft
      case  27: draw_filllowmid();break;                           //LowMid
      case  28: draw_fillhimid();break;                            //HiMid
      case  29: draw_filllowright();break;                         //LowRight
      case  30: draw_fillhiright();break;                          //HiRight
      case  31: draw_fillextremelowright();break;                  //ExtremeLowRight
      case  32: draw_fillextremehiright();break;                   //ExtremeHiRight
      case  33: draw_panelfillleft();break;                        //PanelFillLeft
      case  34: draw_panelfillcenter();break;                      //PanelFillCenter
      case  35: draw_panelfillright();break;                       //PanelFillRight
      case  36: draw_panelfillline();break;                        //PanelFillLine
      case  37: draw_oppositelinesnobackground();break;            //OppositeLinesNoBackground
      case  38: draw_openinglines();break;                         //OpeningLines
      case  39: draw_openinglines();break;                         //OpeningLinesReinit
      case  40: draw_linewideflash();break;                        //LineWideFlash
      case  41: draw_lineleftflash();break;                        //LineLeftFlash
      case  42: draw_linecenterflash();break;                      //LineCenterFlash
      case  43: draw_linerightflash();break;                       //LineRightFlash
      case  44: draw_upwards_line_whiteout();break;                //Upwards Line White Out
      case  45: draw_upwards_line();break;                         //Upwards Line
      case  46: draw_lines1();break;                               //Lines 1
      case  47: draw_lines2();break;                               //Lines 2
      case  48: draw_lines3();break;                               //Lines 3
      case  49: draw_lines4();break;                               //Lines 4
      case  50: draw_lines5();break;                               //Lines 5
      case  51: draw_lines6();break;                               //Lines 6
      case  52: draw_lines7();break;                               //Lines 7
      case  53: draw_lines8();break;                               //Lines 8
      case  54: draw_lines9();break;                               //Lines 9
      case  55: draw_lines10();break;                              //Lines 10
      case  56: draw_unfoldinglines();break;                       //Unfolding Lines
      case  57: draw_mugen();break;                                //Mugen
      case  58: draw_turningsinglelines();break;                   //TurningSingleLines
      case  59: draw_randomappearinglines();break;                 //RandomAppearingLines
      case  60: draw_nonotak_1();break;                            //Nonotak 1
      case  61: draw_nonotak_2();break;                            //Nonotak 2
      case  62: draw_nonotak_3();break;                            //Nonotak 3
      case  63: draw_nonotak_4();break;                            //Nonotak 4
      case  64: draw_nonotak_5();break;                            //Nonotak 5
      case  65: draw_nonotakPanelFill();break;                     //NonotakPanelFill - ExtremeLeft
      case  66: draw_nonotakPanelFill();break;                     //NonotakPanelFill - Left
      case  67: draw_nonotakPanelFill();break;                     //NonotakPanelFill - Center
      case  68: draw_nonotakPanelFill();break;                     //NonotakPanelFill - Right
      case  69: draw_nonotakPanelFill();break;                     //NonotakPanelFill - ExtremeRight
      case  70: draw_nonotakWoosh();break;                         //NonotakWoosh 1
      case  71: draw_nonotakWoosh();break;                         //NonotakWoosh 2
      case  72: draw_nonotakWoosh();break;                         //NonotakWoosh 3
      case  73: draw_nonotakWoosh();break;                         //NonotakWoosh 4
      case  74: draw_rotatingcut_black();break;                    //RotatingCut - B&W
      case  75: draw_rotatingcut_blue();break;                     //RotatingCut - Blue
      case  76: draw_rotatingcut_black_fast();break;               //RotatingCutFast - B&W
      case  77: draw_reddiagonallines();break;                     //RedDiagonalLines
      case  78: draw_bluediagonallines();break;                    //BlueDiagonalLines
      case  79: draw_bluediagonallines2();break;                   //BlueDiagonalLines2
      case  80: draw_bluediagonallines3();break;                   //BlueDiagonalLines3
      case  81: draw_reddiagonallines2();break;                    //RedDiagonalLines2
      case  82: draw_whitediagonallines();break;                   //WhiteDiagonalLines
      case  83: draw_whitediagonallines2();break;                  //WhiteDiagonalLines2
      case  84: draw_whitestraightlines();break;                   //WhiteStraightLines
      case  85: draw_star(2);break;                                //Star - 2 sides
      case  86: draw_star(3);break;                                //Star - 3 sides
      case  87: draw_star(4);break;                                //Star - 4 sides
      case  88: draw_star(6);break;                                //Star - 6 sides
      case  89: draw_star(8);break;                                //Star - 8 sides
      case  90: draw_rotating_circles();break;                     //Rotating Circles
      case  91: draw_jointcircles();break;                         //JointCircles
      case  92: draw_parallelworlds();break;                       //ParallelWorlds - Regular
      case  93: draw_parallelworlds();break;                       //ParallelWorlds - Slow
      case  94: draw_parallelworlds();break;                       //ParallelWorlds - RedFlash
      case  95: draw_parallelworlds();break;                       //ParallelWorlds - Reverse
      case  96: draw_multicrecy();break;                           //MultiCrecy - Very low Intensity      
      case  97: draw_multicrecy();break;                           //MultiCrecy - Low Intensity
      case  98: draw_multicrecy();break;                           //MultiCrecy - Medium Intensity
      case  99: draw_multicrecy();break;                           //MultiCrecy - High Intensity
      case 100: draw_multicrecy();break;                           //MultiCrecy - Hardcore Intensity
      case 101: draw_multicrecy();break;                           //MultiCrecy - Double Intensity
      case 102: draw_multicrecy();break;                           //MultiCrecy - Refrain
      case 103: draw_snake1();break;                               //Snake - 1
      case 104: draw_snake2();break;                               //Snake - 2
      case 105: draw_snake3();break;                               //Snake - 3
      case 106: draw_snake4();break;                               //Snake - 4
      case 107: draw_snake5();break;                               //Snake - 5
      case 108: draw_snake6();break;                               //Snake - 6  
      case 109: draw_movingsine();break;                           //MovingSine
      case 110: draw_carglass();break;                             //Carglass        
      case 111: draw_va_et_vient_1();break;                        //Va et vient - Vertical
      case 112: draw_va_et_vient_2();break;                        //Va et vient - Horizontal
      case 113: draw_horizontal_impulsewhiterectangle();break;     //ImpulseWhiteRectangle - Horizontal
      case 114: draw_vertical_impulsewhiterectangle();break;       //ImpulseWhiteRectangle - Vertical
      case 115: draw_horizontal_impulseredrectangle();break;       //ImpulseRedRectangle - Horizontal
      case 116: draw_vertical_impulseredrectangle();break;         //ImpulseRedRectangle - Vertical
      case 117: draw_mixedlines(0,2,0);break;                      //MixedLines1
      case 118: draw_mixedlines(2,0,0);break;                      //MixedLines2
      case 119: draw_mixedlines(1,3,0);break;                      //MixedLines3
      case 120: draw_mixedlines(3,1,0);break;                      //MixedLines4
      case 121: draw_mixedlines(1,2,0);break;                      //MixedLines5
      case 122: draw_mixedlines(2,3,0);break;                      //MixedLines6
      case 123: draw_mixedlines(1,3,2);break;                      //MixedLines7
      case 124: draw_mixedlines(3,1,2);break;                      //MixedLines8
      case 125: draw_mixedlines(0,0,1);break;                      //MixedLines9
      case 126: draw_mixedlines(0,0,2);break;                      //MixedLines10
      case 127: draw_mixedlines(0,0,3);break;                      //MixedLines11
      case 128: draw_mixedlines(0,0,4);break;                      //MixedLines12
      case 129: draw_mixedlines(0,0,5);break;                      //MixedLines13
      case 130: draw_mixedlines(0,0,6);break;                      //MixedLines14
      case 131: draw_upwardsglitchlines();break;                   //UpwardsGlitchLines
      case 132: draw_diagonalglitchlines();break;                  //DiagonalGlitchLines
      case 133: draw_compressedlines();break;                      //CompressedLines
      case 134: draw_upwardsglitchmixedlines();break;              //UpwardsGlitchMixedLines
      case 135: draw_upwardsglitchmixedlines2();break;             //UpwardsGlitchMixedLines2
      case 136: draw_growingtriangles();break;                     //GrowingTriangles
      case 137: draw_smallsquareleft();break;                      //SmallSquareLeft
      case 138: draw_smallsquarecenter();break;                    //SmallSquareCenter
      case 139: draw_smallsquareright();break;                     //SmallSquareRight
      case 140: draw_smallsquares();break;                         //SmallSquares
      case 141: draw_movinglines();break;                          //MovingLines
      case 142: draw_movingsquares();break;                        //MovingSquares
      case 143: draw_orbitingparticles();break;                    //OrbitingParticles
      case 144: draw_arrowstyle();break;                           //ArrowStyle
      case 145: draw_singlearrow();break;                          //SingleArrow - Up-Down White
      case 146: draw_singlearrow();break;                          //SingleArrow - Left-Right White
      case 147: draw_singlearrow();break;                          //SingleArrow - Right-Left White
      case 148: draw_singlearrow();break;                          //SingleArrow - Down-Up White
      case 149: draw_singlearrow();break;                          //SingleArrow - Up-Down Red
      case 150: draw_singlearrow();break;                          //SingleArrow - Left-Right Red
      case 151: draw_singlearrow();break;                          //SingleArrow - Right-Left Red
      case 152: draw_singlearrow();break;                          //SingleArrow - Down-Up Red
      case 153: draw_sweepingBallsAndArrow();break;                //SweepingBallsAndArrows
      case 154: draw_columns();break;                              //ColumnsWhite
      case 155: draw_columns();break;                              //ColumnsBlack
      case 156: draw_columnsred();break;                           //ColumnsWhiteRed
      case 157: draw_columnsred();break;                           //ColumnsBlackRed
      case 158: draw_continuoustriangles();break;                  //ContinuousTrianglesResync
      case 159: draw_continuoustriangles();break;                  //ContinuousTrianglesResyncInvert
      case 160: draw_continuoustriangles();break;                  //ContinuousTrianglesDrift
      case 161: draw_continuoustriangles();break;                  //ContinuousTrianglesDriftInvert
      case 162: draw_beatcircle();break;                           //BeatCircle
      case 163: draw_beatcirclelines();break;                      //BeatCircleLinesReinit
      case 164: draw_beatcirclelines();break;                      //BeatCircleLines
      case 165: draw_beatcirclecolorlines(1);break;                //BeatCircleColorLines1
      case 166: draw_beatcirclecolorlines(2);break;                //BeatCircleColorLines2
      case 167: draw_atoms();break;                                //Atoms - One Electron
      case 168: draw_atoms();break;                                //Atoms - Two Electrons
      case 169: draw_atoms();break;                                //Atoms - Three Electrons
      case 170: draw_perfectcircle();break;                        //PerfectCircle
      case 171: draw_tunnel();break;                               //TunnelWhite
      case 172: draw_tunnel();break;                               //TunnelRed
      case 173: draw_explodingcircle();break;                      //ExplodingCircle
      case 174: draw_explodingcircleleft();break;                  //ExplodingCircleLeft
      case 175: draw_explodingcircleright();break;                 //ExplodingCircleRight
      case 176: draw_colorwaves();break;                           //ColorWaves - Regular
      case 177: draw_colorwaves();break;                           //ColorWaves - Strong
      case 178: draw_glitch();break;                               //GlitchTriangle
      case 179: draw_glitch();break;                               //GlitchLine
      case 180: draw_barWavesWhite();break;                        //BarWaves - White
      case 181: draw_barWavesRed();break;                          //BarWaves - Red
      case 182: draw_barWavesBlue();break;                         //BarWaves - Blue
      case 183: draw_sinefuckedup(0);break;                        //FuckedUpSine1
      case 184: draw_sinefuckedup(1);break;                        //FuckedUpSine2
      case 185: draw_sinefuckedup(2);break;                        //FuckedUpSine3 - NO REINIT
      case 186: draw_sinefuckedup(2);break;                        //FuckedUpSine3
      case 187: draw_rotatingsquare();break;                       //RotatingSquare
      case 188: draw_mandala();break;                              //Mandala
      case 189: draw_mandala();break;                              //Mandala - change shape
      case 190: draw_clock();break;                                //Clock
      case 191: draw_invertexplode();break;                        //InvertExplode
      case 192: draw_crescent();break;                             //Crescent
      case 193: draw_trigoShapes();break;                          //TrigoShapes
      case 194: draw_newtonpendulum();break;                       //NewtonPendulum
      case 195: draw_circlepusher();break;                         //CirclePusherRotate
      case 196: draw_circlepusher();break;                         //CirclePusherStraight
      case 197: draw_patatap();break;                              //Patatap
      case 198: draw_patatap();break;                              //Patatap
      case 199: draw_patatap();break;                              //Patatap
      case 200: draw_patatap();break;                              //Patatap
      case 201: draw_patatap();break;                              //Patatap
      case 202: draw_patatap();break;                              //Patatap
      case 203: draw_patatap();break;                              //Patatap
      case 204: draw_patatap();break;                              //Patatap
      case 205: draw_patatap();break;                              //Patatap
      case 206: draw_patatap();break;                              //Patatap
      case 207: draw_patatap();break;                              //Patatap
      case 208: draw_patatap();break;                              //Patatap
      case 209: draw_patatap();break;                              //Patatap
      case 210: draw_patatap();break;                              //Patatap
      case 211: draw_patatap();break;                              //Patatap
      case 212: draw_patatap();break;                              //Patatap
      case 213: draw_patatapWithAudioInput();break;                //Patatap with audio input
      case 214: draw_shadows();break;                              //Shadows
      case 215: draw_spiraltriangle();break;                       //SpiralTriangle
      case 216: draw_pulsestar();break;                            //PulseStar
      case 217: draw_arrowshape();break;                           //ArrowShape
      case 218: draw_moire();break;                                //Moire
      case 219: draw_tumbler();break;                              //Tumbler
      case 220: draw_superformula();break;                         //Superformula
      case 221: draw_hypnoAudio();break;                           //HypnoAudio
      case 222: draw_hypnoAudio();break;                           //HypnoAudio - Without Audio (manual mode)
      case 223: draw_snow();break;                                 //Snow
      case 224: draw_initFlasher();break;                          //Intro - initFlasher
      case 225: draw_rain();break;                                 //Rain                 
      case 226: draw_whitenoise();break;                           //WhiteNoise
      case 227: draw_whitenoisecrescendo();break;                  //WhiteNoiseCrescendo
      case 228: draw_hyperspeed();break;                           //HyperSpeed
      case 229: draw_randombwflow();break;                         //RandomBWFlow
      case 230: draw_randomsmokeparticles();break;                 //RandomSmokeParticles
      case 231: draw_periodicNoise();break;                        //PeriodicNoise
      case 232: draw_doublegradient();break;                       //DoubleGradient transition
      case 233: draw_sonar(false);break;                           //Sonar
      case 234: draw_sonar(true);break;                            //SonarAllWhite
      case 235: draw_thunderlines();break;                         //ThunderLinesInit
      case 236: draw_thunderlines();break;                         //ThunderLines - More Lines
      case 237: draw_openingWhiteOut();break;                      //Opening Whiteout
      case 238: draw_darksnakes();break;                           //DarkSnakes
      case 239: draw_brightsnakes();break;                         //BrightSnakes
      case 240: draw_milktank();break;                             //Milktank
      case 241: draw_flashingdotsborder();break;                   //FlashingDotsBorder
      case 242: draw_lightfusion();break;                          //LightFusion
      case 243: draw_bwtriangles();break;                          //BWTriangles
      case 244: draw_colorvertex();break;                          //ColorVertex
      case 245: draw_gloubiboulga();break;                         //Gloubiboulga
      case 246: draw_carremarshall();break;                        //CarreMarshall
      case 247: draw_marshallstrobo();break;                       //MarshallStrobo
      case 248: draw_strobonormal();break;                         //Strobonormal
      case 249: draw_stroboX();break;                              //StroboX
      case 250: draw_dynamicAngleLinesWhite();break;               //Dynamic Angle Lines - White
      case 251: draw_dynamicAngleLinesHalfRed();break;             //Dynamic Angle Lines - Half Red
      case 252: draw_dynamicAngleLinesRed();break;                 //Dynamic Angle Lines - Red
      case 253: draw_spots();break;                                //Spots
      case 254: draw_stroboline();break;                           //StroboLine
      case 255: draw_randomWhiteLineFlash();break;                 //RandomWhiteLineFlash
      case 256: draw_strobored();break;                            //StroboRed
      case 257: draw_spotsmulticolor();break;                      //SpotsMultiColor
      case 258: draw_strobolinecolor();break;                      //StroboLineColor
      case 259: draw_strobocolor();break;                          //Strobocolor
      case 260: draw_trianglestrobo();break;                       //TriangleStrobo
      case 261: draw_trianglestrobocolor();break;                  //TriangleStrobo
      case 262: draw_hypnoflashtriangle();break;                   //HypnoFlashTriangle
      case 263: draw_fauveRandomFlash();break;                     //FauveRandomFlash
      case 264: draw_rednoiseshape1();break;                       //RedNoiseShape 1
      case 265: draw_rednoiseshape2();break;                       //RedNoiseShape 2
      case 266: draw_rednoiseshape3();break;                       //RedNoiseShape 3
      case 267: draw_rednoiseshape4();break;                       //RedNoiseShape 4
      case 268: draw_rednoiseshape5();break;                       //RedNoiseShape 5
      case 269: draw_rednoiseshape6();break;                       //RedNoiseShape 6
      case 270: draw_fusee_up();break;                             //FuseeUp
      case 271: draw_fusee_down();break;                           //FuseeDown
      case 272: draw_fusee_left();break;                           //FuseeLeft
      case 273: draw_fusee_right();break;                          //FuseeRight
      case 274: draw_fusee_centerhorizontal();break;               //FuseeCenterHorizontal
      case 275: draw_fusee_centervertical();break;                 //FuseeCenterVertical
      case 276: draw_doublefusee();break;                          //Double Fusee
      case 277: draw_fusee_up_red();break;                         //FuseeUp
      case 278: draw_fusee_down_red();break;                       //FuseeDown
      case 279: draw_fusee_left_red();break;                       //FuseeLeft
      case 280: draw_fusee_right_red();break;                      //FuseeRight
      case 281: draw_fusee_centerhorizontal_red();break;           //FuseeCenterHorizontal
      case 282: draw_fusee_centervertical_red();break;             //FuseeCenterVertical
      case 283: draw_responsivecirclesbw();break;                  //ResponsiveCirclesBW
      case 284: draw_responsivecircles();break;                    //ResponsiveCircles
      case 285: draw_manualcircle();break;                         //ManualCircle
      case 286: draw_automaticcircle();break;                      //AutomaticCircle
      case 287: draw_waveform();break;                             //Waveform
      case 288: draw_worms();break;                                //Worms
      case 289: draw_kaleidotriangle();break;                      //KaleidoTriangle
      case 290: draw_rhombus();break;                              //Rhombus
      case 291: draw_glitchdiagonallines();break;                  //GlitchDiagonalLines
      case 292: draw_particlesexplode();break;                     //ParticlesExplode
      case 293: draw_symmetry();break;                             //Symmetry
      case 294: draw_pixellines();break;                           //PixelLines
      case 295: draw_circlecontour();break;                        //CircleContour
      case 296: draw_colorexplode();break;                         //ColorExplode
      case 297: draw_colorrain();break;                            //ColorRain
      case 298: draw_warpspeed();break;                            //WarpSpeed
      case 299: draw_digitalhexparticles();break;                  //DigitalHexParticles
      case 300: draw_redarctransition();break;                     //RedArcTransition
      case 301: draw_redarctransition();break;                     //BlueArcTransition
      case 302: draw_shutter();break;                              //Shutter
      case 303: draw_butterfly();break;                            //Butterfly
      case 304: draw_bezierflowers();break;                        //BezierFlowers
      case 305: draw_lightpainting();break;                        //LightPainting
      case 306: draw_particlesflow();break;                        //ParticlesFlow
      case 307: draw_particlesflow();break;                        //ParticlesFlowRed
      case 308: draw_flower();break;                               //Flower
      case 309: draw_doubleflowers();break;                        //DoubleFlowers
      case 310: draw_fireflies();break;                            //Fireflies
      case 311: draw_firenoisesquares();break;                     //FireNoiseSquares
      case 312: draw_bloodski();break;                             //BloodSki
      case 313: draw_mechaniclines();break;                        //MechanicLines
      case 314: draw_redGlowingBalls();break;                      //RedWhiteGlowingBalls
      case 315: draw_redGlowingBalls2();break;                     //RedWhiteGlowingBalls 2
      case 316: draw_redvsblackvswhite();break;                    //RedvsBlackvsWhite
      case 317: draw_perlincolor();break;                          //PerlinColor
      case 318: draw_wind_particles();break;                       //Wind particles
      case 319: draw_rorschach();break;                            //Rorschach 1
      case 320: draw_rorschach();break;                            //Rorschach 2
      case 321: draw_rorschach();break;                            //Rorschach 3
      case 322: draw_rorschach();break;                            //Rorschach 4
      case 323: draw_rorschach();break;                            //Rorschach 5
      case 324: break;                                             //RorschachSetColor - special action, draw function shall not be called !
      case 325: break;                                             //RorschachSetBlack&White - special action, draw function shall not be called !
      case 326: draw_progressivered();break;                       //ProgressiveRed
      case 327: draw_weirdsquare();break;                          //WeirdSquare
      case 328: draw_lightblobs();break;                           //LightBlobs
      case 329: draw_redmetaballs();break;                         //RedMetaBalls
      case 330: draw_reverseTriangles();break;                     //ReverseTriangles
      case 331: draw_thirdDimension_bigasscube();break;            //3D BigAssCube
      case 332: draw_thirdDimension_cornercube();break;            //3D CornerCube
      case 333: draw_thirdDimension_glitchcube();break;            //3D GlitchCube
      case 334: draw_thirdDimension_noglitchcube();break;          //3D NoGlitchCube
      case 335: draw_thirdDimension_jerkycube();break;             //3D JerkyCube
      case 336: draw_thirdDimension_movingjerkycube();break;       //3D MovingJerkyCube
      case 337: draw_thirdDimension_doublecube();break;            //3D DoubleCube
      case 338: draw_thirdDimension_singlepyramid();break;         //3D SinglePyramid
      case 339: draw_thirdDimension_multiplepyramids();break;      //3D MultiplePyramids
      case 340: draw_energyGrid();break;                           //EnergyGrid
      case 341: draw_randompaint();break;                          //RandomPaint
      case 342: draw_redwave();break;                              //RedWave
      case 343: draw_diagonalcolor();break;                        //DiagonalColor
      case 344: draw_scope();break;                                //Scope
      case 345: draw_squarewavegenerator();break;                  //SquareWaveGenerator
      case 346: draw_fallingcircles();break;                       //FallingCircles
      case 347: draw_explodingparticles();break;                   //SetExplodingParticles
      case 348: draw_explodingparticles();break;                   //ReleaseExplodingParticles
      case 349: draw_tesselate();break;                            //Tesselate
      case 350: draw_patchwork();break;                            //Patchwork
      case 351: draw_vines();break;                                //Vines
      case 352: draw_nightroad();break;                            //NightRoad
      case 353: draw_slasher();break;                              //Slasher
      case 354: draw_colorbeat();break;                            //ColorBeat
      case 355: draw_colorbeatstroboline();break;                  //ColorBeatStroboline
      case 356: draw_colorbeatwhitestrobotriangle();break;         //ColorBeatWhiteStroboTriangle
      case 357: draw_colorbeattransition();break;                  //ColorBeatTransition
      case 358: draw_nekojiru();break;                             //NekoJiru
      case 359: draw_letterexplode();break;                        //LetterExplode
      case 360: draw_rotozoomblue();break;                         //RotozoomWhite
      case 361: draw_rotozoom();break;                             //Rotozoom 1
      case 362: draw_rotozoom();break;                             //Rotozoom 2
      case 363: draw_rotozoom();break;                             //Rotozoom 3
      case 364: draw_spiraluality();break;                         //Spiraluality
      case 365: draw_rotatingHalfCircle();break;                   //RotatingHalfCircle
      case 366: draw_slicedWaveWhite();break;                      //SlicedWave - White
      case 367: draw_slicedWaveRed();break;                        //SlicedWave - Red
      case 368: draw_arcwave();break;                              //ArcWave
      case 369: draw_redSun();break;                               //RedSun
      case 370: draw_greenArcRot();break;                          //ArcRot - Green
      case 371: draw_redArcRot();break;                            //ArcRot - Red
      case 372: draw_hypnopendulum();break;                        //HypnoPendulum
      case 373: draw_largewheelpendulum();break;                   //LargeWheelPendulum
      case 374: draw_singlesquarespiral();break;                   //SingleSquareSpiral
      case 375: draw_dualsquarespiral();break;                     //DualSquareSpiral
      case 376: draw_complexspiral();break;                        //ComplexSpiralReinit
      case 377: draw_complexspiral();break;                        //ComplexSpiral
      case 378: draw_whiteoutwardspiral();break;                   //OutwardSpiralWhite
      case 379: draw_blueoutwardspiral();break;                    //OutwardSpiralBlue
      case 380: draw_redoutwardspiral();break;                     //OutwardSpiralRed
      case 381: draw_fastspiral();break;                           //FastSpiral
      case 382: draw_inwardsspiral();break;                        //InwardsSpiral
      case 383: draw_inwardsspiralreverse();break;                 //InwardsSpiralReverse
      case 384: draw_hypnospiralred();break;                       //HypnoSpiralRed
      case 385: draw_electricspiral();break;                       //ElectricSpiral
      case 386: draw_cosmocurve();break;                           //CosmoCurve
      case 387: draw_cosmocurve();break;                           //CosmoCurveReinit
      case 388: draw_kaleido();break;                              //Kaleido
      case 389: draw_kaleidoinverse();break;                       //KaleidoInverse
      case 390: draw_revolutionlines();break;                      //RevolutionLines
      case 391: draw_discostar();break;                            //DiscoStar
      case 392: draw_wormhole();break;                             //WormHole
      case 393: draw_tetris();break;                               //Tetris - 1 player game
      case 394: draw_pong();break;                                 //Pong - 2 player game
      case 395: draw_shiftpixelsup();break;                        //ShiftPixelsUp / Slow
      case 396: draw_shiftpixelsdown();break;                      //ShiftPixelsDown / Slow
      case 397: draw_shiftpixelsleft();break;                      //ShiftPixelsLeft / Slow
      case 398: draw_shiftpixelsright();break;                     //ShiftPixelsRight / Slow
      case 399: draw_shiftpixelsup();break;                        //ShiftPixelsUp / Fast
      case 400: draw_shiftpixelsdown();break;                      //ShiftPixelsDown / Fast
      case 401: draw_shiftpixelsleft();break;                      //ShiftPixelsLeft / Fast
      case 402: draw_shiftpixelsright();break;                     //ShiftPixelsRight / Fast
      case 403: draw_shredpixelsvertical();break;                  //ShredPixelsVertical / Slow
      case 404: draw_shredpixelshorizontal();break;                //ShredPixelsHorizontal / Slow
      case 405: draw_shredpixelsvertical();break;                  //ShredPixelsVertical / Slow
      case 406: draw_shredpixelshorizontal();break;                //ShredPixelsHorizontal / Slow
      case 407: draw_spiderwebs();break;                           //Spider Webs - White - Manual
      case 408: draw_spiderwebs();break;                           //Spider Webs - Red - Manual
      case 409: draw_spiderwebs();break;                           //Spider Webs - White - Manual Fade
      case 410: draw_spiderwebs();break;                           //Spider Webs - Red - Manual Fade
      case 411: draw_spiderwebs();break;                           //Spider Webs - White - Audio
      case 412: draw_woublines();break;                            //Woublines - White Inwards
      case 413: draw_woublines();break;                            //Woublines - White Outwards
      case 414: draw_woublines();break;                            //Woublines - Red Inwards
      case 415: draw_woublines();break;                            //Woublines - Red Outwards
      case 416: draw_woublines();break;                            //Woublines - Audio
      case 417: draw_signalWaveform_white_kick();break;            //Signal waveform - White - Kick
      case 418: draw_signalWaveform_red_kick();break;              //Signal waveform - Red - Kick
      case 419: draw_signalWaveform_white_snare();break;           //Signal waveform - White - Snare
      case 420: draw_signalWaveform_red_snare();break;             //Signal waveform - Red - Snare
      case 421: draw_signalWaveform_white_cymbals();break;         //Signal waveform - White - Cymbals
      case 422: draw_signalWaveform_red_cymbals();break;           //Signal waveform - Red - Cymbals
      case 423: draw_signalWaveform_white_bass();break;            //Signal waveform - White - Bass
      case 424: draw_signalWaveform_red_bass();break;              //Signal waveform - Red - Bass
      case 425: draw_signalWaveform_white_keys();break;            //Signal waveform - White - Keys
      case 426: draw_signalWaveform_red_keys();break;              //Signal waveform - Red - Keys
      case 427: draw_signalWaveform_white_guitar();break;          //Signal waveform - White - Guitar
      case 428: draw_signalWaveform_red_guitar();break;            //Signal waveform - Red - Guitar
      case 429: draw_simplespiral(255,255,255);break;              //Simple Spiral - White
      case 430: draw_simplespiral(255,0,0);break;                  //Simple Spiral - Red
      case 431: draw_singlesquarespiralwhite();break;              //SingleSquareSpiralWhite
      case 432: draw_dualsquarespiralwhite();break;                //DualSquareSpiralWhite
      case 433: draw_tvpoweroff();break;                           //TV Power Off
      case 434: draw_whitespread_start();break;                    //White Spread Start
      case 435: draw_whitespread_end();break;                      //White Spread End
      case 436: draw_scannerLine1_fastWhite();break;               //ScannerLine 1 - Fast White
      case 437: draw_scannerLine2_fastWhite();break;               //ScannerLine 2 - Fast White
      case 438: draw_scannerLine1_fastRed();break;                 //ScannerLine 1 - Fast Red
      case 439: draw_scannerLine2_fastRed();break;                 //ScannerLine 2 - Fast Red
      case 440: draw_scannerLine1_slowWhite();break;               //ScannerLine 1 - Slow White
      case 441: draw_scannerLine2_slowWhite();break;               //ScannerLine 2 - Slow White
      case 442: draw_scannerLine1_slowRed();break;                 //ScannerLine 1 - Slow Red
      case 443: draw_scannerLine2_slowRed();break;                 //ScannerLine 2 - Slow Red
      case 509: draw_dirtyAudioProcessing();break;                 //Audio Monitoring
      case 510: draw_displayFFT_bass();break;                      //DisplayFFT - Bass
      
      default: break;                                              //Default animation : do nothing, the screen will not be updated
    }
  }
  
  //At the end of every draw cycle, reset the impulse flags to prevent processing old audio data
  //This is not such a good idea, as on slower machines, the draw thread may be interrupted - and as such, some impulses may be lost
  //impulseMessageProcessed = true;
}

//////////////////////////////////////////////////////////////
// Execute specific init actions according to the animation //
//////////////////////////////////////////////////////////////



public void specificActions() {
    
  if (drawAnimation == 1)
  {
    
    //Reset the color mode
    colorMode(RGB);
    
    switch(animationnumber) {
      case 1:    //BlackOut

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(0);
        background(0);
        break;

      case 2:    //WhiteOut

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(255);
        break;

      case 3:   //WideFlash

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain;
        break;

      case 4:    //LongWideFlash

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain*4;
        break;

      case 5:    //FlashExtremeLeft
      
        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawextremeleft = flash_sustain;
        break;

      case 6:   //FlashLeft

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawleft = flash_sustain;
        break;
      
      case 7:   //FlashCenter

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawcenter = flash_sustain;
        break;
      
      case 8:   //FlashRight

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawright = flash_sustain;
        break;

      case 9:   //FlashExtremeRight
      
        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawextremeright = flash_sustain;
        break;

      case 10:    //WideFlashRed

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain;
        break;

      case 11:   //FlashExtremeLeftRed

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawleft = flash_sustain;
        break;

      case 12:   //FlashLeftRed

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawleft = flash_sustain;
        break;
      
      case 13:   //FlashCenterRed

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawcenter = flash_sustain;
        break;
      
      case 14:   //FlashRightRed

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawright = flash_sustain;
        break;

      case 15:   //FlashExtremeRightRed

        rectMode(CORNER);
        resetMatrix();
        frameRate(35);
        drawright = flash_sustain;
        break;


      case 16:   //FadeoutExtremeLeft

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(35);
        break;

      case 17:   //FadeoutLeft

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(35);
        break;
      
      case 18:   //FadeoutCenter

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(35);
        break;
      
      case 19:   //FadeoutRight

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(35);
        break;
      
      case 20:   //FadeoutExtremeRight

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(35);
        break;

      case 21:   //Fadeout

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(25);
        break;

      case 22:   //Fadein

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(25);
        break;

      case 23:    //ExtremeLowLeft

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;

      case 24:    //ExtremeHiLeft

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;

      case 25:    //LowLeft

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;
      
      case 26:    //HiLeft

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;
      
      case 27:    //LowMid

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;
      
      case 28:    //HiMid

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;
      
      case 29:    //LowRight

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;
      
      case 30:    //HiRight

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;
      
      case 31:    //ExtremeLowRight

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;

      case 32:    //ExtremeHiRight

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        fill(255);
        background(0);
        break;

      case 33:    //PanelFillLeft

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        if (panelFillListInit == false) {
          panelFillList = new ArrayList<PanelFillClass>();
          panelFillListInit = true;
        }
        panelfill_draw = true;
        if (NUMBER_OF_PANELS == 3) {
          panelFillList.add(new PanelFillClass(0*(width/NUMBER_OF_PANELS), height, 0));
        }
        else {
          panelFillList.add(new PanelFillClass(1*(width/NUMBER_OF_PANELS), height, 0));
        }
        
        break;
      
      case 34:    //PanelFillCenter

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        
        if (panelFillListInit == false) {
          panelFillList = new ArrayList<PanelFillClass>();
          panelFillListInit = true;
        }
        
        panelfill_draw = true;
        
        if (NUMBER_OF_PANELS == 3) {
          panelFillList.add(new PanelFillClass(1*(width/NUMBER_OF_PANELS), height, 1));
        }
        else {
          panelFillList.add(new PanelFillClass(2*(width/NUMBER_OF_PANELS), height, 1));
        }
        break;
      
      case 35:    //PanelFillRight

        rectMode(CORNER);
        frameRate(50);
        noStroke();
        
        if (panelFillListInit == false) {
          panelFillList = new ArrayList<PanelFillClass>();
          panelFillListInit = true;
        }
        
        panelfill_draw = true;
        
        if (NUMBER_OF_PANELS == 3) {
          panelFillList.add(new PanelFillClass(2*(width/NUMBER_OF_PANELS), height, 2));
        }
        else {
          panelFillList.add(new PanelFillClass(3*(width/NUMBER_OF_PANELS), height, 2));
        }
        break;

      case 36:   //PanelFillLines

        if (panelFillLinesListInit == false) {
          panelFillLinesList = new ArrayList<PanelFillLineClass>();
          panelFillLinesListInit = true;
        }
        rectMode(CORNER);
        frameRate(50);
        noStroke();
        panelfilllines_draw = true;  
        break;

      case 37:    //OppositeLinesNoBackground

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        noStroke() ;
        fill(255) ;
        break;
      
      case 38:    //OpeningLines

        frameRate(50);
        background(0);
        stroke(255);
        strokeWeight(8); 
        break;
      
      case 39:    //OpeningLinesReinit

        frameRate(50);
        background(0);
        stroke(255);
        strokeWeight(8); 
        openinglines_x = 0;
        break;

      case 40:   //LineWideFlash

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain;
        break;
      
      case 41:   //LineLeftFlash

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain;
        break;
      
      case 42:   //LineCenterFlash

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain;
        break;
      
      case 43:   //LineRightFlash

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);
        drawwide = flash_sustain;
        break;
 
      case 44:    //Upwards Line White Out

        rectMode(CORNER);
        colorMode(RGB, 255);
        frameRate(25);
        stroke(0);
        strokeWeight(16);
        background(255);
        break;
      
      case 45:   //Upwards Line

        noSmooth();
        colorMode(RGB, 255);
        stroke(255);
        strokeWeight(8);
        line_height = height;
        frameRate(25);
        break;

      case 46:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 47:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 48:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 49:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 50:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 51:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 52:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 53:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 54:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 55:    //Lines

        frameRate(50);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 56:    //Unfolding Lines

        rectMode(CORNER);
        background(0);
        strokeWeight(4);
        stroke(255);
        frameRate(50);
        smooth();
        supposed_height = 1;  
        break;

      case 57:    //Mugen

        smooth();
        mugen_xamp = 0;    //5*width/12;
        mugen_yamp = 0;    //3*height/8;
        background(0);
        frameRate(50);
        strokeCap(ROUND);
        colorMode(RGB); 
        break;

      case 58:    //TurningSingleLines

        frameRate(50);
        colorMode(RGB);
        noFill();
        stroke(255);
        strokeWeight(16);
        
        if (turningsinglelines_init != -1.0f*width) {
          turningsinglelines_init = -1.0f*width;
          turningsinglelines_lines = new ArrayList<SingleTurningLine>();
        }
        turningsinglelines_lines.add(new SingleTurningLine(turningsinglelines_angle));
        turningsinglelines_angle += turningsinglelines_angleincrement;
        break;
      
      case 59:    //RandomAppearingLines

        frameRate(50);
        colorMode(RGB);
        noFill();
        stroke(255);
        strokeWeight(8);
        randomappearinglines_initx = width/4;
        randomappearinglines_inity = -height;
        randomappearinglines_framecount = 0;
        randomappearinglines_currentangle = random(0,2*PI);
        randomappearinglines_currentx = randomappearinglines_initx; 
        randomappearinglines_currenty = randomappearinglines_inity;
        randomappearinglines_previousx = randomappearinglines_initx;
        randomappearinglines_previousy = randomappearinglines_inity;
        break;

      case 60:          //Nonotak 1

        if (nonotak_1_color == 0) {nonotak_1_color = 255;}
        else {nonotak_1_color = 0;}
        frameRate(20);
        colorMode(RGB);
        background(0);
        stroke(255);
        strokeWeight(4);
        noFill();
        nonotak_1_x += 2;
        break;
      
      case 61:          //Nonotak 2

        frameRate(50);
        colorMode(RGB);
        background(0);
        noStroke();
        nonotak_2_x = 0;
        break;
        
      case 62:          //Nonotak 3

        frameRate(50);
        colorMode(RGB);
        background(0);
        noStroke();
        nonotak_3_x = 0;
        break;
        
      case 63:          //Nonotak 4

        frameRate(60);
        colorMode(RGB);
        background(0);
        stroke(255);
        strokeWeight(8);
        noFill();
        break;
      
      case 64:          //Nonotak 5

        frameRate(60);
        colorMode(RGB);
        background(0);
        strokeWeight(8);
        nonotak_5_y = 0;
        nonotak_5_up = false;
        break;
      
      case 65:    //NonotakPanelFill - ExtremeLeft

        frameRate(30);
        noStroke();
        if (NUMBER_OF_PANELS == 3) {
          nonotakPanelFill_list.add(new NonotakPanelFill(2));
        }
        else if (NUMBER_OF_PANELS == 5) {
          nonotakPanelFill_list.add(new NonotakPanelFill(0));
        }
        break;

      case 66:         //NonotakPanelFill - Left

        frameRate(30);
        noStroke();
        if (NUMBER_OF_PANELS == 3) {
          nonotakPanelFill_list.add(new NonotakPanelFill(0));
        }
        else if (NUMBER_OF_PANELS == 5) {
          nonotakPanelFill_list.add(new NonotakPanelFill(1));
        }
        break;
      
      case 67:         //NonotakPanelFill - Center

        frameRate(30);
        noStroke();
        if (NUMBER_OF_PANELS == 3) {
          nonotakPanelFill_list.add(new NonotakPanelFill(1));
        }
        else if (NUMBER_OF_PANELS == 5) {
          nonotakPanelFill_list.add(new NonotakPanelFill(2));
        }
        break;
      
      case 68:        //NonotakPanelFill - Right

        frameRate(30);
        noStroke();
        if (NUMBER_OF_PANELS == 3) {
          nonotakPanelFill_list.add(new NonotakPanelFill(2));
        }
        else if (NUMBER_OF_PANELS == 5) {
          nonotakPanelFill_list.add(new NonotakPanelFill(3));
        }
        break;

        
      case 69:    //NonotakPanelFill - ExtremeRight

        frameRate(30);
        noStroke();
        if (NUMBER_OF_PANELS == 3) {
          nonotakPanelFill_list.add(new NonotakPanelFill(0));
        }
        else if (NUMBER_OF_PANELS == 5) {
          nonotakPanelFill_list.add(new NonotakPanelFill(4));
        }
        break;

      case 70:    //NonotakWoosh 1

        frameRate(60);
        nonotakWoosh_list.add(new NonotakWoosh(0));
        break;
      
      case 71:    //NonotakWoosh 2

        frameRate(60);
        nonotakWoosh_list.add(new NonotakWoosh(1));
        break;
      
      case 72:    //NonotakWoosh 3

        frameRate(60);
        nonotakWoosh_list.add(new NonotakWoosh(2));
        break;
      
      case 73:    //NonotakWoosh 4

        frameRate(60);
        nonotakWoosh_list.add(new NonotakWoosh(3));
        break;
      
      case 74:    //RotatingCut - B&W

        frameRate(50);
        colorMode(HSB);
        break;
      
      case 75:    //RotatingCut - Blue

        frameRate(50);
        colorMode(HSB);
        break;

      case 76:    //RotatingCutFast - B&W

        frameRate(80);
        colorMode(HSB);
        break;

      case 77:    //RedDiagonalLines

        frameRate(50);
        background(0);
        stroke(255,0,0);
        strokeWeight(8);
        redposx = 0;
        redposy = 0;
        break;
      
      case 78:    //BlueDiagonalLines

        frameRate(50);
        stroke(0,0,255);
        strokeWeight(8);
        blueposx = 0;
        blueposy = 0;
        break;

      case 79:    //BlueDiagonalLines2

        frameRate(50);
        stroke(0,0,255);
        strokeWeight(8);
        blueposx = 0;
        blueposy = 0;
        break;
      
      case 80:    //BlueDiagonalLines3

        frameRate(50);
        stroke(0,0,255);
        strokeWeight(8);
        blueposx = 0;
        blueposy = 0;
        break;
      
      case 81:    //RedDiagonalLines2

        frameRate(50);
        stroke(255,0,0);
        strokeWeight(8);
        redposx = 0;
        redposy = 0;
        break;
      
      case 82:    //WhiteDiagonalLines

        frameRate(50);
        strokeWeight(8);
        blueposx = 0;
        blueposy = 0;
        break;
      
      case 83:    //WhiteDiagonalLines2

        frameRate(50);
        strokeWeight(8);
        redposx = 0;
        redposy = 0;
        break;
      
      case 84:    //WhiteStraightLines

        frameRate(50);
        stroke(255);
        strokeWeight(8);
        redposx = 0;
        redposy = 0;
        break;

      case 85:    //Star2Sides

        smooth();
        fill(255);
        noStroke();
        frameRate(50);
        break;
      
      case 86:    //Star3Sides

        smooth();
        fill(255);
        noStroke();
        frameRate(50);
        break;
      
      case 87:    //Star4Sides

        smooth();
        fill(255);
        noStroke();
        frameRate(50);
        break;
      
      case 88:    //Star6Sides

        smooth();
        fill(255);
        noStroke();
        frameRate(50);
        break;
      
      case 89:    //Star8Sides

        smooth();
        fill(255);
        noStroke();
        frameRate(50);
        break;
      
      case 90:   //Rotating Circles
      
        colorMode(RGB, 255);
        ellipseMode(CENTER);
        frameRate(25);
        break;

      case 91:    //JointCircles

        frameRate(50);
        fill(255);
        stroke(255);
        strokeWeight(2);
        break;

      case 92:    //ParallelWorlds - Regular

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        parallelworlds_init = true;
        parallelworlds_list.add(new ParallelWorldLine(true));
        parallelworlds_speed = 3;
        parallelworlds_reverse = false;
        break;
      
      case 93:    //ParallelWorlds - Slow

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        parallelworlds_init = true;
        parallelworlds_list.add(new ParallelWorldLine(true));
        parallelworlds_speed = 2;
        parallelworlds_reverse = false;
        crecy_internalCounter = 3;
        break;
      
      case 94:    //ParallelWorlds - Flash

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        parallelworlds_init = true;
        parallelworlds_list.add(new ParallelWorldLine(true));
        parallelworlds_flashpower = 255;
        parallelworlds_reverse = false;
        crecy_internalCounter = 3;
        break;
      
      case 95:    //ParallelWorlds - Reverse

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        parallelworlds_init = true;
        parallelworlds_list.add(new ParallelWorldLine(false));
        parallelworlds_reverse = true;
        crecy_internalCounter = 3;
        break;

      case 96:    //MultiCrecy - Very light intensity

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        
        //Reinit the parallel worlds arraylist
        parallelworlds_list = new ArrayList<ParallelWorldLine>();
        
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 3;
        int numberOfCrecys3 = 5;
        for (int j=0; j<numberOfCrecys3;j++) {
          crecy_list.add(new Crecy(5));
        }
        break;
      
      case 97:    //MultiCrecy - Low intensity

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 1;
        int numberOfCrecys = PApplet.parseInt(random(5,8));
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys = PApplet.parseInt(random(7,12));
        }
        for (int j=0; j<numberOfCrecys;j++) {
          crecy_list.add(new Crecy(1));
        }
        break;
      
      case 98:    //MultiCrecy - Medium intensity

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 1;
        int numberOfCrecys_1 = PApplet.parseInt(random(3,6));
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys_1 = PApplet.parseInt(random(4,8));
        }
        for (int j=0; j<numberOfCrecys_1;j++) {
          crecy_list.add(new Crecy(1));
        }
        int numberOfCrecys2 = 3;
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys2 = 6;
        }
        for (int j=0; j<numberOfCrecys2;j++) {
          crecy_list.add(new Crecy(2));
        }
        break;
      
      case 99:    //MultiCrecy - High intensity

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 0;
        int numberOfCrecys_2 = PApplet.parseInt(random(4,7));
        for (int j=0; j<numberOfCrecys_2;j++) {
          crecy_list.add(new Crecy(1));
        }
        int numberOfCrecys2_1 = 2;
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys2_1 = 3;
        }
        for (int j=0; j<numberOfCrecys2_1;j++) {
          crecy_list.add(new Crecy(2));
        }
        crecy_list.add(new Crecy(3));
       
        break;
      
      case 100:    //MultiCrecy - Hardcore intensity

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 3;
        int numberOfCrecys_3 = PApplet.parseInt(random(2,3));
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys_3 = PApplet.parseInt(random(3,6));
        }
        for (int j=0; j<numberOfCrecys_3;j++) {
          crecy_list.add(new Crecy(4));
        }
        int numberOfCrecys2_2 = 2;
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys2_2 = 4;
        }
        for (int j=0; j<numberOfCrecys2_2;j++) {      
          crecy_list.add(new Crecy(2));
        }
        if (random(1) > 0.8f) {
          crecy_list.add(new Crecy(3));
        }
        break;
      

      
      case 101:    //MultiCrecy - Double intensity

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 3;
        int numberOfCrecys4 = PApplet.parseInt(random(2,4));
        if (NUMBER_OF_PANELS >= 5) {
          numberOfCrecys4 = PApplet.parseInt(random(3,7));
        }
        for (int j=0; j<numberOfCrecys4;j++) {
          crecy_list.add(new Crecy(4));
        }
        int numberOfCrecys5 = 1;
        for (int j=0; j<numberOfCrecys5;j++) {
          crecy_list.add(new Crecy(6));
        }
        break;
      
      case 102:    //MultiCrecy - Refrain

        frameRate(50);
        if (parallelworlds_init == false) {
          parallelworlds_list = new ArrayList<ParallelWorldLine>();
        }
        parallelworlds_init = true;
        if (crecy_init == false) {
          crecy_list = new ArrayList<Crecy>();
        }
        crecy_init = true;
        crecy_internalCounter = 3;
        int numberOfCrecys6 = PApplet.parseInt(random(4,6));
        for (int j=0; j<numberOfCrecys6;j++) {
          crecy_list.add(new Crecy(1));
        }
        crecy_list.add(new Crecy(2));
        for (int k=0; k<2; k++) {
          crecy_list.add(new Crecy(3));
        }
        break;
      
      case 103:    //Snake1

        frameRate(50);
        if (snake_init == false) {
          snake_specialInit();
          snake_instance1 = new Snake(4, true);
          snake_instance2 = new Snake(4, true);
          snake_instance3 = new Snake(4, true);
          snake_instance4 = new Snake(4, true);
          snake_instance5 = new Snake(4, true);
          snake_instance6 = new Snake(4, true);        
        }
        snake_init = true;
        break;
      
      case 104:    //Snake2

        frameRate(50);
        if (snake_init == false) {
          snake_specialInit();
          snake_instance1 = new Snake(4, true);
          snake_instance2 = new Snake(4, true);
          snake_instance3 = new Snake(4, true);
          snake_instance4 = new Snake(4, true);
          snake_instance5 = new Snake(4, true);
          snake_instance6 = new Snake(4, true);        
        }
        snake_init = true;
        break;
      
      case 105:    //Snake3

        frameRate(50);
        if (snake_init == false) {
          snake_specialInit();
          snake_instance1 = new Snake(4, true);
          snake_instance2 = new Snake(4, true);
          snake_instance3 = new Snake(4, true);
          snake_instance4 = new Snake(4, true);
          snake_instance5 = new Snake(4, true);
          snake_instance6 = new Snake(4, true);
        }
        snake_init = true;
        break;
      
      case 106:    //Snake4

        frameRate(50);
        if (snake_init == false) {
          snake_specialInit();
          snake_instance1 = new Snake(4, true);
          snake_instance2 = new Snake(4, true);
          snake_instance3 = new Snake(4, true);
          snake_instance4 = new Snake(4, true);
          snake_instance5 = new Snake(4, true);
          snake_instance6 = new Snake(4, true);
        }
        snake_init = true;
        break;
      
      case 107:    //Snake5

        frameRate(50);
        if (snake_init == false) {
          snake_specialInit();
          snake_instance1 = new Snake(4, true);
          snake_instance2 = new Snake(4, true);
          snake_instance3 = new Snake(4, true);
          snake_instance4 = new Snake(4, true);
          snake_instance5 = new Snake(4, true);
          snake_instance6 = new Snake(4, true);
        }
        snake_init = true;
        break;
      
      case 108:    //Snake6

        frameRate(50);
        if (snake_init == false) {
          snake_specialInit();
          snake_instance1 = new Snake(4, true);
          snake_instance2 = new Snake(4, true);
          snake_instance3 = new Snake(4, true);
          snake_instance4 = new Snake(4, true);
          snake_instance5 = new Snake(4, true);
          snake_instance6 = new Snake(4, true);
        }
        snake_init = true;
        break;

      case 109:   //MovingSine

        frameRate(25);
        background(0);
        stroke(255);
        strokeWeight(1);
        movingsine_speed = 0.4f;
        float movingsine_x = 0;
        float movingsine_theta = 0;
        for (int j = 0; j < SineElem.length; j++) {
          movingsine_x += width/movingsine_howMany;
          SineElem[j]= new ExLine(movingsine_x, movingsine_theta);
          movingsine_theta += PI/movingsine_howMany;
        }
        break;
      
      case 110:    //Carglass
      
        frameRate(50);
        strokeWeight(4);
        carglass_progress = 0;
        carglass_linelength = (width/2)*1.2f;
        break;
      
      case 111:    //Va et vient - 1
      
        frameRate(100);
        va_et_vient_progress = 0;
        strokeWeight(8);
        break;
      
      case 112:    //Va et vient - 2
      
        frameRate(100);
        va_et_vient_progress = 0;
        strokeWeight(8);
        break;

      case 113:    //ImpulseRectangles

        frameRate(50);
        colorMode(RGB);
        fill(255);
        noStroke();
        impulserectangles_posx = 0;
        impulserectangles_posy = 0;
        break;
      
      case 114:    //ImpulseRectangles

        frameRate(50);
        colorMode(RGB);
        fill(255);
        noStroke();
        impulserectangles_posx = 0;
        impulserectangles_posy = 0;
        break;
      
      case 115:    //ImpulseRectangles

        frameRate(50);
        colorMode(RGB);
        fill(255);
        noStroke();
        impulserectangles_posx = 0;
        impulserectangles_posy = 0;
        break;
      
      case 116:    //ImpulseRectangles

        frameRate(50);
        colorMode(RGB);
        fill(255);
        noStroke();
        impulserectangles_posx = 0;
        impulserectangles_posy = 0;
        break;

      case 117:    //MixedLines1

        rectMode(CORNER);
        frameRate(50);
        stroke(255);
        init_mixedlines(0,2,0);
        break;
      
      case 118:    //MixedLines2

        frameRate(50);
        stroke(255);
        init_mixedlines(2,0,0);
        break;
      
      case 119:    //MixedLines3

        frameRate(50);
        stroke(255);
        init_mixedlines(1,3,0);
        break;
      
      case 120:    //MixedLines4

        frameRate(50);
        stroke(255);
        init_mixedlines(3,1,0);
        break;
      
      case 121:    //MixedLines5

        frameRate(50);
        stroke(255);
        init_mixedlines(1,2,0);
        break;
      
      case 122:    //MixedLines6

        frameRate(50);
        stroke(255);
        init_mixedlines(2,3,0);
        break;
      
      case 123:    //MixedLines7

        frameRate(50);
        stroke(255);
        init_mixedlines(1,3,2);
        break;
      
      case 124:    //MixedLines8

        frameRate(50);
        stroke(255);
        init_mixedlines(3,1,2);
        break;
      
      case 125:    //MixedLines9

        frameRate(50);
        stroke(255);
        init_mixedlines(0,0,1);
        break;
      
      case 126:    //MixedLines10

        frameRate(50);
        stroke(255);
        init_mixedlines(0,0,2);
        break;
      
      case 127:    //MixedLines11

        frameRate(50);
        stroke(255);
        init_mixedlines(0,0,3);
        break;
      
      case 128:    //MixedLines12

        frameRate(50);
        stroke(255);
        init_mixedlines(0,0,4);
        break;
      
      case 129:    //MixedLines13

        frameRate(50);
        stroke(255);
        init_mixedlines(0,0,5);
        break;
      
      case 130:    //MixedLines14

        frameRate(50);
        stroke(255);
        init_mixedlines(0,0,6);
        break;

      case 131:    //UpwardsGlitchLines

        stroke(255);
        colorMode(RGB);
        // Line spacing
        upwards_glitchlines_a = 0;
        upwards_glitchlines_b = height/3;
        upwards_glitchlines_c = 2*height/3;
        
        upwards_glitchlines_interligne = height/8;
        upwards_glitchlines_speed = height/(height-1);
        upwards_glitchlines_count = 0;
        upwards_glitchlines_glitch_x = width/16; 
        upwards_glitchlines_glitch_y = height/24;  
        upwards_glitchlines_freq=10;
        strokeWeight(4);
        break;
      
      case 132:    //DiagonalGlitchLines

        stroke(255);
        frameRate(50);
        colorMode(RGB);
        // Initialisation des hauteurs des lignes
        diagonal_glitchlines_a = 0;
        diagonal_glitchlines_b = height/3;
        diagonal_glitchlines_c = 2*height/3;
        
        // initialisation des parametres
        diagonal_glitchlines_strokeWidth = 4;
        diagonal_glitchlines_speed = 2;
        diagonal_glitchlines_count = 0;
        strokeWeight(diagonal_glitchlines_strokeWidth);
        break;
      
      case 133:    //CompressedLines

        stroke(255);
        strokeWeight(4);
        frameRate(40);
        compressedlines_ratio = height;
        break;

      case 134:    //UpwardsGlitchMixedLines

        background(0);
        frameRate(40);
        stroke(255);
        fill(255);
        colorMode(RGB);
        // initialisation des parametres
        upwards_glitch_mixedlines_epaisseurLigne = 4;
        upwards_glitch_mixedlines_interligne = upwards_glitch_mixedlines_epaisseurLigne*3;
        strokeWeight(upwards_glitch_mixedlines_epaisseurLigne);
        strokeCap(SQUARE);
        upwards_glitch_mixedlines_speed = 1;
        
        // Initialisation des hauteurs des lignes
        upwards_glitch_mixedlines_b = height/2;
        upwards_glitch_mixedlines_c = 3*height/4;   
        upwards_glitch_mixedlines_d = height;
        
        upwards_glitch_mixedlines_e=upwards_glitch_mixedlines_b-upwards_glitch_mixedlines_interligne;
        upwards_glitch_mixedlines_f=upwards_glitch_mixedlines_c-upwards_glitch_mixedlines_interligne;
        upwards_glitch_mixedlines_g=upwards_glitch_mixedlines_d-upwards_glitch_mixedlines_interligne;
        
        upwards_glitch_mixedlines_ac = height/4;  
        break;
      
      case 135:    //UpwardsGlitchMixedLines2

        frameRate(40);
        stroke(255);
        
        // initialisation des parametres
        upwards_glitch_mixedlines_epaisseurLigne = 4;
        upwards_glitch_mixedlines_interligne = upwards_glitch_mixedlines_epaisseurLigne*3;
        strokeWeight(upwards_glitch_mixedlines_epaisseurLigne);
        strokeCap(SQUARE);
        upwards_glitch_mixedlines_speed = 1;
        
        // Initialisation des hauteurs des lignes
        upwards_glitch_mixedlines_b = height/2;
        upwards_glitch_mixedlines_c = 3*height/4;   
        upwards_glitch_mixedlines_d = height;
        
        upwards_glitch_mixedlines_e=upwards_glitch_mixedlines_b-upwards_glitch_mixedlines_interligne;
        upwards_glitch_mixedlines_f=upwards_glitch_mixedlines_c-upwards_glitch_mixedlines_interligne;
        upwards_glitch_mixedlines_g=upwards_glitch_mixedlines_d-upwards_glitch_mixedlines_interligne; 
        
        upwards_glitch_mixedlines_ac = 0;
        upwards_glitch_mixedlines_bc = height/4;
        upwards_glitch_mixedlines_cc = height/2;
        upwards_glitch_mixedlines_dc = 3*height/4; 
        break;
      
      case 136:    //GrowingTriangles

        smooth();
        frameRate(50);
        strokeWeight(8);
         
        noFill();
        background(0);
        trianglelist.add(new growingTriangle());
        stroke(255);
        break;
      
      case 137:    //SmallSquareLeft

        background(0);
        noSmooth();
        frameRate(40);
        fill(255);
        noStroke();
        strokeWeight(1);
        break;
      
      case 138:    //SmallSquareCenter

        background(0);
        noSmooth();
        frameRate(40);
        fill(255);
        noStroke();
        strokeWeight(1);
        break;
      
      case 139:    //SmallSquareRight

        background(0);
        noSmooth();
        frameRate(40);
        fill(255);
        noStroke();
        strokeWeight(1);
        break;
      
      case 140:    //SmallSquares

        background(0);
        noSmooth();
        frameRate(40);
        fill(255);
        noStroke();
        strokeWeight(1);
        break;

      case 141:    //MovingLines

        frameRate(50);
        stroke(255);
        strokeWeight(6); 
        break;
      
      case 142:    //MovingSquares

        rectMode(CORNER);
        frameRate(50);
        noStroke(); 
        break;

      case 143:    //OrbitingParticles

        frameRate(60);
        background(0);
        strokeWeight(8);
        stroke(255);
        colorMode(RGB);
        strokeCap(ROUND);
        noSmooth();
        if (orbitingparticles_initialised == false) {
          orbitingparticles_particlelist = new OrbitingParticle[orbitingparticles_number];
          
          //The first particle shall be red
          orbitingparticles_particlelist[0] = new OrbitingParticle(orbitingparticles_globalx,orbitingparticles_globaly,orbitingparticles_dispersion,random(orbitingparticles_speedmin, orbitingparticles_speedmax), color(255,0,0));
          
          for (int j = 1; j < orbitingparticles_number; j++) {
            orbitingparticles_particlelist[j] = new OrbitingParticle(orbitingparticles_globalx,orbitingparticles_globaly,orbitingparticles_dispersion,random(orbitingparticles_speedmin, orbitingparticles_speedmax), color(255));
          }
        }
        orbitingparticles_initialised = true;
        orbitingparticles_changefocus();
        break;
      
      case 144:    //ArrowStyle

        noFill();
        frameRate(50);
        colorMode(RGB); 
        strokeWeight(16);
        strokeCap(SQUARE);
        stroke(255);
        arrowstyle_pos = - 0.9f*height;
        arrowstyle_height = height/2; 
        break;

      case 145:    //SingleArrow - Up-Down White

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(0,height/2,color(255)));
        break;
      
      case 146:    //SingleArrow - Left-Right White

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(1,height/2,color(255)));
        break;
      
      case 147:    //SingleArrow - Right-Left White

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(2,height/2,color(255)));
        break;
      
      case 148:    //SingleArrow - Down-Up White

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(3,height/2,color(255)));
        break;
      
      case 149:    //SingleArrow - Up-Down Red

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(0,height/2,color(255,0,0)));
        break;
      
      case 150:    //SingleArrow - Left-Right Red

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(1,height/2,color(255,0,0)));
        break;
      
      case 151:    //SingleArrow - Right-Left Red

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(2,height/2,color(255,0,0)));
        break;
      
      case 152:    //SingleArrow - Down-Up Red

        singlearrow_setup();
        singlearrow_arrowlist.add(new SingleArrow(3,height/2,color(255,0,0)));
        break;

      case 153:    //SweepingBallsAndArrows

        frameRate(50);
        if (sweeperBalls_init == false) {
          sweeperBalls_list = new ArrayList<SweeperBall>();
          sweeperBalls_listarrow = new ArrayList<DoubleArrow>();
        }
        sweeperBalls_init = true;
        for (int j = 0; j<sweeperBalls_nbOfBalls; j++) {
          sweeperBalls_list.add(new SweeperBall());
        }
        sweeperBalls_listarrow.add(new DoubleArrow());
        break;

      case 154:    //ColumnsWhite

        frameRate(50);
        colorMode(RGB);
        columns_firstheight2 = height - columns_offsety - columns_firstheight1;
        columns_secondheight2 = height - columns_offsety - columns_secondheight1;
        columns_thirdheight2 = height - columns_offsety - columns_thirdheight1;
        columns_shift = false;
        break;
      
      case 155:    //ColumnsBlack

        frameRate(50);
        colorMode(RGB);
        columns_firstheight2 = height - columns_offsety - columns_firstheight1;
        columns_secondheight2 = height - columns_offsety - columns_secondheight1;
        columns_thirdheight2 = height - columns_offsety - columns_thirdheight1;
        columns_shift = true;
        break;

      case 156:    //ColumnsWhiteRed

        frameRate(50);
        colorMode(RGB);
        columns_firstheight2 = height - columns_offsety - columns_firstheight1;
        columns_secondheight2 = height - columns_offsety - columns_secondheight1;
        columns_thirdheight2 = height - columns_offsety - columns_thirdheight1;
        columns_shift = false;
        break;
      
      case 157:    //ColumnsBlackRed

        frameRate(50);
        colorMode(RGB);
        columns_firstheight2 = height - columns_offsety - columns_firstheight1;
        columns_secondheight2 = height - columns_offsety - columns_secondheight1;
        columns_thirdheight2 = height - columns_offsety - columns_thirdheight1;
        columns_shift = true;
        break;

      case 158:    //ContinuousTriangles - Resynchronize

        frameRate(50);
        colorMode(RGB);
        noStroke();
        continoustriangles_drift = false;
        continoustriangles_invert = false;
        continoustriangles_resync = true;
        continoustriangles_setup();
        break;
      
      case 159:    //ContinuousTrianglesInvert - Resynchronize

        frameRate(50);
        colorMode(RGB);
        noStroke();
        continoustriangles_drift = false;
        continoustriangles_invert = true;
        continoustriangles_resync = true;
        continoustriangles_setup();
        break;
      
      case 160:    //ContinuousTriangles - Drift

        frameRate(50);
        colorMode(RGB);
        noStroke();
        continoustriangles_drift = true;
        continoustriangles_invert = false;
        continoustriangles_resync = false;
        continoustriangles_setup();
        break;
      
      case 161:    //ContinuousTrianglesInvert - Drift

        frameRate(50);
        colorMode(RGB);
        noStroke();
        continoustriangles_drift = true;
        continoustriangles_invert = true;
        continoustriangles_resync = false;
        continoustriangles_setup();
        break;

      case 162:    //BeatCircle

        frameRate(50);
        noStroke();
        if (beatcircle_counter %2 == 0)
        {fill(255);}
        else
        {fill(255,0,0);}
        beatcircle_counter += 1;
        beatcircle_radius = height;
        break;
      
      case 163:    //BeatCircleLinesReinit

        frameRate(50);
        strokeWeight(8);
        strokeCap(SQUARE);
        noStroke();
        if (beatcircle_counter %2 == 0)
        {fill(255);}
        else
        {fill(255,0,0);}
        beatcircle_counter += 1;
        beatcircle_radius = height;
        beatcircles_linepos = 0;
        break;
      
      case 164:    //BeatCircleLines

        frameRate(50);
        strokeWeight(8);
        strokeCap(SQUARE);
        noStroke();
        if (beatcircle_counter %2 == 0)
        {fill(255);}
        else
        {fill(255,0,0);}
        beatcircle_counter += 1;
        beatcircle_radius = height;
        beatcircles_linepos +=1;
        break;
      
      case 165:    //BeatCircleColorLines1

        frameRate(50);
        strokeWeight(8);
        strokeCap(SQUARE);
        noStroke();
        if (beatcircle_counter %2 == 0)
        {fill(255);}
        else
        {fill(255,0,0);}
        beatcircle_counter += 1;
        beatcircle_radius = height;
        beatcircles_linepos +=1;
        break;
      
      case 166:    //BeatCircleColorLines2

        frameRate(50);
        strokeWeight(8);
        strokeCap(SQUARE);
        noStroke();
        if (beatcircle_counter %2 == 0)
        {fill(255);}
        else
        {fill(255,0,0);}
        beatcircle_counter += 1;
        beatcircle_radius = height;
        beatcircles_linepos +=1;
        break;

      case 167:    //Atoms - One Electron
  
        atoms_setup(1);
        break;
      
      case 168:    //Atoms - Two Electron
 
        atoms_setup(2);
        break;
      
      case 169:    //Atoms - Three Electron
       
        atoms_setup(3);
        break;
      
      case 170:    //PerfectCircle

        frameRate(50);
        noStroke();
        if (perfect_circleinitialised == false) {
          perfect_circleperfectcirclelist = new ArrayList<PerfectCircle>(); 
          perfect_circleperfectcirclelist.add(new PerfectCircle(0, 0));
          perfect_circleperfectcirclelist.add(new PerfectCircle(2*PI/3.0f, 0));
          perfect_circleperfectcirclelist.add(new PerfectCircle(4*PI/3.0f, 0));
        }
        perfect_circleinitialised = true;
        perfect_circlebeatprotosize = perfect_circlebeatprotomaxsize;
        perfect_circleredprotocolor = !perfect_circleredprotocolor;
        break;

      case 171:    //TunnelWhite

        frameRate(50);  
        noStroke();
        strokeWeight(2);
        smooth();
        background(0);
        for (int j=0; j<tunnel_num; j++) {
          float var = map(j, 0, tunnel_num-1, 0, PI);
          tunnel_grises[j]=10+235*sin(var);
        }
        tunnel_color_counter = 0;
        break;
      
      case 172:    //TunnelRed

        
        frameRate(50);  
        strokeWeight(2);
        noStroke();
        smooth();
        background(0);
        for (int k=0; k<tunnel_num; k++) {
          float var = map(k, 0, tunnel_num-1, 0, PI);
          tunnel_grises[k]=10+235*sin(var);
        }
        tunnel_color_counter = 1;
        break;

      case 173:    //ExplodingCircle

        background(0);
        frameRate(50);
        stroke(255); 
        noFill();
        strokeWeight(28);
        explodingcircle_counter = 0;
        break;

      case 174:    //ExplodingCircleLeft

        background(0);
        frameRate(60);
        stroke(255); 
        noFill();
        strokeWeight(28);
        explodingcircle_counter = 0;
        break;
      
      case 175:    //ExplodingCircleRight

        background(0);
        frameRate(60);
        stroke(255,0,0); 
        noFill();
        strokeWeight(28);
        explodingcircle_counter = 0;
        break;

      case 176:    //ColorWaves - Regular

        colorMode(HSB);
        background(0);
        smooth();
        if (waves_init == false) {
          waves_list = new ArrayList<ColorWave>();
        }
        waves_init = true;
        create_randomwave();
        break;
      
      case 177:    //ColorWaves - Strong

        colorMode(HSB);
        background(0);
        smooth();
        if (waves_init == false) {
          waves_list = new ArrayList<ColorWave>();
        }
        waves_init = true;
        create_strongwave();
        break;
      
      case 178:   //GlitchTriangle
      
        resetMatrix();
        frameRate(25);    
        redImg = createChannel(0xff, 0x00, 0x00, 0);
        greenImg = createChannel(0x00, 0xff, 0x00, 0);
        blueImg = createChannel(0x00, 0x00, 0xff, 0);
        break;

      case 179:   //GlitchLine

        rectMode(CORNER);
        resetMatrix();
        frameRate(25);    
        redImg = createChannel(0xff, 0x00, 0x00, 1);
        greenImg = createChannel(0x00, 0xff, 0x00, 1);
        blueImg = createChannel(0x00, 0x00, 0xff, 1);
        break;

      case 180:    //BarWavesWhite

        if (!barWaves_init) {
          barWaves_columns = width/4;
          barWaves_offSets = new float[barWaves_columns];
          barWaves_offTheta = new float[barWaves_columns];  
          barWaves_stepX = width/barWaves_columns;
        }
        strokeWeight(barWaves_stepX+1);
       
        barWaves_initWaves();
        barWaves_init = true;    
        break;
      
      case 181:    //BarWavesRed

        if (!barWaves_init) {
          barWaves_columns = width/4;
          barWaves_offSets = new float[barWaves_columns];
          barWaves_offTheta = new float[barWaves_columns];  
          barWaves_stepX = width/barWaves_columns;
        }
        strokeWeight(barWaves_stepX+1);
       
        barWaves_initWaves();
        barWaves_init = true;    
        break;
      
      case 182:    //BarWavesBlue

        if (!barWaves_init) {
          barWaves_columns = width/4;
          barWaves_offSets = new float[barWaves_columns];
          barWaves_offTheta = new float[barWaves_columns];  
          barWaves_stepX = width/barWaves_columns;
        }
        strokeWeight(barWaves_stepX+1);
       
        barWaves_initWaves();
        barWaves_init = true;
        break;  
          
      case 183:   //FuckedUpSine1

        frameRate(50);
        strokeWeight(4);
        noFill();
        smooth();
        break;
      
      case 184:   //FuckedUpSine2

        frameRate(50);
        strokeWeight(4);
        noFill();
        smooth();
        break;

      case 185:    //FuckedUpSine3 - no reinit

        frameRate(50);
        strokeWeight(4);
        noFill();
        smooth();
        break;

      case 186:   //FuckedUpSine3

        frameRate(50);
        strokeWeight(4);
        noFill();
        smooth();
        sine_fuckedup_counter = 250;
        v = -6.45f;
        w = 12.9f;
        break;

      case 187:   //RotatingSquare

        rectMode(CORNER);
        frameRate(50);
        stroke(0);
        strokeWeight(rotatingSquare_strokeweight);
        if (rotatingSquare_init == false) {
          int rectangle_x, rectangle_y;
          int rectangle_size = height;
          int rectangle_strokeweight = 6; //strokeWeight
          int col = 255;
          rectangle_x = width/2;
          rectangle_y = height/2 ;
          TriRotElem[0] = new TriRot(rectangle_x, rectangle_y, rectangle_size, rectangle_strokeweight, col);
          rotatingSquare_init = true;
        }
        break;
      
      case 188:    //Mandala

        colorMode(RGB);
        smooth();
        background(0);
        strokeCap(ROUND);
        strokeWeight(1);
        frameRate(60);
        mandala_ballsize = mandala_maxballsize;
        break;
      
      case 189:    //Mandala - change shape

        colorMode(RGB);
        smooth();
        background(0);
        strokeCap(ROUND);
        strokeWeight(1);
        frameRate(60);
        //mandala_ballsize = mandala_maxballsize;
        mandala_switch = !mandala_switch;
        break;
      
      case 190:    //Clock

        frameRate(50);
        colorMode(RGB);
        clock_rotate = true;
        break;

      case 191:    //InvertExplode

        frameRate(50);
        colorMode(HSB);
        invertexplode_maxcirclewidth = width*1.2f;
        invertexplode_circlewidth = invertexplode_maxcirclewidth;
        invertexplode_pos = 0;
        invertexplode_linelength = width/6;
        invertexplode_circlehue = invertexplode_maxcirclehue;
        invertexplode_angle += invertexplode_anglespeed;
        break;

      case 192:    //Crescent

        frameRate(60);
        colorMode(HSB); 
        strokeWeight(12);
        crescent_distext = width/2;
        crescent_distint = width/4;
        crescent_emphasis = 0;
        break;
      
      case 193:    //Trigo Shapes

        frameRate(60);
        noStroke();
        colorMode(HSB);
        if (trigoshapes_initComplete == false) {
          trigoshapes_particles = new TrigoShapeParticle[11]; // Create trigoshapes_particles
          for(int n = 0; n < trigoshapes_particles.length; n++)
            trigoshapes_particles[n] = new TrigoShapeParticle(width/2, height/2);
          trigoshapes_particles2 = new TrigoShapeParticle[6]; // Create trigoshapes_particles
          for(int n = 0; n < trigoshapes_particles2.length; n++)
            trigoshapes_particles2[n] = new TrigoShapeParticle(width/2, height/2);
          trigoshapes_arrowImage = createArrowImage();
          trigoshapes_radius = (180*width)/400;
          trigoshapes_smallradius = (90*width)/400;
        }
        else {
          trigoshapes_chosenFunction = (trigoshapes_chosenFunction+1) % 9;
          trigoshapes_particleAngle += HALF_PI;
          trigoshapes_particleFormation = 0; 
        }
        trigoshapes_initComplete = true;
        break;
      
      case 194:    //NewtonPendulum

        noStroke();
        frameRate(50);
        fill(255);
        stroke(255);
        strokeWeight(4);
        newtonpendulum_lengths[0] = 0.00009f;
        for(int n=1;n<30;n++){
          //arrange newtonpendulum_lengths so frequency difference between WavePendulums is constant
          newtonpendulum_lengths[n] = newtonpendulum_g*newtonpendulum_lengths[n-1]/( newtonpendulum_g + 4*PI*PI*newtonpendulum_lengths[n-1] + 4*PI*sqrt(newtonpendulum_g*newtonpendulum_lengths[n-1]) );
        }
        newtonpendulum_pends = new ArrayList();
        for(int n=0; n<30; n++){
          newtonpendulum_p = new WavePendulum(newtonpendulum_lengths[n],0.2f);
          newtonpendulum_pends.add(newtonpendulum_p);
        }
        break;

      case 195:    //CirclePusherRotate

        frameRate(50);
        circlepusher_setAngleRotate = true;
        if (circlepusher_alreadyGenerated == false) {
          circlepusher_initialize_circles();
        }
        circlepusher_alreadyGenerated = true;
        stroke(255);
        strokeWeight(1);
        fill(255);
        smooth();
        break;

      case 196:    //CirclePusherStraight

        frameRate(50);
        circlepusher_setAngleRotate = false;
        if (circlepusher_alreadyGenerated == false) {
          circlepusher_initialize_circles();
        }
        circlepusher_alreadyGenerated = true;
        stroke(255);
        fill(255);
        smooth();
        break;

      case 197:    //Patatap 0

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(0));
        break;
      
      case 198:    //Patatap 1

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(1));
        break;
      
      case 199:    //Patatap 2

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(2));
        break;
      
      case 200:    //Patatap 3

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(3));
        break;
      
      case 201:    //Patatap 4

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(4));
        break;
      
      case 202:    //Patatap 5

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(5));
        break;
      
      case 203:    //Patatap 6

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(6));
        break;
      
      case 204:    //Patatap 7

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(7));
        break;
      
      case 205:    //Patatap 8

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(8));
        break;
      
      case 206:    //Patatap 9

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(9));
        break;
      
      case 207:    //Patatap 10

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(10));
        break;
      
      case 208:    //Patatap 11

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(11));
        break;
      
      case 209:    //Patatap 12

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(12));
        break;
      
      case 210:    //Patatap 13

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(13));
        break;
      
      case 211:    //Patatap 14

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatapObjectList.add(new PatatapObject(14));
        break;
      
      case 212:    //Patatap 15

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        patatap_currentColorset = (patatap_currentColorset+1)%patatap_colorsetBackground.length;
        break;

      case 213:    //Patatap with Audio

        frameRate(50);
        colorMode(RGB);
        if (patatap_init == false) {
          patatap_init = true;
          patatapObjectList = new ArrayList<PatatapObject>();
        }
        break;
      
      case 214:    //Shadows
      
        frameRate(60);
        noStroke();
        break;
      
      case 215:    //SpiralTriangle

        frameRate(50); 
        break;

      case 216:    //PulseStar

        pulsestar_R = height;
        pulsestar_N = 9;
        pulsestar_OMEGA = 0.2f;
        fill(255);
        stroke(0);
        strokeWeight(4);
        strokeCap(ROUND);
        frameRate(50);
        break;
      
      case 217:    //ArrowShape

        frameRate(50);
        break;
      
      case 218:    //Moire

        int divs = 8;
        frameRate(50);
        moireOne = new moire(width/2,height*7/15,0,divs);
        moireTwo = new moire(width/2,height*8/15,0,divs);
        break;
      
      case 219:    //Tumbler

        frameRate(50);
        noStroke();
        break;
      
      case 220:    //Superformula

        background(0);
        noStroke();
        frameRate(50);
        smooth();
        strokeWeight(2);
        superformula_change();
        break;
      
      case 221:    //HypnoAudio

        frameRate(50);
        colorMode(RGB);
        strokeWeight(4);
        hypnoAudio_listenToAudio = true;
        break;
      
      case 222:    //HypnoAudio - Without audio

        frameRate(50);
        colorMode(RGB);
        strokeWeight(4);
        hypnoAudio_listenToAudio = false;
        hypnoAudio_currentPoint = (hypnoAudio_currentPoint + 1)%hypnoAudio_coordinates.length;
        break;
      
      case 223:   //Snow

        background(0);
        frameRate(50);
        for(snowflakecounter=0; snowflakecounter<snowMatrix.length; snowflakecounter=snowflakecounter+1)
        {
          snowMatrix[snowflakecounter]=new Floco(random(width), random(height), random(-snowflakemaxValue, snowflakemaxValue), random(1, 2), color(random(100, 255)));
        }
        break;

      case 224:    //Long noise movie (previous set's intro)
      
        frameRate(18);
        initFlasher_progress = 0;
        break;

      case 225:   //Rain

        rectMode(CORNER);
        background(0);
        noStroke();
        smooth();
        frameRate(20);
        colorMode(RGB);
    
        int raindrops_i = 0;
        while (raindrops_i<howManyRainDrops) {
          raindrops_x[raindrops_i] = random(0, width);
          raindrops_y[raindrops_i] =random(0, height);
          raindrops_speed[raindrops_i] = random(0.3f,2);
          raindrops_i +=1;
        }
        break;

      case 226:    //WhiteNoise

        frameRate(50);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        break;

      case 227:    //WhiteNoiseCrescendo

        frameRate(50);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        whitenoisecrescendo_brightness = 20;
        break;

      case 228:    //HyperSpeed

        frameRate(60);
        stroke(255);
        strokeWeight(4);
        strokeCap(ROUND);
        
        if (hyperspeed_init == false) {
          hyperspeed_nagarelist = new ArrayList<NagareBoshi>();
          for (int j = 0; j < hyperspeed_numberofstars; j++) {
            hyperspeed_nagarelist.add(new NagareBoshi());
          }
        }
        break;
      
      case 229:    //RandomBWFlow

        frameRate(50);
        colorMode(HSB);
        if (randomBWFlow_initComplete == false) {
          for (int y = 0; y < randomBWFlow_resolutionY; y ++) {
            randomBWFlow_wind[y] = 1 * sin(4 * PI * y / randomBWFlow_resolutionY);
            for (int x = 0; x < randomBWFlow_resolutionX; x ++) {
              randomBWFlow_flow[x][y] = new PVector();
              //randomBWFlow_flow[x][y] = new PVector(0.2 - random(0.4), 0.2 - random(0.4));
            }
          }
        }
        else {
          for (int y = 0; y < randomBWFlow_resolutionY; y ++) {
            randomBWFlow_wind[y] = -randomBWFlow_wind[y];
            for (int x = 0; x < randomBWFlow_resolutionX; x ++) {
              randomBWFlow_flow[x][y].x = random(-1,1);
              randomBWFlow_flow[x][y].y = randomBWFlow_flow[x][y].y;
            }
          }
        }
        if (randomBWFlow_initComplete == false) {
          for (int j = 0; j < randomBWFlow_particleCount; j ++) {
            bwflowparticle[j] = new RandomBWFlowParticle(random(randomBWFlow_resolutionX),
              random(randomBWFlow_resolutionY));
          }
        }
        randomBWFlow_initComplete = true; 
        break;

      case 230:    //RandomSmokeParticles

        frameRate(50);
        colorMode(HSB);
        smooth();
        background(0xffffffff);
        smokeparticles_seed = (int) random(2531, 15824);
        noStroke();
        filter(INVERT);      
        break;

      case 231:    //PeriodicNoise

        frameRate(50);
        break;    

      case 232:    //DoubleGradient

        rectMode(CORNER);
        //No initialization of the variables, as for this particular animation it is easier to play live this way
        //doublegradient_a = 0;
        //doublegradient_b = width;
        //doublegradient_direction = true;
        frameRate(50);
        break;
      
      case 233:    //Sonar

        frameRate(50); 
        smooth();
        break;

      case 234:    //SonarAllWhite

        frameRate(70); 
        smooth();
        break;
      
      case 235:    //ThunderLinesInit

        frameRate(60);
        stroke(255); 
        noFill();
        strokeWeight(4);
        colorMode(RGB);
        strokeCap(ROUND);
        thunderline_setupcomplete = false;
        thunderline_density = 25;
        setup_thunderlines();
        thunderline_init = true;
        thunderline_setupcomplete = true;
        break;
      
      case 236:    //ThunderLines - More lines

        frameRate(60);
        stroke(255); 
        noFill();
        strokeWeight(4);
        colorMode(RGB);
        strokeCap(ROUND);
        thunderline_setupcomplete = false;
        if (thunderline_density < 60) {
          thunderline_density += 1;
        }
        setup_thunderlines();
        thunderline_init = true;
        thunderline_setupcomplete = true;
        break;
      
      case 237:    //Opening Whiteout

        frameRate(40);
        noStroke(); 
        fill(255);
        
        //If enough time (10s) has passed since the last animation call, reinit the parameters
        if (System.nanoTime() - openingWhiteout_lastInitTimestamp > TEN_SECONDS) {
          background(0);
          openingWhiteout_verticalCpt = 0;
          openingWhiteout_cpt = 0;
        }
        
        openingWhiteout_lastInitTimestamp = System.nanoTime();
        break;
      
      case 238:    //DarkSnakes

        frameRate(60);
        colorMode(RGB);
        stroke(0, 0, 0, 10);
        smooth();
        for(int j = 0; j < darksnakes_snakes.length; j++) {
          darksnakes_snakes[j].tm = 1;
        }  
        break;
      
      case 239:    //BrightSnakes

        frameRate(60);
        colorMode(RGB);
        stroke(255, 40);
        smooth();
        for(int j = 0; j < brightsnakes_snakes.length; j++) {
          brightsnakes_snakes[j].tm = 1;
        }  
        break;

      case 240:    //MilkTank

        colorMode(HSB);
        strokeWeight(8);
        frameRate(50);
        noStroke();
      
        milktank_w = width;
        milktank_h = height;  
        milktank_regroupX = width/2;
        milktank_regroupY = height/2;
        milktank_pixi = new int[milktank_w][milktank_h];
        milktank_blobs = new milktank_blob[milktank_numberofparticles];
        for(int j = 0; j < milktank_blobs.length; j++) {
          milktank_blobs[j] = new milktank_blob();
        }    
        break;

      case 241:    //FlashingDotsBorder

        frameRate(50);
        strokeWeight(0);
        stroke(255);
        fill(255);
        // initialize values of grid
        for (int j=0; j<flashingdotsborder_y.length; j++) {
          for (int k=0; k<flashingdotsborder_x.length; k++) {
            flashingdotsborder_x[k]=(width/(flashingdotsborder_num-1))*k;
            flashingdotsborder_y[j]=(height/(flashingdotsborder_num-1))*j;
          }
        }
        break;

      case 242:    //LightFusion

        noStroke();
        background(255);
        frameRate(60);
        lightfusion_xspan = lightfusion_xmax - lightfusion_xmin;
        lightfusion_yspan = lightfusion_ymax - lightfusion_ymin;
        lightfusion_X = width/6;
        lightfusion_Y = height;
        lightfusion_speedX = width/24.0f;
        lightfusion_speedY = height/128.0f;
        lightfusion_moveUp = true;
        lightfusion_moveRight = true;
        lightfusion_column = true;
        
        // draw first frame
        lightfusion_drawFrame(0);
        break;

      case 243:    //BWTriangles

        frameRate(50); 
        background(0);
        //strokeWeight(0.1);
        noStroke();
        createParticleSystem();
        break;

      case 244:    //ColorVertex

        smooth();
        frameRate(60);
        colorvertex_pointarray = new ArrayList();
        for (int j=0;j<30;j++) {
          colorvertex_pointarray.add(new colorvertex_Dots(new PVector(random(-64, 64), random(-50, 50))));
        }
        break;

      case 245:    //Gloubiboulga

        colorMode(HSB);
        frameRate(60);
        gloubiboulga_swarm = new ArrayList();
        for (int j=0; j<20; j++) {
            PVector newpos = new PVector(width/2, height/2);
            GloubiboulgaDots myGloubiboulgaDots = new GloubiboulgaDots( newpos, 1 );
            myGloubiboulgaDots.col=color(random(255), random(180, 210), 255, 90);
            gloubiboulga_swarm.add(myGloubiboulgaDots);
            myGloubiboulgaDots.col=color(random(255), random(180, 210), 255, 90);
        }
        break;
      
      case 246:    //CarreMarshall

        frameRate(13);
        stroke(255);
        fill(255);
        rectMode(CORNER);
        // Initialisation des hauteurs des lignes
        carreMarshall_a = 0;
      
        // initialisation des parametres
        carreMarshall_epaisseurLigne = 4;
        carreMarshall_interligne = 3*carreMarshall_epaisseurLigne/2;
        carreMarshall_vitesseLigne = 1;
        carreMarshall_largeurCarre = width/NUMBER_OF_PANELS;
        strokeWeight(carreMarshall_epaisseurLigne);
        break;
      
      case 247:    //MarshallStrobo

        rectMode(CORNER);
        frameRate(25);
        stroke(255);
        fill(255);
        // Initialisation des hauteurs des lignes
        carreMarshall_a = 0;
      
        // initialisation des parametres
        carreMarshall_epaisseurLigne = 4;
        carreMarshall_interligne = 3*carreMarshall_epaisseurLigne/2;
        carreMarshall_vitesseLigne = 1;
        carreMarshall_largeurCarre = width/NUMBER_OF_PANELS;
        strokeWeight(carreMarshall_epaisseurLigne);
        break;

      case 248:   //Strobonormal

        rectMode(CORNER);
        frameRate(25);
        noStroke();
        strokeWeight(8);
        background(0);
        colorMode(RGB);
        break;
      
      case 249:    //StroboX

        rectMode(CORNER);
        frameRate(25);
        stroke(255);
        strokeWeight(16);
        background(0);
        break;

      case 250:    //DynamicAngleLines - White
      
        setup_dynamicAngleLines();
        break;
      
      case 251:    //DynamicAngleLines - Half Red
        
        setup_dynamicAngleLines();
        break;
      
      case 252:    //DynamicAngleLines - Red
        
        setup_dynamicAngleLines();
        break;

      case 253:    //Spots

        frameRate(50);
        stroke(255);
        colorMode(RGB);
        spots_tailleCone = 4;
        strokeWeight(4);
        break;
      
      case 254:    //StroboLine

        rectMode(CORNER);
        frameRate(60);
        colorMode(RGB);
        fill(255);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 255:        //RandomWhiteLineFlash

        frameRate(50);
        fill(0);
        noStroke();
        rect(0,0,width,height);
        break;

      case 256:    //StroboRed

        rectMode(CORNER);
        frameRate(25);
        noStroke();
        background(0);
        break;

      case 257:    //SpotsMultiColor

        frameRate(50);
        noStroke();
        colorMode(RGB);
        spots_tailleCone = 4;
        strokeWeight(4);
        break;
      
      case 258:    //StroboLine

        rectMode(CORNER);
        frameRate(50);
        colorMode(RGB);
        fill(255);
        stroke(255);
        strokeWeight(4);
        break;
      
      case 259:   //Strobonormal

        rectMode(CORNER);
        frameRate(25);
        noStroke();
        strokeWeight(8);
        background(0);
        colorMode(RGB);
        break;

      case 260:    //TriangleStrobo

        frameRate(50);
        stroke(255);
        strokeWeight(8);
        break;
      
      case 261:   //TriangleStroboColor

        rectMode(CORNER);
        frameRate(25);
        noStroke();
        strokeWeight(8);
        background(0);
        break;

      case 262:    //HypnoTriangle

        frameRate(40);
        if (hypnotriangle_init == true) {
          hypnotriangle_init = false;
          hypnotriangle_list = new ArrayList<HypnoTriangle>();
        }
        hypnotriangle_list.add(new HypnoTriangle(hypnotriangle_instancecounter));
        hypnotriangle_instancecounter += 1;
        break;

      case 263:    //FauveRandomFlash
      
        frameRate(40);    
        break;

      case 264:    //RedNoiseShape1

        frameRate(50);
        colorMode(RGB);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        break;
      
      case 265:    //RedNoiseShape2

        frameRate(50);
        colorMode(RGB);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        break;
      
      case 266:    //RedNoiseShape3

        frameRate(50);
        colorMode(RGB);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        break;
      
      case 267:    //RedNoiseShape4

        frameRate(50);
        colorMode(RGB);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        break;
      
      case 268:    //RedNoiseShape5

        frameRate(50);
        colorMode(RGB);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        rednoise_circlerad = 0;
        break;
      
      case 269:    //RedNoiseShape6

        frameRate(50);
        colorMode(RGB);
        noStroke();
        noFill(); 
        rectMode(CORNER);
        break;
      
      case 270:    //Fusee up

        fusee_init(0);
        break;
      
      case 271:    //Fusee down

        fusee_init(1);
        break;
      
      case 272:    //Fusee left

        fusee_init(2);
        break;
      
      case 273:    //Fusee right

        fusee_init(3);
        break;
      
      case 274:    //Fusee center Horizontal

        fusee_init(4);
        break;
      
      case 275:    //Fusee center Vertical

        fusee_init(5);
        break;
      
      case 276:    //Double Fusee

        doublefusee_init();
        break;

      case 277:    //Fusee up Red

        fusee_init(0);
        break;
      
      case 278:    //Fusee down Red

        fusee_init(1);
        break;
      
      case 279:    //Fusee left Red

        fusee_init(2);
        break;
      
      case 280:    //Fusee right Red

        fusee_init(3);
        break;
      
      case 281:    //Fusee center Horizontal Red

        fusee_init(4);
        break;
      
      case 282:    //Fusee center Vertical Red

        fusee_init(5);
        break;
      
      case 283:   //ResponsiveCirclesBW
      
        noStroke();
        smooth();
        frameRate(50);
        if (responsiveCircles_alreadycalled == false) {
          responsiveCircles_x = -48 ;
          responsiveCircles_y = height/2;      
        }
        responsiveCircles_alreadycalled = true;
        break;
      
      case 284:   //ResponsiveCircles
      
        noStroke();
        smooth();
        frameRate(50);
        if (responsiveCircles_alreadycalled == false) {
          responsiveCircles_x = -48 ;
          responsiveCircles_y = height/2;      
        }
        responsiveCircles_alreadycalled = true;
        break;
      
      case 285:   //ManualCircle

        frameRate(50);
        smooth();
        noFill();
        strokeWeight(8);
        colorMode(RGB);
        stroke(255,255,255);
       
        dropcircle_x = width/2;
        dropcircle_y = height/2;
        rings.add(new CirclePulse(dropcircle_x, dropcircle_y, dropcircle_sz));    
        break;
      
      case 286:   //AutomaticCircle

        frameRate(50);
        smooth();
        noFill();
        strokeWeight(8);
        colorMode(RGB);
        stroke(255,255,255);
       
        dropcircle_x = width/2;
        dropcircle_y = height/2;
        //rings.add(new CirclePulse(dropcircle_x, dropcircle_y, dropcircle_sz));    
        break;
      
      case 287:   //Waveform

        frameRate(25);
        noStroke();
        waveform_y_growing = 32;
        break;
      
      case 288:   //Worms

        frameRate(25);
        smooth();
        noStroke();
        if (worms_init == false) {
          worms = new Worm[numWorms];
          for (int j=0; j<numWorms; j++) {
            worms[j] = new Worm(random(0,width),random(0,height),random(0,2*PI));
          }
          worms_init = true;
        }
        pulsed = false;
        break;
      
      case 289:   //KaleidoTriangle

        resetMatrix();
        frameRate(50);
        colorMode(RGB);
        trianglepos = 0;
        break;
      
      case 290:   //Rhombus

        rectMode(CORNER);
        resetMatrix();
        colorMode(RGB);
        frameRate(25);
        rhombus_diaX = width/2;
        break;
              
      case 291:    //GlitchDiagonalLines

        frameRate(50);
        strokeWeight(3);
        for (int j = 0; j < glitchdiagonallines_num; j++) {
          //glitchdiagonallines_particleArray[j] = new glitchdiagonallines_Particle ((int)random(width),(int)random(height));
          glitchdiagonallines_particleArray[j] = new glitchdiagonallines_Particle ((int)random(width), (int)random(height)); 
          //glitchdiagonallines_particleArray[j] = new glitchdiagonallines_Particle (width/2, height/2);
        }
        break;
      
      case 292:   //ParticlesExplode

        //colorMode(RGB, 360, 100, 100);
        background(0,100,0); 
        frameRate(50);
        if (particlesexplode_alreadyinitialised == false) {
          arr = new ArrayList<ParticleExplode>();
        }
        particlesexplode_alreadyinitialised = true;
        
        for(int l = 0; l < 3; l++){
          particleColor = color(random(50,100), random(180,220), random(220,250));
          for(int j = 0; j < 10; j++){
            for (int k = 0; k<NUMBER_OF_PANELS; k++) {
              arr.add(new ParticleExplode(new PVector((2*k + 1)*width/(NUMBER_OF_PANELS*2), height/2), particleColor));
            }
          }
        }

      case 293:   //Symmetry

        strokeWeight(4);
        strokeCap(ROUND);
        resetMatrix();
        frameRate(30);
        background(0);
        smooth();
        incrementMode();
        break;
      
      case 294:    //PixelLines

        pixellines_color1 = new IntList();  
        pixellines_color2 = new IntList();
        pixellines_color1.append(color(236,208,120));
        pixellines_color1.append(color(217,91,67));
        pixellines_color1.append(color(192,41,66));
        pixellines_color1.append(color(84,36,55));
        pixellines_color1.append(color(83,119,122));
    
        pixellines_color2.append(color(236,208,120));
        pixellines_color2.append(color(217,91,67));
        pixellines_color2.append(color(192,41,66));
        pixellines_color2.append(color(84,36,55));
        pixellines_color2.append(color(83,119,122));  
    
        frameRate(10);
        noSmooth();
        strokeWeight(pixellines_strokeWidth);
        break;
      
      case 295:    //CircleContour

        frameRate(25);
        background(0);
        colorMode(HSB);
        smooth();
        break;
      
      case 296:    //ColorExplode

        
        background(0);
        strokeWeight(4); 
        colorexplode_intcounter = 0;
        colorMode(HSB);
        if (colorexplode_init == false) {
          for(int j = 0; j < colorexplode_Z.length; j++) {
            colorexplode_Z[j] = new colorexplode_particle(random(width), random(height), random(-.5f,.5f), random(-.5f,.5f), 1);
          }
          colorexplode_init = true;
        }
        frameRate(50);
        
        break;
      
      case 297:    //ColorRain
        colorMode(HSB);
        background(0);
        frameRate(30);
        noFill();
        strokeWeight(1);
        noStroke();
        if (colorrain_init == false) {
          colorrain_cells = new colorrain_CellArray((float)width, (float)height, width/4, height/4);
          colorrain_init  = true;
        }
        break;
      
      case 298:    //WarpSpeed

        frameRate(50); 
        break;
      
      case 299:    //DigitalHexParticles

        background(0);
        noFill();
        strokeWeight(4);
        strokeCap(ROUND);
        noSmooth();
        frameRate(50);
        digitalhexparticleSystem = new DigitalHexParticleSystem(10);
        break;
      
      case 300:    //RedArcTransition

        frameRate(50);
        //background(0);
        stroke(255,0,0,70);
        strokeWeight(4);
        redarctransition_bottomtopx = width;
        redarctransition_bottomtopy = width;
        redarctransition_bottomdownx = 0;
        redarctransition_bottomdowny = width;
        redarctransition_x1 = 0;
        redarctransition_y1 = 0;
        redarctransition_x2 = 0;
        redarctransition_y2 = width;
        redarctransition_x21 = 0;
        redarctransition_y21 = 0;
        redarctransition_x22 = width;
        redarctransition_y22 = 0;
        redarctransition_topleftx = 0;
        redarctransition_toplefty = 0;
        redarctransition_toprightx = width;
        redarctransition_toprighty = 0;
        break;
      
      case 301:    //BlueArcTransition

        frameRate(50);
        //background(0);
        stroke(0,0,255,70);
        strokeWeight(4);
        redarctransition_bottomtopx = width;
        redarctransition_bottomtopy = width;
        redarctransition_bottomdownx = 0;
        redarctransition_bottomdowny = width;
        redarctransition_x1 = 0;
        redarctransition_y1 = 0;
        redarctransition_x2 = 0;
        redarctransition_y2 = width;
        redarctransition_x21 = 0;
        redarctransition_y21 = 0;
        redarctransition_x22 = width;
        redarctransition_y22 = 0;
        redarctransition_topleftx = 0;
        redarctransition_toplefty = 0;
        redarctransition_toprightx = width;
        redarctransition_toprighty = 0;
        break;

      case 302:    //Shutter

        frameRate(50);
        strokeWeight(1);
        noStroke();
        shutter_colorMode = (shutter_colorMode + 1) % 3;
        shutter_distance = shutter_distanceInit;
        break;

      case 303:    //Butterfly

        background(0);
        noFill();
        frameRate(60);
        noSmooth();
        strokeWeight(1);
        butterfly_s = random(90, 100);    
        break;
      
      case 304:    //BezierFlowers

        background(0);
        stroke(255);
        strokeWeight(2);
        frameRate(50);
        colorMode(HSB, 255);
         
        for(int count = 0; count < bezierflowers_MAX_POINT; count++){
          bezierflowers_controlpoints[count] = new ControlPoint();
        }
        bezierflowers_initialize();
        break;
      
      case 305:    //LightPainting
        frameRate(60);
        background(0);
        if (lightpainting_initok == false) {
          lightpainting_canvas = new LightPaintingCanvas3D(lightpainting_focalLength, lightpainting_interaction_distance);
       
          //Initialize the array of Particles to be used in the animation.
          for (int j = 0; j < lightpainting_particleCount; j++) {
            lightpainting_sparks[j] = new LightPaintingParticle(random(256), random(256), random(256));
          }
        }
        lightpainting_initok = true;
        lightpainting_addRandomLine();
        break;

      case 306:    //ParticlesFlow

        frameRate(50);
        colorMode(HSB, 255);
       
        particlesflow_currFrame = new int[width*height];
        particlesflow_prevFrame = new int[width*height];
        particlesflow_tempFrame = new int[width*height];
        for(int j=0; j<width*height; j++) {
          particlesflow_currFrame[j] = color(0, 0, 0);
          particlesflow_prevFrame[j] = color(0, 0, 0);
          particlesflow_tempFrame[j] = color(0, 0, 0);
        }
       
        particlesflow_particles = new ParticleFlow[(width+particlesflow_particleMargin*2)/particlesflow_particlesDensity*(height+particlesflow_particleMargin*2)/particlesflow_particlesDensity];
        int elementcpt = 0;
        for(int y=-particlesflow_particleMargin; y<height+particlesflow_particleMargin; y+=particlesflow_particlesDensity) {
          for(int x=-particlesflow_particleMargin; x<width+particlesflow_particleMargin; x+=particlesflow_particlesDensity) {
             if (elementcpt == particlesflow_particles.length) {
               break;
             }
             int c = color(100+50*sin(PI*x/width), 127, 255*sin(PI*y/width));
             particlesflow_particles[elementcpt++] = new ParticleFlow(x, y, c);
          }
        }
        break;
      
      case 307:    //ParticlesFlowRed

        frameRate(50);
        colorMode(HSB, 255);
       
        particlesflow_currFrame = new int[width*height];
        particlesflow_prevFrame = new int[width*height];
        particlesflow_tempFrame = new int[width*height];
        for(int j=0; j<width*height; j++) {
          particlesflow_currFrame[j] = color(0, 0, 0);
          particlesflow_prevFrame[j] = color(0, 0, 0);
          particlesflow_tempFrame[j] = color(0, 0, 0);
        }
       
        particlesflow_particles = new ParticleFlow[(width+particlesflow_particleMargin*2)/particlesflow_particlesDensity*(height+particlesflow_particleMargin*2)/particlesflow_particlesDensity];
        int counter = 0;
        for(int y=-particlesflow_particleMargin; y<height+particlesflow_particleMargin; y+=particlesflow_particlesDensity) {
          for(int x=-particlesflow_particleMargin; x<width+particlesflow_particleMargin; x+=particlesflow_particlesDensity) {
             if (counter == particlesflow_particles.length) {
               //println(counter);
               break;
             }
             int c = color((253+12*sin(PI*x/width))%255, 255, 255*sin(PI*y/width));
             particlesflow_particles[counter++] = new ParticleFlow(x, y, c);
          }
        }
        break;
      
      case 308:    //Flowers

        smooth();
        noFill();
        frameRate(50);
    
        colorMode(HSB);
        initFlowers();
        //background(0);
        flowers_sequencenumber += 1;
        break;

      case 309:    //DoubleFlowers

        frameRate(60);
        smooth();
        noStroke();
        colorMode(HSB);
        doubleflower_initFlowers();
        break;

      case 310:    //Fireflies

        background(0);
        fireflies_edge = width/6;
        if (fireflies_init == false) {
          fireflies_list = new ArrayList<Firefly>();
        }
        fireflies_init = true;
        fireflies_init();
        break;
      
      case 311:    //FireNoiseSquare

        int sq_size = width/(8*NUMBER_OF_PANELS);
        frameRate(30);
        squares = new FireNoiseSquare[width/sq_size*height/sq_size];
       
        int idx = 0;
        for (int k=0; k < width/sq_size; k++){
            for (int j=0; j < height/sq_size; j++){
              int c = floor(random(0,18));
              squares[idx] = new FireNoiseSquare(k*sq_size, j*sq_size, sq_size, c);
              idx++;
            }
        }
        break;
      
      case 312:    //BloodSki

        frameRate(50);
        noStroke ();
        colorMode(RGB);
      
        bloodSki_Co = 10;
        bloodSki_Xc = bloodSki_Co/2;
        bloodSki_Yc = 3*bloodSki_Co/4;
        bloodSki_Wc = width-bloodSki_Co;
        bloodSki_Hc = height-bloodSki_Co;
        bloodSki_S  = 50;
        bloodSki_N  = 50;
        bloodSki_minRad= PApplet.parseInt(width/16);
        bloodSki_maxRad= PApplet.parseInt(width/4);
        bloodSki_particleManager = new BloodSkiParticleManager (bloodSki_N, bloodSki_minRad, bloodSki_maxRad, width/2, height/2, 0);
        break;
      
      case 313:   //MechanicLines

        frameRate(50);
        strokeWeight(12);
        strokeCap(SQUARE);
        break;

      case 314:    //RedWhiteGlowingBalls
      
        frameRate(50);
        break;
        
      case 315:    //RedWhiteGlowingBalls - 2

        frameRate(50);
        break;
      
      case 316:   //RedvsBlackvsWhite

        smooth();
        frameRate(50);
        background(255);
        noStroke();
        strokeWeight(8);
        redvsblackvswhite_incr = (width/dots_row)*2;
        redvsblackvswhite_frameCount = 0;
        dots = new ArrayList();
       
        for (int y = PApplet.parseInt(- redvsblackvswhite_incr/2); y < height *1.3f; y+= .9f*redvsblackvswhite_incr) {
          if (one_off) {
            redvsblackvswhite_start = -redvsblackvswhite_incr/2;
            one_off = false;
          }
          else {
            redvsblackvswhite_start = 0;
            one_off = true;
          }
          for (int x = PApplet.parseInt(redvsblackvswhite_start); x < width ; x += redvsblackvswhite_incr) {
            dots.add(new Pulse(x, y));
            redvsblackvswhite_i++;
          }
        }
        break;

      case 317:    //PerlinColor

        noiseDetail(10);
        frameRate(50);
        background(255);
        noStroke();
        //colorMode(HSB, 30.0, 255, 1.0, 255);
        colorMode(HSB);
        for(int l=0; l<colorperlin_myAngleThing.length; l++){
          int theLength = colorperlin_myAngleThing[0].length;
          for(int j=0; j<theLength; j++){
            int tempX = (int)(width/(colorperlin_numX-10.0f)*(l-4));
            int tempY = (int)(height/(colorperlin_numY-10.0f)*(j-4));
            //float theHue = PI+atan2((float)tempY-(float)colorperlin_height/2.0, (float)tempX-(float)colorperlin_width/2.0);
            colorperlin_myAngleThing[l][j] = new AngleThing(tempX, tempY);
            colorperlin_myAngleThing[l][j].render();
          }
        }
        break;
      
      case 318:   //Wind particles

          frameRate(30) ;
          background(0) ;
          particle = new Particle[NUMPARTICLES] ;
          for ( int j = 0 ; j < NUMPARTICLES; j++) {
            particle[j] = new Particle(PApplet.parseInt(random(0,width)), PApplet.parseInt(random(0,height)), new PVector(0.0f,0.0f), color(min(random(210,255),255),0,min(random(0,100),255)));
          }
          wind = new Wind() ;   
          smooth() ;
        break;

      case 319:    //Rorschach

        frameRate(50);
        smooth();
        noStroke();
         
        resetParams(0);
        generateCircleImage();
        generateBalls();
        break;
      
      case 320:    //Rorschach

        frameRate(50);
        smooth();
        noStroke();
         
        resetParams(1);
        generateCircleImage();
        generateBalls();
        break;
      
      case 321:    //Rorschach

        frameRate(50);
        smooth();
        noStroke();
         
        resetParams(2);
        generateCircleImage();
        generateBalls();
        break;
      
      case 322:    //Rorschach

        frameRate(50);
        smooth();
        noStroke();
         
        resetParams(3);
        generateCircleImage();
        generateBalls();
        break;
      
      case 323:    //Rorschach

        frameRate(50);
        smooth();
        noStroke();
         
        resetParams(4);
        generateCircleImage();
        generateBalls();
        break;
      
      case 324:    //RorschachSetColor

        frameRate(50);
        smooth();
        noStroke();
        randomColor = true;
        backgroundColor = color(0);
        ballColor = color(255,0,0);
        switch(movementMode)
        {
          case 0 : animationnumber = 319;break;
          case 1 : animationnumber = 320;break;
          case 2 : animationnumber = 321;break;
          case 3 : animationnumber = 322;break;
          case 4 : animationnumber = 323;break;
        }
        specificActions();
        break;
      
      case 325:    //RorschachSetBlack&White

        frameRate(50);
        smooth();
        noStroke();
        randomColor = false;
        backgroundColor = color(0);
        ballColor = color(255);
        switch(movementMode)
        {
          case 0 : animationnumber = 319;break;
          case 1 : animationnumber = 320;break;
          case 2 : animationnumber = 321;break;
          case 3 : animationnumber = 322;break;
          case 4 : animationnumber = 323;break;
        }
        specificActions();
        break;
      
      case 326:    //ProgressiveRed

        frameRate(50);
        progressivered_color = 0;
        break;
      
      case 327:    //WeirdSquares

        noStroke();
        colorMode(HSB);
        noiseDetail(2);
        frameRate(50);
      
        weirdsquare_step = height/2;
        weirdsquare_bezierbase = height/3;
        weirdsquare_offset = height/15;
        weirdsquare_redbackground = 0;
      
        weirdsquare_initialize();  
        break;
      
      case 328:    //LightBlobs
      
       frameRate(50);
       lightblobs_w = PApplet.parseInt(width*lightblobs_scale);
       lightblobs_h = PApplet.parseInt(height*lightblobs_scale);
         
       lightblobs_pg = createGraphics(lightblobs_w, lightblobs_h);
         
       for (int j=0; j<lightblobs_numBlobs; j++) {
         lightblobs_b[j] = new lightblobs_Blob(random(lightblobs_w),random(lightblobs_h),random(-1,1),random(-1,1), 1+random(15));
       }
       break;
      
      case 329:    //RedMetaBalls

        colorMode(HSB);
        redmetaballs_w = width/2;
        redmetaballs_h = height/2;
        frameRate(50);
        redmetaballs_pg = createGraphics(redmetaballs_w, redmetaballs_h);
         
        for (int j=0; j<redmetaballs_numBlobs; j++) {
          redmetaballs_b[j] = new redmetaballs_Blob(random(redmetaballs_w),random(redmetaballs_h),random(-1,1),random(-1,1));
        }
        break;
      
      case 330:    //Reverse Triangles

        frameRate(60);
        reverseTriangles_red = createGraphics(width, height);
        reverseTriangles_green = createGraphics(width/NUMBER_OF_PANELS, height);
        reverseTriangles_size = reverseTriangles_sizeInit;
        break;

      case 331:    //3DBigAssCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        thirdDimension_viewer3d = new ProjectionViewer();  
        thirdDimension_viewer3d.create_cube(width, color(0,0,255), color(0,255,0), 6, 12, false, 0, 0, 0, 0, 0, 0.04f, 0.02f, 0.03f, true, true, true, false, false);
        
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 332:    //CornerCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        thirdDimension_viewer3d = new ProjectionViewer();  
        thirdDimension_viewer3d.create_cube(3*width/4, color(0,0,255), color(0,255,255), 4, 8, true, 0, 0, true, true, false, false, true);
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 333:    //GlitchCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        if (thirdDimension_noglitchcubeinit == false) {
          thirdDimension_viewer3d = new ProjectionViewer();  
          thirdDimension_viewer3d.create_cube(width/2, color(0,0,255), color(0,255,0), 3, 6, true, width/4, height/4, true, true, true, false, false);
        }
              
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = true;
        break;
      
      case 334:    //NoGlitchCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        if (thirdDimension_noglitchcubeinit == false) {
          thirdDimension_viewer3d = new ProjectionViewer();
          thirdDimension_viewer3d.create_cube(width/2, color(0,0,255), color(0,255,0), 3, 6, true, width/4, height/4, true, true, true, false, false);
        }
        
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = true;
        break;
      
      case 335:    //JerkyCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        if (thirdDimension_jerkyinit == false) {
          thirdDimension_viewer3d = new ProjectionViewer();
          thirdDimension_viewer3d.create_cube(0.85f*width/2, color(0,0,255), color(0,0,255), 3, 6, false, width/4, 0.85f*height/4, 0, 0, 0, 0.02f, 0.025f, 0.03f, true, true, true, false, false, false);
          thirdDimension_viewer3d.wireframes.get(0).rotate3DX(thirdDimension_viewer3d.wireframes.get(0).findCenter(),-0.35f);
          thirdDimension_viewer3d.wireframes.get(0).rotate3DY(thirdDimension_viewer3d.wireframes.get(0).findCenter(),0.35f);
          thirdDimension_viewer3d.wireframes.get(0).rotate3DZ(thirdDimension_viewer3d.wireframes.get(0).findCenter(),0.1f);      
        }
        
        thirdDimension_jerkyinit = true;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 336:    //MovingJerkyCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        if (thirdDimension_jerkyinit == false) {
          thirdDimension_viewer3d = new ProjectionViewer();
          thirdDimension_viewer3d.create_cube(0.85f*width/2, color(0,0,255), color(0,0,255), 3, 6, false, width/4, 0.85f*height/4, 0, 0, 0, 0.02f, 0.025f, 0.03f, true, true, true, false, false, false);
          thirdDimension_viewer3d.wireframes.get(0).rotate3DX(thirdDimension_viewer3d.wireframes.get(0).findCenter(),-0.35f);
          thirdDimension_viewer3d.wireframes.get(0).rotate3DY(thirdDimension_viewer3d.wireframes.get(0).findCenter(),0.35f);
          thirdDimension_viewer3d.wireframes.get(0).rotate3DZ(thirdDimension_viewer3d.wireframes.get(0).findCenter(),0.1f);      
        }
        
        thirdDimension_jerkyinit = true;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 337:    //DoubleCube

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        thirdDimension_viewer3d = new ProjectionViewer();  
        thirdDimension_viewer3d.create_cube(3*width/4, color(0,0,255), color(0,255,255), 3, 6, true, width/8, 0.8f*height/8, true, true, false, false, true);
        thirdDimension_viewer3d.create_cube(width/2, color(0,0,255), color(0,255,255), 3, 6, false, width/4, 0.8f*height/4, true, true, false, false, false);
        
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 338:    //SinglePyramid
      
        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        thirdDimension_viewer3d = new ProjectionViewer();  
        if (random(1) > 0.5f) {
        thirdDimension_viewer3d.create_pyramid(width/2, color(0,0,255), color(0,0,255), 3, 6, false, width/2, height/2, 0, 0, 0, random(0.02f, 0.05f), random(0.02f, 0.05f), random(0.02f, 0.05f), true, true, false, true, false);
        }
        else {
        thirdDimension_viewer3d.create_pyramid(width/2, color(0,0,255), color(0,0,255), 3, 6, false, width/2, height/2, 0, 0, 0, -random(0.02f, 0.05f), -random(0.02f, 0.05f), -random(0.02f, 0.05f), true, true, false, true, false); 
        }
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 339:    //MultiplePyramids

        colorMode(HSB);
        frameRate(50);
        strokeCap(ROUND);
        smooth();
        thirdDimension_colorlist3d[0] = color(0,255,255);
        thirdDimension_colorlist3d[1] = color(0,0,255);
        
        thirdDimension_viewer3d = new ProjectionViewer();  
        thirdDimension_viewer3d.create_pyramid(width/2, color(0,0,255), color(0,255,255), 3, 6, false, -width/4, -height/4, random(1, 3), random(0.5f, 2), random(-1, 1), random(0.04f), random(0.04f), random(0.04f), true, true, false, true, false);
        
        thirdDimension_jerkyinit = false;
        thirdDimension_noglitchcubeinit = false;
        break;
      
      case 340:    //Energy Triangles

        frameRate(40);
        colorMode(HSB);
        smooth();
        background(0);
        strokeWeight(4);
      
        if (energytriangles_init == false) {
          for (int k = energytriangles_density; k > 0; k-=1) {
            for (int j = energytriangles_density; j > 0; j-=1) {
              float xPos = k *(width/energytriangles_density) -width/energytriangles_density/2; 
              float yPos = j *(height/energytriangles_density) -width/energytriangles_density/2; 
              float no = k * j + 1;
        
              EnergyTriangles.add(new EnergyTriangle(xPos, yPos, no));
            }
          }
        }
        energytriangles_init = true;
        energytriangles_energy = 500;
        break;

      case 341:    //RandomPaint

        background(5);
        stroke(255, 255, 0, 1);
        strokeWeight(10);
        frameRate(24);
        smooth();
        randompaint_startX = random(width);
        randompaint_startY = random(height);
        break;

      case 342:    //Redwave

        noStroke();
        frameRate(60);
        redwave_xspan = redwave_xmax - redwave_xmin;
        redwave_yspan = redwave_ymax - redwave_ymin;
        // draw first frame
        redwave_drawFrame(0);
        break;
      
      case 343:    //DiagonalColor

        colorMode(HSB);
        frameRate(60);
        smooth();
        
        if (diagonalcolor_init == false) {
          for (int j = 0; j < diagonalcolors.length;j++) {
            if (j < diagonalcolors.length - diagonalcolors.length/10) {
              diagonalcolors[j] = new DiagonalColor(0);
            }
            else {
              diagonalcolors[j] = new DiagonalColor(180);
            }
          }
          diagonalcolor_init = true;
        }
        break;
      
      case 344:    //Scope

        frameRate(50);
        background(0);
        smooth();
        strokeCap(SQUARE);
        break;
      
      case 345:    //SquareWaveGenerator

        frameRate(50);
        strokeCap(ROUND);
        if (squarewave_alreadycalled == false)
          {
          squarewave_button = new int[width];
          for (int j = 1; j < width; j++) {
            squarewave_button[j] = 0;
          } 
          squarewave_timer = new int[width];
          for (int j = 1; j < width; j++) {
            squarewave_timer[j]   = 0;    
          }
        squarewave_alreadycalled = true;
        }
        strokeWeight(4);
        squarewave_signalpulse = true;   
        squarewave_signalframecounter = frameCount;
        break;
      
      case 346:    //FallingCircles

        background(0);
        smooth();
        colorMode(HSB);
        strokeWeight(1);
        frameRate(50);
        if (fallingCircles_init == false) {
          fallingCircles = new FallingCircles(NUMBER_OF_PANELS*4);
          fallingcircles_fade = 40;
          fallingCircles_init = true;
        }
    
        break;
      
      case 347:    //SetExplodingParticles

        frameRate(30);
        colorMode(HSB);
        strokeWeight(4);
        if (explodingparticle_init == false) {
          for (int j=0;j<nbExplodingParticles;j++) {
            explodingparticle[j]=new ExplodingParticles();
          }
          explodingparticle_init = true;
        }
        fill(0,100);
        ExplodingParticles_explodeflag = true;
        break;
      
      case 348:    //ReleaseExplodingParticles

        frameRate(30);
        colorMode(HSB);
        strokeWeight(4);
        if (explodingparticle_init == false) {
          for (int j=0;j<nbExplodingParticles;j++) {
            explodingparticle[j]=new ExplodingParticles();
          }
          explodingparticle_init = true;
        }
        fill(0,100);
        ExplodingParticles_explodeflag = false;
        break;
      
      case 349:    //Tesselate

        smooth();
        noStroke();
        strokeJoin(ROUND);
        background(0);
        frameRate(50);
        tesselate_size_point_x = width/2;
        break;
          
      case 350:     //Patchwork

        frameRate(50);
        colorMode(HSB);
        noStroke();
        break;

      case 351:    //Vines

        frameRate(50);
        strokeWeight(1);
        noFill();
        if (flowing_lines_init == false) {
          flowing_lines_Path = new FlowingLinePath();
          //flowing_lines_lines = new FlowingLine[] { new FlowingLine(color(222,56,75), 30f, 80, 20f), 
          //                                          new FlowingLine(color(255,170,0), 15.0f, 50, 15f), 
          //                                          new FlowingLine(color(255,0,0), -15.0f, 45, 15f) };
          flowing_lines_lines = new FlowingLine[] { new FlowingLine(color(255,255,255), 30f, 80, 20f), 
                                                      new FlowingLine(color(160,160,160), 15.0f, 50, 15f), 
                                                      new FlowingLine(color(255,0,0), -15.0f, 45, 15f) };
          
        }
        flowing_lines_init = true;
        break;

      case 352:    //NightRoad

        noStroke();
        background(255);
        frameRate(60);
        nightroad_xspan = nightroad_xmax - nightroad_xmin;
        nightroad_yspan = nightroad_ymax - nightroad_ymin;
        nightroad_Y = 0;
        colorMode(HSB);
        //nightroad_drawFrame(0);
        break;
      
      case 353:    //Slasher

        frameRate(50);
        colorMode(RGB);
        if (slasher_initialized == false) {
          slash=new Slash[slasher_nb];
          for(int j=0; j<slasher_nb; j++){
              slash[j]=new Slash(slasher_colors[j%3]);
          }
        }
        slasher_initialized = true;
        for(int j=0; j<slasher_nb; j++){
            slash[j].initSlash();
        }    
    
        break;      

      case 354:    //ColorBeat

        colorMode(HSB);
        frameRate(50);
        colorbeat_maxval = 5*height/6;
        colorbeat_minvalue = height/6;
        colorbeat_value = colorbeat_maxval; 
        break;

      case 355:    //ColorBeatStroboLine

        colorMode(HSB);
        frameRate(25);
        break;
      
      case 356:    //ColorBeatWhiteStroboTriangle

        colorMode(HSB);
        frameRate(25);
        break;
      
      case 357:    //ColorBeatTransition

        colorMode(HSB);
        frameRate(50);
        frameRate(50);
        colorbeat_transitionpos = 0;
        break;
      
      case 358:    //NekoJiru

        colorMode(RGB);
        frameRate(50);
        
        nekojiru_mx = 5*width/(2*NUMBER_OF_PANELS);
        nekojiru_my = 6*height/8;
        nekojiru_eyearcparam1 = height/8;
        nekojiru_eyearcparam2 = width/(2*NUMBER_OF_PANELS);
        nekojiru_bulgesize = width/(32*NUMBER_OF_PANELS/3);
        nekojiru_bulgedistance = width/(2*NUMBER_OF_PANELS);
        nekojiru_eyesizeX = 2*height/5;
        nekojiru_eyesizeY = 2*width/(3*NUMBER_OF_PANELS);
        nekojiru_eyedistance = 2*width/NUMBER_OF_PANELS;
        nekojiru_blinkyMax = height;
        nekojiru_blinkyNasty = height/2;
        
        nekojiru_initStateMachine();
        break;
      
      case 359:    //LetterExplode

        frameRate(50);
        background(0);
        smooth();
        noFill();
        colorMode(HSB);
      
        for (int j = 0; j < particleletters_N; j++) {
          particleletters_parts.add(new LetterParticle(random(width), random(height), 0, 0));
        }
        particleletters_font = loadFont("AldotheApache-48.vlw");
        break;
      
      case 360:    //RotozoomWhite

        frameRate(50);
        colorMode(RGB);
        break;

      case 361:    //Rotozoom 1

        frameRate(60);
        colorMode(RGB);
        rotozoom_img=loadImage(NUMBER_OF_PANELS + "_panels/" + "Rotozoom/rotozoom1.jpg");
        rotozoom_img.resize(256, 256);
        break;
      
      case 362:    //Rotozoom 2

        frameRate(60);
        colorMode(RGB);
        rotozoom_img=loadImage(NUMBER_OF_PANELS + "_panels/" + "Rotozoom/rotozoom2.jpg");
        rotozoom_img.resize(256, 256);
        break;
      
      case 363:    //Rotozoom 3

        frameRate(60);
        colorMode(RGB);
        rotozoom_img=loadImage(NUMBER_OF_PANELS + "_panels/" + "Rotozoom/rotozoom3.jpg");
        rotozoom_img.resize(256, 256);
        break;
      
      case 364:    //Spiraluality
      
        noStroke();
        frameRate(25);
        break;

      case 365:    //RotatingHalfCircle

        frameRate(50);
        fill(0);
        noStroke();
        rect(0,0,width,height);
        break;

      case 366:    //SlicedWave - White

        frameRate(60);
        noFill();
        strokeCap(SQUARE); 
        randomSeed(36);
       
        if (slicedWave_init == false) {
          for (int k=0; k<slicedWave_slices; k++) {
            for (int j=0; j<slicedWave_pieces; j++) {
              slicedWave_r[slicedWave_c] = random(j*(width/slicedWave_pieces), (j+1)*(width/slicedWave_pieces));
              slicedWave_c++;
            }
          }
          slicedWave_init = true;
        }
        slicedWave_angleStock += 15;    
        break;
      
      case 367:    //SlicedWave - Red
        
        frameRate(60);
        noFill();
        strokeCap(SQUARE); 
        randomSeed(36);
       
        if (slicedWave_init == false) {
          for (int k=0; k<slicedWave_slices; k++) {
            for (int j=0; j<slicedWave_pieces; j++) {
              slicedWave_r[slicedWave_c] = random(j*(width/slicedWave_pieces), (j+1)*(width/slicedWave_pieces));
              slicedWave_c++;
            }
          }
          slicedWave_init = true;
        }
        slicedWave_angleStock += 15;    
        break;

      case 368:    //ArcWave

        colorMode(RGB);
        frameRate(60);
        arcwave_maxi=(int)sqrt(width/2*height/2)*4;
        background(0);
        arcwave_arcs= new ArcWaveClass[5];
        arcwave_ray = 0;
        for(int a=0;a<5;a++){
          arcwave_arcs[a]=new ArcWaveClass(width/2,height/2,32+a*32);
        }
        arcwave_arcs=(ArcWaveClass[]) reverse(arcwave_arcs);
        noFill();
        stroke(255);
        strokeWeight(8);
        smooth();
        strokeCap(ROUND);
    
        break;

      case 369:    //RedSun

        redSun_szS = width*.7f;
        redSun_internalCircleRadius = 0;
        break;

      case 370:    //ArcRot - Green

        frameRate(60);
        colorMode(HSB);
        noFill();
        smooth();
        strokeWeight(8);
        arcRot_pulseSize = arcRot_maxPulseSize;    
        break;
      
      case 371:    //ArcRot - Red

        frameRate(60);
        colorMode(HSB);
        noFill();
        smooth();
        strokeWeight(8);
        arcRot_pulseSize = arcRot_maxPulseSize;
        break;

      case 372:    //HypnoPendulum

        frameRate(40);
        colorMode(RGB);
        hypnopendulum_lengths[0] = 400;
        for(int n=1;n<pendulum_n;n++){
          //arrange lengths so frequency difference between HypnoWheelPendulums is constant
          hypnopendulum_lengths[n] = hypnopendulum_lengths[n-1] - 2;
        }
        hypnopendulum_fadein = 0;
         
         
        hypnopendulum_pends = new ArrayList();
        for(int n=0; n<pendulum_n; n++){
          hypnopendulum_p = new HypnoWheelPendulum(hypnopendulum_lengths[n],color(150*(n%4),0,0));
          hypnopendulum_pends.add(hypnopendulum_p);
        }
        smooth();
        break;
      
      case 373:    //LargeWheelPendulum

        frameRate(50);
        colorMode(RGB);
        wheelpendulum_lengths[0] = 200;
        for(int n=1;n<pendulum_n;n++){
          //arrange lengths so frequency difference between LargeWheelPendulums is constant
          wheelpendulum_lengths[n] = wheelpendulum_lengths[n-1] - 1;
        }
        wheelpendulum_pends = new ArrayList();
        for(int n=0; n<pendulum_n; n++){
          if ((n%4) != 0) {
            wheelpendulum_p = new LargeWheelPendulum(wheelpendulum_lengths[n],color(205*(n%4),0,0));
          }
          else {
            wheelpendulum_p = new LargeWheelPendulum(wheelpendulum_lengths[n],color(255,255,255));
          }
          wheelpendulum_pends.add(wheelpendulum_p);
        }
        smooth();
        break;
      
      case 374:    //SingleSquareSpiral

        frameRate(50);
        noStroke();
        rectMode(CORNER);
        break;
      
      case 375:    //DualSquareSpiral

        frameRate(50);
        noStroke();
        rectMode(CORNER);
        break;
      
      case 376:    //ComplexSpiralReinit

        colorMode(HSB);
        frameRate(50);
        stroke(0,0,0);
        fill(0);
        strokeWeight(6);
        rectMode(CORNER);
        complexspiral_counter = 0;
        break;
      
      case 377:    //ComplexSpiral

        colorMode(HSB);
        frameRate(50);
        stroke(0,0,0);
        fill(0);
        strokeWeight(6);
        rectMode(CORNER);
        break;

      case 378:    //OutwardSpiralWhite

        outwardspiral_init();
        break;
      
      case 379:    //OutwardSpiralBlue

        outwardspiral_init();
        break;
      
      case 380:    //OutwardSpiralRed

        outwardspiral_init();
        break;
      
      case 381:    //FastSpiral

        fastspiral_init();
        break;
      
      case 382:    //InwardsSpiral

        background(0);
        frameRate(50);
        noStroke(); 
        inwardsspiral_counter = 0;
        break;
      
      case 383:    //InwardsSpiralReverse

        frameRate(50);
        noStroke(); 
        inwardsspiral_counter = 0;
        break;

      case 384:    //HypnoSpiralRed

        noStroke();
        background(255);
        frameRate(60);
        hypnospiralred_X = width/2;
        hypnospiralred_Y = height/2;
        hypnospiralred_xspan = hypnospiralred_xmax - hypnospiralred_xmin;
        hypnospiralred_yspan = hypnospiralred_ymax - hypnospiralred_ymin;
        hypnospiralred_drawFrame(0);
        break;

      case 385:    //ElectricSpiral

        electricspiral_cx = width/2;
        electricspiral_cy = height/2;
        electricspiral_crad = (max(width,height)/2) * 0.85f;
        electricspiral_framecounter = 0;
        noStroke();
        smooth();
        colorMode(HSB);
        background(0);
        frameRate(50);
        
        for (int j = 0; j < electricspiral_nbrPoints; ++j)
        {
          electricspiral_dots[j] = new ElectricSpiralDot();
          electricspiral_dots[j].tine = -1;
        }
        break;

      case 386:    //CosmoCurve

        cosmoscurve_center = new PVector(width/2,height/2);
        colorMode(RGB);
        frameRate(50);
        background(0);
        smooth();
        noStroke();
        break;
      
      case 387:    //CosmoCurveReinit

        cosmoscurve_center = new PVector(width/2,height/2);
        colorMode(RGB);
        frameRate(50);
        background(0);
        smooth();
        noStroke();
        cosmoscurve_n = 0;
        cosmoscurve_d = 2;
        break;

      case 388:    //Kaleido

        background(0);
        frameRate(60);
        colorMode(RGB);
        //kaleido_posX = 0;
        strokeWeight(1);
        fill(0);
        stroke(0);
        noSmooth();
        break;
      
      case 389:    //KaleidoGray

        background(0);
        frameRate(60);
        colorMode(RGB);
        //kaleido_posX = 0;
        strokeWeight(1);
        fill(0);
        stroke(0);
        noSmooth();
        break;
      
      case 390:    //RevolutionLines

        frameRate(50);
        colorMode(RGB);
        fill(0);
        noStroke();
        rect(0,0,width,height);
        colorMode(HSB);
        revolutionline_lines = new RevolutionLine[0];
        //background(0);
        smooth();
        fill(0,8);
        strokeWeight(4);
        new RevolutionLine(width/2, height/2, 0);
        new RevolutionLine(width/6, -height/12, 0.1f);
        break;
      
      case 391:    //DiscoStar

        frameRate(50);
        smooth();
        colorMode(HSB);
        noStroke();
        break;
      
      case 392:    //WormHole
  
        frameRate(50);
        strokeWeight(4);
        noFill();
        smooth();
        wormhole_c = wormhole_c_init; 
        break;

      case 393:   //Tetris

        frameRate(15);
        textSize(24);
        textAlign(CENTER, CENTER);
        board = new Grid(0, 0, width, height, 8, 4*NUMBER_OF_PANELS);
        setup_tetris();
        break;
      
      case 394:   //Pong

        frameRate(35);
        noStroke();
        textSize(28);  
        textAlign(CENTER, CENTER);
        font = loadFont("Gobold-28.vlw");
        textFont(font,height);
        pongball= new Ball();
        bottom=new Paddle();
        top=new Paddle();
        top.y=0;
        gamestart = true;
        break;

      case 395:    //ShiftPixelsUp - Slow

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 396:    //ShiftPixelsDown - Slow

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 397:    //ShiftPixelsLeft - Slow

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 398:    //ShiftPixelsRight - Slow

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 399:    //ShiftPixelsUp - Fast

        frameRate(60);
        shiftpixels_speed = shiftpixels_fastspeed;
        break;
      
      case 400:    //ShiftPixelsDown - Fast

        frameRate(60);
        shiftpixels_speed = shiftpixels_fastspeed;
        break;
      
      case 401:    //ShiftPixelsLeft - Fast

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 402:    //ShiftPixelsRight - Fast

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 403:    //ShredPixelsVertical - Slow

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 404:    //ShredPixelsHorizontal - Slow

        frameRate(60);
        shiftpixels_speed = shiftpixels_slowspeed;
        break;
      
      case 405:    //ShredPixelsVertical - Fast

        frameRate(60);
        shiftpixels_speed = shiftpixels_fastspeed;
        break;
      
      case 406:    //ShredPixelsHorizontal - Fast

        frameRate(60);
        shiftpixels_speed = shiftpixels_fastspeed;
        break;      
      
      case 407:    //SpiderWebs - Manual - White
        
        smooth();
        spiderweb_audioReactive = false;
        spiderweb_fade = false;
        spiderweb_color = SPIDERWEB_WHITE;
        spiderweb_init();
        break;
        
      case 408:    //SpiderWebs - Manual - Red
        
        smooth();
        spiderweb_audioReactive = false;
        spiderweb_fade = false;
        spiderweb_color = SPIDERWEB_RED;
        spiderweb_init();
        break;
        
      case 409:    //SpiderWebs - Manual Fade - White
        
        smooth();
        spiderweb_audioReactive = false;
        spiderweb_fade = true;
        spiderweb_color = SPIDERWEB_WHITE;
        spiderweb_fadecpt = 0;
        spiderweb_init();
        break;
        
      case 410:    //SpiderWebs - Manual Fade - Red
        
        smooth();
        spiderweb_audioReactive = false;
        spiderweb_fade = true;
        spiderweb_color = SPIDERWEB_RED;
        spiderweb_fadecpt = 0;
        spiderweb_init();
        break;
        
      case 411:    //SpiderWebs - Audio
        
        smooth();
        spiderweb_audioReactive = true;
        spiderweb_fade = false;
        spiderweb_color = SPIDERWEB_WHITE;
        break;
        
      case 412:    //Woublines - White Inwards

        strokeWeight(4);
        smooth();
        frameRate(80);
        if (woublines_init == false) {
          woublines_list = new ArrayList<WoubLine>();
          woublines_init = true;
        }
        woublines_list.add(new WoubLine(0));
        woublines_audio = false;
        break;
        
      case 413:    //Woublines - White Outwards

        strokeWeight(4);
        smooth();
        frameRate(80);
        if (woublines_init == false) {
          woublines_list = new ArrayList<WoubLine>();
          woublines_init = true;
        }
        woublines_list.add(new WoubLine(1));
        woublines_audio = false;
        break;
        
      case 414:    //Woublines - Red Inwards

        strokeWeight(4);
        smooth();
        frameRate(80);
        if (woublines_init == false) {
          woublines_list = new ArrayList<WoubLine>();
          woublines_init = true;
        }
        woublines_list.add(new WoubLine(2));
        woublines_audio = false;
        break;
        
      case 415:    //Woublines - Red Outwards

        strokeWeight(4);
        smooth();
        frameRate(80);
        if (woublines_init == false) {
          woublines_list = new ArrayList<WoubLine>();
          woublines_init = true;
        }
        woublines_list.add(new WoubLine(3));
        woublines_audio = false;
        break;
        
      case 416:    //Woublines - Audio

        strokeWeight(4);
        smooth();
        frameRate(80);
        if (woublines_init == false) {
          woublines_list = new ArrayList<WoubLine>();
          woublines_init = true;
        }
        woublines_audio = true;
        break;
        
      case 417:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 418:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 419:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 420:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 421:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 422:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 423:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 424:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 425:    //Signal Waveform

        setup_signalWaveform();
        break;

      case 426:    //Signal Waveform

        setup_signalWaveform();
        break;

      case 427:    //Signal Waveform

        setup_signalWaveform();
        break;

      case 428:    //Signal Waveform

        setup_signalWaveform();
        break;
        
      case 429:    //Simple Spiral - White
      
        frameRate(60);
        noFill();
        background(0);
        strokeWeight(6);
        break;

      case 430:    //Simple Spiral - Red
      
        frameRate(60);
        noFill();
        background(0);
        strokeWeight(6);
        break;
        
      case 431:    //SingleSquareSpiralWhite

        frameRate(50);
        noStroke();
        rectMode(CORNER);
        break;
      
      case 432:    //DualSquareSpiralWhite

        frameRate(50);
        noStroke();
        rectMode(CORNER);
        break;
      
      case 433:    //TV Power Off
      
        tvpoweroff_progress = 0;
        background(0);
        noStroke();
        fill(255);
        break;
        
      case 434:    //White Spread - Start
        frameRate(90);
        whitespread_progress = 0;
        break;
        
      case 435:    //White Spread - End
        frameRate(90);
        whitespread_progress = 0;
        break;
      
      case 436:    //ScannerLine 1 - Fast White
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
      
      case 437:    //ScannerLine 2 - Fast White
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
        
      case 438:    //ScannerLine 1 - Fast Red
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
        
      case 439:    //ScannerLine 2 - Fast Red
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
        
      case 440:    //ScannerLine 1 - Slow White
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
      
      case 441:    //ScannerLine 2 - Slow White
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
        
      case 442:    //ScannerLine 1 - Slow Red
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
        
      case 443:    //ScannerLine 2 - Slow Red
        frameRate(90);
        colorMode(RGB);
        scannerLine_progress = 0;
        break;
        
      case 509:    //Audio Monitoring

        background(0);
        uglyImpulseKickList = new ArrayList<UglyImpulseKick>();
        uglyImpulseSnareList = new ArrayList<UglyImpulseSnare>();
        uglyImpulseCymbalList = new ArrayList<UglyImpulseCymbal>();
        uglyImpulseBassList = new ArrayList<UglyImpulseBass>();
        break;
      
      case 510:    //Bass FFT display
        
        frameRate(50);
        colorMode(RGB);
        noStroke();
        break;
        
      default:     //Not implemented case - do nothing
        break;
    }
 }

//Put the flag to 1, allow the draw function
setupcomplete = true;

}

////////////////////////////////////////////////////////////////////////////////////
///                        TPM2Serial converter definition                       ///
/// Library to communicate with an TPM2 serial device using the tpm2net protocol ///
////////////////////////////////////////////////////////////////////////////////////










///////////////////////////////////
/// TPM2Net Protocol definition ///
///////////////////////////////////

/**
 * TPM2Net protocol converter
 * 
 * TPM2 uses UDP as transport layer, Port 65506 
 * 
 * see http://www.ledstyles.de/ftopic18969.html for more details
 * 
 * Protocol:
 * Blockstart-Byte      :  0x9C
 * 
 * Block-Type           :  0xDA = Frame Data (Data) *or*
 *                         0xC0 = Instruction (Command) *or*
 *                         0xAA = Requested Answer (from Microcontroller to Master)
 * 
 * 16 Bit Frame Size    :  High-Byte first, then
 *                         Low-Byte
 * 
 * Packet number        :  0-255
 * 
 * Number of Packets    :  1-255
 *
 * Payload (Body Data)  :  1 - 65.535 Bytes Daten oder Befehle mit Parametern
 * 
 * Blockende-Byte       : 0x36
 * 
 * @author Michael Vogt
 *
 */
 

public static final int TPM2_NET_PORT = 65506;
private static final int TPM2_NET_HEADER_SIZE = 6;                
private static final byte START_BYTE = (byte) 0x9C;
private static final byte DATA_FRAME = (byte) 0xDA;
private static final byte CMD_FRAME = (byte) 0xc0;
private static final byte BLOCK_END = (byte) 0x36;

/**
 * Create a TPM2.Net payload. Hint: this is the 2nd release of the protocol, added totalPackets
 * 
 * @param frame
 * @return
 */
public byte[] createImagePayload(int packetNumber, int totalPackets, byte[] data) {
    int frameSize = data.length;
    byte[] outputBuffer = new byte[frameSize + TPM2_NET_HEADER_SIZE + 1];
    
    outputBuffer[0] = START_BYTE;
    outputBuffer[1] = DATA_FRAME;
    outputBuffer[2] = ((byte)(frameSize >> 8 & 0xFF));
    outputBuffer[3] = ((byte)(frameSize & 0xFF));
    outputBuffer[4] = ((byte)packetNumber);
    outputBuffer[5] = ((byte)totalPackets);
    //write footer
    outputBuffer[TPM2_NET_HEADER_SIZE + frameSize] = BLOCK_END;                

    //copy payload
    System.arraycopy(data, 0, outputBuffer, TPM2_NET_HEADER_SIZE, frameSize);
    return outputBuffer;
}

/**
 * send a cmd data packet, used as PING command
 * 
 * @param data
 * @return
 */
public byte[] createCmdPayload(byte[] data) {
    int frameSize = data.length;
    byte[] outputBuffer = new byte[frameSize + TPM2_NET_HEADER_SIZE + 1];
    
    outputBuffer[0] = START_BYTE;
    outputBuffer[1] = CMD_FRAME;
    outputBuffer[2] = ((byte)(frameSize >> 8 & 0xFF));
    outputBuffer[3] = ((byte)(frameSize & 0xFF));
    outputBuffer[4] = ((byte)0);
    outputBuffer[5] = ((byte)0);

    //write footer
    outputBuffer[TPM2_NET_HEADER_SIZE + frameSize] = BLOCK_END;                

    //copy payload
    System.arraycopy(data, 0, outputBuffer, TPM2_NET_HEADER_SIZE, frameSize);
    return outputBuffer;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

/**
 * library to communicate with an TPM2 serial device using the tpm2net protocol
 * created for ledstyles.de 
 * 
 * @author Michael Vogt / neophob.com
 *
 */
public class Tpm2Serial {
        
    /** internal lib version. */
    public static final String VERSION = "1.1";

    private Adler32 adler = new Adler32();
    
    /** The baud. */
    private int baud;
    
    /** The port. */
    private Serial port;

    /** map to store checksum of image. */
    private long lastDataMap;
            

    /**
     * Create a new instance to communicate with the Teensy.
     *
     * @param portName the port name
     * @param targetBuffersize the target buffersize
     * @param baud the baudrate         
     * @throws NoSerialPortFoundException the no serial port found exception
     */
    public Tpm2Serial(String portName, int targetBuffersize, int baud) throws IllegalArgumentException, NoSerialPortFoundException {
            
        outputLog.println("-- Initializing TPM2Serial lib -- version " + VERSION);
        
        this.baud = baud;
        
        lastDataMap = 0L;
        
        String serialPortName="";        
        
        if (portName != "") {
                //open specific port
                serialPortName = portName;
                port = openPort(portName, baud);
        } else {
                //the port was not defined, try to find it by guessing
                String[] ports = Serial.list();
                for (int i=0; port==null && i<ports.length; i++) {
                        outputLog.println("Serial ports info - open port : " + ports[i]);
                        try {
                                serialPortName = ports[i];
                                openPort(ports[i], this.baud);
                        //catch all, there are multiple exception to catch (NoSerialPortFoundException, PortInUseException...)
                        } catch (Exception e) {
                                // search next port...
                        }
                }
        }
                        
        if (port==null) {
                throw new NoSerialPortFoundException("Error: no serial port found!");
        }
        outputLog.println("Found serial port : " + serialPortName);
            
    }
    

    /**
     * clean up library.
     */
    public void dispose() {
            if (connected()) {
                    port.stop();
            }
    }

    /**
     * return the version of the library.
     *
     * @return String version number
     */
    public String version() {
            return VERSION;
    }


    /**
     * return connection state of lib.
     *
     * @return wheter rainbowudino is connected
     */
    public boolean connected() {
            return (port != null);
    }    



    /**
     * wrapper class to send a RGB image to the miniDmx device.
     * the rgb image gets converted to the miniDmx compatible
     * "image format"
     *
     * @param data rgb data (int[64], each int contains one RGB pixel)
     * @param colorFormat the color format
     * @return true if send was successful
     */
    //public boolean sendRgbFrame(int[] data, String colorFormat) {
    //        return sendFrame(convertBufferTo24bit(data, colorFormat));
    //}


    
    /**
     * get md5 hash out of an image. used to check if the image changed
     *
     * @param data the data
     * @return true if send was successful
     */
    private boolean didFrameChange(byte data[]) {
        adler.reset();
        adler.update(data);
        long l = adler.getValue();
        
        if (lastDataMap==l) {
                //last frame was equal current frame, do not send it!
                return false;
        }
        //update new hash
        lastDataMap=l;
        return true;
    }
    
    /**
     * @param data byte[3*8*4]
     * @return true if send was successful
     * @throws IllegalArgumentException the illegal argument exception
     * Send frame if the frame changed, or if the program is in init mode, or if blackout is active
     */
    public boolean sendFrame(byte data[]) throws IllegalArgumentException {
      
      if (didFrameChange(data) || (drawImage == 1 && imagenumber == 0) || (drawAnimation == 1 && animationnumber == 1) || (drawAnimation == 1 && animationnumber == 2)) {
          writeSerialData(data);
       }
       return false;
    }
    

    public Serial getPort() {
            return port;
    }

    /**
     * send the data to the serial port.
     *
     * @param cmdfull the cmdfull
     * 
     */
    private synchronized void writeSerialData(byte[] cmdfull) {
            if (port==null) {
                    outputLog.println("!!! Error !!! Port not ready !");
            }
            
            try {
                    port.write(cmdfull);
                    //port.output.flush();
                    //DO NOT flush the buffer... hmm not sure about this, processing flush also
                    //and i discovered strange "hangs"...
            } catch (Exception e) {
                    outputLog.println("Error !!! Failed sending serial data ! Caught exception : " + e);                       
            }                
    }


        
}

//Initially inside the TPM2Serial class, openPort is best declared as a global function : Serial requires the Papplet as an argument
private Serial openPort(String portName, int baud) throws NoSerialPortFoundException {
        Serial myTeensyPort = null;
        try {
                myTeensyPort = new Serial(this, portName, baud); 
                myTeensyPort.write("PXL".getBytes());
        } catch (Exception e) {        
                outputLog.println("Warning : Failed to open port " + portName + "  Exception raised : " + e);
                if (myTeensyPort != null) {
                        myTeensyPort.stop();                                                
                }
                myTeensyPort = null;
                throw new NoSerialPortFoundException("Failed to open port "+portName+": "+e);
        }        
        return myTeensyPort;
}
////////////////////////////////////////////////////////
// Special animations resulting from user interaction //
////////////////////////////////////////////////////////

final float RAD_FACTOR = 6.28318f;
boolean userInputAnim_enableDrawForCurrentCycle = true;      //Set to true at the beginning of each cycle, this variable is set to false whenever a userInputAnim draw is called. This way, only one draw can be called per cycle
boolean userInputAnim_activateAutoModeDMXStrobe = false;
//////////////////////////////////////////
// Tempo-synced color stroboscope
//////////////////////////////////////////

//StroboAutoPad parameters - special animation which is not to be registered
float registeredTempo;
boolean stroboAutoPadNoteOff = false;

public void draw_stroboAutoPad(int colorset, float tempo, int noteSpeed) {
  if (authorizePanelStrobe == true) {

    //Update the tempo
    frameRate(2 * noteSpeed * tempo/60);
    
    if (frameCount % 2 == 0)
    {
      if (colorset == COLORSET_RED) {
        background(255,0,0);
      }
      else {
        background(255);        
      }
      rect(-width,-height,3*width,3*height);
    }
    else
    {
      background(0);
    }
    
    if (stroboAutoPadNoteOff == true) {
      tempo = registeredTempo;
      stroboAutoPadNoteOff = false;
    }
  }
  if (authorizeDMXStrobe == true) {
    //DMX - TBIL
    if (noteSpeed<=1) {
      
    }
    else if (noteSpeed<=2) {
      
    }
    else if (noteSpeed<=4) {
      
    }
    else if (noteSpeed<=8) {
      
    }
  }
}

//Tempo in argument is supposed to be given in BPM
//Speed : 1 - > one flash per beat, 2 -> 8th, 4 -> 16th, 8 -> 32th, etc.
public void setup_stroboAutoPad(int colorset, float tempo, int noteSpeed) {
  registeredTempo = tempo;
  frameRate(2 * noteSpeed * tempo/60);
}

//////////////////////////////////////////
// White-Out
//////////////////////////////////////////

public void draw_AutoModeWhiteOut(int whiteout) {
  draw_AutoModeWhiteOut(whiteout, 0);
}

public void draw_AutoModeWhiteOut(int whiteout, int modulation) {
  
  if (userInputAnim_enableDrawForCurrentCycle == true) {
    //pushStyle();  // Start a new style
    
    if (random(255) > whiteout) {  //Make the screen glitch when the hipass gets stronger - whiteoutPower is between 0 and 127 
      fill(255, map(whiteout,0,127,0,255));  
    }
    else {
      fill(0);
    } 
    rect(-width,-height,3*width,3*height);
  
    if (modulation > RMX_CC_VAL_THR_1) {
      float blackout_modulation = 0;
      //4th
      if (modulation <= RMX_CC_VAL_THR_2) {
        blackout_modulation = cos(1*RAD_FACTOR*(automaticSequencer.currentPosition % 1.0f));
      }
      //8th
      else if (modulation <= RMX_CC_VAL_THR_3) {
        blackout_modulation = cos(2*RAD_FACTOR*(automaticSequencer.currentPosition % 0.5f));
      }
      //16th
      else if (modulation <= RMX_CC_VAL_THR_4) {
        blackout_modulation = cos(4*RAD_FACTOR*(automaticSequencer.currentPosition % 0.25f));
      }
      fill(0, blackout_modulation*map(whiteout,0,100,130,255));
      rect(-width,-height,3*width,3*height);
    }
    userInputAnim_enableDrawForCurrentCycle = false;
    //popStyle();
  }
}

//////////////////////////////////////////
// Red-Out
//////////////////////////////////////////

public void draw_AutoModeRedOut(int whiteout) {
  draw_AutoModeRedOut(whiteout, 0);
}

public void draw_AutoModeRedOut(int whiteout, int modulation) {
  
  if (userInputAnim_enableDrawForCurrentCycle == true) {
    //pushStyle();  // Start a new style
    //colorMode(RGB);
    
    if (random(255) > whiteout) {  //Make the screen glitch when the hipass gets stronger - whiteoutPower is between 0 and 127 
      fill(255,0,0, map(whiteout,0,127,0,255));  
    }
    else {
      fill(0);
    } 
    //noStroke();
    rect(-width,height,3*width,3*height);
    
    
    if (modulation > RMX_CC_VAL_THR_1) {
      float blackout_modulation = 0;
      //4th
      if (modulation <= RMX_CC_VAL_THR_2) {
        blackout_modulation = cos(1*RAD_FACTOR*(automaticSequencer.currentPosition % 1.0f));
      }
      //8th
      else if (modulation <= RMX_CC_VAL_THR_3) {
        blackout_modulation = cos(2*RAD_FACTOR*(automaticSequencer.currentPosition % 0.5f));
      }
      //16th
      else if (modulation <= RMX_CC_VAL_THR_4) {
        blackout_modulation = cos(4*RAD_FACTOR*(automaticSequencer.currentPosition % 0.25f));
      }
      fill(0, blackout_modulation*map(whiteout,0,100,130,255));
      rect(-width,-height,3*width,3*height);
    }
  
    userInputAnim_enableDrawForCurrentCycle = false;
    //popStyle();
  }
  
}
//////////////////////////////////////////
// BlackOut
//////////////////////////////////////////

public void draw_AutoModeBlackOut(int blackout) {
  draw_AutoModeBlackOut(blackout, 0);
}

public void draw_AutoModeBlackOut(int blackout, int modulation) {
  if (userInputAnim_enableDrawForCurrentCycle == true) {
    //pushStyle();  // Start a new style
    //colorMode(RGB);
    fill(0, map(blackout,0,127,0,255));
    //noStroke();
    rect(-width,-height,3*width,3*height);
    
    //Modulate with a black/white sine flash
    if (modulation > RMX_CC_VAL_THR_1) {
      float whiteout_modulation = 0;
      //4th
      if (modulation <= RMX_CC_VAL_THR_2) {
        whiteout_modulation = cos(1*RAD_FACTOR*(automaticSequencer.currentPosition % 1.0f));
      }
      //8th
      else if (modulation <= RMX_CC_VAL_THR_3) {
        whiteout_modulation = cos(2*RAD_FACTOR*(automaticSequencer.currentPosition % 0.5f));
      }
      //16th
      else if (modulation <= RMX_CC_VAL_THR_4) {
        whiteout_modulation = cos(4*RAD_FACTOR*(automaticSequencer.currentPosition % 0.25f));
      }
      fill(255, min(255, whiteout_modulation*map(blackout,0,100,130,255)));
      rect(-width,-height,3*width,3*height);
    }
    userInputAnim_enableDrawForCurrentCycle = false;
    //popStyle();
  }
}

//////////////////////////////////////////
// Repeat-synced splitter/shredder
//////////////////////////////////////////

public void draw_AutoModeShredder(int shredderPower) {
  shiftpixels_speed = shiftpixels_fastspeed;
  if (shredderPower < 30) {
    draw_shiftpixelsup();
  }
  else if (shredderPower < 50) {
    draw_shiftpixelsdown();
  }
  else if (shredderPower < 70) {
    draw_shiftpixelsleft();
  }  
  else if (shredderPower < 90) {
    draw_shiftpixelsright();
  }
  else if (shredderPower < 110) {
    draw_shredpixelsvertical();
  }
  else {
    draw_shredpixelshorizontal();
  }
  
}

//////////////////////////////////////////
// Automatic color tint
//////////////////////////////////////////

int automodecolortint_hue = 0;

public void draw_AutoModeColorChange() {
  pushStyle();  
  colorMode(HSB);
  fill(automodecolortint_hue % 360,255,255, 100);
  noStroke();
  rect(0,0,width,height);
  popStyle();
  automodecolortint_hue += 1;
}

//////////////////////////////////////////
// Kill LED Panel
//////////////////////////////////////////

public void draw_AutoModeKillLedPanel() {
  pushStyle();  // Start a new style
  fill(0);
  noStroke();
  rect(0,0,width,height);
  popStyle();
}

//////////////////////////////////////////
// WhiteJamaMono
//////////////////////////////////////////

public void draw_whiteJamaMono(int whiteJamaMonoPosition_x) {
  pushStyle();
  fill(255);
  noStroke();
  rect((int) (whiteJamaMonoPosition_x * width/127) - width,0,width,height);    //Scale the MIDI value to the screen's width
  popStyle();
}

//////////////////////////////////////////
// KillPanels
//////////////////////////////////////////

public void draw_killLedPanels() {
  pushStyle();
  fill(0);
  noStroke();
  rect(0,0,width,height);
  popStyle();
}

//////////////////////////////////////////
// WhiteNoiseEffect
//////////////////////////////////////////

public void draw_whiteNoiseEffect(int noiseIntensity) {
  pushStyle();
  noStroke();
  for (int i=0;i<width/4;i++) {
    for (int j=0;j<height/4;j++) {
      fill(random(noiseIntensity));
      rect(i*4,j*4,4,4);
    }
  }
  popStyle();
}

//////////////////////////////////////////
// RMX responsive auto DMX strobe
//////////////////////////////////////////

public void draw_AutoModeDMXStrobe(int val, int modulation) {
  //Only use the modulation for this animation
  
  if (modulation > RMX_CC_VAL_THR_1) {
    if (userInputAnim_activateAutoModeDMXStrobe == false || dmxAnimationNumber_strobe != 26) {
      loadDMXAnimation_strobe(26);
    }
    userInputAnim_activateAutoModeDMXStrobe = true;
  }
  else {
    if (userInputAnim_activateAutoModeDMXStrobe == true) {
      loadDMXAnimation_strobe(0);
      userInputAnim_activateAutoModeDMXStrobe = false;
    }
  }
}
  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Strobot" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
